# Worldgen JSON to Rust: xtask Code Generation Plan

## Overview

Replace the trait-based density function system with an **enum-based** system, generated by a new **`unastar_worldgen_gen`** xtask crate. The generator parses `java-ed-world/worldgen/` JSON files and emits Rust source code directly into the source tree. This replaces ~1600 lines of handcoded `overworld.rs` with auto-generated, type-safe, high-performance enum-based density functions.

## Current State Analysis

### What Exists
- **Trait infrastructure**: `DensityFunction` trait with `Arc<dyn DensityFunction>` in `crates/unastar/src/world/generator/density/`
- **Handcoded overworld**: `overworld.rs` (1641 lines) manually translating Java/JSON to Rust
- **JSON data**: `java-ed-world/worldgen/` with 940+ JSON files defining vanilla worldgen:
  - `density_function/` - 35 density function compositions
  - `noise/` - 60 noise parameter definitions
  - `noise_settings/` - 7 dimension configs (overworld.json is ~2600 lines)
  - `biome/`, `configured_feature/`, `placed_feature/`, etc.

### Problems with Current Trait Approach
- **Dynamic dispatch overhead**: vtable lookup on every `compute()` call (billions per chunk)
- **Heap allocation**: Every node is `Arc<dyn DensityFunction>` = heap alloc + refcount
- **Poor cache locality**: Pointer chasing through the tree
- **Limited optimization**: Compiler can't inline across trait object boundaries

### Key Insight
The JSON files use recursive type discrimination via `"type": "minecraft:..."` fields. This maps perfectly to a Rust enum:
```json
{
  "type": "minecraft:add",
  "argument1": 0.5,
  "argument2": { "type": "minecraft:noise", "noise": "minecraft:temperature", ... }
}
```
→
```rust
DensityFunction::Add(
    Box::new(DensityFunction::Constant(0.5)),
    Box::new(DensityFunction::Noise { holder: NoiseRef::Temperature, xz_scale: 0.25, y_scale: 0.0 })
)
```

## Desired End State

1. **New xtask crate**: `crates/unastar_worldgen_gen/` parses JSON and generates Rust
2. **Enum-based DensityFunction**: Single enum with all ~30 variants, `Box<DensityFunction>` for recursion
3. **Generated source files**: Output to `crates/unastar/src/world/generator/density/generated/`
4. **Static dispatch**: All `compute()` calls resolved at compile time via match
5. **Git-tracked output**: Generated files committed to repo for easy debugging/diffing

### Generated Structure
```
crates/unastar/src/world/generator/density/generated/
├── mod.rs                    # Re-exports
├── density_function.rs       # DensityFunction enum + impl
├── noise_params.rs           # NoiseParams constants/registry
├── overworld.rs              # build_overworld_router(seed) -> NoiseRouter
├── nether.rs                 # build_nether_router(seed) -> NoiseRouter
└── end.rs                    # build_end_router(seed) -> NoiseRouter
```

### Verification
- `cargo run -p unastar_worldgen_gen` regenerates all files
- `cargo build -p unastar` succeeds with generated code
- `cargo test -p unastar` terrain tests pass
- Performance improvement measurable (expect 2-5x faster density computation)

## What We're NOT Doing

- Not implementing biome/feature/structure generation yet (density functions first)
- Not supporting datapack/modded worldgen (vanilla only for now)
- Not keeping the trait-based system (full replacement with enums)
- Not using build.rs (xtask to source tree instead)

## Implementation Approach

**Two-phase xtask generator:**
1. **Parse Phase**: Read all JSON, resolve references, build in-memory graph
2. **Emit Phase**: Generate Rust source files with enum constructors

**Key design decisions:**
- `Box<DensityFunction>` for recursive variants (enum can't contain itself directly)
- `NoiseRef` enum for noise references (resolved to actual noise at runtime with seed)
- Spline data inlined as `Vec<SplinePoint>` literals
- All constants as `f64` literals with full precision

---

## Phase 1: Create unastar_worldgen_gen Crate

### Overview
Set up the xtask crate structure with basic CLI.

### Changes Required:

#### 1. Create crate directory structure
```
crates/unastar_worldgen_gen/
├── Cargo.toml
└── src/
    ├── main.rs           # CLI entry point
    ├── parser/
    │   ├── mod.rs
    │   ├── density_function.rs  # JSON → IR
    │   ├── noise.rs             # noise/*.json parsing
    │   └── noise_settings.rs    # noise_settings/*.json parsing
    └── emitter/
        ├── mod.rs
        ├── density_function.rs  # IR → Rust code
        └── noise.rs
```

#### 2. Cargo.toml
**File**: `crates/unastar_worldgen_gen/Cargo.toml`

```toml
[package]
name = "unastar_worldgen_gen"
version = "0.1.0"
edition = "2024"

[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
walkdir = "2"
```

#### 3. Basic main.rs
**File**: `crates/unastar_worldgen_gen/src/main.rs`

```rust
use std::path::PathBuf;

mod parser;
mod emitter;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")?;
    let root = PathBuf::from(&manifest_dir).parent().unwrap().parent().unwrap().to_path_buf();

    let json_root = root.join("java-ed-world").join("worldgen");
    let output_dir = root.join("crates").join("unastar").join("src")
        .join("world").join("generator").join("density").join("generated");

    println!("Parsing JSON from: {}", json_root.display());
    println!("Output to: {}", output_dir.display());

    // Phase 1: Parse all JSON
    let noises = parser::noise::parse_all(&json_root.join("noise"))?;
    let density_functions = parser::density_function::parse_all(&json_root.join("density_function"))?;
    let noise_settings = parser::noise_settings::parse_all(&json_root.join("noise_settings"))?;

    // Phase 2: Emit Rust code
    std::fs::create_dir_all(&output_dir)?;
    emitter::emit_all(&output_dir, &noises, &density_functions, &noise_settings)?;

    println!("Done! Generated files in {}", output_dir.display());
    Ok(())
}
```

### Success Criteria:

#### Automated Verification:
- [x] `cargo build -p unastar_worldgen_gen` succeeds
- [x] `cargo run -p unastar_worldgen_gen` runs without error (even if output is placeholder)

---

## Phase 2: JSON Parsing Infrastructure

### Overview
Build the serde types to parse Minecraft's worldgen JSON schema into an intermediate representation.

### Changes Required:

#### 1. Density function parser types
**File**: `crates/unastar_worldgen_gen/src/parser/density_function.rs`

```rust
use serde::Deserialize;
use std::collections::HashMap;
use std::path::Path;

/// A density function argument - can be constant, reference, or inline
#[derive(Debug, Clone, Deserialize)]
#[serde(untagged)]
pub enum DensityFunctionArg {
    Constant(f64),
    Reference(String),
    Inline(Box<DensityFunctionDef>),
}

/// All density function types from Minecraft
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "type")]
pub enum DensityFunctionDef {
    #[serde(rename = "minecraft:constant")]
    Constant { argument: f64 },

    #[serde(rename = "minecraft:add")]
    Add { argument1: DensityFunctionArg, argument2: DensityFunctionArg },

    #[serde(rename = "minecraft:mul")]
    Mul { argument1: DensityFunctionArg, argument2: DensityFunctionArg },

    #[serde(rename = "minecraft:min")]
    Min { argument1: DensityFunctionArg, argument2: DensityFunctionArg },

    #[serde(rename = "minecraft:max")]
    Max { argument1: DensityFunctionArg, argument2: DensityFunctionArg },

    #[serde(rename = "minecraft:clamp")]
    Clamp { input: DensityFunctionArg, min: f64, max: f64 },

    #[serde(rename = "minecraft:abs")]
    Abs { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:square")]
    Square { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:cube")]
    Cube { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:squeeze")]
    Squeeze { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:half_negative")]
    HalfNegative { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:quarter_negative")]
    QuarterNegative { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:noise")]
    Noise { noise: String, xz_scale: f64, y_scale: f64 },

    #[serde(rename = "minecraft:shifted_noise")]
    ShiftedNoise {
        noise: String,
        shift_x: DensityFunctionArg,
        shift_y: DensityFunctionArg,
        shift_z: DensityFunctionArg,
        xz_scale: f64,
        y_scale: f64,
    },

    #[serde(rename = "minecraft:y_clamped_gradient")]
    YClampedGradient { from_y: i32, to_y: i32, from_value: f64, to_value: f64 },

    #[serde(rename = "minecraft:flat_cache")]
    FlatCache { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:cache_2d")]
    Cache2D { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:cache_once")]
    CacheOnce { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:interpolated")]
    Interpolated { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:blend_alpha")]
    BlendAlpha,

    #[serde(rename = "minecraft:blend_offset")]
    BlendOffset,

    #[serde(rename = "minecraft:blend_density")]
    BlendDensity { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:range_choice")]
    RangeChoice {
        input: DensityFunctionArg,
        min_inclusive: f64,
        max_exclusive: f64,
        when_in_range: DensityFunctionArg,
        when_out_of_range: DensityFunctionArg,
    },

    #[serde(rename = "minecraft:spline")]
    Spline { spline: SplineDef },

    #[serde(rename = "minecraft:weird_scaled_sampler")]
    WeirdScaledSampler {
        input: DensityFunctionArg,
        noise: String,
        rarity_value_mapper: String,
    },

    #[serde(rename = "minecraft:shift_a")]
    ShiftA { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:shift_b")]
    ShiftB { argument: DensityFunctionArg },

    #[serde(rename = "minecraft:shift")]
    Shift { argument: DensityFunctionArg },
}

#[derive(Debug, Clone, Deserialize)]
pub struct SplineDef {
    pub coordinate: DensityFunctionArg,
    pub points: Vec<SplinePoint>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SplinePoint {
    pub location: f64,
    pub value: SplineValue,
    pub derivative: f64,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(untagged)]
pub enum SplineValue {
    Constant(f64),
    Nested(SplineDef),
}

/// Parse all density functions from a directory
pub fn parse_all(dir: &Path) -> Result<HashMap<String, DensityFunctionArg>, Box<dyn std::error::Error>> {
    let mut functions = HashMap::new();

    for entry in walkdir::WalkDir::new(dir) {
        let entry = entry?;
        if entry.path().extension().map_or(false, |e| e == "json") {
            let rel_path = entry.path().strip_prefix(dir)?;
            let name = rel_path.with_extension("").to_string_lossy()
                .replace('\\', "/");

            let content = std::fs::read_to_string(entry.path())?;
            let def: DensityFunctionArg = serde_json::from_str(&content)?;
            functions.insert(format!("minecraft:{}", name), def);
        }
    }

    Ok(functions)
}
```

#### 2. Noise params parser
**File**: `crates/unastar_worldgen_gen/src/parser/noise.rs`

```rust
use serde::Deserialize;
use std::collections::HashMap;
use std::path::Path;

#[derive(Debug, Clone, Deserialize)]
pub struct NoiseParams {
    #[serde(rename = "firstOctave")]
    pub first_octave: i32,
    pub amplitudes: Vec<f64>,
}

pub fn parse_all(dir: &Path) -> Result<HashMap<String, NoiseParams>, Box<dyn std::error::Error>> {
    let mut noises = HashMap::new();

    for entry in walkdir::WalkDir::new(dir) {
        let entry = entry?;
        if entry.path().extension().map_or(false, |e| e == "json") {
            let name = entry.path().file_stem().unwrap().to_string_lossy();
            let content = std::fs::read_to_string(entry.path())?;
            let params: NoiseParams = serde_json::from_str(&content)?;
            noises.insert(format!("minecraft:{}", name), params);
        }
    }

    Ok(noises)
}
```

### Success Criteria:

#### Automated Verification:
- [x] Parses `java-ed-world/worldgen/noise/temperature.json` correctly
- [x] Parses `java-ed-world/worldgen/density_function/overworld/continents.json` correctly
- [x] Parses `java-ed-world/worldgen/noise_settings/overworld.json` correctly
- [x] `cargo run -p unastar_worldgen_gen` parses all files without error

---

## Phase 3: Define Target Enum Types

### Overview
Define the enum-based DensityFunction that will replace the trait system.

### Changes Required:

#### 1. New density function enum
**File**: `crates/unastar/src/world/generator/density/generated/density_function.rs` (generated, but define target structure)

```rust
//! Generated density function enum.
//!
//! This replaces the trait-based `Arc<dyn DensityFunction>` with a closed enum
//! for static dispatch and better performance.

use crate::world::generator::noise::DoublePerlinNoise;

/// Reference to a noise parameter set (resolved at runtime with seed).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum NoiseRef {
    Temperature,
    Vegetation,
    Continentalness,
    Erosion,
    Ridges,
    Shift,
    AquiferBarrier,
    AquiferFloodedness,
    AquiferSpread,
    AquiferLava,
    OreVeinA,
    OreVeinB,
    OreGap,
    CaveLayer,
    CaveCheese,
    CaveEntrance,
    Spaghetti2d,
    Spaghetti2dModulator,
    Spaghetti2dElevation,
    Spaghetti2dThickness,
    Spaghetti3d1,
    Spaghetti3d2,
    Spaghetti3dRarity,
    Spaghetti3dThickness,
    SpaghettiRoughness,
    SpaghettiRoughnessModulator,
    Noodle,
    NoodleThickness,
    NoodleRidgeA,
    NoodleRidgeB,
    Pillar,
    PillarRareness,
    PillarThickness,
    // ... all noise types
}

/// Spline point value - constant or nested spline.
#[derive(Debug, Clone)]
pub enum SplineValue {
    Constant(f64),
    Nested(Box<Spline>),
}

/// A point on a cubic Hermite spline.
#[derive(Debug, Clone)]
pub struct SplinePoint {
    pub location: f64,
    pub value: SplineValue,
    pub derivative: f64,
}

/// Cubic Hermite spline.
#[derive(Debug, Clone)]
pub struct Spline {
    pub coordinate: Box<DensityFunction>,
    pub points: Vec<SplinePoint>,
}

/// Rarity type for weird scaled sampler.
#[derive(Debug, Clone, Copy)]
pub enum RarityType {
    Type1,
    Type2,
}

/// All density function types as a closed enum.
///
/// Uses `Box<DensityFunction>` for recursive variants since enums can't
/// directly contain themselves.
#[derive(Debug, Clone)]
pub enum DensityFunction {
    // === Constants ===
    Constant(f64),

    // === Binary operations ===
    Add(Box<DensityFunction>, Box<DensityFunction>),
    Mul(Box<DensityFunction>, Box<DensityFunction>),
    Min(Box<DensityFunction>, Box<DensityFunction>),
    Max(Box<DensityFunction>, Box<DensityFunction>),

    // === Unary operations ===
    Abs(Box<DensityFunction>),
    Square(Box<DensityFunction>),
    Cube(Box<DensityFunction>),
    HalfNegative(Box<DensityFunction>),
    QuarterNegative(Box<DensityFunction>),
    Squeeze(Box<DensityFunction>),

    // === Clamping ===
    Clamp { input: Box<DensityFunction>, min: f64, max: f64 },

    // === Y-based ===
    YClampedGradient { from_y: i32, to_y: i32, from_value: f64, to_value: f64 },

    // === Noise ===
    Noise { noise_ref: NoiseRef, xz_scale: f64, y_scale: f64 },
    ShiftedNoise {
        noise_ref: NoiseRef,
        shift_x: Box<DensityFunction>,
        shift_y: Box<DensityFunction>,
        shift_z: Box<DensityFunction>,
        xz_scale: f64,
        y_scale: f64,
    },
    ShiftA(NoiseRef),
    ShiftB(NoiseRef),
    WeirdScaledSampler {
        input: Box<DensityFunction>,
        noise_ref: NoiseRef,
        rarity_type: RarityType,
    },

    // === Caching markers (replaced during wiring) ===
    FlatCache(Box<DensityFunction>),
    Cache2D(Box<DensityFunction>),
    CacheOnce(Box<DensityFunction>),
    Interpolated(Box<DensityFunction>),

    // === Blending ===
    BlendAlpha,
    BlendOffset,
    BlendDensity(Box<DensityFunction>),

    // === Control flow ===
    RangeChoice {
        input: Box<DensityFunction>,
        min_inclusive: f64,
        max_exclusive: f64,
        when_in_range: Box<DensityFunction>,
        when_out_of_range: Box<DensityFunction>,
    },

    // === Splines ===
    Spline(Spline),
}

impl DensityFunction {
    /// Compute density at a point.
    #[inline]
    pub fn compute(&self, ctx: &FunctionContext, noises: &NoiseRegistry) -> f64 {
        match self {
            Self::Constant(v) => *v,

            Self::Add(a, b) => a.compute(ctx, noises) + b.compute(ctx, noises),
            Self::Mul(a, b) => a.compute(ctx, noises) * b.compute(ctx, noises),
            Self::Min(a, b) => a.compute(ctx, noises).min(b.compute(ctx, noises)),
            Self::Max(a, b) => a.compute(ctx, noises).max(b.compute(ctx, noises)),

            Self::Abs(a) => a.compute(ctx, noises).abs(),
            Self::Square(a) => { let v = a.compute(ctx, noises); v * v },
            Self::Cube(a) => { let v = a.compute(ctx, noises); v * v * v },
            Self::HalfNegative(a) => {
                let v = a.compute(ctx, noises);
                if v > 0.0 { v } else { v * 0.5 }
            },
            Self::QuarterNegative(a) => {
                let v = a.compute(ctx, noises);
                if v > 0.0 { v } else { v * 0.25 }
            },
            Self::Squeeze(a) => {
                let v = a.compute(ctx, noises).clamp(-1.0, 1.0);
                v / 2.0 - v * v * v / 24.0
            },

            Self::Clamp { input, min, max } => input.compute(ctx, noises).clamp(*min, *max),

            Self::YClampedGradient { from_y, to_y, from_value, to_value } => {
                let y = ctx.block_y;
                if y <= *from_y { *from_value }
                else if y >= *to_y { *to_value }
                else {
                    let t = (y - from_y) as f64 / (to_y - from_y) as f64;
                    from_value + t * (to_value - from_value)
                }
            },

            Self::Noise { noise_ref, xz_scale, y_scale } => {
                noises.get(*noise_ref).get_value(
                    ctx.block_x as f64 * xz_scale,
                    ctx.block_y as f64 * y_scale,
                    ctx.block_z as f64 * xz_scale,
                )
            },

            // ... continue for all variants

            _ => todo!("Implement remaining variants"),
        }
    }
}

/// Context for density function evaluation.
pub struct FunctionContext {
    pub block_x: i32,
    pub block_y: i32,
    pub block_z: i32,
}

/// Registry of instantiated noise functions (created from seed).
pub struct NoiseRegistry {
    noises: std::collections::HashMap<NoiseRef, DoublePerlinNoise>,
}

impl NoiseRegistry {
    pub fn new(seed: i64) -> Self {
        // Create all noise instances from seed
        todo!()
    }

    pub fn get(&self, noise_ref: NoiseRef) -> &DoublePerlinNoise {
        self.noises.get(&noise_ref).expect("noise not found")
    }
}
```

### Success Criteria:

#### Automated Verification:
- [x] Enum compiles with all variants
- [x] `compute()` method compiles for implemented variants
- [x] Can construct simple density functions manually

---

## Phase 4: Code Emission

### Overview
Generate Rust code that constructs the DensityFunction enum tree.

### Changes Required:

#### 1. Emitter module
**File**: `crates/unastar_worldgen_gen/src/emitter/density_function.rs`

```rust
use crate::parser::density_function::*;
use std::collections::HashMap;

/// Emit Rust code for a density function
pub fn emit(
    arg: &DensityFunctionArg,
    refs: &HashMap<String, DensityFunctionArg>,
    indent: usize,
) -> String {
    let pad = "    ".repeat(indent);

    match arg {
        DensityFunctionArg::Constant(v) => {
            format!("DensityFunction::Constant({:.16})", v)
        }

        DensityFunctionArg::Reference(name) => {
            // Resolve the reference
            if let Some(def) = refs.get(name) {
                emit(def, refs, indent)
            } else {
                panic!("Unknown reference: {}", name);
            }
        }

        DensityFunctionArg::Inline(def) => {
            emit_def(def, refs, indent)
        }
    }
}

fn emit_def(
    def: &DensityFunctionDef,
    refs: &HashMap<String, DensityFunctionArg>,
    indent: usize,
) -> String {
    match def {
        DensityFunctionDef::Constant { argument } => {
            format!("DensityFunction::Constant({:.16})", argument)
        }

        DensityFunctionDef::Add { argument1, argument2 } => {
            format!(
                "DensityFunction::Add(\n{pad}    Box::new({}),\n{pad}    Box::new({})\n{pad})",
                emit(argument1, refs, indent + 1),
                emit(argument2, refs, indent + 1),
                pad = "    ".repeat(indent),
            )
        }

        DensityFunctionDef::Mul { argument1, argument2 } => {
            format!(
                "DensityFunction::Mul(\n{pad}    Box::new({}),\n{pad}    Box::new({})\n{pad})",
                emit(argument1, refs, indent + 1),
                emit(argument2, refs, indent + 1),
                pad = "    ".repeat(indent),
            )
        }

        DensityFunctionDef::YClampedGradient { from_y, to_y, from_value, to_value } => {
            format!(
                "DensityFunction::YClampedGradient {{ from_y: {}, to_y: {}, from_value: {:.16}, to_value: {:.16} }}",
                from_y, to_y, from_value, to_value
            )
        }

        DensityFunctionDef::Noise { noise, xz_scale, y_scale } => {
            let noise_ref = noise_name_to_ref(noise);
            format!(
                "DensityFunction::Noise {{ noise_ref: NoiseRef::{}, xz_scale: {:.16}, y_scale: {:.16} }}",
                noise_ref, xz_scale, y_scale
            )
        }

        DensityFunctionDef::FlatCache { argument } => {
            format!(
                "DensityFunction::FlatCache(Box::new({}))",
                emit(argument, refs, indent + 1)
            )
        }

        DensityFunctionDef::Spline { spline } => {
            emit_spline(spline, refs, indent)
        }

        // ... continue for all types
        _ => format!("todo!(/* {:?} */)", def),
    }
}

fn emit_spline(spline: &SplineDef, refs: &HashMap<String, DensityFunctionArg>, indent: usize) -> String {
    let coord = emit(&spline.coordinate, refs, indent + 1);

    let points: Vec<String> = spline.points.iter().map(|p| {
        let value = match &p.value {
            SplineValue::Constant(v) => format!("SplineValue::Constant({:.16})", v),
            SplineValue::Nested(nested) => {
                format!("SplineValue::Nested(Box::new({}))", emit_spline_inner(nested, refs, indent + 2))
            }
        };
        format!(
            "SplinePoint {{ location: {:.16}, value: {}, derivative: {:.16} }}",
            p.location, value, p.derivative
        )
    }).collect();

    format!(
        "DensityFunction::Spline(Spline {{\n{pad}    coordinate: Box::new({}),\n{pad}    points: vec![\n{pad}        {}\n{pad}    ],\n{pad}}})",
        coord,
        points.join(&format!(",\n{}        ", "    ".repeat(indent))),
        pad = "    ".repeat(indent),
    )
}

fn noise_name_to_ref(name: &str) -> &'static str {
    let clean = name.strip_prefix("minecraft:").unwrap_or(name);
    match clean {
        "temperature" => "Temperature",
        "vegetation" => "Vegetation",
        "continentalness" => "Continentalness",
        "erosion" => "Erosion",
        "ridge" => "Ridges",
        "offset" => "Shift",
        "aquifer_barrier" => "AquiferBarrier",
        // ... all mappings
        _ => panic!("Unknown noise: {}", name),
    }
}
```

#### 2. Generate overworld.rs
**File**: `crates/unastar_worldgen_gen/src/emitter/mod.rs`

```rust
pub mod density_function;

use std::path::Path;
use std::collections::HashMap;
use crate::parser;

pub fn emit_all(
    output_dir: &Path,
    noises: &HashMap<String, parser::noise::NoiseParams>,
    density_functions: &HashMap<String, parser::density_function::DensityFunctionArg>,
    noise_settings: &HashMap<String, parser::noise_settings::NoiseSettings>,
) -> Result<(), Box<dyn std::error::Error>> {

    // Generate overworld.rs
    if let Some(overworld) = noise_settings.get("minecraft:overworld") {
        let content = generate_router_file("overworld", &overworld.noise_router, density_functions)?;
        std::fs::write(output_dir.join("overworld.rs"), content)?;
    }

    // Generate mod.rs
    let mod_content = r#"//! Generated worldgen code.
//!
//! Do not edit manually - regenerate with `cargo run -p unastar_worldgen_gen`

mod density_function;
mod overworld;

pub use density_function::*;
pub use overworld::*;
"#;
    std::fs::write(output_dir.join("mod.rs"), mod_content)?;

    Ok(())
}

fn generate_router_file(
    name: &str,
    router: &parser::noise_settings::NoiseRouter,
    refs: &HashMap<String, parser::density_function::DensityFunctionArg>,
) -> Result<String, Box<dyn std::error::Error>> {
    let final_density = density_function::emit(&router.final_density, refs, 1);
    // ... emit all 15 router fields

    Ok(format!(r#"//! Generated {name} noise router.

use super::density_function::*;

/// Build the {name} noise router.
pub fn build_{name}_router() -> NoiseRouter {{
    NoiseRouter {{
        final_density: {final_density},
        // ... other fields
    }}
}}
"#))
}
```

### Success Criteria:

#### Automated Verification:
- [x] `cargo run -p unastar_worldgen_gen` generates `overworld.rs`
- [x] Generated code compiles
- [x] Generated code produces valid density function trees

---

## Phase 5: Integration & Replace Legacy

### Overview
Wire up generated code and remove the trait-based system.

### Changes Required:

#### 1. Update density module to use generated code
**File**: `crates/unastar/src/world/generator/density/mod.rs`

Replace trait-based imports with:
```rust
mod generated;
pub use generated::*;
```

#### 2. Update NoiseChunk and other consumers
Replace `Arc<dyn DensityFunction>` with `DensityFunction` (enum).

#### 3. Delete legacy files
- `overworld.rs` (handcoded) → delete after verification
- `function.rs` (trait definition) → delete
- Individual type files (`math.rs`, `spline.rs`, etc.) → consolidate into generated enum

### Success Criteria:

#### Automated Verification:
- [ ] `cargo build -p unastar` succeeds
- [ ] `cargo test -p unastar` passes
- [ ] No remaining `Arc<dyn DensityFunction>` in codebase

#### Manual Verification:
- [ ] Generate terrain with seed 12345
- [ ] Visually compare to before (should be identical)
- [ ] Benchmark shows improved performance

---

## Phase 6: Handle Complex Splines

### Overview
The offset.json spline has 1500+ nested points. Ensure emission doesn't stack overflow.

### Changes Required:

#### 1. Iterative spline emission
Use explicit stack instead of recursion for deeply nested splines.

#### 2. Consider spline data extraction
For very large splines, generate as static data:
```rust
static OFFSET_SPLINE_POINTS: &[SplinePoint] = &[
    SplinePoint { location: -1.1, value: SplineValue::Constant(0.044), derivative: 0.0 },
    // ... 1500 more
];
```

### Success Criteria:

#### Automated Verification:
- [ ] offset.json generates without stack overflow
- [ ] Generated spline evaluates correctly

---

## Testing Strategy

### Unit Tests:
- Each JSON type parses correctly
- Each emit function produces valid Rust
- Round-trip: JSON → parse → emit → compile → compute matches expected

### Integration Tests:
- Full overworld router generates and compiles
- Density values match legacy implementation at 10,000 random positions
- NoiseRouter produces correct terrain

### Performance Tests:
- Benchmark `compute()` calls: enum vs trait
- Expected: 2-5x improvement
- Memory usage comparison

### Manual Testing:
1. Run generator: `cargo run -p unastar_worldgen_gen`
2. Build: `cargo build -p unastar`
3. Generate chunk at (0,0) with seed 12345
4. Compare heightmap to legacy version

## Performance Considerations

**Expected improvements from enum approach:**
- No vtable lookups (~3-5 cycles saved per call)
- Better branch prediction (match is predictable)
- Inlining through the tree (LTO can optimize entire chain)
- Better cache locality (no pointer chasing)
- Potential SIMD vectorization (uniform data layout)

**Estimated speedup: 2-5x for density computation**

## Migration Path

1. Generate code alongside legacy (both exist)
2. Add comparison tests (legacy vs generated output)
3. Verify identical output at many positions
4. Switch consumers to generated code
5. Delete legacy code
6. Performance benchmark

## References

- Research doc: `thoughts/shared/research/2025-12-29-minecraft-java-levelgen-complete-reference.md`
- Handcoded reference: `crates/unastar/src/world/generator/density/overworld.rs`
- JSON source: `java-ed-world/worldgen/`
- Similar pattern: `crates/valentine_gen/` (protocol code generation)
