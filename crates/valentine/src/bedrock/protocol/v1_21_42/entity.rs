// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct CameraPresets {
    pub name: String,
    pub parent: String,
    pub position: Vec3Fopts,
    pub rotation: Vec2Fopts,
    pub rotation_speed: Option<f32>,
    pub snap_to_target: Option<bool>,
    pub horizontal_rotation_limit: Option<Vec2F>,
    pub vertical_rotation_limit: Option<Vec2F>,
    pub continue_targeting: Option<bool>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub radius: Option<f32>,
    pub audio_listener: Option<u8>,
    pub player_effects: Option<bool>,
    pub align_target_and_camera_forward: Option<bool>,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresets {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.parent.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        match &self.rotation_speed {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.snap_to_target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.horizontal_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.vertical_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.continue_targeting {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.radius {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.audio_listener {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.player_effects {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.align_target_and_camera_forward {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let parent = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation = <Vec2Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation_speed = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let snap_to_target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let horizontal_rotation_limit = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let vertical_rotation_limit = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let continue_targeting = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let radius = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let audio_listener = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let player_effects = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let align_target_and_camera_forward = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            name,
            parent,
            position,
            rotation,
            rotation_speed,
            snap_to_target,
            horizontal_rotation_limit,
            vertical_rotation_limit,
            continue_targeting,
            offset,
            entity_offset,
            radius,
            audio_listener,
            player_effects,
            align_target_and_camera_forward,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionInstructionSetSome {
    pub runtime_id: i32,
    pub ease_data: Option<PacketCameraInstructionInstructionSetSomeEaseDataSome>,
    pub position: Option<Vec3F>,
    pub rotation: Option<Vec2F>,
    pub facing: Option<Vec3F>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub default: Option<bool>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstructionInstructionSetSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        match &self.ease_data {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.position {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.rotation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.facing {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.default {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ease_data = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetSomeEaseDataSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let position = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let rotation = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let facing = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let default = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            runtime_id,
            ease_data,
            position,
            rotation,
            facing,
            offset,
            entity_offset,
            default,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstruction {
    pub instruction_set: Option<PacketCameraInstructionInstructionSetSome>,
    pub clear: Option<bool>,
    pub fade: Option<PacketCameraInstructionFadeSome>,
    pub target: Option<PacketCameraInstructionTargetSome>,
    pub remove_target: Option<bool>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstruction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.instruction_set {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.clear {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fade {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.remove_target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let instruction_set = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let clear = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let fade = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionFadeSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionTargetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let remove_target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            instruction_set,
            clear,
            fade,
            target,
            remove_target,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub interaction_model: PacketPlayerAuthInputInteractionModel,
    pub interact_rotation: Vec2F,
    pub tick: i64,
    pub delta: Vec3F,
    pub transaction: Option<PacketPlayerAuthInputTransactionSome>,
    pub item_stack_request: Option<ItemStackRequest>,
    pub content: Option<PacketPlayerAuthInputContentSome>,
    pub block_action: Option<Vec<PacketPlayerAuthInputBlockActionSomeItem>>,
    pub analogue_move_vector: Vec2F,
    pub camera_orientation: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        self.interaction_model.encode(buf)?;
        self.interact_rotation.encode(buf)?;
        self.tick.encode(buf)?;
        self.delta.encode(buf)?;
        if let Some(v) = &self.transaction {
            v.encode(buf)?;
        }
        if let Some(v) = &self.item_stack_request {
            v.encode(buf)?;
        }
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_action {
            v.encode(buf)?;
        }
        self.analogue_move_vector.encode(buf)?;
        self.camera_orientation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let interaction_model = <PacketPlayerAuthInputInteractionModel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let interact_rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let transaction = match input_data_item_interact {
            true => {
                Some(
                    <PacketPlayerAuthInputTransactionSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let item_stack_request = match input_data_item_stack_request {
            true => {
                Some(
                    <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let content = match input_data_client_predicted_vehicle {
            true => {
                Some(
                    <PacketPlayerAuthInputContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let block_action = match input_data_block_action {
            true => {
                Some({
                    let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )? as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <PacketPlayerAuthInputBlockActionSomeItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        let analogue_move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let camera_orientation = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            interaction_model,
            interact_rotation,
            tick,
            delta,
            transaction,
            item_stack_request,
            content,
            block_action,
            analogue_move_vector,
            camera_orientation,
        })
    }
}
