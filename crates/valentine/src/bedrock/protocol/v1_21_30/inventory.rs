// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftGrindstoneRequest(ItemStackRequestActionsItemContentCraftGrindstoneRequest),
    CraftLoomRequest(ItemStackRequestActionsItemContentCraftLoomRequest),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(Box<ItemStackRequestActionsItemContentCraftRecipeAuto>),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    PlaceInContainer(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
    TakeOutContainer(ItemStackRequestActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeID,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Consume(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftCreative(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftGrindstoneRequest(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::CraftLoomRequest(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipe(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Create(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Destroy(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Drop(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::MineBlock(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Place(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::PlaceInContainer(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::Swap(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Take(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::TakeOutContainer(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestActionsItemTypeID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_id {
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftGrindstoneRequest(
                        <ItemStackRequestActionsItemContentCraftGrindstoneRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftLoomRequest(
                        <ItemStackRequestActionsItemContentCraftLoomRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        Box::new(
                            <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => Some(ItemStackRequestActionsItemContent::NonImplemented),
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::PlaceInContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::TakeOutContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequest {
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
    pub cause: ItemStackRequestCause,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        let len = self.actions.len() as i32;
        len.encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len() as i32;
        len.encode(buf)?;
        for item in &self.custom_names {
            item.encode(buf)?;
        }
        self.cause.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let cause = <ItemStackRequestCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            request_id,
            actions,
            custom_names,
            cause,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryContent {
    pub window_id: WindowIDVarint,
    pub input: ItemStacks,
    pub container: FullContainerName,
    pub dynamic_container_size: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.input.encode(buf)?;
        self.container.encode(buf)?;
        self.dynamic_container_size.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = <ItemStacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let container = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dynamic_container_size = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            window_id,
            input,
            container,
            dynamic_container_size,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventorySlot {
    pub window_id: WindowIDVarint,
    pub slot: i32,
    pub container: FullContainerName,
    pub dynamic_container_size: i32,
    pub item: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventorySlot {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.slot.encode(buf)?;
        self.container.encode(buf)?;
        self.dynamic_container_size.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let container = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dynamic_container_size = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            window_id,
            slot,
            container,
            dynamic_container_size,
            item,
        })
    }
}
