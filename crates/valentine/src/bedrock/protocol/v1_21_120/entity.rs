// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct CameraRotationOption {
    pub value: Vec3F,
    pub time: f32,
}
impl crate::bedrock::codec::BedrockCodec for CameraRotationOption {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.value.encode(buf)?;
        self.time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let value = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { value, time })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraSplineEaseType {
    CatmullRom = 0,
    Linear = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraSplineEaseType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(CameraSplineEaseType::CatmullRom),
            1 => Ok(CameraSplineEaseType::Linear),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CameraSplineEaseType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct CameraSplineInstruction {
    pub total_time: f32,
    pub ease_type: CameraSplineEaseType,
    pub curve: Vec<Vec3F>,
    pub progress_key_frames: Vec<Vec2F>,
    pub rotation_options: Vec<CameraRotationOption>,
}
impl crate::bedrock::codec::BedrockCodec for CameraSplineInstruction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.total_time.encode(buf)?;
        self.ease_type.encode(buf)?;
        let len = self.curve.len() as i32;
        len.encode(buf)?;
        for item in &self.curve {
            item.encode(buf)?;
        }
        let len = self.progress_key_frames.len() as i32;
        len.encode(buf)?;
        for item in &self.progress_key_frames {
            item.encode(buf)?;
        }
        let len = self.rotation_options.len() as i32;
        len.encode(buf)?;
        for item in &self.rotation_options {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let total_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ease_type = <CameraSplineEaseType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let curve = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let progress_key_frames = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let rotation_options = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraRotationOption as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            total_time,
            ease_type,
            curve,
            progress_key_frames,
            rotation_options,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimateContentRowLeft {
    pub rowing_time: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateContentRowLeft {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.rowing_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let rowing_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { rowing_time })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketAnimateContent {
    RowLeft(PacketAnimateContentRowLeft),
    RowRight(PacketAnimateContentRowLeft),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimate {
    pub action_id: PacketAnimateActionID,
    pub runtime_entity_id: i64,
    pub data: f32,
    pub content: Option<PacketAnimateContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_id.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.data.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketAnimateContent::RowLeft(v) => v.encode(buf)?,
                PacketAnimateContent::RowRight(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_id = <PacketAnimateActionID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content = match action_id {
            _ => {
                Some(
                    PacketAnimateContent::RowLeft(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketAnimateContent::RowRight(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            action_id,
            runtime_entity_id,
            data,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstruction {
    pub instruction_set: Option<PacketCameraInstructionInstructionSetSome>,
    pub clear: Option<bool>,
    pub fade: Option<PacketCameraInstructionFadeSome>,
    pub target: Option<PacketCameraInstructionTargetSome>,
    pub remove_target: Option<bool>,
    pub fov: Option<PacketCameraInstructionFovSome>,
    pub spline: Option<CameraSplineInstruction>,
    pub attach_to_entity: Option<i64>,
    pub detach_from_entity: Option<bool>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstruction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.instruction_set {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.clear {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fade {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.remove_target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fov {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.spline {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.attach_to_entity {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.detach_from_entity {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let instruction_set = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let clear = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let fade = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionFadeSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionTargetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let remove_target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let fov = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionFovSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let spline = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <CameraSplineInstruction as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let attach_to_entity = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let detach_from_entity = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            instruction_set,
            clear,
            fade,
            target,
            remove_target,
            fov,
            spline,
            attach_to_entity,
            detach_from_entity,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEntityEventEventID {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    Caravan = 64,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
    GrowUp = 76,
    VibrationDetected = 77,
    DrinkMilk = 78,
    WetnessStop = 79,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEventEventID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketEntityEventEventID::Jump),
            2 => Ok(PacketEntityEventEventID::HurtAnimation),
            3 => Ok(PacketEntityEventEventID::DeathAnimation),
            4 => Ok(PacketEntityEventEventID::ArmSwing),
            5 => Ok(PacketEntityEventEventID::StopAttack),
            6 => Ok(PacketEntityEventEventID::TameFail),
            7 => Ok(PacketEntityEventEventID::TameSuccess),
            8 => Ok(PacketEntityEventEventID::ShakeWet),
            9 => Ok(PacketEntityEventEventID::UseItem),
            10 => Ok(PacketEntityEventEventID::EatGrassAnimation),
            11 => Ok(PacketEntityEventEventID::FishHookBubble),
            12 => Ok(PacketEntityEventEventID::FishHookPosition),
            13 => Ok(PacketEntityEventEventID::FishHookHook),
            14 => Ok(PacketEntityEventEventID::FishHookTease),
            15 => Ok(PacketEntityEventEventID::SquidInkCloud),
            16 => Ok(PacketEntityEventEventID::ZombieVillagerCure),
            18 => Ok(PacketEntityEventEventID::Respawn),
            19 => Ok(PacketEntityEventEventID::IronGolemOfferFlower),
            20 => Ok(PacketEntityEventEventID::IronGolemWithdrawFlower),
            21 => Ok(PacketEntityEventEventID::LoveParticles),
            22 => Ok(PacketEntityEventEventID::VillagerAngry),
            23 => Ok(PacketEntityEventEventID::VillagerHappy),
            24 => Ok(PacketEntityEventEventID::WitchSpellParticles),
            25 => Ok(PacketEntityEventEventID::FireworkParticles),
            26 => Ok(PacketEntityEventEventID::InLoveParticles),
            27 => Ok(PacketEntityEventEventID::SilverfishSpawnAnimation),
            28 => Ok(PacketEntityEventEventID::GuardianAttack),
            29 => Ok(PacketEntityEventEventID::WitchDrinkPotion),
            30 => Ok(PacketEntityEventEventID::WitchThrowPotion),
            31 => Ok(PacketEntityEventEventID::MinecartTntPrimeFuse),
            32 => Ok(PacketEntityEventEventID::CreeperPrimeFuse),
            33 => Ok(PacketEntityEventEventID::AirSupplyExpired),
            34 => Ok(PacketEntityEventEventID::PlayerAddXpLevels),
            35 => Ok(PacketEntityEventEventID::ElderGuardianCurse),
            36 => Ok(PacketEntityEventEventID::AgentArmSwing),
            37 => Ok(PacketEntityEventEventID::EnderDragonDeath),
            38 => Ok(PacketEntityEventEventID::DustParticles),
            39 => Ok(PacketEntityEventEventID::ArrowShake),
            57 => Ok(PacketEntityEventEventID::EatingItem),
            60 => Ok(PacketEntityEventEventID::BabyAnimalFeed),
            61 => Ok(PacketEntityEventEventID::DeathSmokeCloud),
            62 => Ok(PacketEntityEventEventID::CompleteTrade),
            63 => Ok(PacketEntityEventEventID::RemoveLeash),
            64 => Ok(PacketEntityEventEventID::Caravan),
            65 => Ok(PacketEntityEventEventID::ConsumeTotem),
            66 => Ok(PacketEntityEventEventID::PlayerCheckTreasureHunterAchievement),
            67 => Ok(PacketEntityEventEventID::EntitySpawn),
            68 => Ok(PacketEntityEventEventID::DragonPuke),
            69 => Ok(PacketEntityEventEventID::ItemEntityMerge),
            70 => Ok(PacketEntityEventEventID::StartSwim),
            71 => Ok(PacketEntityEventEventID::BalloonPop),
            72 => Ok(PacketEntityEventEventID::TreasureHunt),
            73 => Ok(PacketEntityEventEventID::AgentSummon),
            74 => Ok(PacketEntityEventEventID::ChargedItem),
            75 => Ok(PacketEntityEventEventID::Fall),
            76 => Ok(PacketEntityEventEventID::GrowUp),
            77 => Ok(PacketEntityEventEventID::VibrationDetected),
            78 => Ok(PacketEntityEventEventID::DrinkMilk),
            79 => Ok(PacketEntityEventEventID::WetnessStop),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEntityEventEventID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i64,
    pub event_id: PacketEntityEventEventID,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketEntityEventEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
