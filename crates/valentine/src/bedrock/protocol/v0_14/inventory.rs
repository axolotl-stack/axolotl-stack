// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct MetadatadictionaryItemValueT5 {
    pub blockid: i16,
    pub itemcount: i8,
    pub itemdamage: i16,
}
impl crate::bedrock::codec::BedrockCodec for MetadatadictionaryItemValueT5 {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.blockid.encode(buf)?;
        self.itemcount.encode(buf)?;
        self.itemdamage.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let blockid = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let itemcount = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let itemdamage = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            blockid,
            itemcount,
            itemdamage,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadatadictionaryItemValueT6 {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for MetadatadictionaryItemValueT6 {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadatadictionaryItemValueT7 {
    pub pitch: f32,
    pub yaw: f32,
    pub roll: f32,
}
impl crate::bedrock::codec::BedrockCodec for MetadatadictionaryItemValueT7 {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.roll.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let roll = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { pitch, yaw, roll })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadatadictionaryItemValue {
    T0(i8),
    T1(i16),
    T2(i32),
    T3(f32),
    T4(Lstring),
    T5(MetadatadictionaryItemValueT5),
    T6(MetadatadictionaryItemValueT6),
    T7(MetadatadictionaryItemValueT7),
    T8(i64),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadatadictionaryItem {
    pub content: u8,
    pub value: Option<MetadatadictionaryItemValue>,
}
impl crate::bedrock::codec::BedrockCodec for MetadatadictionaryItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.content.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                MetadatadictionaryItemValue::T0(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T1(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T2(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T3(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T4(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T5(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T6(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T7(v) => v.encode(buf)?,
                MetadatadictionaryItemValue::T8(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let content = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let value = match compareto {
            0 => {
                Some(
                    MetadatadictionaryItemValue::T0(
                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            1 => {
                Some(
                    MetadatadictionaryItemValue::T1(
                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            2 => {
                Some(
                    MetadatadictionaryItemValue::T2(
                        <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            3 => {
                Some(
                    MetadatadictionaryItemValue::T3(
                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            4 => {
                Some(
                    MetadatadictionaryItemValue::T4(
                        <Lstring as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            5 => {
                Some(
                    MetadatadictionaryItemValue::T5(
                        <MetadatadictionaryItemValueT5 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            6 => {
                Some(
                    MetadatadictionaryItemValue::T6(
                        <MetadatadictionaryItemValueT6 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            7 => {
                Some(
                    MetadatadictionaryItemValue::T7(
                        <MetadatadictionaryItemValueT7 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            8 => {
                Some(
                    MetadatadictionaryItemValue::T8(
                        <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { content, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerClose {
    pub windowid: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerClose {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.windowid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let windowid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { windowid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerOpen {
    pub windowid: i8,
    pub type_: i8,
    pub slotcount: i16,
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerOpen {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.windowid.encode(buf)?;
        self.type_.encode(buf)?;
        self.slotcount.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let windowid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let type_ = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slotcount = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            windowid,
            type_,
            slotcount,
            x,
            y,
            z,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemstacksItem {
    pub slot: Slot,
}
impl crate::bedrock::codec::BedrockCodec for ItemstacksItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { slot })
    }
}
pub type Itemstacks = Vec<ItemstacksItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerSetContentHotbardataT0Item {
    pub slot: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerSetContentHotbardataT0Item {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { slot })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketContainerSetContentHotbardata {
    Default(i16),
    T0(Vec<PacketContainerSetContentHotbardataT0Item>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerSetContent {
    pub windowid: i8,
    pub slotdata: Itemstacks,
    pub hotbardata: PacketContainerSetContentHotbardata,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerSetContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.windowid.encode(buf)?;
        self.slotdata.encode(buf)?;
        match &self.hotbardata {
            PacketContainerSetContentHotbardata::T0(v) => v.encode(buf)?,
            PacketContainerSetContentHotbardata::Default(v) => v.encode(buf)?,
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let windowid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slotdata = <Itemstacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hotbardata = match windowid {
            0 => {
                PacketContainerSetContentHotbardata::T0({
                    let len = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <PacketContainerSetContentHotbardataT0Item as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => {
                PacketContainerSetContentHotbardata::Default(
                    <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
        };
        Ok(Self {
            windowid,
            slotdata,
            hotbardata,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerSetData {
    pub windowid: i8,
    pub property: i16,
    pub value: i16,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerSetData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.windowid.encode(buf)?;
        self.property.encode(buf)?;
        self.value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let windowid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let property = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let value = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { windowid, property, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerSetSlot {
    pub windowid: i8,
    pub slot: i16,
    pub unknown: i16,
    pub item: Slot,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerSetSlot {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.windowid.encode(buf)?;
        self.slot.encode(buf)?;
        self.unknown.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let windowid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slot = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            windowid,
            slot,
            unknown,
            item,
        })
    }
}
pub type EnchantList = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub enum PacketCraftingDataRecipesRecipeItem {
    T0(ShapelessRecipe),
    T1(ShapedRecipe),
    T2(FurnaceRecipe),
    T3(FurnaceRecipeData),
    T4(EnchantList),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingDataRecipes {
    pub entrytype: i32,
    pub recipe: Vec<Option<PacketCraftingDataRecipesRecipeItem>>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingDataRecipes {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entrytype.encode(buf)?;
        let len = self.recipe.len() as i32;
        len.encode(buf)?;
        for item in &self.recipe {
            if let Some(v) = &item {
                match v {
                    PacketCraftingDataRecipesRecipeItem::T0(v) => v.encode(buf)?,
                    PacketCraftingDataRecipesRecipeItem::T1(v) => v.encode(buf)?,
                    PacketCraftingDataRecipesRecipeItem::T2(v) => v.encode(buf)?,
                    PacketCraftingDataRecipesRecipeItem::T3(v) => v.encode(buf)?,
                    PacketCraftingDataRecipesRecipeItem::T4(v) => v.encode(buf)?,
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entrytype = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let recipe = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match entrytype {
                            0 => {
                                Some(
                                    PacketCraftingDataRecipesRecipeItem::T0(
                                        <ShapelessRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            1 => {
                                Some(
                                    PacketCraftingDataRecipesRecipeItem::T1(
                                        <ShapedRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            2 => {
                                Some(
                                    PacketCraftingDataRecipesRecipeItem::T2(
                                        <FurnaceRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            3 => {
                                Some(
                                    PacketCraftingDataRecipesRecipeItem::T3(
                                        <FurnaceRecipeData as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            4 => {
                                Some(
                                    PacketCraftingDataRecipesRecipeItem::T4(
                                        <EnchantList as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        Ok(Self { entrytype, recipe })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingData {
    pub recipes: PacketCraftingDataRecipes,
    pub cleanrecipes: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipes.encode(buf)?;
        self.cleanrecipes.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipes = <PacketCraftingDataRecipes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let cleanrecipes = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { recipes, cleanrecipes })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingEvent {
    pub windowid: i8,
    pub recipetype: i32,
    pub recipeid: uuid::Uuid,
    pub input: Itemstacks,
    pub result: Itemstacks,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.windowid.encode(buf)?;
        self.recipetype.encode(buf)?;
        self.recipeid.encode(buf)?;
        self.input.encode(buf)?;
        self.result.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let windowid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let recipetype = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let recipeid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let input = <Itemstacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let result = <Itemstacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            windowid,
            recipetype,
            recipeid,
            input,
            result,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDropItem {
    pub itemtype: i8,
    pub item: Slot,
}
impl crate::bedrock::codec::BedrockCodec for PacketDropItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.itemtype.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let itemtype = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { itemtype, item })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecordsItem {
    pub x: i8,
    pub y: i8,
    pub z: i8,
}
impl crate::bedrock::codec::BedrockCodec for RecordsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUseItem {
    pub blockcoordinates: Blockcoordinates,
    pub face: i8,
    pub facecoordinates: Vector3,
    pub playerposition: Vector3,
    pub slot: i32,
    pub item: Slot,
}
impl crate::bedrock::codec::BedrockCodec for PacketUseItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.blockcoordinates.encode(buf)?;
        self.face.encode(buf)?;
        self.facecoordinates.encode(buf)?;
        self.playerposition.encode(buf)?;
        self.slot.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let blockcoordinates = <Blockcoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let facecoordinates = <Vector3 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let playerposition = <Vector3 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            blockcoordinates,
            face,
            facecoordinates,
            playerposition,
            slot,
            item,
        })
    }
}
