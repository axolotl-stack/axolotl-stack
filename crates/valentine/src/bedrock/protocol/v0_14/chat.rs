// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub enum PacketTextName {
    T1(String),
    T3(String),
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketTextMessage {
    T0(String),
    T1(String),
    T2(String),
    T3(String),
    T4(String),
    T5(String),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketText {
    pub type_: i8,
    pub name: Option<PacketTextName>,
    pub message: Option<PacketTextMessage>,
    pub parameters: Option<Vec<String>>,
}
impl crate::bedrock::codec::BedrockCodec for PacketText {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.name {
            match v {
                PacketTextName::T1(v) => v.encode(buf)?,
                PacketTextName::T3(v) => v.encode(buf)?,
            }
        }
        if let Some(v) = &self.message {
            match v {
                PacketTextMessage::T0(v) => v.encode(buf)?,
                PacketTextMessage::T1(v) => v.encode(buf)?,
                PacketTextMessage::T2(v) => v.encode(buf)?,
                PacketTextMessage::T3(v) => v.encode(buf)?,
                PacketTextMessage::T4(v) => v.encode(buf)?,
                PacketTextMessage::T5(v) => v.encode(buf)?,
            }
        }
        if let Some(v) = &self.parameters {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let name = match type_ {
            1 => {
                Some(
                    PacketTextName::T1(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            3 => {
                Some(
                    PacketTextName::T3(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => None,
        };
        let message = match type_ {
            0 => {
                Some(
                    PacketTextMessage::T0(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            1 => {
                Some(
                    PacketTextMessage::T1(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            2 => {
                Some(
                    PacketTextMessage::T2(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            3 => {
                Some(
                    PacketTextMessage::T3(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            4 => {
                Some(
                    PacketTextMessage::T4(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            5 => {
                Some(
                    PacketTextMessage::T5(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => None,
        };
        let parameters = match type_ {
            2 => {
                Some({
                    let len = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <String as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            type_,
            name,
            message,
            parameters,
        })
    }
}
