// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub entityid: i64,
    pub entitytype: i32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speedx: f32,
    pub speedy: f32,
    pub speedz: f32,
    pub yaw: f32,
    pub pitch: f32,
    pub metadata: Metadatadictionary,
    pub links: i16,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.entitytype.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speedx.encode(buf)?;
        self.speedy.encode(buf)?;
        self.speedz.encode(buf)?;
        self.yaw.encode(buf)?;
        self.pitch.encode(buf)?;
        self.metadata.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entitytype = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedx = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedy = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedz = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <Metadatadictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let links = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entityid,
            entitytype,
            x,
            y,
            z,
            speedx,
            speedy,
            speedz,
            yaw,
            pitch,
            metadata,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddItemEntity {
    pub entityid: i64,
    pub item: Slot,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speedx: f32,
    pub speedy: f32,
    pub speedz: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddItemEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.item.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speedx.encode(buf)?;
        self.speedy.encode(buf)?;
        self.speedz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedx = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedy = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedz = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entityid,
            item,
            x,
            y,
            z,
            speedx,
            speedy,
            speedz,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub entityid: i64,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speedx: f32,
    pub speedy: f32,
    pub speedz: f32,
    pub yaw: f32,
    pub headyaw: f32,
    pub pitch: f32,
    pub item: Slot,
    pub metadata: Metadatadictionary,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        self.entityid.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speedx.encode(buf)?;
        self.speedy.encode(buf)?;
        self.speedz.encode(buf)?;
        self.yaw.encode(buf)?;
        self.headyaw.encode(buf)?;
        self.pitch.encode(buf)?;
        self.item.encode(buf)?;
        self.metadata.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedx = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedy = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speedz = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let headyaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <Metadatadictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            uuid,
            username,
            entityid,
            x,
            y,
            z,
            speedx,
            speedy,
            speedz,
            yaw,
            headyaw,
            pitch,
            item,
            metadata,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimate {
    pub actionid: i8,
    pub entityid: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.actionid.encode(buf)?;
        self.entityid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let actionid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { actionid, entityid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub entityid: i64,
    pub eventid: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.eventid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let eventid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { entityid, eventid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEffect {
    pub entityid: i64,
    pub eventid: i8,
    pub effectid: i8,
    pub amplifier: i8,
    pub particles: i8,
    pub duration: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.eventid.encode(buf)?;
        self.effectid.encode(buf)?;
        self.amplifier.encode(buf)?;
        self.particles.encode(buf)?;
        self.duration.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let eventid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let effectid = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let amplifier = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let particles = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let duration = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entityid,
            eventid,
            effectid,
            amplifier,
            particles,
            duration,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EntitylocationsItem {
    pub eid: i64,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub yaw: f32,
    pub headyaw: f32,
    pub pitch: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntitylocationsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.eid.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.yaw.encode(buf)?;
        self.headyaw.encode(buf)?;
        self.pitch.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let eid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let headyaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            eid,
            x,
            y,
            z,
            yaw,
            headyaw,
            pitch,
        })
    }
}
pub type Entitylocations = Vec<EntitylocationsItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntity {
    pub entities: Entitylocations,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entities.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entities = <Entitylocations as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entities })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovePlayer {
    pub entityid: i64,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub yaw: f32,
    pub headyaw: f32,
    pub pitch: f32,
    pub mode: i8,
    pub onground: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.yaw.encode(buf)?;
        self.headyaw.encode(buf)?;
        self.pitch.encode(buf)?;
        self.mode.encode(buf)?;
        self.onground.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let headyaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let mode = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let onground = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entityid,
            x,
            y,
            z,
            yaw,
            headyaw,
            pitch,
            mode,
            onground,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAction {
    pub entityid: i64,
    pub actionid: i32,
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub face: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.actionid.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.face.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let actionid = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let face = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entityid,
            actionid,
            x,
            y,
            z,
            face,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerArmorEquipment {
    pub entityid: i64,
    pub helmet: Slot,
    pub chestplate: Slot,
    pub leggings: Slot,
    pub boots: Slot,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerArmorEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.helmet.encode(buf)?;
        self.chestplate.encode(buf)?;
        self.leggings.encode(buf)?;
        self.boots.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let helmet = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chestplate = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let leggings = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let boots = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entityid,
            helmet,
            chestplate,
            leggings,
            boots,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerEquipment {
    pub entityid: i64,
    pub item: Slot,
    pub slot: i8,
    pub selectedslot: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.item.encode(buf)?;
        self.slot.encode(buf)?;
        self.selectedslot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Slot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slot = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let selectedslot = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entityid,
            item,
            slot,
            selectedslot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerListEntriesItemT0 {
    pub clientuuid: uuid::Uuid,
    pub entityid: i64,
    pub displayname: String,
    pub skin: Skin,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerListEntriesItemT0 {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.clientuuid.encode(buf)?;
        self.entityid.encode(buf)?;
        self.displayname.encode(buf)?;
        self.skin.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let clientuuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let displayname = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            clientuuid,
            entityid,
            displayname,
            skin,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerListEntriesItemT1 {
    pub clientuuid: uuid::Uuid,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerListEntriesItemT1 {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.clientuuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let clientuuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { clientuuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketPlayerListEntriesItem {
    T0(Box<PacketPlayerListEntriesItemT0>),
    T1(PacketPlayerListEntriesItemT1),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerList {
    pub type_: i8,
    pub entries: Vec<Option<PacketPlayerListEntriesItem>>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerList {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        let len = self.entries.len() as i32;
        len.encode(buf)?;
        for item in &self.entries {
            if let Some(v) = &item {
                match v {
                    PacketPlayerListEntriesItem::T0(v) => v.encode(buf)?,
                    PacketPlayerListEntriesItem::T1(v) => v.encode(buf)?,
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entries = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            0 => {
                                Some(
                                    PacketPlayerListEntriesItem::T0(
                                        Box::new(
                                            <PacketPlayerListEntriesItemT0 as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            1 => {
                                Some(
                                    PacketPlayerListEntriesItem::T1(
                                        <PacketPlayerListEntriesItemT1 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        Ok(Self { type_, entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerStatus {
    pub status: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerStatus {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let status = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { status })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveEntity {
    pub entityid: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { entityid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemovePlayer {
    pub entityid: i64,
    pub clientuuid: uuid::Uuid,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemovePlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.clientuuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let clientuuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entityid, clientuuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityData {
    pub entityid: i64,
    pub metadata: Metadatadictionary,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.metadata.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <Metadatadictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entityid, metadata })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityLink {
    pub riderid: i64,
    pub riddenid: i64,
    pub linktype: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityLink {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.riderid.encode(buf)?;
        self.riddenid.encode(buf)?;
        self.linktype.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let riderid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let riddenid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let linktype = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            riderid,
            riddenid,
            linktype,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EntitymotionsItem {
    pub eid: i64,
    pub motx: f32,
    pub moty: f32,
    pub motz: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntitymotionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.eid.encode(buf)?;
        self.motx.encode(buf)?;
        self.moty.encode(buf)?;
        self.motz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let eid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let motx = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let moty = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let motz = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { eid, motx, moty, motz })
    }
}
pub type Entitymotions = Vec<EntitymotionsItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityMotion {
    pub entities: Entitymotions,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityMotion {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entities.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entities = <Entitymotions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entities })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTakeItemEntity {
    pub target: i64,
    pub entityid: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketTakeItemEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.target.encode(buf)?;
        self.entityid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let target = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { target, entityid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTileEntityData {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub namedtag: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketTileEntityData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.namedtag.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let namedtag = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { x, y, z, namedtag })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerattributesItem {
    pub minvalue: f32,
    pub maxvalue: f32,
    pub id: f32,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for PlayerattributesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.minvalue.encode(buf)?;
        self.maxvalue.encode(buf)?;
        self.id.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let minvalue = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let maxvalue = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let id = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            minvalue,
            maxvalue,
            id,
            name,
        })
    }
}
pub type Playerattributes = Vec<PlayerattributesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAttributes {
    pub entityid: i64,
    pub attributes: Playerattributes,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAttributes {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entityid.encode(buf)?;
        self.attributes.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entityid = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let attributes = <Playerattributes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entityid, attributes })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum EntityMetadataItem {
    T0(i8),
    T1(i16),
    T2(i32),
    T3(f32),
    T4(Lstring),
    T5(MetadatadictionaryItemValueT5),
    T6(MetadatadictionaryItemValueT6),
    T7(MetadatadictionaryItemValueT7),
    T8(i64),
}
