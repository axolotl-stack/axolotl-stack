// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddBehaviorTree {
    pub behaviortree: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddBehaviorTree {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.behaviortree.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let behaviortree = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { behaviortree })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEcsEntity {
    pub network_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEcsEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.network_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub unique_id: i64,
    pub runtime_id: i64,
    pub entity_type: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub body_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.unique_id as i64).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_id as i64).encode(buf)?;
        self.entity_type.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.body_yaw.encode(buf)?;
        self.attributes.encode(buf)?;
        self.metadata.encode(buf)?;
        self.properties.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let body_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let attributes = {
            let res: EntityAttributes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <EntityAttributesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let links = {
            let res: Links = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            unique_id,
            runtime_id,
            entity_type,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            body_yaw,
            attributes,
            metadata,
            properties,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddItemEntity {
    pub entity_id_self: i64,
    pub runtime_entity_id: i64,
    pub item: Item,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub metadata: MetadataDictionary,
    pub is_from_fishing: bool,
}
#[derive(Debug, Clone)]
pub struct PacketAddItemEntityArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketAddItemEntityArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketAddItemEntity {
    type Args = PacketAddItemEntityArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id_self as i64).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.item.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.metadata.encode(buf)?;
        self.is_from_fishing.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let is_from_fishing = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            item,
            position,
            velocity,
            metadata,
            is_from_fishing,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPainting {
    pub entity_id_self: i64,
    pub runtime_entity_id: i64,
    pub coordinates: Vec3F,
    pub direction: i32,
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPainting {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id_self as i64).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.direction as i32).encode(buf)?;
        self.title.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let coordinates = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let direction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            coordinates,
            direction,
            title,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub runtime_id: i64,
    pub platform_chat_id: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub gamemode: GameMode,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
    pub links: Links,
    pub device_id: String,
    pub device_os: DeviceOs,
}
#[derive(Debug, Clone)]
pub struct PacketAddPlayerArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketAddPlayerArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    type Args = PacketAddPlayerArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_id as i64).encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.held_item.encode(buf)?;
        self.gamemode.encode(buf)?;
        self.metadata.encode(buf)?;
        self.properties.encode(buf)?;
        self.unique_id.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let links = {
            let res: Links = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let device_os = <DeviceOs as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            username,
            runtime_id,
            platform_chat_id,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            held_item,
            gamemode,
            metadata,
            properties,
            unique_id,
            permission_level,
            command_permission,
            abilities,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddVolumeEntityBounds {
    pub min: BlockCoordinates,
    pub max: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddVolumeEntityBounds {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let min = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let max = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { min, max })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddVolumeEntity {
    pub runtime_id: i64,
    pub nbt: Vec<u8>,
    pub encoding_identifier: String,
    pub instance_name: String,
    pub bounds: PacketAddVolumeEntityBounds,
    pub dimension: i32,
    pub engine_version: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddVolumeEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_id as i64).encode(buf)?;
        self.nbt.encode(buf)?;
        self.encoding_identifier.encode(buf)?;
        self.instance_name.encode(buf)?;
        self.bounds.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension as i32).encode(buf)?;
        self.engine_version.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let encoding_identifier = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let instance_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bounds = <PacketAddVolumeEntityBounds as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let engine_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_id,
            nbt,
            encoding_identifier,
            instance_name,
            bounds,
            dimension,
            engine_version,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAdventureSettings {
    pub flags: AdventureFlags,
    pub command_permission: CommandPermissionLevelVarint,
    pub action_permissions: ActionPermissions,
    pub permission_level: PermissionLevel,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAdventureSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        crate::bedrock::codec::VarInt(self.custom_stored_permissions as i32)
            .encode(buf)?;
        self.user_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let flags = <AdventureFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevelVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let action_permissions = <ActionPermissions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let custom_stored_permissions = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAgentActionActionType {
    None = 0,
    Attack = 1,
    Collect = 2,
    Destroy = 3,
    DetectRedstone = 4,
    DetectObstacle = 5,
    Drop = 6,
    DropAll = 7,
    Inspect = 8,
    InspectData = 9,
    InspectItemCount = 10,
    InspectItemDetail = 11,
    InspectItemSpace = 12,
    Interact = 13,
    Move = 14,
    PlaceBlock = 15,
    Till = 16,
    TransferItemTo = 17,
    Turn = 18,
}
impl crate::bedrock::codec::BedrockCodec for PacketAgentActionActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketAgentActionActionType::None),
            1 => Ok(PacketAgentActionActionType::Attack),
            2 => Ok(PacketAgentActionActionType::Collect),
            3 => Ok(PacketAgentActionActionType::Destroy),
            4 => Ok(PacketAgentActionActionType::DetectRedstone),
            5 => Ok(PacketAgentActionActionType::DetectObstacle),
            6 => Ok(PacketAgentActionActionType::Drop),
            7 => Ok(PacketAgentActionActionType::DropAll),
            8 => Ok(PacketAgentActionActionType::Inspect),
            9 => Ok(PacketAgentActionActionType::InspectData),
            10 => Ok(PacketAgentActionActionType::InspectItemCount),
            11 => Ok(PacketAgentActionActionType::InspectItemDetail),
            12 => Ok(PacketAgentActionActionType::InspectItemSpace),
            13 => Ok(PacketAgentActionActionType::Interact),
            14 => Ok(PacketAgentActionActionType::Move),
            15 => Ok(PacketAgentActionActionType::PlaceBlock),
            16 => Ok(PacketAgentActionActionType::Till),
            17 => Ok(PacketAgentActionActionType::TransferItemTo),
            18 => Ok(PacketAgentActionActionType::Turn),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAgentActionActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAgentAction {
    pub request_id: String,
    pub action_type: PacketAgentActionActionType,
    pub body: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAgentAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        self.action_type.encode(buf)?;
        self.body.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let request_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let action_type = <PacketAgentActionActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let body = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            request_id,
            action_type,
            body,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketAgentAnimationAnimation {
    ArmSwing = 0,
    Shrug = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketAgentAnimationAnimation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketAgentAnimationAnimation::ArmSwing),
            1 => Ok(PacketAgentAnimationAnimation::Shrug),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAgentAnimationAnimation), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAgentAnimation {
    pub animation: PacketAgentAnimationAnimation,
    pub entity_runtime_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAgentAnimation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.animation.encode(buf)?;
        crate::bedrock::codec::VarLong(self.entity_runtime_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let animation = <PacketAgentAnimationAnimation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            animation,
            entity_runtime_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAnimateActionId {
    None = 0,
    SwingArm = 1,
    Unknown = 2,
    WakeUp = 3,
    CriticalHit = 4,
    MagicCriticalHit = 5,
    RowRight = 128,
    RowLeft = 129,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateActionId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketAnimateActionId::None),
            1 => Ok(PacketAnimateActionId::SwingArm),
            2 => Ok(PacketAnimateActionId::Unknown),
            3 => Ok(PacketAnimateActionId::WakeUp),
            4 => Ok(PacketAnimateActionId::CriticalHit),
            5 => Ok(PacketAnimateActionId::MagicCriticalHit),
            128 => Ok(PacketAnimateActionId::RowRight),
            129 => Ok(PacketAnimateActionId::RowLeft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAnimateActionId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimateContentRowLeft {
    pub boat_rowing_time: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateContentRowLeft {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.boat_rowing_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let boat_rowing_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { boat_rowing_time })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketAnimateContent {
    RowLeft(PacketAnimateContentRowLeft),
    RowRight(PacketAnimateContentRowLeft),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimate {
    pub action_id: PacketAnimateActionId,
    pub runtime_entity_id: i64,
    pub content: Option<PacketAnimateContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_id.encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketAnimateContent::RowLeft(v) => {
                    v.encode(buf)?;
                }
                PacketAnimateContent::RowRight(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_id = <PacketAnimateActionId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let content = match action_id {
            PacketAnimateActionId::RowLeft => {
                Some(
                    PacketAnimateContent::RowLeft(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketAnimateActionId::RowRight => {
                Some(
                    PacketAnimateContent::RowRight(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            action_id,
            runtime_entity_id,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimateEntity {
    pub animation: String,
    pub next_state: String,
    pub stop_condition: String,
    pub stop_condition_version: i32,
    pub controller: String,
    pub blend_out_time: f32,
    pub runtime_entity_ids: Vec<i64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.animation.encode(buf)?;
        self.next_state.encode(buf)?;
        self.stop_condition.encode(buf)?;
        self.stop_condition_version.encode(buf)?;
        self.controller.encode(buf)?;
        self.blend_out_time.encode(buf)?;
        let len = self.runtime_entity_ids.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.runtime_entity_ids {
            crate::bedrock::codec::VarLong((*item) as i64).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let animation = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let next_state = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let stop_condition = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let stop_condition_version = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let controller = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let blend_out_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_ids = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as i64,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            animation,
            next_state,
            stop_condition,
            stop_condition_version,
            controller,
            blend_out_time,
            runtime_entity_ids,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnvilDamage {
    pub damage: u8,
    pub position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnvilDamage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.damage.encode(buf)?;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let damage = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { damage, position })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketAvailableCommandsEnumsItemValuesItem {
    Byte(u8),
    Int(u32),
    Short(u16),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumsItem {
    pub name: String,
    pub values: Vec<Option<PacketAvailableCommandsEnumsItemValuesItem>>,
}
#[derive(Debug, Clone)]
pub struct PacketAvailableCommandsEnumsItemArgs {
    pub _enum_type: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsEnumsItem {
    type Args = PacketAvailableCommandsEnumsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            if let Some(v) = item {
                match v {
                    PacketAvailableCommandsEnumsItemValuesItem::Byte(v) => {
                        (*v).encode(buf)?;
                    }
                    PacketAvailableCommandsEnumsItemValuesItem::Int(v) => {
                        (*v).encode(buf)?;
                    }
                    PacketAvailableCommandsEnumsItemValuesItem::Short(v) => {
                        (*v).encode(buf)?;
                    }
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match args._enum_type {
                            Byte => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Byte(
                                        <u8 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            Int => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Int(
                                        <u32 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            Short => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Short(
                                        <u16 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsChainedSubcommandsItemValuesItem {
    pub index: u16,
    pub value: u16,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsChainedSubcommandsItemValuesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.index.encode(buf)?;
        self.value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let index = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let value = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { index, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsChainedSubcommandsItem {
    pub name: String,
    pub values: Vec<PacketAvailableCommandsChainedSubcommandsItemValuesItem>,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsChainedSubcommandsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsChainedSubcommandsItemValuesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    Int = 1,
    Float = 3,
    Value = 4,
    WildcardInt = 5,
    Operator = 6,
    CommandOperator = 7,
    Target = 8,
    WildcardTarget = 10,
    FilePath = 17,
    IntegerRange = 23,
    EquipmentSlots = 43,
    String = 44,
    BlockPosition = 52,
    Position = 53,
    Message = 55,
    RawText = 58,
    Json = 62,
    BlockStates = 71,
    Command = 74,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Int,
                )
            }
            3 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Float,
                )
            }
            4 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Value,
                )
            }
            5 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardInt,
                )
            }
            6 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Operator,
                )
            }
            7 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::CommandOperator,
                )
            }
            8 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Target,
                )
            }
            10 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardTarget,
                )
            }
            17 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::FilePath,
                )
            }
            23 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::IntegerRange,
                )
            }
            43 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::EquipmentSlots,
                )
            }
            44 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::String,
                )
            }
            52 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::BlockPosition,
                )
            }
            53 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Position,
                )
            }
            55 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Message,
                )
            }
            58 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::RawText,
                )
            }
            62 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Json,
                )
            }
            71 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::BlockStates,
                )
            }
            74 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Command,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType {
    Valid = 16,
    Enum = 48,
    Suffixed = 256,
    SoftEnum = 1040,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            16 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Valid,
                )
            }
            48 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Enum,
                )
            }
            256 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Suffixed,
                )
            }
            1040 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::SoftEnum,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    pub parameter_name: String,
    pub value_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType,
    pub enum_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType,
    pub optional: bool,
    pub options: CommandFlags,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.parameter_name.encode(buf)?;
        self.value_type.encode(buf)?;
        self.enum_type.encode(buf)?;
        self.optional.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let parameter_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let enum_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let optional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let options = <CommandFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            parameter_name,
            value_type,
            enum_type,
            optional,
            options,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItem {
    pub chaining: bool,
    pub parameters: Vec<
        PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem,
    >,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.chaining.encode(buf)?;
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let chaining = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let parameters = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { chaining, parameters })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItem {
    pub name: String,
    pub description: String,
    pub flags: u16,
    pub permission_level: u8,
    pub alias: i32,
    pub chained_subcommand_offsets: Vec<u16>,
    pub overloads: Vec<PacketAvailableCommandsCommandDataItemOverloadsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsCommandDataItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.description.encode(buf)?;
        self.flags.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.alias.encode(buf)?;
        let len = self.chained_subcommand_offsets.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.chained_subcommand_offsets {
            (*item).encode(buf)?;
        }
        let len = self.overloads.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.overloads {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let description = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let flags = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let permission_level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let alias = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let chained_subcommand_offsets = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let overloads = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            name,
            description,
            flags,
            permission_level,
            alias,
            chained_subcommand_offsets,
            overloads,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsDynamicEnumsItem {
    pub name: String,
    pub values: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsDynamicEnumsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    CheatsEnabled = 0,
    OperatorPermissions = 1,
    HostPermissions = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::CheatsEnabled,
                )
            }
            1 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::OperatorPermissions,
                )
            }
            2 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::HostPermissions,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    pub constraint: PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.constraint.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let constraint = <PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { constraint })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItem {
    pub value_index: i32,
    pub enum_index: i32,
    pub constraints: Vec<PacketAvailableCommandsEnumConstraintsItemConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsEnumConstraintsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.value_index.encode(buf)?;
        self.enum_index.encode(buf)?;
        let len = self.constraints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let value_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let enum_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let constraints = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItemConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            value_index,
            enum_index,
            constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommands {
    pub values_len: i32,
    pub _enum_type: EnumSizeBasedOnValuesLen,
    pub enum_values: Vec<String>,
    pub chained_subcommand_values: Vec<String>,
    pub suffixes: Vec<String>,
    pub enums: Vec<PacketAvailableCommandsEnumsItem>,
    pub chained_subcommands: Vec<PacketAvailableCommandsChainedSubcommandsItem>,
    pub command_data: Vec<PacketAvailableCommandsCommandDataItem>,
    pub dynamic_enums: Vec<PacketAvailableCommandsDynamicEnumsItem>,
    pub enum_constraints: Vec<PacketAvailableCommandsEnumConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommands {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.values_len as i32).encode(buf)?;
        {
            let len = self.values_len as usize;
            let val_i32 = self._enum_type as i32;
            if len <= 0xff {
                (val_i32 as u8).encode(buf)?;
            } else if len <= 0xffff {
                (val_i32 as u16).encode(buf)?;
            } else {
                (val_i32 as u32).encode(buf)?;
            }
        }
        let len = self.enum_values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enum_values {
            item.encode(buf)?;
        }
        let len = self.chained_subcommand_values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.chained_subcommand_values {
            item.encode(buf)?;
        }
        let len = self.suffixes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.suffixes {
            item.encode(buf)?;
        }
        let len = self.enums.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enums {
            item.encode(buf)?;
        }
        let len = self.chained_subcommands.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.chained_subcommands {
            item.encode(buf)?;
        }
        let len = self.command_data.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.command_data {
            item.encode(buf)?;
        }
        let len = self.dynamic_enums.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.dynamic_enums {
            item.encode(buf)?;
        }
        let len = self.enum_constraints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enum_constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let values_len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let _enum_type = {
            let len = values_len as usize;
            let raw_val = if len <= 0xff {
                <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())? as i32
            } else if len <= 0xffff {
                <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())? as i32
            } else {
                <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
            };
            match raw_val {
                0 => EnumSizeBasedOnValuesLen::Byte,
                1 => EnumSizeBasedOnValuesLen::Short,
                _ => EnumSizeBasedOnValuesLen::Int,
            }
        };
        let enum_values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let chained_subcommand_values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let suffixes = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let enums = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketAvailableCommandsEnumsItemArgs {
                                _enum_type: _enum_type as i32,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let chained_subcommands = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsChainedSubcommandsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let command_data = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let dynamic_enums = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsDynamicEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let enum_constraints = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            values_len,
            _enum_type,
            enum_values,
            chained_subcommand_values,
            suffixes,
            enums,
            chained_subcommands,
            command_data,
            dynamic_enums,
            enum_constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableEntityIdentifiers {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableEntityIdentifiers {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBiomeDefinitionList {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBiomeDefinitionList {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockEntityData {
    pub position: BlockCoordinates,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEntityData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { position, nbt })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketBlockEventType {
    Sound = 0,
    ChangeState = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketBlockEventType::Sound),
            1 => Ok(PacketBlockEventType::ChangeState),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBlockEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockEvent {
    pub position: BlockCoordinates,
    pub type_: PacketBlockEventType,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.type_.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let type_ = <PacketBlockEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { position, type_, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockPickRequest {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub add_user_data: bool,
    pub selected_slot: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockPickRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z as i32).encode(buf)?;
        self.add_user_data.encode(buf)?;
        self.selected_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let add_user_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            x,
            y,
            z,
            add_user_data,
            selected_slot,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketBookEditType {
    ReplacePage = 0,
    AddPage = 1,
    DeletePage = 2,
    SwapPages = 3,
    Sign = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketBookEditType::ReplacePage),
            1 => Ok(PacketBookEditType::AddPage),
            2 => Ok(PacketBookEditType::DeletePage),
            3 => Ok(PacketBookEditType::SwapPages),
            4 => Ok(PacketBookEditType::Sign),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBookEditType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentAddPage {
    pub page_number: u8,
    pub text: String,
    pub photo_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentAddPage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_number.encode(buf)?;
        self.text.encode(buf)?;
        self.photo_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let photo_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            page_number,
            text,
            photo_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentDeletePage {
    pub page_number: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentDeletePage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_number.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { page_number })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentSign {
    pub title: String,
    pub author: String,
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentSign {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.author.encode(buf)?;
        self.xuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let author = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { title, author, xuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentSwapPages {
    pub page_1: u8,
    pub page_2: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentSwapPages {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_1.encode(buf)?;
        self.page_2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page_1 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let page_2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { page_1, page_2 })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketBookEditContent {
    AddPage(PacketBookEditContentAddPage),
    DeletePage(PacketBookEditContentDeletePage),
    ReplacePage(PacketBookEditContentAddPage),
    Sign(PacketBookEditContentSign),
    SwapPages(PacketBookEditContentSwapPages),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEdit {
    pub type_: PacketBookEditType,
    pub slot: u8,
    pub content: Option<PacketBookEditContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEdit {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.slot.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketBookEditContent::AddPage(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::DeletePage(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::ReplacePage(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::Sign(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::SwapPages(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketBookEditType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match type_ {
            PacketBookEditType::AddPage => {
                Some(
                    PacketBookEditContent::AddPage(
                        <PacketBookEditContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::DeletePage => {
                Some(
                    PacketBookEditContent::DeletePage(
                        <PacketBookEditContentDeletePage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::ReplacePage => {
                Some(
                    PacketBookEditContent::ReplacePage(
                        <PacketBookEditContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::Sign => {
                Some(
                    PacketBookEditContent::Sign(
                        <PacketBookEditContentSign as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::SwapPages => {
                Some(
                    PacketBookEditContent::SwapPages(
                        <PacketBookEditContentSwapPages as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, slot, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketBossEventType {
    ShowBar = 0,
    RegisterPlayer = 1,
    HideBar = 2,
    UnregisterPlayer = 3,
    SetBarProgress = 4,
    SetBarTitle = 5,
    UpdateProperties = 6,
    Texture = 7,
    Query = 8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketBossEventType::ShowBar),
            1 => Ok(PacketBossEventType::RegisterPlayer),
            2 => Ok(PacketBossEventType::HideBar),
            3 => Ok(PacketBossEventType::UnregisterPlayer),
            4 => Ok(PacketBossEventType::SetBarProgress),
            5 => Ok(PacketBossEventType::SetBarTitle),
            6 => Ok(PacketBossEventType::UpdateProperties),
            7 => Ok(PacketBossEventType::Texture),
            8 => Ok(PacketBossEventType::Query),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBossEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentQuery {
    pub player_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentQuery {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.player_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { player_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentSetBarProgress {
    pub progress: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentSetBarProgress {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.progress.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { progress })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentSetBarTitle {
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentSetBarTitle {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { title })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentShowBar {
    pub title: String,
    pub progress: f32,
    pub screen_darkening: i16,
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentShowBar {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.progress.encode(buf)?;
        self.screen_darkening.encode(buf)?;
        crate::bedrock::codec::VarInt(self.color as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.overlay as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let screen_darkening = <i16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let color = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let overlay = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            title,
            progress,
            screen_darkening,
            color,
            overlay,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentTexture {
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentTexture {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.color as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.overlay as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let color = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let overlay = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { color, overlay })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentUpdateProperties {
    pub screen_darkening: i16,
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentUpdateProperties {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.screen_darkening.encode(buf)?;
        crate::bedrock::codec::VarInt(self.color as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.overlay as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let screen_darkening = <i16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let color = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let overlay = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            screen_darkening,
            color,
            overlay,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketBossEventContent {
    Query(PacketBossEventContentQuery),
    RegisterPlayer(PacketBossEventContentQuery),
    SetBarProgress(PacketBossEventContentSetBarProgress),
    SetBarTitle(PacketBossEventContentSetBarTitle),
    ShowBar(Box<PacketBossEventContentShowBar>),
    Texture(PacketBossEventContentTexture),
    UnregisterPlayer(PacketBossEventContentQuery),
    UpdateProperties(PacketBossEventContentUpdateProperties),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEvent {
    pub boss_entity_id: i64,
    pub type_: PacketBossEventType,
    pub content: Option<PacketBossEventContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.boss_entity_id as i64).encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketBossEventContent::Query(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::RegisterPlayer(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::SetBarProgress(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::SetBarTitle(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::ShowBar(v) => {
                    (&**v).encode(buf)?;
                }
                PacketBossEventContent::Texture(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::UnregisterPlayer(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::UpdateProperties(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let boss_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let type_ = <PacketBossEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            PacketBossEventType::Query => {
                Some(
                    PacketBossEventContent::Query(
                        <PacketBossEventContentQuery as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::RegisterPlayer => {
                Some(
                    PacketBossEventContent::RegisterPlayer(
                        <PacketBossEventContentQuery as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::SetBarProgress => {
                Some(
                    PacketBossEventContent::SetBarProgress(
                        <PacketBossEventContentSetBarProgress as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::SetBarTitle => {
                Some(
                    PacketBossEventContent::SetBarTitle(
                        <PacketBossEventContentSetBarTitle as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::ShowBar => {
                Some(
                    PacketBossEventContent::ShowBar(
                        Box::new(
                            <PacketBossEventContentShowBar as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            PacketBossEventType::Texture => {
                Some(
                    PacketBossEventContent::Texture(
                        <PacketBossEventContentTexture as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::UnregisterPlayer => {
                Some(
                    PacketBossEventContent::UnregisterPlayer(
                        <PacketBossEventContentQuery as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::UpdateProperties => {
                Some(
                    PacketBossEventContent::UpdateProperties(
                        <PacketBossEventContentUpdateProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            boss_entity_id,
            type_,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCamera {
    pub camera_entity_unique_id: i64,
    pub target_player_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCamera {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.camera_entity_unique_id as i64)
            .encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.target_player_unique_id as i64)
            .encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let camera_entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let target_player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            camera_entity_unique_id,
            target_player_unique_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCameraInstructionInstructionSetEaseDataType {
    Linear = 0,
    Spring = 1,
    InQuad = 2,
    OutQuad = 3,
    InOutQuad = 4,
    InCubic = 5,
    OutCubic = 6,
    InOutCubic = 7,
    InQuart = 8,
    OutQuart = 9,
    InOutQuart = 10,
    InQuint = 11,
    OutQuint = 12,
    InOutQuint = 13,
    InSine = 14,
    OutSine = 15,
    InOutSine = 16,
    InExpo = 17,
    OutExpo = 18,
    InOutExpo = 19,
    InCirc = 20,
    OutCirc = 21,
    InOutCirc = 22,
    InBounce = 23,
    OutBounce = 24,
    InOutBounce = 25,
    InBack = 26,
    OutBack = 27,
    InOutBack = 28,
    InElastic = 29,
    OutElastic = 30,
    InOutElastic = 31,
}
impl crate::bedrock::codec::BedrockCodec
for PacketCameraInstructionInstructionSetEaseDataType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCameraInstructionInstructionSetEaseDataType::Linear),
            1 => Ok(PacketCameraInstructionInstructionSetEaseDataType::Spring),
            2 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InQuad),
            3 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutQuad),
            4 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutQuad),
            5 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InCubic),
            6 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutCubic),
            7 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutCubic),
            8 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InQuart),
            9 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutQuart),
            10 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutQuart),
            11 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InQuint),
            12 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutQuint),
            13 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutQuint),
            14 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InSine),
            15 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutSine),
            16 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutSine),
            17 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InExpo),
            18 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutExpo),
            19 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutExpo),
            20 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InCirc),
            21 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutCirc),
            22 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutCirc),
            23 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InBounce),
            24 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutBounce),
            25 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutBounce),
            26 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InBack),
            27 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutBack),
            28 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutBack),
            29 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InElastic),
            30 => Ok(PacketCameraInstructionInstructionSetEaseDataType::OutElastic),
            31 => Ok(PacketCameraInstructionInstructionSetEaseDataType::InOutElastic),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCameraInstructionInstructionSetEaseDataType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionInstructionSetEaseData {
    pub type_: PacketCameraInstructionInstructionSetEaseDataType,
    pub duration: f32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketCameraInstructionInstructionSetEaseData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.duration.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketCameraInstructionInstructionSetEaseDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { type_, duration })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionInstructionSet {
    pub runtime_id: i32,
    pub ease_data: Option<PacketCameraInstructionInstructionSetEaseData>,
    pub position: Option<Vec3F>,
    pub rotation: Option<Vec2F>,
    pub facing: Option<Vec3F>,
    pub default: Option<bool>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstructionInstructionSet {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        match &self.ease_data {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.position {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.rotation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.facing {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.default {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let ease_data = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetEaseData as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let position = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let rotation = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let facing = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let default = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        Ok(Self {
            runtime_id,
            ease_data,
            position,
            rotation,
            facing,
            default,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionFade {
    pub fade_in_duration: f32,
    pub wait_duration: f32,
    pub fade_out_duration: f32,
    pub color_rgb: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstructionFade {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.fade_in_duration.encode(buf)?;
        self.wait_duration.encode(buf)?;
        self.fade_out_duration.encode(buf)?;
        self.color_rgb.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let fade_in_duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let wait_duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let fade_out_duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let color_rgb = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            fade_in_duration,
            wait_duration,
            fade_out_duration,
            color_rgb,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstruction {
    pub instruction_set: Option<PacketCameraInstructionInstructionSet>,
    pub clear: Option<bool>,
    pub fade: Option<PacketCameraInstructionFade>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstruction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.instruction_set {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.clear {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fade {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let instruction_set = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSet as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let clear = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let fade = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionFade as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        Ok(Self {
            instruction_set,
            clear,
            fade,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraPresets {
    pub presets: Vec<CameraPresets>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraPresets {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.presets.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.presets {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let presets = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraPresets as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { presets })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCameraShakeAction {
    Add = 0,
    Stop = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraShakeAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCameraShakeAction::Add),
            1 => Ok(PacketCameraShakeAction::Stop),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCameraShakeAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraShake {
    pub intensity: f32,
    pub duration: f32,
    pub type_: u8,
    pub action: PacketCameraShakeAction,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraShake {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.intensity.encode(buf)?;
        self.duration.encode(buf)?;
        self.type_.encode(buf)?;
        self.action.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let intensity = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action = <PacketCameraShakeAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            intensity,
            duration,
            type_,
            action,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChangeDimension {
    pub dimension: i32,
    pub position: Vec3F,
    pub respawn: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketChangeDimension {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.dimension as i32).encode(buf)?;
        self.position.encode(buf)?;
        self.respawn.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let respawn = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            dimension,
            position,
            respawn,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChangeMobProperty {
    pub entity_unique_id: i64,
    pub property: String,
    pub bool_value: bool,
    pub string_value: String,
    pub int_value: i32,
    pub float_value: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketChangeMobProperty {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_unique_id as i64).encode(buf)?;
        self.property.encode(buf)?;
        self.bool_value.encode(buf)?;
        self.string_value.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.int_value as i32).encode(buf)?;
        self.float_value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let property = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bool_value = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let string_value = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let int_value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let float_value = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_unique_id,
            property,
            bool_value,
            string_value,
            int_value,
            float_value,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChunkRadiusUpdate {
    pub chunk_radius: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketChunkRadiusUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.chunk_radius as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { chunk_radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheBlobStatus {
    pub misses: i32,
    pub haves: i32,
    pub missing: Vec<u64>,
    pub have: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheBlobStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.misses as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.haves as i32).encode(buf)?;
        let len = self.missing.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.missing {
            (*item).encode(buf)?;
        }
        let len = self.have.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.have {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let misses = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let haves = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let missing = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let have = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            misses,
            haves,
            missing,
            have,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheMissResponse {
    pub blobs: Vec<Blob>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheMissResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.blobs.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.blobs {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let blobs = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Blob as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { blobs })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheStatus {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCheatAbility {
    pub entity_unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCheatAbility {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_unique_id.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            entity_unique_id,
            permission_level,
            command_permission,
            abilities,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientStartItemCooldown {
    pub category: String,
    pub duration: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientStartItemCooldown {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.category.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.duration as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let category = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { category, duration })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientToServerHandshake {}
impl crate::bedrock::codec::BedrockCodec for PacketClientToServerHandshake {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemDataTracked {
    pub objects: Vec<TrackedObject>,
    pub decorations: Vec<MapDecoration>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemDataTracked {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.objects.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.objects {
            item.encode(buf)?;
        }
        let len = self.decorations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.decorations {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let objects = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TrackedObject as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let decorations = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <MapDecoration as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { objects, decorations })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemDataTexture {
    pub width: i32,
    pub height: i32,
    pub x_offset: i32,
    pub y_offset: i32,
    pub pixels: Vec<i32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemDataTexture {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.width as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.height as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.x_offset as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y_offset as i32).encode(buf)?;
        let len = self.pixels.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.pixels {
            crate::bedrock::codec::VarInt((*item) as i32).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let width = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let x_offset = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let y_offset = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let pixels = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as i32,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            width,
            height,
            x_offset,
            y_offset,
            pixels,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemData {
    pub map_id: i64,
    pub update_flags: UpdateMapFlags,
    pub dimension: u8,
    pub locked: bool,
    pub origin: Vec3I,
    pub included_in: Option<Vec<i64>>,
    pub scale: Option<u8>,
    pub tracked: Option<PacketClientboundMapItemDataTracked>,
    pub texture: Option<Box<PacketClientboundMapItemDataTexture>>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.map_id as i64).encode(buf)?;
        self.update_flags.encode(buf)?;
        self.dimension.encode(buf)?;
        self.locked.encode(buf)?;
        self.origin.encode(buf)?;
        if let Some(v) = &self.included_in {
            v.encode(buf)?;
        }
        if let Some(v) = &self.scale {
            v.encode(buf)?;
        }
        if let Some(v) = &self.tracked {
            v.encode(buf)?;
        }
        if let Some(v) = &self.texture {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let update_flags = <UpdateMapFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let locked = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let included_in = if update_flags.contains(UpdateMapFlags::INITIALISATION) {
            Some({
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?
                                .0 as i64,
                        );
                }
                tmp_vec
            })
        } else {
            None
        };
        let scale = if (update_flags.contains(UpdateMapFlags::INITIALISATION)
            || update_flags.contains(UpdateMapFlags::DECORATION)
            || update_flags.contains(UpdateMapFlags::TEXTURE))
        {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let tracked = if update_flags.contains(UpdateMapFlags::DECORATION) {
            Some(
                <PacketClientboundMapItemDataTracked as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let texture = if update_flags.contains(UpdateMapFlags::TEXTURE) {
            Some(
                Box::new(
                    <PacketClientboundMapItemDataTexture as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                ),
            )
        } else {
            None
        };
        Ok(Self {
            map_id,
            update_flags,
            dimension,
            locked,
            origin,
            included_in,
            scale,
            tracked,
            texture,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCodeBuilder {
    pub url: String,
    pub should_open_code_builder: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCodeBuilder {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.url.encode(buf)?;
        self.should_open_code_builder.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let url = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let should_open_code_builder = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            url,
            should_open_code_builder,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCodeBuilderSourceOperation {
    None = 0,
    Get = 1,
    Set = 2,
    Reset = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketCodeBuilderSourceOperation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCodeBuilderSourceOperation::None),
            1 => Ok(PacketCodeBuilderSourceOperation::Get),
            2 => Ok(PacketCodeBuilderSourceOperation::Set),
            3 => Ok(PacketCodeBuilderSourceOperation::Reset),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCodeBuilderSourceOperation), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCodeBuilderSourceCategory {
    None = 0,
    CodeStatus = 1,
    Instantiation = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketCodeBuilderSourceCategory {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCodeBuilderSourceCategory::None),
            1 => Ok(PacketCodeBuilderSourceCategory::CodeStatus),
            2 => Ok(PacketCodeBuilderSourceCategory::Instantiation),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCodeBuilderSourceCategory), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCodeBuilderSource {
    pub operation: PacketCodeBuilderSourceOperation,
    pub category: PacketCodeBuilderSourceCategory,
    pub value: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketCodeBuilderSource {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.operation.encode(buf)?;
        self.category.encode(buf)?;
        self.value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let operation = <PacketCodeBuilderSourceOperation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let category = <PacketCodeBuilderSourceCategory as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { operation, category, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdateContentFalse {
    pub minecart_entity_runtime_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentFalse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.minecart_entity_runtime_id as i64)
            .encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let minecart_entity_runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { minecart_entity_runtime_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCommandBlockUpdateContentTrueMode {
    Impulse = 0,
    Repeat = 1,
    Chain = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentTrueMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCommandBlockUpdateContentTrueMode::Impulse),
            1 => Ok(PacketCommandBlockUpdateContentTrueMode::Repeat),
            2 => Ok(PacketCommandBlockUpdateContentTrueMode::Chain),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCommandBlockUpdateContentTrueMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdateContentTrue {
    pub position: BlockCoordinates,
    pub mode: PacketCommandBlockUpdateContentTrueMode,
    pub needs_redstone: bool,
    pub conditional: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentTrue {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.mode.encode(buf)?;
        self.needs_redstone.encode(buf)?;
        self.conditional.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let mode = <PacketCommandBlockUpdateContentTrueMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let needs_redstone = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let conditional = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            position,
            mode,
            needs_redstone,
            conditional,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketCommandBlockUpdateContent {
    False(PacketCommandBlockUpdateContentFalse),
    True(Box<PacketCommandBlockUpdateContentTrue>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdate {
    pub content: Option<PacketCommandBlockUpdateContent>,
    pub command: String,
    pub last_output: String,
    pub name: String,
    pub should_track_output: bool,
    pub tick_delay: i32,
    pub execute_on_first_tick: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketCommandBlockUpdateContent::False(v) => {
                    v.encode(buf)?;
                }
                PacketCommandBlockUpdateContent::True(v) => {
                    (&**v).encode(buf)?;
                }
            }
        }
        self.command.encode(buf)?;
        self.last_output.encode(buf)?;
        self.name.encode(buf)?;
        self.should_track_output.encode(buf)?;
        self.tick_delay.encode(buf)?;
        self.execute_on_first_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let is_block = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = if is_block {
            Some(
                PacketCommandBlockUpdateContent::True(
                    Box::new(
                        <PacketCommandBlockUpdateContentTrue as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                ),
            )
        } else {
            Some(
                PacketCommandBlockUpdateContent::False(
                    <PacketCommandBlockUpdateContentFalse as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                ),
            )
        };
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let last_output = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let should_track_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tick_delay = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let execute_on_first_tick = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            content,
            command,
            last_output,
            name,
            should_track_output,
            tick_delay,
            execute_on_first_tick,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum PacketCommandOutputOutputType {
    Last = 1,
    Silent = 2,
    All = 3,
    DataSet = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandOutputOutputType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketCommandOutputOutputType::Last),
            2 => Ok(PacketCommandOutputOutputType::Silent),
            3 => Ok(PacketCommandOutputOutputType::All),
            4 => Ok(PacketCommandOutputOutputType::DataSet),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCommandOutputOutputType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandOutputOutputItem {
    pub success: bool,
    pub message_id: String,
    pub parameters: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandOutputOutputItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.success.encode(buf)?;
        self.message_id.encode(buf)?;
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let success = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let message_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let parameters = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            success,
            message_id,
            parameters,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandOutput {
    pub origin: CommandOrigin,
    pub output_type: PacketCommandOutputOutputType,
    pub success_count: i32,
    pub output: Vec<PacketCommandOutputOutputItem>,
    pub data_set: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandOutput {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.origin.encode(buf)?;
        self.output_type.encode(buf)?;
        crate::bedrock::codec::VarInt(self.success_count as i32).encode(buf)?;
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        if let Some(v) = &self.data_set {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let output_type = <PacketCommandOutputOutputType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let success_count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let output = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCommandOutputOutputItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let data_set = match output_type {
            PacketCommandOutputOutputType::DataSet => {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        Ok(Self {
            origin,
            output_type,
            success_count,
            output,
            data_set,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandRequest {
    pub command: String,
    pub origin: CommandOrigin,
    pub internal: bool,
    pub version: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.command.encode(buf)?;
        self.origin.encode(buf)?;
        self.internal.encode(buf)?;
        crate::bedrock::codec::VarInt(self.version as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let internal = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            command,
            origin,
            internal,
            version,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCompletedUsingItemUseMethod {
    EquipArmor = 0,
    Eat = 1,
    Attack = 2,
    Consume = 3,
    Throw = 4,
    Shoot = 5,
    Place = 6,
    FillBottle = 7,
    FillBucket = 8,
    PourBucket = 9,
    UseTool = 10,
    Interact = 11,
    Retrieved = 12,
    Dyed = 13,
    Traded = 14,
    BrushingCompleted = 15,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItemUseMethod {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCompletedUsingItemUseMethod::EquipArmor),
            1 => Ok(PacketCompletedUsingItemUseMethod::Eat),
            2 => Ok(PacketCompletedUsingItemUseMethod::Attack),
            3 => Ok(PacketCompletedUsingItemUseMethod::Consume),
            4 => Ok(PacketCompletedUsingItemUseMethod::Throw),
            5 => Ok(PacketCompletedUsingItemUseMethod::Shoot),
            6 => Ok(PacketCompletedUsingItemUseMethod::Place),
            7 => Ok(PacketCompletedUsingItemUseMethod::FillBottle),
            8 => Ok(PacketCompletedUsingItemUseMethod::FillBucket),
            9 => Ok(PacketCompletedUsingItemUseMethod::PourBucket),
            10 => Ok(PacketCompletedUsingItemUseMethod::UseTool),
            11 => Ok(PacketCompletedUsingItemUseMethod::Interact),
            12 => Ok(PacketCompletedUsingItemUseMethod::Retrieved),
            13 => Ok(PacketCompletedUsingItemUseMethod::Dyed),
            14 => Ok(PacketCompletedUsingItemUseMethod::Traded),
            15 => Ok(PacketCompletedUsingItemUseMethod::BrushingCompleted),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCompletedUsingItemUseMethod), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCompletedUsingItem {
    pub used_item_id: i16,
    pub use_method: PacketCompletedUsingItemUseMethod,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.used_item_id.encode(buf)?;
        self.use_method.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let used_item_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let use_method = <PacketCompletedUsingItemUseMethod as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { used_item_id, use_method })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCompressedBiomeDefinitions {
    pub raw_payload: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompressedBiomeDefinitions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.raw_payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw_payload = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { raw_payload })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerClose {
    pub window_id: WindowId,
    pub server: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerClose {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { window_id, server })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerOpen {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub coordinates: BlockCoordinates,
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerOpen {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.runtime_entity_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            window_id,
            window_type,
            coordinates,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerSetData {
    pub window_id: WindowId,
    pub property: i32,
    pub value: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerSetData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.property as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.value as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let property = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { window_id, property, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCorrectPlayerMovePrediction {
    pub position: Vec3F,
    pub delta: Vec3F,
    pub on_ground: bool,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCorrectPlayerMovePrediction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.delta.encode(buf)?;
        self.on_ground.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let tick = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            position,
            delta,
            on_ground,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingData {
    pub recipes: Recipes,
    pub potion_type_recipes: PotionTypeRecipes,
    pub potion_container_recipes: PotionContainerChangeRecipes,
    pub material_reducers: Vec<MaterialReducer>,
    pub clear_recipes: bool,
}
#[derive(Debug, Clone)]
pub struct PacketCraftingDataArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketCraftingDataArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingData {
    type Args = PacketCraftingDataArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipes.encode(buf)?;
        self.potion_type_recipes.encode(buf)?;
        self.potion_container_recipes.encode(buf)?;
        let len = self.material_reducers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.material_reducers {
            item.encode(buf)?;
        }
        self.clear_recipes.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipes = {
            let res: Recipes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <RecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let potion_type_recipes = {
            let res: PotionTypeRecipes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PotionTypeRecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let potion_container_recipes = {
            let res: PotionContainerChangeRecipes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PotionContainerChangeRecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let material_reducers = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <MaterialReducer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let clear_recipes = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            recipes,
            potion_type_recipes,
            potion_container_recipes,
            material_reducers,
            clear_recipes,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCraftingEventRecipeType {
    Inventory = 0,
    Crafting = 1,
    Workbench = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingEventRecipeType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCraftingEventRecipeType::Inventory),
            1 => Ok(PacketCraftingEventRecipeType::Crafting),
            2 => Ok(PacketCraftingEventRecipeType::Workbench),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCraftingEventRecipeType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingEvent {
    pub window_id: WindowId,
    pub recipe_type: PacketCraftingEventRecipeType,
    pub recipe_id: uuid::Uuid,
    pub input: Vec<Item>,
    pub result: Vec<Item>,
}
#[derive(Debug, Clone)]
pub struct PacketCraftingEventArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketCraftingEventArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingEvent {
    type Args = PacketCraftingEventArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.recipe_type.encode(buf)?;
        self.recipe_id.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.result.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe_type = <PacketCraftingEventRecipeType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe_id = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let result = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            window_id,
            recipe_type,
            recipe_id,
            input,
            result,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreatePhoto {
    pub entity_unique_id: i64,
    pub photo_name: String,
    pub item_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreatePhoto {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_unique_id.encode(buf)?;
        self.photo_name.encode(buf)?;
        self.item_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let photo_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let item_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_unique_id,
            photo_name,
            item_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContentItemsItem {
    pub entry_id: i32,
    pub item: ItemLegacy,
}
#[derive(Debug, Clone)]
pub struct PacketCreativeContentItemsItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketCreativeContentItemsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContentItemsItem {
    type Args = PacketCreativeContentItemsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.entry_id as i32).encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entry_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let item = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self { entry_id, item })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContent {
    pub items: Vec<PacketCreativeContentItemsItem>,
}
#[derive(Debug, Clone)]
pub struct PacketCreativeContentArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketCreativeContentArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContent {
    type Args = PacketCreativeContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.items.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.items {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let items = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCreativeContentItemsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketCreativeContentItemsItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { items })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDeathInfo {
    pub cause: String,
    pub messages: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketDeathInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cause.encode(buf)?;
        let len = self.messages.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.messages {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cause = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let messages = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { cause, messages })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDebugInfo {
    pub player_unique_id: i64,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketDebugInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.player_unique_id as i64).encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let data = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { player_unique_id, data })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketDebugRendererType {
    Clear = 1,
    AddCube = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketDebugRendererType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketDebugRendererType::Clear),
            2 => Ok(PacketDebugRendererType::AddCube),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketDebugRendererType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDebugRendererContentAddCube {
    pub text: String,
    pub position: Vec3F,
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
    pub duration: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketDebugRendererContentAddCube {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.text.encode(buf)?;
        self.position.encode(buf)?;
        self.red.encode(buf)?;
        self.green.encode(buf)?;
        self.blue.encode(buf)?;
        self.alpha.encode(buf)?;
        self.duration.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let red = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let green = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let blue = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let alpha = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            text,
            position,
            red,
            green,
            blue,
            alpha,
            duration,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketDebugRendererContent {
    AddCube(Box<PacketDebugRendererContentAddCube>),
    Clear,
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDebugRenderer {
    pub type_: PacketDebugRendererType,
    pub content: Option<PacketDebugRendererContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketDebugRenderer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketDebugRendererContent::AddCube(v) => {
                    (&**v).encode(buf)?;
                }
                PacketDebugRendererContent::Clear => {}
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketDebugRendererType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            PacketDebugRendererType::AddCube => {
                Some(
                    PacketDebugRendererContent::AddCube(
                        Box::new(
                            <PacketDebugRendererContentAddCube as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            PacketDebugRendererType::Clear => Some(PacketDebugRendererContent::Clear),
            _ => None,
        };
        Ok(Self { type_, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketDimensionDataDefinitionsItemGenerator {
    Legacy = 0,
    Overworld = 1,
    Flat = 2,
    Nether = 3,
    End = 4,
    Void = 5,
}
impl crate::bedrock::codec::BedrockCodec
for PacketDimensionDataDefinitionsItemGenerator {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketDimensionDataDefinitionsItemGenerator::Legacy),
            1 => Ok(PacketDimensionDataDefinitionsItemGenerator::Overworld),
            2 => Ok(PacketDimensionDataDefinitionsItemGenerator::Flat),
            3 => Ok(PacketDimensionDataDefinitionsItemGenerator::Nether),
            4 => Ok(PacketDimensionDataDefinitionsItemGenerator::End),
            5 => Ok(PacketDimensionDataDefinitionsItemGenerator::Void),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketDimensionDataDefinitionsItemGenerator), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDimensionDataDefinitionsItem {
    pub id: String,
    pub max_height: i32,
    pub min_height: i32,
    pub generator: PacketDimensionDataDefinitionsItemGenerator,
}
impl crate::bedrock::codec::BedrockCodec for PacketDimensionDataDefinitionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.max_height as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.min_height as i32).encode(buf)?;
        self.generator.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let max_height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let min_height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let generator = <PacketDimensionDataDefinitionsItemGenerator as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            id,
            max_height,
            min_height,
            generator,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDimensionData {
    pub definitions: Vec<PacketDimensionDataDefinitionsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketDimensionData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.definitions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.definitions {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let definitions = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketDimensionDataDefinitionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { definitions })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDisconnect {
    pub hide_disconnect_reason: bool,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketDisconnect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.hide_disconnect_reason.encode(buf)?;
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let hide_disconnect_reason = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            hide_disconnect_reason,
            message,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEditorNetwork {
    pub payload: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEditorNetwork {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let payload = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { payload })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEduUriResourcePacket {
    pub resource: EducationSharedResourceUri,
}
impl crate::bedrock::codec::BedrockCodec for PacketEduUriResourcePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.resource.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let resource = <EducationSharedResourceUri as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { resource })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEducationSettingsAgentCapabilities {
    pub has: bool,
    pub can_modify_blocks: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketEducationSettingsAgentCapabilities {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.has.encode(buf)?;
        self.can_modify_blocks.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let has = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let can_modify_blocks = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { has, can_modify_blocks })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEducationSettingsExternalLinkSettings {
    pub has: bool,
    pub url: String,
    pub display_name: String,
}
impl crate::bedrock::codec::BedrockCodec
for PacketEducationSettingsExternalLinkSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.has.encode(buf)?;
        self.url.encode(buf)?;
        self.display_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let has = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let url = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { has, url, display_name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEducationSettings {
    pub code_builder_default_uri: String,
    pub code_builder_title: String,
    pub can_resize_code_builder: bool,
    pub disable_legacy_title_bar: bool,
    pub post_process_filter: String,
    pub screenshot_border_path: String,
    pub agent_capabilities: Option<PacketEducationSettingsAgentCapabilities>,
    pub has_override_uri: bool,
    pub override_uri: Option<String>,
    pub has_quiz: bool,
    pub external_link_settings: Option<PacketEducationSettingsExternalLinkSettings>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEducationSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.code_builder_default_uri.encode(buf)?;
        self.code_builder_title.encode(buf)?;
        self.can_resize_code_builder.encode(buf)?;
        self.disable_legacy_title_bar.encode(buf)?;
        self.post_process_filter.encode(buf)?;
        self.screenshot_border_path.encode(buf)?;
        let val = self.agent_capabilities.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.agent_capabilities {
            v.encode(buf)?;
        }
        self.has_override_uri.encode(buf)?;
        if let Some(v) = &self.override_uri {
            v.encode(buf)?;
        }
        self.has_quiz.encode(buf)?;
        let val = self.external_link_settings.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.external_link_settings {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let code_builder_default_uri = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let code_builder_title = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let can_resize_code_builder = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let disable_legacy_title_bar = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let post_process_filter = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let screenshot_border_path = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_agent_capabilities = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let agent_capabilities = if has_agent_capabilities {
            Some(
                <PacketEducationSettingsAgentCapabilities as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let has_override_uri = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let override_uri = if has_override_uri {
            Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let has_quiz = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let has_external_link_settings = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let external_link_settings = if has_external_link_settings {
            Some(
                <PacketEducationSettingsExternalLinkSettings as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        Ok(Self {
            code_builder_default_uri,
            code_builder_title,
            can_resize_code_builder,
            disable_legacy_title_bar,
            post_process_filter,
            screenshot_border_path,
            agent_capabilities,
            has_override_uri,
            override_uri,
            has_quiz,
            external_link_settings,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEmoteFlags {
    ServerSide = 1,
    MuteChat = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketEmoteFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketEmoteFlags::ServerSide),
            2 => Ok(PacketEmoteFlags::MuteChat),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEmoteFlags), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEmote {
    pub entity_id: i64,
    pub emote_id: String,
    pub xuid: String,
    pub platform_id: String,
    pub flags: PacketEmoteFlags,
}
impl crate::bedrock::codec::BedrockCodec for PacketEmote {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.entity_id as i64).encode(buf)?;
        self.emote_id.encode(buf)?;
        self.xuid.encode(buf)?;
        self.platform_id.encode(buf)?;
        self.flags.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let emote_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let platform_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let flags = <PacketEmoteFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id,
            emote_id,
            xuid,
            platform_id,
            flags,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEmoteList {
    pub player_id: i64,
    pub emote_pieces: Vec<uuid::Uuid>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEmoteList {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.player_id as i64).encode(buf)?;
        let len = self.emote_pieces.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.emote_pieces {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let emote_pieces = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { player_id, emote_pieces })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEntityEventEventId {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    Caravan = 64,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
    GrowUp = 76,
    VibrationDetected = 77,
    DrinkMilk = 78,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEventEventId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketEntityEventEventId::Jump),
            2 => Ok(PacketEntityEventEventId::HurtAnimation),
            3 => Ok(PacketEntityEventEventId::DeathAnimation),
            4 => Ok(PacketEntityEventEventId::ArmSwing),
            5 => Ok(PacketEntityEventEventId::StopAttack),
            6 => Ok(PacketEntityEventEventId::TameFail),
            7 => Ok(PacketEntityEventEventId::TameSuccess),
            8 => Ok(PacketEntityEventEventId::ShakeWet),
            9 => Ok(PacketEntityEventEventId::UseItem),
            10 => Ok(PacketEntityEventEventId::EatGrassAnimation),
            11 => Ok(PacketEntityEventEventId::FishHookBubble),
            12 => Ok(PacketEntityEventEventId::FishHookPosition),
            13 => Ok(PacketEntityEventEventId::FishHookHook),
            14 => Ok(PacketEntityEventEventId::FishHookTease),
            15 => Ok(PacketEntityEventEventId::SquidInkCloud),
            16 => Ok(PacketEntityEventEventId::ZombieVillagerCure),
            18 => Ok(PacketEntityEventEventId::Respawn),
            19 => Ok(PacketEntityEventEventId::IronGolemOfferFlower),
            20 => Ok(PacketEntityEventEventId::IronGolemWithdrawFlower),
            21 => Ok(PacketEntityEventEventId::LoveParticles),
            22 => Ok(PacketEntityEventEventId::VillagerAngry),
            23 => Ok(PacketEntityEventEventId::VillagerHappy),
            24 => Ok(PacketEntityEventEventId::WitchSpellParticles),
            25 => Ok(PacketEntityEventEventId::FireworkParticles),
            26 => Ok(PacketEntityEventEventId::InLoveParticles),
            27 => Ok(PacketEntityEventEventId::SilverfishSpawnAnimation),
            28 => Ok(PacketEntityEventEventId::GuardianAttack),
            29 => Ok(PacketEntityEventEventId::WitchDrinkPotion),
            30 => Ok(PacketEntityEventEventId::WitchThrowPotion),
            31 => Ok(PacketEntityEventEventId::MinecartTntPrimeFuse),
            32 => Ok(PacketEntityEventEventId::CreeperPrimeFuse),
            33 => Ok(PacketEntityEventEventId::AirSupplyExpired),
            34 => Ok(PacketEntityEventEventId::PlayerAddXpLevels),
            35 => Ok(PacketEntityEventEventId::ElderGuardianCurse),
            36 => Ok(PacketEntityEventEventId::AgentArmSwing),
            37 => Ok(PacketEntityEventEventId::EnderDragonDeath),
            38 => Ok(PacketEntityEventEventId::DustParticles),
            39 => Ok(PacketEntityEventEventId::ArrowShake),
            57 => Ok(PacketEntityEventEventId::EatingItem),
            60 => Ok(PacketEntityEventEventId::BabyAnimalFeed),
            61 => Ok(PacketEntityEventEventId::DeathSmokeCloud),
            62 => Ok(PacketEntityEventEventId::CompleteTrade),
            63 => Ok(PacketEntityEventEventId::RemoveLeash),
            64 => Ok(PacketEntityEventEventId::Caravan),
            65 => Ok(PacketEntityEventEventId::ConsumeTotem),
            66 => Ok(PacketEntityEventEventId::PlayerCheckTreasureHunterAchievement),
            67 => Ok(PacketEntityEventEventId::EntitySpawn),
            68 => Ok(PacketEntityEventEventId::DragonPuke),
            69 => Ok(PacketEntityEventEventId::ItemEntityMerge),
            70 => Ok(PacketEntityEventEventId::StartSwim),
            71 => Ok(PacketEntityEventEventId::BalloonPop),
            72 => Ok(PacketEntityEventEventId::TreasureHunt),
            73 => Ok(PacketEntityEventEventId::AgentSummon),
            74 => Ok(PacketEntityEventEventId::ChargedItem),
            75 => Ok(PacketEntityEventEventId::Fall),
            76 => Ok(PacketEntityEventEventId::GrowUp),
            77 => Ok(PacketEntityEventEventId::VibrationDetected),
            78 => Ok(PacketEntityEventEventId::DrinkMilk),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEntityEventEventId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i64,
    pub event_id: PacketEntityEventEventId,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.event_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let event_id = <PacketEntityEventEventId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityPickRequest {
    pub runtime_entity_id: u64,
    pub selected_slot: u8,
    pub with_data: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityPickRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.with_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let with_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            selected_slot,
            with_data,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketEventEventType {
    AchievementAwarded = 0,
    EntityInteract = 1,
    PortalBuilt = 2,
    PortalUsed = 3,
    MobKilled = 4,
    CauldronUsed = 5,
    PlayerDeath = 6,
    BossKilled = 7,
    AgentCommand = 8,
    AgentCreated = 9,
    BannerPatternRemoved = 10,
    CommandExecuted = 11,
    FishBucketed = 12,
    MobBorn = 13,
    PetDied = 14,
    CauldronBlockUsed = 15,
    ComposterBlockUsed = 16,
    BellBlockUsed = 17,
    ActorDefinition = 18,
    RaidUpdate = 19,
    PlayerMovementAnomaly = 20,
    PlayerMovementCorrected = 21,
    HoneyHarvested = 22,
    TargetBlockHit = 23,
    PiglinBarter = 24,
    WaxedOrUnwaxedCopper = 25,
    CodeBuilderRuntimeAction = 26,
    CodeBuilderScoreboard = 27,
    StriderRiddenInLavaInOverworld = 28,
    SneakCloseToSculkSensor = 29,
    CarefulRestoration = 30,
}
impl crate::bedrock::codec::BedrockCodec for PacketEventEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketEventEventType::AchievementAwarded),
            1 => Ok(PacketEventEventType::EntityInteract),
            2 => Ok(PacketEventEventType::PortalBuilt),
            3 => Ok(PacketEventEventType::PortalUsed),
            4 => Ok(PacketEventEventType::MobKilled),
            5 => Ok(PacketEventEventType::CauldronUsed),
            6 => Ok(PacketEventEventType::PlayerDeath),
            7 => Ok(PacketEventEventType::BossKilled),
            8 => Ok(PacketEventEventType::AgentCommand),
            9 => Ok(PacketEventEventType::AgentCreated),
            10 => Ok(PacketEventEventType::BannerPatternRemoved),
            11 => Ok(PacketEventEventType::CommandExecuted),
            12 => Ok(PacketEventEventType::FishBucketed),
            13 => Ok(PacketEventEventType::MobBorn),
            14 => Ok(PacketEventEventType::PetDied),
            15 => Ok(PacketEventEventType::CauldronBlockUsed),
            16 => Ok(PacketEventEventType::ComposterBlockUsed),
            17 => Ok(PacketEventEventType::BellBlockUsed),
            18 => Ok(PacketEventEventType::ActorDefinition),
            19 => Ok(PacketEventEventType::RaidUpdate),
            20 => Ok(PacketEventEventType::PlayerMovementAnomaly),
            21 => Ok(PacketEventEventType::PlayerMovementCorrected),
            22 => Ok(PacketEventEventType::HoneyHarvested),
            23 => Ok(PacketEventEventType::TargetBlockHit),
            24 => Ok(PacketEventEventType::PiglinBarter),
            25 => Ok(PacketEventEventType::WaxedOrUnwaxedCopper),
            26 => Ok(PacketEventEventType::CodeBuilderRuntimeAction),
            27 => Ok(PacketEventEventType::CodeBuilderScoreboard),
            28 => Ok(PacketEventEventType::StriderRiddenInLavaInOverworld),
            29 => Ok(PacketEventEventType::SneakCloseToSculkSensor),
            30 => Ok(PacketEventEventType::CarefulRestoration),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEventEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEvent {
    pub runtime_id: i64,
    pub event_type: PacketEventEventType,
    pub use_player_id: u8,
    pub event_data: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_id as i64).encode(buf)?;
        self.event_type.encode(buf)?;
        self.use_player_id.encode(buf)?;
        self.event_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let event_type = <PacketEventEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let use_player_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let event_data = <Vec<
            u8,
        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_id,
            event_type,
            use_player_id,
            event_data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketFeatureRegistryFeaturesItem {
    pub name: String,
    pub options: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketFeatureRegistryFeaturesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let options = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, options })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketFeatureRegistry {
    pub features: Vec<PacketFeatureRegistryFeaturesItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketFeatureRegistry {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.features.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.features {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let features = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketFeatureRegistryFeaturesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { features })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketFilterTextPacket {
    pub text: String,
    pub from_server: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketFilterTextPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.text.encode(buf)?;
        self.from_server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let from_server = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { text, from_server })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameRulesChanged {
    pub rules: GameRules,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameRulesChanged {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.rules.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let rules = {
            let res: GameRules = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <GameRule as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { rules })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketGameTestRequestRotation {
    T0Deg = 0,
    T90Deg = 1,
    T180Deg = 2,
    T270Deg = 3,
    T360Deg = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameTestRequestRotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketGameTestRequestRotation::T0Deg),
            1 => Ok(PacketGameTestRequestRotation::T90Deg),
            2 => Ok(PacketGameTestRequestRotation::T180Deg),
            3 => Ok(PacketGameTestRequestRotation::T270Deg),
            4 => Ok(PacketGameTestRequestRotation::T360Deg),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketGameTestRequestRotation), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameTestRequest {
    pub max_tests_per_batch: i32,
    pub repetitions: i32,
    pub rotation: PacketGameTestRequestRotation,
    pub stop_on_error: bool,
    pub position: BlockCoordinates,
    pub tests_per_row: i32,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameTestRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.max_tests_per_batch as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.repetitions as i32).encode(buf)?;
        self.rotation.encode(buf)?;
        self.stop_on_error.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.tests_per_row as i32).encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let max_tests_per_batch = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let repetitions = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let rotation = <PacketGameTestRequestRotation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let stop_on_error = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tests_per_row = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            max_tests_per_batch,
            repetitions,
            rotation,
            stop_on_error,
            position,
            tests_per_row,
            name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameTestResults {
    pub succeeded: bool,
    pub error: String,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameTestResults {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.succeeded.encode(buf)?;
        self.error.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let succeeded = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let error = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { succeeded, error, name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGuiDataPickItem {
    pub item_name: String,
    pub item_effects: String,
    pub hotbar_slot: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketGuiDataPickItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.item_name.encode(buf)?;
        self.item_effects.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let item_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let item_effects = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hotbar_slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            item_name,
            item_effects,
            hotbar_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketHurtArmor {
    pub cause: i32,
    pub damage: i32,
    pub armor_slots: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketHurtArmor {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.cause as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.damage as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.armor_slots as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cause = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let damage = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let armor_slots = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { cause, damage, armor_slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInitiateWebSocketConnection {
    pub server: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketInitiateWebSocketConnection {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let server = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { server })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketInteractActionId {
    LeaveVehicle = 3,
    MouseOverEntity = 4,
    NpcOpen = 5,
    OpenInventory = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketInteractActionId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            3 => Ok(PacketInteractActionId::LeaveVehicle),
            4 => Ok(PacketInteractActionId::MouseOverEntity),
            5 => Ok(PacketInteractActionId::NpcOpen),
            6 => Ok(PacketInteractActionId::OpenInventory),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketInteractActionId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketInteractPosition {
    LeaveVehicle(Vec3F),
    MouseOverEntity(Vec3F),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInteract {
    pub action_id: PacketInteractActionId,
    pub target_entity_id: i64,
    pub position: Option<PacketInteractPosition>,
}
impl crate::bedrock::codec::BedrockCodec for PacketInteract {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_id.encode(buf)?;
        crate::bedrock::codec::VarLong(self.target_entity_id as i64).encode(buf)?;
        if let Some(v) = &self.position {
            match v {
                PacketInteractPosition::LeaveVehicle(v) => {
                    v.encode(buf)?;
                }
                PacketInteractPosition::MouseOverEntity(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_id = <PacketInteractActionId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let target_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let position = match action_id {
            PacketInteractActionId::LeaveVehicle => {
                Some(
                    PacketInteractPosition::LeaveVehicle(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            PacketInteractActionId::MouseOverEntity => {
                Some(
                    PacketInteractPosition::MouseOverEntity(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            action_id,
            target_entity_id,
            position,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryContent {
    pub window_id: WindowIdVarint,
    pub input: ItemStacks,
}
#[derive(Debug, Clone)]
pub struct PacketInventoryContentArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketInventoryContentArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryContent {
    type Args = PacketInventoryContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.input.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let res: ItemStacks = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Item as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                ItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { window_id, input })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventorySlot {
    pub window_id: WindowIdVarint,
    pub slot: i32,
    pub item: Item,
}
#[derive(Debug, Clone)]
pub struct PacketInventorySlotArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketInventorySlotArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketInventorySlot {
    type Args = PacketInventorySlotArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        crate::bedrock::codec::VarInt(self.slot as i32).encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self { window_id, slot, item })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryTransaction {
    pub transaction: Transaction,
}
#[derive(Debug, Clone)]
pub struct PacketInventoryTransactionArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketInventoryTransactionArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryTransaction {
    type Args = PacketInventoryTransactionArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.transaction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let transaction = <Transaction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            TransactionArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self { transaction })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemComponent {
    pub entries: ItemComponentList,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemComponent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entries.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entries = {
            let res: ItemComponentList = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemComponentListItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemFrameDropItem {
    pub coordinates: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemFrameDropItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { coordinates })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemStackRequest {
    pub requests: Vec<ItemStackRequest>,
}
#[derive(Debug, Clone)]
pub struct PacketItemStackRequestArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketItemStackRequestArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketItemStackRequest {
    type Args = PacketItemStackRequestArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.requests.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let requests = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemStackRequestArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { requests })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemStackResponse {
    pub responses: ItemStackResponses,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemStackResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.responses.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let responses = {
            let res: ItemStackResponses = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemStackResponsesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { responses })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketLabTableActionType {
    Combine = 0,
    React = 1,
    Reset = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketLabTableActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketLabTableActionType::Combine),
            1 => Ok(PacketLabTableActionType::React),
            2 => Ok(PacketLabTableActionType::Reset),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLabTableActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLabTable {
    pub action_type: PacketLabTableActionType,
    pub position: Vec3I,
    pub reaction_type: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketLabTable {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.position.encode(buf)?;
        self.reaction_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <PacketLabTableActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let reaction_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            action_type,
            position,
            reaction_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLecternUpdate {
    pub page: u8,
    pub page_count: u8,
    pub position: Vec3I,
    pub drop_book: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLecternUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page.encode(buf)?;
        self.page_count.encode(buf)?;
        self.position.encode(buf)?;
        self.drop_book.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let page_count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let drop_book = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            page,
            page_count,
            position,
            drop_book,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLessonProgress {
    pub action: u8,
    pub score: i32,
    pub identifier: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketLessonProgress {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.score as i32).encode(buf)?;
        self.identifier.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let score = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let identifier = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { action, score, identifier })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunkBlobs {
    pub hashes: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunkBlobs {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.hashes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.hashes {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let hashes = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { hashes })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunk {
    pub x: i32,
    pub z: i32,
    pub sub_chunk_count: i32,
    pub highest_subchunk_count: Option<u16>,
    pub blobs: Option<PacketLevelChunkBlobs>,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunk {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.sub_chunk_count as i32).encode(buf)?;
        if let Some(v) = &self.highest_subchunk_count {
            v.encode(buf)?;
        }
        let val = self.blobs.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.blobs {
            v.encode(buf)?;
        }
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let sub_chunk_count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let highest_subchunk_count = match sub_chunk_count {
            -2 => Some(<u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?),
            _ => None,
        };
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let blobs = if cache_enabled {
            Some(
                <PacketLevelChunkBlobs as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            x,
            z,
            sub_chunk_count,
            highest_subchunk_count,
            blobs,
            payload,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketLevelEventEvent {
    SoundClick = 1000,
    SoundClickFail = 1001,
    SoundShoot = 1002,
    SoundDoor = 1003,
    SoundFizz = 1004,
    SoundIgnite = 1005,
    SoundGhast = 1007,
    SoundGhastShoot = 1008,
    SoundBlazeShoot = 1009,
    SoundDoorBump = 1010,
    SoundDoorCrash = 1012,
    SoundEndermanTeleport = 1018,
    SoundAnvilBreak = 1020,
    SoundAnvilUse = 1021,
    SoundAnvilFall = 1022,
    SoundPop = 1030,
    SoundPortal = 1032,
    SoundItemframeAddItem = 1040,
    SoundItemframeRemove = 1041,
    SoundItemframePlace = 1042,
    SoundItemframeRemoveItem = 1043,
    SoundItemframeRotateItem = 1044,
    SoundCamera = 1050,
    SoundOrb = 1051,
    SoundTotem = 1052,
    SoundArmorStandBreak = 1060,
    SoundArmorStandHit = 1061,
    SoundArmorStandFall = 1062,
    SoundArmorStandPlace = 1063,
    PointedDripstoneLand = 1064,
    DyeUsed = 1065,
    InkSackUsed = 1066,
    ParticleShoot = 2000,
    ParticleDestroy = 2001,
    ParticleSplash = 2002,
    ParticleEyeDespawn = 2003,
    ParticleSpawn = 2004,
    ParticleCropGrowth = 2005,
    ParticleGuardianCurse = 2006,
    ParticleDeathSmoke = 2007,
    ParticleBlockForceField = 2008,
    ParticleProjectileHit = 2009,
    ParticleDragonEggTeleport = 2010,
    ParticleCropEaten = 2011,
    ParticleCritical = 2012,
    ParticleEndermanTeleport = 2013,
    ParticlePunchBlock = 2014,
    ParticleBubble = 2015,
    ParticleEvaporate = 2016,
    ParticleDestroyArmorStand = 2017,
    ParticleBreakingEgg = 2018,
    ParticleDestroyEgg = 2019,
    ParticleEvaporateWater = 2020,
    ParticleDestroyBlockNoSound = 2021,
    ParticleKnockbackRoar = 2022,
    ParticleTeleportTrail = 2023,
    ParticlePointCloud = 2024,
    ParticleExplosion = 2025,
    ParticleBlockExplosion = 2026,
    ParticleVibrationSignal = 2027,
    ParticleDripstoneDrip = 2028,
    ParticleFizzEffect = 2029,
    ParticleWaxOn = 2030,
    ParticleWaxOff = 2031,
    ParticleScrape = 2032,
    ParticleElectricSpark = 2033,
    ParticleTurtleEgg = 2034,
    ParticleSculkShriek = 2035,
    SculkCatalystBloom = 2036,
    SculkCharge = 2037,
    SculkChargePop = 2038,
    SonicExplosion = 2039,
    StartRain = 3001,
    StartThunder = 3002,
    StopRain = 3003,
    StopThunder = 3004,
    PauseGame = 3005,
    PauseGameNoScreen = 3006,
    SetGameSpeed = 3007,
    RedstoneTrigger = 3500,
    CauldronExplode = 3501,
    CauldronDyeArmor = 3502,
    CauldronCleanArmor = 3503,
    CauldronFillPotion = 3504,
    CauldronTakePotion = 3505,
    CauldronFillWater = 3506,
    CauldronTakeWater = 3507,
    CauldronAddDye = 3508,
    CauldronCleanBanner = 3509,
    BlockStartBreak = 3600,
    BlockStopBreak = 3601,
    BlockBreakSpeed = 3602,
    ParticlePunchBlockDown = 3603,
    ParticlePunchBlockUp = 3604,
    ParticlePunchBlockNorth = 3605,
    ParticlePunchBlockSouth = 3606,
    ParticlePunchBlockWest = 3607,
    ParticlePunchBlockEast = 3608,
    SetData = 4000,
    PlayersSleeping = 9800,
    SleepingPlayers = 9801,
    AddParticleMask = 16384,
    AddParticleBubble = 16385,
    AddParticleBubbleManual = 16386,
    AddParticleCritical = 16387,
    AddParticleBlockForceField = 16388,
    AddParticleSmoke = 16389,
    AddParticleExplode = 16390,
    AddParticleEvaporation = 16391,
    AddParticleFlame = 16392,
    AddParticleCandleFlame = 16393,
    AddParticleLava = 16394,
    AddParticleLargeSmoke = 16395,
    AddParticleRedstone = 16396,
    AddParticleRisingRedDust = 16397,
    AddParticleItemBreak = 16398,
    AddParticleSnowballPoof = 16399,
    AddParticleHugeExplode = 16400,
    AddParticleHugeExplodeSeed = 16401,
    AddParticleMobFlame = 16402,
    AddParticleHeart = 16403,
    AddParticleTerrain = 16404,
    AddParticleTownAura = 16405,
    AddParticlePortal = 16406,
    AddParticleWaterSplash = 16408,
    AddParticleWaterSplashManual = 16409,
    AddParticleWaterWake = 16410,
    AddParticleDripWater = 16411,
    AddParticleDripLava = 16412,
    AddParticleDripHoney = 16413,
    AddParticleStalactiteDripWater = 16414,
    AddParticleStalactiteDripLava = 16415,
    AddParticleFallingDust = 16416,
    AddParticleMobSpell = 16417,
    AddParticleMobSpellAmbient = 16418,
    AddParticleMobSpellInstantaneous = 16419,
    AddParticleInk = 16420,
    AddParticleSlime = 16421,
    AddParticleRainSplash = 16422,
    AddParticleVillagerAngry = 16423,
    AddParticleVillagerHappy = 16424,
    AddParticleEnchantmentTable = 16425,
    AddParticleTrackingEmitter = 16426,
    AddParticleNote = 16427,
    AddParticleWitchSpell = 16428,
    AddParticleCarrot = 16429,
    AddParticleMobAppearance = 16430,
    AddParticleEndRod = 16431,
    AddParticleDragonsBreath = 16432,
    AddParticleSpit = 16433,
    AddParticleTotem = 16434,
    AddParticleFood = 16435,
    AddParticleFireworksStarter = 16436,
    AddParticleFireworksSpark = 16437,
    AddParticleFireworksOverlay = 16438,
    AddParticleBalloonGas = 16439,
    AddParticleColoredFlame = 16440,
    AddParticleSparkler = 16441,
    AddParticleConduit = 16442,
    AddParticleBubbleColumnUp = 16443,
    AddParticleBubbleColumnDown = 16444,
    AddParticleSneeze = 16445,
    AddParticleShulkerBullet = 16446,
    AddParticleBleach = 16447,
    AddParticleDragonDestroyBlock = 16448,
    AddParticleMyceliumDust = 16449,
    AddParticleFallingRedDust = 16450,
    AddParticleCampfireSmoke = 16451,
    AddParticleTallCampfireSmoke = 16452,
    AddParticleDragonBreathFire = 16453,
    AddParticleDragonBreathTrail = 16454,
    AddParticleBlueFlame = 16455,
    AddParticleSoul = 16456,
    AddParticleObsidianTear = 16457,
    AddParticlePortalReverse = 16458,
    AddParticleSnowflake = 16459,
    AddParticleVibrationSignal = 16460,
    AddParticleSculkSensorRedstone = 16461,
    AddParticleSporeBlossomShower = 16462,
    AddParticleSporeBlossomAmbient = 16463,
    AddParticleWax = 16464,
    AddParticleElectricSpark = 16465,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1000 => Ok(PacketLevelEventEvent::SoundClick),
            1001 => Ok(PacketLevelEventEvent::SoundClickFail),
            1002 => Ok(PacketLevelEventEvent::SoundShoot),
            1003 => Ok(PacketLevelEventEvent::SoundDoor),
            1004 => Ok(PacketLevelEventEvent::SoundFizz),
            1005 => Ok(PacketLevelEventEvent::SoundIgnite),
            1007 => Ok(PacketLevelEventEvent::SoundGhast),
            1008 => Ok(PacketLevelEventEvent::SoundGhastShoot),
            1009 => Ok(PacketLevelEventEvent::SoundBlazeShoot),
            1010 => Ok(PacketLevelEventEvent::SoundDoorBump),
            1012 => Ok(PacketLevelEventEvent::SoundDoorCrash),
            1018 => Ok(PacketLevelEventEvent::SoundEndermanTeleport),
            1020 => Ok(PacketLevelEventEvent::SoundAnvilBreak),
            1021 => Ok(PacketLevelEventEvent::SoundAnvilUse),
            1022 => Ok(PacketLevelEventEvent::SoundAnvilFall),
            1030 => Ok(PacketLevelEventEvent::SoundPop),
            1032 => Ok(PacketLevelEventEvent::SoundPortal),
            1040 => Ok(PacketLevelEventEvent::SoundItemframeAddItem),
            1041 => Ok(PacketLevelEventEvent::SoundItemframeRemove),
            1042 => Ok(PacketLevelEventEvent::SoundItemframePlace),
            1043 => Ok(PacketLevelEventEvent::SoundItemframeRemoveItem),
            1044 => Ok(PacketLevelEventEvent::SoundItemframeRotateItem),
            1050 => Ok(PacketLevelEventEvent::SoundCamera),
            1051 => Ok(PacketLevelEventEvent::SoundOrb),
            1052 => Ok(PacketLevelEventEvent::SoundTotem),
            1060 => Ok(PacketLevelEventEvent::SoundArmorStandBreak),
            1061 => Ok(PacketLevelEventEvent::SoundArmorStandHit),
            1062 => Ok(PacketLevelEventEvent::SoundArmorStandFall),
            1063 => Ok(PacketLevelEventEvent::SoundArmorStandPlace),
            1064 => Ok(PacketLevelEventEvent::PointedDripstoneLand),
            1065 => Ok(PacketLevelEventEvent::DyeUsed),
            1066 => Ok(PacketLevelEventEvent::InkSackUsed),
            2000 => Ok(PacketLevelEventEvent::ParticleShoot),
            2001 => Ok(PacketLevelEventEvent::ParticleDestroy),
            2002 => Ok(PacketLevelEventEvent::ParticleSplash),
            2003 => Ok(PacketLevelEventEvent::ParticleEyeDespawn),
            2004 => Ok(PacketLevelEventEvent::ParticleSpawn),
            2005 => Ok(PacketLevelEventEvent::ParticleCropGrowth),
            2006 => Ok(PacketLevelEventEvent::ParticleGuardianCurse),
            2007 => Ok(PacketLevelEventEvent::ParticleDeathSmoke),
            2008 => Ok(PacketLevelEventEvent::ParticleBlockForceField),
            2009 => Ok(PacketLevelEventEvent::ParticleProjectileHit),
            2010 => Ok(PacketLevelEventEvent::ParticleDragonEggTeleport),
            2011 => Ok(PacketLevelEventEvent::ParticleCropEaten),
            2012 => Ok(PacketLevelEventEvent::ParticleCritical),
            2013 => Ok(PacketLevelEventEvent::ParticleEndermanTeleport),
            2014 => Ok(PacketLevelEventEvent::ParticlePunchBlock),
            2015 => Ok(PacketLevelEventEvent::ParticleBubble),
            2016 => Ok(PacketLevelEventEvent::ParticleEvaporate),
            2017 => Ok(PacketLevelEventEvent::ParticleDestroyArmorStand),
            2018 => Ok(PacketLevelEventEvent::ParticleBreakingEgg),
            2019 => Ok(PacketLevelEventEvent::ParticleDestroyEgg),
            2020 => Ok(PacketLevelEventEvent::ParticleEvaporateWater),
            2021 => Ok(PacketLevelEventEvent::ParticleDestroyBlockNoSound),
            2022 => Ok(PacketLevelEventEvent::ParticleKnockbackRoar),
            2023 => Ok(PacketLevelEventEvent::ParticleTeleportTrail),
            2024 => Ok(PacketLevelEventEvent::ParticlePointCloud),
            2025 => Ok(PacketLevelEventEvent::ParticleExplosion),
            2026 => Ok(PacketLevelEventEvent::ParticleBlockExplosion),
            2027 => Ok(PacketLevelEventEvent::ParticleVibrationSignal),
            2028 => Ok(PacketLevelEventEvent::ParticleDripstoneDrip),
            2029 => Ok(PacketLevelEventEvent::ParticleFizzEffect),
            2030 => Ok(PacketLevelEventEvent::ParticleWaxOn),
            2031 => Ok(PacketLevelEventEvent::ParticleWaxOff),
            2032 => Ok(PacketLevelEventEvent::ParticleScrape),
            2033 => Ok(PacketLevelEventEvent::ParticleElectricSpark),
            2034 => Ok(PacketLevelEventEvent::ParticleTurtleEgg),
            2035 => Ok(PacketLevelEventEvent::ParticleSculkShriek),
            2036 => Ok(PacketLevelEventEvent::SculkCatalystBloom),
            2037 => Ok(PacketLevelEventEvent::SculkCharge),
            2038 => Ok(PacketLevelEventEvent::SculkChargePop),
            2039 => Ok(PacketLevelEventEvent::SonicExplosion),
            3001 => Ok(PacketLevelEventEvent::StartRain),
            3002 => Ok(PacketLevelEventEvent::StartThunder),
            3003 => Ok(PacketLevelEventEvent::StopRain),
            3004 => Ok(PacketLevelEventEvent::StopThunder),
            3005 => Ok(PacketLevelEventEvent::PauseGame),
            3006 => Ok(PacketLevelEventEvent::PauseGameNoScreen),
            3007 => Ok(PacketLevelEventEvent::SetGameSpeed),
            3500 => Ok(PacketLevelEventEvent::RedstoneTrigger),
            3501 => Ok(PacketLevelEventEvent::CauldronExplode),
            3502 => Ok(PacketLevelEventEvent::CauldronDyeArmor),
            3503 => Ok(PacketLevelEventEvent::CauldronCleanArmor),
            3504 => Ok(PacketLevelEventEvent::CauldronFillPotion),
            3505 => Ok(PacketLevelEventEvent::CauldronTakePotion),
            3506 => Ok(PacketLevelEventEvent::CauldronFillWater),
            3507 => Ok(PacketLevelEventEvent::CauldronTakeWater),
            3508 => Ok(PacketLevelEventEvent::CauldronAddDye),
            3509 => Ok(PacketLevelEventEvent::CauldronCleanBanner),
            3600 => Ok(PacketLevelEventEvent::BlockStartBreak),
            3601 => Ok(PacketLevelEventEvent::BlockStopBreak),
            3602 => Ok(PacketLevelEventEvent::BlockBreakSpeed),
            3603 => Ok(PacketLevelEventEvent::ParticlePunchBlockDown),
            3604 => Ok(PacketLevelEventEvent::ParticlePunchBlockUp),
            3605 => Ok(PacketLevelEventEvent::ParticlePunchBlockNorth),
            3606 => Ok(PacketLevelEventEvent::ParticlePunchBlockSouth),
            3607 => Ok(PacketLevelEventEvent::ParticlePunchBlockWest),
            3608 => Ok(PacketLevelEventEvent::ParticlePunchBlockEast),
            4000 => Ok(PacketLevelEventEvent::SetData),
            9800 => Ok(PacketLevelEventEvent::PlayersSleeping),
            9801 => Ok(PacketLevelEventEvent::SleepingPlayers),
            16384 => Ok(PacketLevelEventEvent::AddParticleMask),
            16385 => Ok(PacketLevelEventEvent::AddParticleBubble),
            16386 => Ok(PacketLevelEventEvent::AddParticleBubbleManual),
            16387 => Ok(PacketLevelEventEvent::AddParticleCritical),
            16388 => Ok(PacketLevelEventEvent::AddParticleBlockForceField),
            16389 => Ok(PacketLevelEventEvent::AddParticleSmoke),
            16390 => Ok(PacketLevelEventEvent::AddParticleExplode),
            16391 => Ok(PacketLevelEventEvent::AddParticleEvaporation),
            16392 => Ok(PacketLevelEventEvent::AddParticleFlame),
            16393 => Ok(PacketLevelEventEvent::AddParticleCandleFlame),
            16394 => Ok(PacketLevelEventEvent::AddParticleLava),
            16395 => Ok(PacketLevelEventEvent::AddParticleLargeSmoke),
            16396 => Ok(PacketLevelEventEvent::AddParticleRedstone),
            16397 => Ok(PacketLevelEventEvent::AddParticleRisingRedDust),
            16398 => Ok(PacketLevelEventEvent::AddParticleItemBreak),
            16399 => Ok(PacketLevelEventEvent::AddParticleSnowballPoof),
            16400 => Ok(PacketLevelEventEvent::AddParticleHugeExplode),
            16401 => Ok(PacketLevelEventEvent::AddParticleHugeExplodeSeed),
            16402 => Ok(PacketLevelEventEvent::AddParticleMobFlame),
            16403 => Ok(PacketLevelEventEvent::AddParticleHeart),
            16404 => Ok(PacketLevelEventEvent::AddParticleTerrain),
            16405 => Ok(PacketLevelEventEvent::AddParticleTownAura),
            16406 => Ok(PacketLevelEventEvent::AddParticlePortal),
            16408 => Ok(PacketLevelEventEvent::AddParticleWaterSplash),
            16409 => Ok(PacketLevelEventEvent::AddParticleWaterSplashManual),
            16410 => Ok(PacketLevelEventEvent::AddParticleWaterWake),
            16411 => Ok(PacketLevelEventEvent::AddParticleDripWater),
            16412 => Ok(PacketLevelEventEvent::AddParticleDripLava),
            16413 => Ok(PacketLevelEventEvent::AddParticleDripHoney),
            16414 => Ok(PacketLevelEventEvent::AddParticleStalactiteDripWater),
            16415 => Ok(PacketLevelEventEvent::AddParticleStalactiteDripLava),
            16416 => Ok(PacketLevelEventEvent::AddParticleFallingDust),
            16417 => Ok(PacketLevelEventEvent::AddParticleMobSpell),
            16418 => Ok(PacketLevelEventEvent::AddParticleMobSpellAmbient),
            16419 => Ok(PacketLevelEventEvent::AddParticleMobSpellInstantaneous),
            16420 => Ok(PacketLevelEventEvent::AddParticleInk),
            16421 => Ok(PacketLevelEventEvent::AddParticleSlime),
            16422 => Ok(PacketLevelEventEvent::AddParticleRainSplash),
            16423 => Ok(PacketLevelEventEvent::AddParticleVillagerAngry),
            16424 => Ok(PacketLevelEventEvent::AddParticleVillagerHappy),
            16425 => Ok(PacketLevelEventEvent::AddParticleEnchantmentTable),
            16426 => Ok(PacketLevelEventEvent::AddParticleTrackingEmitter),
            16427 => Ok(PacketLevelEventEvent::AddParticleNote),
            16428 => Ok(PacketLevelEventEvent::AddParticleWitchSpell),
            16429 => Ok(PacketLevelEventEvent::AddParticleCarrot),
            16430 => Ok(PacketLevelEventEvent::AddParticleMobAppearance),
            16431 => Ok(PacketLevelEventEvent::AddParticleEndRod),
            16432 => Ok(PacketLevelEventEvent::AddParticleDragonsBreath),
            16433 => Ok(PacketLevelEventEvent::AddParticleSpit),
            16434 => Ok(PacketLevelEventEvent::AddParticleTotem),
            16435 => Ok(PacketLevelEventEvent::AddParticleFood),
            16436 => Ok(PacketLevelEventEvent::AddParticleFireworksStarter),
            16437 => Ok(PacketLevelEventEvent::AddParticleFireworksSpark),
            16438 => Ok(PacketLevelEventEvent::AddParticleFireworksOverlay),
            16439 => Ok(PacketLevelEventEvent::AddParticleBalloonGas),
            16440 => Ok(PacketLevelEventEvent::AddParticleColoredFlame),
            16441 => Ok(PacketLevelEventEvent::AddParticleSparkler),
            16442 => Ok(PacketLevelEventEvent::AddParticleConduit),
            16443 => Ok(PacketLevelEventEvent::AddParticleBubbleColumnUp),
            16444 => Ok(PacketLevelEventEvent::AddParticleBubbleColumnDown),
            16445 => Ok(PacketLevelEventEvent::AddParticleSneeze),
            16446 => Ok(PacketLevelEventEvent::AddParticleShulkerBullet),
            16447 => Ok(PacketLevelEventEvent::AddParticleBleach),
            16448 => Ok(PacketLevelEventEvent::AddParticleDragonDestroyBlock),
            16449 => Ok(PacketLevelEventEvent::AddParticleMyceliumDust),
            16450 => Ok(PacketLevelEventEvent::AddParticleFallingRedDust),
            16451 => Ok(PacketLevelEventEvent::AddParticleCampfireSmoke),
            16452 => Ok(PacketLevelEventEvent::AddParticleTallCampfireSmoke),
            16453 => Ok(PacketLevelEventEvent::AddParticleDragonBreathFire),
            16454 => Ok(PacketLevelEventEvent::AddParticleDragonBreathTrail),
            16455 => Ok(PacketLevelEventEvent::AddParticleBlueFlame),
            16456 => Ok(PacketLevelEventEvent::AddParticleSoul),
            16457 => Ok(PacketLevelEventEvent::AddParticleObsidianTear),
            16458 => Ok(PacketLevelEventEvent::AddParticlePortalReverse),
            16459 => Ok(PacketLevelEventEvent::AddParticleSnowflake),
            16460 => Ok(PacketLevelEventEvent::AddParticleVibrationSignal),
            16461 => Ok(PacketLevelEventEvent::AddParticleSculkSensorRedstone),
            16462 => Ok(PacketLevelEventEvent::AddParticleSporeBlossomShower),
            16463 => Ok(PacketLevelEventEvent::AddParticleSporeBlossomAmbient),
            16464 => Ok(PacketLevelEventEvent::AddParticleWax),
            16465 => Ok(PacketLevelEventEvent::AddParticleElectricSpark),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLevelEventEvent), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEvent {
    pub event: PacketLevelEventEvent,
    pub position: Vec3F,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event = <PacketLevelEventEvent as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { event, position, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEventGeneric {
    pub event_id: i32,
    pub nbt: NbtLoop,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventGeneric {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.event_id as i32).encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let nbt = <NbtLoop as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { event_id, nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEvent {
    pub sound_id: SoundType,
    pub position: Vec3F,
    pub extra_data: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.extra_data as i32).encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let sound_id = <SoundType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let extra_data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            extra_data,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventOld {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: i32,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventOld {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.entity_type as i32).encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let entity_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventV2 {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventV2 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id as i32).encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLogin {
    pub protocol_version: i32,
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for PacketLogin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.protocol_version.encode(buf)?;
        self.tokens.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let protocol_version = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tokens = <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { protocol_version, tokens })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapCreateLockedCopy {
    pub original_map_id: i64,
    pub new_map_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapCreateLockedCopy {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.original_map_id as i64).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.new_map_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let original_map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let new_map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            original_map_id,
            new_map_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapInfoRequestClientPixelsItem {
    pub rgba: i32,
    pub index: u16,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapInfoRequestClientPixelsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.rgba.encode(buf)?;
        self.index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let rgba = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let index = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { rgba, index })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapInfoRequest {
    pub map_id: i64,
    pub client_pixels: Vec<PacketMapInfoRequestClientPixelsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapInfoRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.map_id as i64).encode(buf)?;
        let len = self.client_pixels.len();
        (len as u32).encode(buf)?;
        for item in &self.client_pixels {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let client_pixels = {
            let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketMapInfoRequestClientPixelsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { map_id, client_pixels })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobArmorEquipment {
    pub runtime_entity_id: i64,
    pub helmet: Item,
    pub chestplate: Item,
    pub leggings: Item,
    pub boots: Item,
}
#[derive(Debug, Clone)]
pub struct PacketMobArmorEquipmentArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketMobArmorEquipmentArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketMobArmorEquipment {
    type Args = PacketMobArmorEquipmentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.helmet.encode(buf)?;
        self.chestplate.encode(buf)?;
        self.leggings.encode(buf)?;
        self.boots.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let helmet = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let chestplate = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let leggings = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let boots = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            runtime_entity_id,
            helmet,
            chestplate,
            leggings,
            boots,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketMobEffectEventId {
    Add = 1,
    Update = 2,
    Remove = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffectEventId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketMobEffectEventId::Add),
            2 => Ok(PacketMobEffectEventId::Update),
            3 => Ok(PacketMobEffectEventId::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMobEffectEventId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEffect {
    pub runtime_entity_id: i64,
    pub event_id: PacketMobEffectEventId,
    pub effect_id: i32,
    pub amplifier: i32,
    pub particles: bool,
    pub duration: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.event_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.effect_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.amplifier as i32).encode(buf)?;
        self.particles.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.duration as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let event_id = <PacketMobEffectEventId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let effect_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let amplifier = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let particles = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            runtime_entity_id,
            event_id,
            effect_id,
            amplifier,
            particles,
            duration,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEquipment {
    pub runtime_entity_id: i64,
    pub item: Item,
    pub slot: u8,
    pub selected_slot: u8,
    pub window_id: WindowId,
}
#[derive(Debug, Clone)]
pub struct PacketMobEquipmentArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketMobEquipmentArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEquipment {
    type Args = PacketMobEquipmentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.item.encode(buf)?;
        self.slot.encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.window_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            item,
            slot,
            selected_slot,
            window_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketModalFormRequest {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.form_id as i32).encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let form_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketModalFormResponseContentCancelReason {
    Closed = 0,
    Busy = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormResponseContentCancelReason {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketModalFormResponseContentCancelReason::Closed),
            1 => Ok(PacketModalFormResponseContentCancelReason::Busy),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketModalFormResponseContentCancelReason), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketModalFormResponseContent {
    pub cancel_reason: PacketModalFormResponseContentCancelReason,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormResponseContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cancel_reason.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cancel_reason = <PacketModalFormResponseContentCancelReason as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { cancel_reason })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketModalFormResponse {
    pub form_id: i32,
    pub data: Option<String>,
    pub content: Option<PacketModalFormResponseContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.form_id as i32).encode(buf)?;
        let val = self.data.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.data {
            v.encode(buf)?;
        }
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let form_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let has_response_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = if has_response_data {
            Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let has_cancel_reason = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = if has_cancel_reason {
            Some(
                <PacketModalFormResponseContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        Ok(Self { form_id, data, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMotionPredictionHints {
    pub entity_runtime_id: i64,
    pub velocity: Vec3F,
    pub on_ground: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketMotionPredictionHints {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.entity_runtime_id as i64).encode(buf)?;
        self.velocity.encode(buf)?;
        self.on_ground.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_runtime_id,
            velocity,
            on_ground,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntity {
    pub runtime_entity_id: i64,
    pub flags: u8,
    pub position: Vec3F,
    pub rotation: Rotation,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.flags.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation = <Rotation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            flags,
            position,
            rotation,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntityDelta {
    pub runtime_entity_id: i64,
    pub flags: DeltaMoveFlags,
    pub x: Option<f32>,
    pub y: Option<f32>,
    pub z: Option<f32>,
    pub rot_x: Option<u8>,
    pub rot_y: Option<u8>,
    pub rot_z: Option<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntityDelta {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.flags.encode(buf)?;
        if let Some(v) = &self.x {
            v.encode(buf)?;
        }
        if let Some(v) = &self.y {
            v.encode(buf)?;
        }
        if let Some(v) = &self.z {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_x {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_y {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_z {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let flags = <DeltaMoveFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let x = if flags.contains(DeltaMoveFlags::HAS_X) {
            Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let y = if flags.contains(DeltaMoveFlags::HAS_Y) {
            Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let z = if flags.contains(DeltaMoveFlags::HAS_Z) {
            Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_x = if flags.contains(DeltaMoveFlags::HAS_ROT_X) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_y = if flags.contains(DeltaMoveFlags::HAS_ROT_Y) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_z = if flags.contains(DeltaMoveFlags::HAS_ROT_Z) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        Ok(Self {
            runtime_entity_id,
            flags,
            x,
            y,
            z,
            rot_x,
            rot_y,
            rot_z,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketMovePlayerMode {
    Normal = 0,
    Reset = 1,
    Teleport = 2,
    Rotation = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketMovePlayerMode::Normal),
            1 => Ok(PacketMovePlayerMode::Reset),
            2 => Ok(PacketMovePlayerMode::Teleport),
            3 => Ok(PacketMovePlayerMode::Rotation),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMovePlayerMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketMovePlayerTeleportCause {
    Unknown = 0,
    Projectile = 1,
    ChorusFruit = 2,
    Command = 3,
    Behavior = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerTeleportCause {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketMovePlayerTeleportCause::Unknown),
            1 => Ok(PacketMovePlayerTeleportCause::Projectile),
            2 => Ok(PacketMovePlayerTeleportCause::ChorusFruit),
            3 => Ok(PacketMovePlayerTeleportCause::Command),
            4 => Ok(PacketMovePlayerTeleportCause::Behavior),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMovePlayerTeleportCause), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovePlayerTeleport {
    pub cause: PacketMovePlayerTeleportCause,
    pub source_entity_type: LegacyEntityType,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerTeleport {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cause.encode(buf)?;
        self.source_entity_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cause = <PacketMovePlayerTeleportCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let source_entity_type = <LegacyEntityType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { cause, source_entity_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovePlayer {
    pub runtime_id: i32,
    pub position: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub mode: PacketMovePlayerMode,
    pub on_ground: bool,
    pub ridden_runtime_id: i32,
    pub teleport: Option<PacketMovePlayerTeleport>,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_id as i32).encode(buf)?;
        self.position.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.mode.encode(buf)?;
        self.on_ground.encode(buf)?;
        crate::bedrock::codec::VarInt(self.ridden_runtime_id as i32).encode(buf)?;
        if let Some(v) = &self.teleport {
            v.encode(buf)?;
        }
        crate::bedrock::codec::VarLong(self.tick as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let mode = <PacketMovePlayerMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let ridden_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let teleport = match mode {
            PacketMovePlayerMode::Teleport => {
                Some(
                    <PacketMovePlayerTeleport as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => None,
        };
        let tick = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            runtime_id,
            position,
            pitch,
            yaw,
            head_yaw,
            mode,
            on_ground,
            ridden_runtime_id,
            teleport,
            tick,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketMultiplayerSettingsActionType {
    EnableMultiplayer = 0,
    DisableMultiplayer = 1,
    RefreshJoinCode = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketMultiplayerSettingsActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketMultiplayerSettingsActionType::EnableMultiplayer),
            1 => Ok(PacketMultiplayerSettingsActionType::DisableMultiplayer),
            2 => Ok(PacketMultiplayerSettingsActionType::RefreshJoinCode),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMultiplayerSettingsActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMultiplayerSettings {
    pub action_type: PacketMultiplayerSettingsActionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketMultiplayerSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <PacketMultiplayerSettingsActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { action_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkChunkPublisherUpdateSavedChunksItem {
    pub x: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketNetworkChunkPublisherUpdateSavedChunksItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { x, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkChunkPublisherUpdate {
    pub coordinates: BlockCoordinates,
    pub radius: i32,
    pub saved_chunks: Vec<PacketNetworkChunkPublisherUpdateSavedChunksItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkChunkPublisherUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::VarInt(self.radius as i32).encode(buf)?;
        let len = self.saved_chunks.len();
        (len as u32).encode(buf)?;
        for item in &self.saved_chunks {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let saved_chunks = {
            let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketNetworkChunkPublisherUpdateSavedChunksItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            coordinates,
            radius,
            saved_chunks,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketNetworkSettingsCompressionAlgorithm {
    Deflate = 0,
    Snappy = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkSettingsCompressionAlgorithm {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketNetworkSettingsCompressionAlgorithm::Deflate),
            1 => Ok(PacketNetworkSettingsCompressionAlgorithm::Snappy),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNetworkSettingsCompressionAlgorithm), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkSettings {
    pub compression_threshold: u16,
    pub compression_algorithm: PacketNetworkSettingsCompressionAlgorithm,
    pub client_throttle: bool,
    pub client_throttle_threshold: u8,
    pub client_throttle_scalar: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.compression_threshold.encode(buf)?;
        self.compression_algorithm.encode(buf)?;
        self.client_throttle.encode(buf)?;
        self.client_throttle_threshold.encode(buf)?;
        self.client_throttle_scalar.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let compression_threshold = <u16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let compression_algorithm = <PacketNetworkSettingsCompressionAlgorithm as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_throttle = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_throttle_threshold = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_throttle_scalar = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            compression_threshold,
            compression_algorithm,
            client_throttle,
            client_throttle_threshold,
            client_throttle_scalar,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkStackLatency {
    pub timestamp: u64,
    pub needs_response: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkStackLatency {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.timestamp.encode(buf)?;
        self.needs_response.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let timestamp = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let needs_response = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { timestamp, needs_response })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketNpcDialogueActionType {
    Open = 0,
    Close = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcDialogueActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketNpcDialogueActionType::Open),
            1 => Ok(PacketNpcDialogueActionType::Close),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNpcDialogueActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcDialogue {
    pub entity_id: u64,
    pub action_type: PacketNpcDialogueActionType,
    pub dialogue: String,
    pub screen_name: String,
    pub npc_name: String,
    pub action_json: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcDialogue {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id.encode(buf)?;
        self.action_type.encode(buf)?;
        self.dialogue.encode(buf)?;
        self.screen_name.encode(buf)?;
        self.npc_name.encode(buf)?;
        self.action_json.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action_type = <PacketNpcDialogueActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dialogue = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let screen_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let npc_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action_json = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id,
            action_type,
            dialogue,
            screen_name,
            npc_name,
            action_json,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketNpcRequestRequestType {
    SetActions = 0,
    ExecuteAction = 1,
    ExecuteClosingCommands = 2,
    SetName = 3,
    SetSkin = 4,
    SetInteractionText = 5,
    ExecuteOpeningCommands = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequestRequestType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketNpcRequestRequestType::SetActions),
            1 => Ok(PacketNpcRequestRequestType::ExecuteAction),
            2 => Ok(PacketNpcRequestRequestType::ExecuteClosingCommands),
            3 => Ok(PacketNpcRequestRequestType::SetName),
            4 => Ok(PacketNpcRequestRequestType::SetSkin),
            5 => Ok(PacketNpcRequestRequestType::SetInteractionText),
            6 => Ok(PacketNpcRequestRequestType::ExecuteOpeningCommands),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNpcRequestRequestType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketNpcRequestActionType {
    SetActions = 0,
    ExecuteAction = 1,
    ExecuteClosingCommands = 2,
    SetName = 3,
    SetSkin = 4,
    SetInteractText = 5,
    ExecuteOpeningCommands = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequestActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketNpcRequestActionType::SetActions),
            1 => Ok(PacketNpcRequestActionType::ExecuteAction),
            2 => Ok(PacketNpcRequestActionType::ExecuteClosingCommands),
            3 => Ok(PacketNpcRequestActionType::SetName),
            4 => Ok(PacketNpcRequestActionType::SetSkin),
            5 => Ok(PacketNpcRequestActionType::SetInteractText),
            6 => Ok(PacketNpcRequestActionType::ExecuteOpeningCommands),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNpcRequestActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcRequest {
    pub runtime_entity_id: i64,
    pub request_type: PacketNpcRequestRequestType,
    pub command: String,
    pub action_type: PacketNpcRequestActionType,
    pub scene_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.request_type.encode(buf)?;
        self.command.encode(buf)?;
        self.action_type.encode(buf)?;
        self.scene_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let request_type = <PacketNpcRequestRequestType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action_type = <PacketNpcRequestActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let scene_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            request_type,
            command,
            action_type,
            scene_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketOnScreenTextureAnimation {
    pub animation_type: u32,
}
impl crate::bedrock::codec::BedrockCodec for PacketOnScreenTextureAnimation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.animation_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let animation_type = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { animation_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketOpenSign {
    pub position: BlockCoordinates,
    pub is_front: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketOpenSign {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.is_front.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_front = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { position, is_front })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPacketViolationWarningViolationType {
    Malformed = 0,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarningViolationType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPacketViolationWarningViolationType::Malformed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPacketViolationWarningViolationType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPacketViolationWarningSeverity {
    Warning = 0,
    FinalWarning = 1,
    Terminating = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarningSeverity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPacketViolationWarningSeverity::Warning),
            1 => Ok(PacketPacketViolationWarningSeverity::FinalWarning),
            2 => Ok(PacketPacketViolationWarningSeverity::Terminating),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPacketViolationWarningSeverity), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPacketViolationWarning {
    pub violation_type: PacketPacketViolationWarningViolationType,
    pub severity: PacketPacketViolationWarningSeverity,
    pub packet_id: i32,
    pub reason: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarning {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.violation_type.encode(buf)?;
        self.severity.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.packet_id as i32).encode(buf)?;
        self.reason.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let violation_type = <PacketPacketViolationWarningViolationType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let severity = <PacketPacketViolationWarningSeverity as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let packet_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let reason = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            violation_type,
            severity,
            packet_id,
            reason,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPhotoInfoRequest {
    pub photo_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketPhotoInfoRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.photo_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let photo_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { photo_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPhotoTransfer {
    pub image_name: String,
    pub image_data: String,
    pub book_id: String,
    pub photo_type: u8,
    pub source_type: u8,
    pub owner_entity_unique_id: i64,
    pub new_photo_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPhotoTransfer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.image_name.encode(buf)?;
        self.image_data.encode(buf)?;
        self.book_id.encode(buf)?;
        self.photo_type.encode(buf)?;
        self.source_type.encode(buf)?;
        self.owner_entity_unique_id.encode(buf)?;
        self.new_photo_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let image_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let image_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let book_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let photo_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let owner_entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let new_photo_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            image_name,
            image_data,
            book_id,
            photo_type,
            source_type,
            owner_entity_unique_id,
            new_photo_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlaySound {
    pub name: String,
    pub coordinates: BlockCoordinates,
    pub volume: f32,
    pub pitch: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlaySound {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.coordinates.encode(buf)?;
        self.volume.encode(buf)?;
        self.pitch.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let volume = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            name,
            coordinates,
            volume,
            pitch,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayStatusStatus {
    LoginSuccess = 0,
    FailedClient = 1,
    FailedSpawn = 2,
    PlayerSpawn = 3,
    FailedInvalidTenant = 4,
    FailedVanillaEdu = 5,
    FailedEduVanilla = 6,
    FailedServerFull = 7,
    FailedEditorVanillaMismatch = 8,
    FailedVanillaEditorMismatch = 9,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayStatusStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayStatusStatus::LoginSuccess),
            1 => Ok(PacketPlayStatusStatus::FailedClient),
            2 => Ok(PacketPlayStatusStatus::FailedSpawn),
            3 => Ok(PacketPlayStatusStatus::PlayerSpawn),
            4 => Ok(PacketPlayStatusStatus::FailedInvalidTenant),
            5 => Ok(PacketPlayStatusStatus::FailedVanillaEdu),
            6 => Ok(PacketPlayStatusStatus::FailedEduVanilla),
            7 => Ok(PacketPlayStatusStatus::FailedServerFull),
            8 => Ok(PacketPlayStatusStatus::FailedEditorVanillaMismatch),
            9 => Ok(PacketPlayStatusStatus::FailedVanillaEditorMismatch),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayStatusStatus), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayStatus {
    pub status: PacketPlayStatusStatus,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let status = <PacketPlayStatusStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { status })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAction {
    pub runtime_entity_id: i64,
    pub action: Action,
    pub position: BlockCoordinates,
    pub result_position: BlockCoordinates,
    pub face: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.action.encode(buf)?;
        self.position.encode(buf)?;
        self.result_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.face as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let action = <Action as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let result_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            runtime_entity_id,
            action,
            position,
            result_position,
            face,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerArmorDamage {
    pub type_: ArmorDamageType,
    pub helmet_damage: Option<i32>,
    pub chestplate_damage: Option<i32>,
    pub leggings_damage: Option<i32>,
    pub boots_damage: Option<i32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerArmorDamage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.helmet_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.chestplate_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.leggings_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.boots_damage {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <ArmorDamageType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let helmet_damage = if type_.contains(ArmorDamageType::HEAD) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i32,
            )
        } else {
            None
        };
        let chestplate_damage = if type_.contains(ArmorDamageType::CHEST) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i32,
            )
        } else {
            None
        };
        let leggings_damage = if type_.contains(ArmorDamageType::LEGS) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i32,
            )
        } else {
            None
        };
        let boots_damage = if type_.contains(ArmorDamageType::FEET) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i32,
            )
        } else {
            None
        };
        Ok(Self {
            type_,
            helmet_damage,
            chestplate_damage,
            leggings_damage,
            boots_damage,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputInputMode {
    Unknown = 0,
    Mouse = 1,
    Touch = 2,
    GamePad = 3,
    MotionController = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputInputMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayerAuthInputInputMode::Unknown),
            1 => Ok(PacketPlayerAuthInputInputMode::Mouse),
            2 => Ok(PacketPlayerAuthInputInputMode::Touch),
            3 => Ok(PacketPlayerAuthInputInputMode::GamePad),
            4 => Ok(PacketPlayerAuthInputInputMode::MotionController),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputInputMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputPlayMode {
    Normal = 0,
    Teaser = 1,
    Screen = 2,
    Viewer = 3,
    Reality = 4,
    Placement = 5,
    LivingRoom = 6,
    ExitLevel = 7,
    ExitLevelLivingRoom = 8,
    NumModes = 9,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputPlayMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayerAuthInputPlayMode::Normal),
            1 => Ok(PacketPlayerAuthInputPlayMode::Teaser),
            2 => Ok(PacketPlayerAuthInputPlayMode::Screen),
            3 => Ok(PacketPlayerAuthInputPlayMode::Viewer),
            4 => Ok(PacketPlayerAuthInputPlayMode::Reality),
            5 => Ok(PacketPlayerAuthInputPlayMode::Placement),
            6 => Ok(PacketPlayerAuthInputPlayMode::LivingRoom),
            7 => Ok(PacketPlayerAuthInputPlayMode::ExitLevel),
            8 => Ok(PacketPlayerAuthInputPlayMode::ExitLevelLivingRoom),
            9 => Ok(PacketPlayerAuthInputPlayMode::NumModes),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputPlayMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputInteractionModel {
    Touch = 0,
    Crosshair = 1,
    Classic = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputInteractionModel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayerAuthInputInteractionModel::Touch),
            1 => Ok(PacketPlayerAuthInputInteractionModel::Crosshair),
            2 => Ok(PacketPlayerAuthInputInteractionModel::Classic),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputInteractionModel), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInputTransaction {
    pub legacy: TransactionLegacy,
    pub actions: TransactionActions,
    pub data: TransactionUseItem,
}
#[derive(Debug, Clone)]
pub struct PacketPlayerAuthInputTransactionArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketPlayerAuthInputTransactionArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputTransaction {
    type Args = PacketPlayerAuthInputTransactionArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.legacy.encode(buf)?;
        self.actions.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let legacy = <TransactionLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let actions = {
            let res: TransactionActions = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TransactionActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionActionsItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let data = <TransactionUseItem as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            TransactionUseItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self { legacy, actions, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInputBlockActionItemContentAbortBreak {
    pub position: Vec3I,
    pub face: i32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketPlayerAuthInputBlockActionItemContentAbortBreak {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.face as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { position, face })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketPlayerAuthInputBlockActionItemContent {
    AbortBreak(PacketPlayerAuthInputBlockActionItemContentAbortBreak),
    ContinueBreak(PacketPlayerAuthInputBlockActionItemContentAbortBreak),
    CrackBreak(PacketPlayerAuthInputBlockActionItemContentAbortBreak),
    PredictBreak(PacketPlayerAuthInputBlockActionItemContentAbortBreak),
    StartBreak(PacketPlayerAuthInputBlockActionItemContentAbortBreak),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInputBlockActionItem {
    pub action: Action,
    pub content: Option<PacketPlayerAuthInputBlockActionItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputBlockActionItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketPlayerAuthInputBlockActionItemContent::AbortBreak(v) => {
                    v.encode(buf)?;
                }
                PacketPlayerAuthInputBlockActionItemContent::ContinueBreak(v) => {
                    v.encode(buf)?;
                }
                PacketPlayerAuthInputBlockActionItemContent::CrackBreak(v) => {
                    v.encode(buf)?;
                }
                PacketPlayerAuthInputBlockActionItemContent::PredictBreak(v) => {
                    v.encode(buf)?;
                }
                PacketPlayerAuthInputBlockActionItemContent::StartBreak(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <Action as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match action {
            Action::AbortBreak => {
                Some(
                    PacketPlayerAuthInputBlockActionItemContent::AbortBreak(
                        <PacketPlayerAuthInputBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::ContinueBreak => {
                Some(
                    PacketPlayerAuthInputBlockActionItemContent::ContinueBreak(
                        <PacketPlayerAuthInputBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::CrackBreak => {
                Some(
                    PacketPlayerAuthInputBlockActionItemContent::CrackBreak(
                        <PacketPlayerAuthInputBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::PredictBreak => {
                Some(
                    PacketPlayerAuthInputBlockActionItemContent::PredictBreak(
                        <PacketPlayerAuthInputBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::StartBreak => {
                Some(
                    PacketPlayerAuthInputBlockActionItemContent::StartBreak(
                        <PacketPlayerAuthInputBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { action, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub interaction_model: PacketPlayerAuthInputInteractionModel,
    pub gaze_direction: Option<Vec3F>,
    pub tick: i64,
    pub delta: Vec3F,
    pub transaction: Option<Box<PacketPlayerAuthInputTransaction>>,
    pub item_stack_request: Option<Box<ItemStackRequest>>,
    pub block_action: Option<Vec<PacketPlayerAuthInputBlockActionItem>>,
    pub analogue_move_vector: Vec2F,
}
#[derive(Debug, Clone)]
pub struct PacketPlayerAuthInputArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PacketPlayerAuthInputArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    type Args = PacketPlayerAuthInputArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        self.interaction_model.encode(buf)?;
        if let Some(v) = &self.gaze_direction {
            v.encode(buf)?;
        }
        crate::bedrock::codec::VarLong(self.tick as i64).encode(buf)?;
        self.delta.encode(buf)?;
        if let Some(v) = &self.transaction {
            v.encode(buf)?;
        }
        if let Some(v) = &self.item_stack_request {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_action {
            v.encode(buf)?;
        }
        self.analogue_move_vector.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let interaction_model = <PacketPlayerAuthInputInteractionModel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let gaze_direction = match play_mode {
            PacketPlayerAuthInputPlayMode::Reality => {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        let tick = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let transaction = if input_data.contains(InputFlag::ITEM_INTERACT) {
            Some(
                Box::new(
                    <PacketPlayerAuthInputTransaction as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        PacketPlayerAuthInputTransactionArgs {
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        let item_stack_request = if input_data.contains(InputFlag::ITEM_STACK_REQUEST) {
            Some(
                Box::new(
                    <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        ItemStackRequestArgs {
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        let block_action = if input_data.contains(InputFlag::BLOCK_ACTION) {
            Some({
                let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PacketPlayerAuthInputBlockActionItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            })
        } else {
            None
        };
        let analogue_move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            interaction_model,
            gaze_direction,
            tick,
            delta,
            transaction,
            item_stack_request,
            block_action,
            analogue_move_vector,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerEnchantOptions {
    pub options: Vec<EnchantOption>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerEnchantOptions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.options.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.options {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let options = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <EnchantOption as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { options })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerFog {
    pub stack: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerFog {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.stack.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.stack {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let stack = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { stack })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerHotbar {
    pub selected_slot: i32,
    pub window_id: WindowId,
    pub select_slot: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerHotbar {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.selected_slot as i32).encode(buf)?;
        self.window_id.encode(buf)?;
        self.select_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let selected_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let select_slot = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            selected_slot,
            window_id,
            select_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerInput {
    pub motion_x: f32,
    pub motion_z: f32,
    pub jumping: bool,
    pub sneaking: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerInput {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.motion_x.encode(buf)?;
        self.motion_z.encode(buf)?;
        self.jumping.encode(buf)?;
        self.sneaking.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let motion_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let motion_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let jumping = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let sneaking = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            motion_x,
            motion_z,
            jumping,
            sneaking,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerList {
    pub records: PlayerRecords,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerList {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.records.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let records = <PlayerRecords as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { records })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerSkin {
    pub uuid: uuid::Uuid,
    pub skin: Skin,
    pub skin_name: String,
    pub old_skin_name: String,
    pub is_verified: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerSkin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.skin.encode(buf)?;
        self.skin_name.encode(buf)?;
        self.old_skin_name.encode(buf)?;
        self.is_verified.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let old_skin_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_verified = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            skin,
            skin_name,
            old_skin_name,
            is_verified,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPositionTrackingDbBroadcastBroadcastAction {
    Update = 0,
    Destory = 1,
    NotFound = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketPositionTrackingDbBroadcastBroadcastAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::Update),
            1 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::Destory),
            2 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::NotFound),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPositionTrackingDbBroadcastBroadcastAction),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPositionTrackingDbBroadcast {
    pub broadcast_action: PacketPositionTrackingDbBroadcastBroadcastAction,
    pub tracking_id: i32,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbBroadcast {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.broadcast_action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.tracking_id as i32).encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let broadcast_action = <PacketPositionTrackingDbBroadcastBroadcastAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            broadcast_action,
            tracking_id,
            nbt,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPositionTrackingDbRequestAction {
    Query = 0,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbRequestAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPositionTrackingDbRequestAction::Query),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPositionTrackingDbRequestAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPositionTrackingDbRequest {
    pub action: PacketPositionTrackingDbRequestAction,
    pub tracking_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.tracking_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <PacketPositionTrackingDbRequestAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { action, tracking_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPurchaseReceipt {
    pub receipts: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPurchaseReceipt {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.receipts.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.receipts {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let receipts = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { receipts })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRefreshEntitlements {}
impl crate::bedrock::codec::BedrockCodec for PacketRefreshEntitlements {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveEcsEntity {
    pub network_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveEcsEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.network_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveEntity {
    pub entity_id_self: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id_self as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { entity_id_self })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveObjective {
    pub objective_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveObjective {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.objective_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { objective_name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveVolumeEntity {
    pub entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveVolumeEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.entity_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { entity_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketRequestAbilityAbility {
    Build = 0,
    Mine = 1,
    DoorsAndSwitches = 2,
    OpenContainers = 3,
    AttackPlayers = 4,
    AttackMobs = 5,
    OperatorCommands = 6,
    Teleport = 7,
    Invulnerable = 8,
    Flying = 9,
    MayFly = 10,
    InstantBuild = 11,
    Lightning = 12,
    FlySpeed = 13,
    WalkSpeed = 14,
    Muted = 15,
    WorldBuilder = 16,
    NoClip = 17,
    AbilityCount = 18,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestAbilityAbility {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketRequestAbilityAbility::Build),
            1 => Ok(PacketRequestAbilityAbility::Mine),
            2 => Ok(PacketRequestAbilityAbility::DoorsAndSwitches),
            3 => Ok(PacketRequestAbilityAbility::OpenContainers),
            4 => Ok(PacketRequestAbilityAbility::AttackPlayers),
            5 => Ok(PacketRequestAbilityAbility::AttackMobs),
            6 => Ok(PacketRequestAbilityAbility::OperatorCommands),
            7 => Ok(PacketRequestAbilityAbility::Teleport),
            8 => Ok(PacketRequestAbilityAbility::Invulnerable),
            9 => Ok(PacketRequestAbilityAbility::Flying),
            10 => Ok(PacketRequestAbilityAbility::MayFly),
            11 => Ok(PacketRequestAbilityAbility::InstantBuild),
            12 => Ok(PacketRequestAbilityAbility::Lightning),
            13 => Ok(PacketRequestAbilityAbility::FlySpeed),
            14 => Ok(PacketRequestAbilityAbility::WalkSpeed),
            15 => Ok(PacketRequestAbilityAbility::Muted),
            16 => Ok(PacketRequestAbilityAbility::WorldBuilder),
            17 => Ok(PacketRequestAbilityAbility::NoClip),
            18 => Ok(PacketRequestAbilityAbility::AbilityCount),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketRequestAbilityAbility), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketRequestAbilityValueType {
    Bool = 1,
    Float = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestAbilityValueType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketRequestAbilityValueType::Bool),
            2 => Ok(PacketRequestAbilityValueType::Float),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketRequestAbilityValueType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRequestAbility {
    pub ability: PacketRequestAbilityAbility,
    pub value_type: PacketRequestAbilityValueType,
    pub bool_value: bool,
    pub float_val: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestAbility {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.ability.encode(buf)?;
        self.value_type.encode(buf)?;
        self.bool_value.encode(buf)?;
        self.float_val.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let ability = <PacketRequestAbilityAbility as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value_type = <PacketRequestAbilityValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bool_value = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let float_val = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            ability,
            value_type,
            bool_value,
            float_val,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRequestChunkRadius {
    pub chunk_radius: i32,
    pub max_radius: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestChunkRadius {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.chunk_radius as i32).encode(buf)?;
        self.max_radius.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let max_radius = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { chunk_radius, max_radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRequestNetworkSettings {
    pub client_protocol: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestNetworkSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.client_protocol.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let client_protocol = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { client_protocol })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRequestPermissions {
    pub entity_unique_id: i64,
    pub permission_level: PermissionLevel,
    pub requested_permissions: RequestPermissions,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestPermissions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_unique_id.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.requested_permissions.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let requested_permissions = <RequestPermissions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_unique_id,
            permission_level,
            requested_permissions,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkData {
    pub pack_id: String,
    pub chunk_index: u32,
    pub progress: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pack_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        self.progress.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let progress = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            pack_id,
            chunk_index,
            progress,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkRequest {
    pub pack_id: String,
    pub chunk_index: u32,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pack_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { pack_id, chunk_index })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketResourcePackClientResponseResponseStatus {
    None = 0,
    Refused = 1,
    SendPacks = 2,
    HaveAllPacks = 3,
    Completed = 4,
}
impl crate::bedrock::codec::BedrockCodec
for PacketResourcePackClientResponseResponseStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketResourcePackClientResponseResponseStatus::None),
            1 => Ok(PacketResourcePackClientResponseResponseStatus::Refused),
            2 => Ok(PacketResourcePackClientResponseResponseStatus::SendPacks),
            3 => Ok(PacketResourcePackClientResponseResponseStatus::HaveAllPacks),
            4 => Ok(PacketResourcePackClientResponseResponseStatus::Completed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketResourcePackClientResponseResponseStatus),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackClientResponse {
    pub response_status: PacketResourcePackClientResponseResponseStatus,
    pub resourcepackids: ResourcePackIds,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackClientResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.response_status.encode(buf)?;
        self.resourcepackids.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let response_status = <PacketResourcePackClientResponseResponseStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resourcepackids = {
            let res: ResourcePackIds = {
                let len = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <String as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            response_status,
            resourcepackids,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketResourcePackDataInfoPackType {
    Addon = 1,
    Cached = 2,
    CopyProtected = 3,
    Behavior = 4,
    PersonaPiece = 5,
    Resources = 6,
    Skins = 7,
    WorldTemplate = 8,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackDataInfoPackType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketResourcePackDataInfoPackType::Addon),
            2 => Ok(PacketResourcePackDataInfoPackType::Cached),
            3 => Ok(PacketResourcePackDataInfoPackType::CopyProtected),
            4 => Ok(PacketResourcePackDataInfoPackType::Behavior),
            5 => Ok(PacketResourcePackDataInfoPackType::PersonaPiece),
            6 => Ok(PacketResourcePackDataInfoPackType::Resources),
            7 => Ok(PacketResourcePackDataInfoPackType::Skins),
            8 => Ok(PacketResourcePackDataInfoPackType::WorldTemplate),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketResourcePackDataInfoPackType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackDataInfo {
    pub pack_id: String,
    pub max_chunk_size: u32,
    pub chunk_count: u32,
    pub size: u64,
    pub hash: ByteArray,
    pub is_premium: bool,
    pub pack_type: PacketResourcePackDataInfoPackType,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackDataInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pack_id.encode(buf)?;
        self.max_chunk_size.encode(buf)?;
        self.chunk_count.encode(buf)?;
        self.size.encode(buf)?;
        self.hash.encode(buf)?;
        self.is_premium.encode(buf)?;
        self.pack_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let max_chunk_size = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let chunk_count = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let hash = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pack_type = <PacketResourcePackDataInfoPackType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            pack_id,
            max_chunk_size,
            chunk_count,
            size,
            hash,
            is_premium,
            pack_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackStack {
    pub must_accept: bool,
    pub behavior_packs: ResourcePackIdVersions,
    pub resource_packs: ResourcePackIdVersions,
    pub game_version: String,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackStack {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.must_accept.encode(buf)?;
        self.behavior_packs.encode(buf)?;
        self.resource_packs.encode(buf)?;
        self.game_version.encode(buf)?;
        self.experiments.encode(buf)?;
        self.experiments_previously_used.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let behavior_packs = {
            let res: ResourcePackIdVersions = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ResourcePackIdVersionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let resource_packs = {
            let res: ResourcePackIdVersions = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ResourcePackIdVersionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let game_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let experiments = {
            let res: Experiments = {
                let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Experiment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments_previously_used = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            must_accept,
            behavior_packs,
            resource_packs,
            game_version,
            experiments,
            experiments_previously_used,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePacksInfoResourcePackLinksItem {
    pub id: String,
    pub url: String,
}
impl crate::bedrock::codec::BedrockCodec
for PacketResourcePacksInfoResourcePackLinksItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        self.url.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let url = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { id, url })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePacksInfo {
    pub must_accept: bool,
    pub has_scripts: bool,
    pub force_server_packs: bool,
    pub behaviour_packs: BehaviourPackInfos,
    pub texture_packs: TexturePackInfos,
    pub resource_pack_links: Vec<PacketResourcePacksInfoResourcePackLinksItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePacksInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.must_accept.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.force_server_packs.encode(buf)?;
        self.behaviour_packs.encode(buf)?;
        self.texture_packs.encode(buf)?;
        let len = self.resource_pack_links.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.resource_pack_links {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let force_server_packs = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let behaviour_packs = {
            let res: BehaviourPackInfos = {
                let len = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <BehaviourPackInfosItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let texture_packs = {
            let res: TexturePackInfos = {
                let len = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TexturePackInfosItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let resource_pack_links = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketResourcePacksInfoResourcePackLinksItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            must_accept,
            has_scripts,
            force_server_packs,
            behaviour_packs,
            texture_packs,
            resource_pack_links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRespawn {
    pub position: Vec3F,
    pub state: u8,
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRespawn {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.state.encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let state = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            position,
            state,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRiderJump {
    pub jump_strength: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRiderJump {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.jump_strength as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let jump_strength = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { jump_strength })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketScriptCustomEvent {
    pub event_name: String,
    pub event_data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketScriptCustomEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event_name.encode(buf)?;
        self.event_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let event_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { event_name, event_data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketScriptMessage {
    pub message_id: String,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketScriptMessage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.message_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let message_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { message_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerSettingsRequest {}
impl crate::bedrock::codec::BedrockCodec for PacketServerSettingsRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerSettingsResponse {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerSettingsResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.form_id as i32).encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let form_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerStats {
    pub server_time: f32,
    pub network_time: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerStats {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server_time.encode(buf)?;
        self.network_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let server_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { server_time, network_time })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerToClientHandshake {
    pub token: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerToClientHandshake {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.token.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let token = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { token })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetCommandsEnabled {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetCommandsEnabled {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDefaultGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDefaultGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDifficulty {
    pub difficulty: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDifficulty {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.difficulty as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let difficulty = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { difficulty })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDisplayObjective {
    pub display_slot: String,
    pub objective_name: String,
    pub display_name: String,
    pub criteria_name: String,
    pub sort_order: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDisplayObjective {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.display_slot.encode(buf)?;
        self.objective_name.encode(buf)?;
        self.display_name.encode(buf)?;
        self.criteria_name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.sort_order as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let display_slot = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let criteria_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let sort_order = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            display_slot,
            objective_name,
            display_name,
            criteria_name,
            sort_order,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityData {
    pub runtime_entity_id: i64,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.metadata.encode(buf)?;
        self.properties.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tick = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            runtime_entity_id,
            metadata,
            properties,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityLink {
    pub link: Link,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityLink {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.link.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let link = <Link as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { link })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityMotion {
    pub runtime_entity_id: i64,
    pub velocity: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityMotion {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.velocity.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            velocity,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetHealth {
    pub health: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetHealth {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.health as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let health = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { health })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLastHurtBy {
    pub entity_type: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLastHurtBy {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.entity_type as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { entity_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLocalPlayerAsInitialized {
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLocalPlayerAsInitialized {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { runtime_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetPlayerGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketSetScoreAction {
    Change = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetScoreAction::Change),
            1 => Ok(PacketSetScoreAction::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum PacketSetScoreEntriesItemContentEntryType {
    Player = 1,
    Entity = 2,
    FakePlayer = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItemContentEntryType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketSetScoreEntriesItemContentEntryType::Player),
            2 => Ok(PacketSetScoreEntriesItemContentEntryType::Entity),
            3 => Ok(PacketSetScoreEntriesItemContentEntryType::FakePlayer),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreEntriesItemContentEntryType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketSetScoreEntriesItemContentEntityUniqueId {
    Entity(i64),
    Player(i64),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreEntriesItemContent {
    pub entry_type: PacketSetScoreEntriesItemContentEntryType,
    pub entity_unique_id: Option<PacketSetScoreEntriesItemContentEntityUniqueId>,
    pub custom_name: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entry_type.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            match v {
                PacketSetScoreEntriesItemContentEntityUniqueId::Entity(v) => {
                    crate::bedrock::codec::ZigZag64((*v) as i64).encode(buf)?;
                }
                PacketSetScoreEntriesItemContentEntityUniqueId::Player(v) => {
                    crate::bedrock::codec::ZigZag64((*v) as i64).encode(buf)?;
                }
            }
        }
        if let Some(v) = &self.custom_name {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entry_type = <PacketSetScoreEntriesItemContentEntryType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_unique_id = match entry_type {
            PacketSetScoreEntriesItemContentEntryType::Entity => {
                Some(
                    PacketSetScoreEntriesItemContentEntityUniqueId::Entity(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as i64,
                    ),
                )
            }
            PacketSetScoreEntriesItemContentEntryType::Player => {
                Some(
                    PacketSetScoreEntriesItemContentEntityUniqueId::Player(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as i64,
                    ),
                )
            }
            _ => None,
        };
        let custom_name = match entry_type {
            PacketSetScoreEntriesItemContentEntryType::FakePlayer => {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        Ok(Self {
            entry_type,
            entity_unique_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreEntriesItem {
    pub scoreboard_id: i64,
    pub objective_name: String,
    pub score: i32,
    pub content: Option<Box<PacketSetScoreEntriesItemContent>>,
}
#[derive(Debug, Clone)]
pub struct PacketSetScoreEntriesItemArgs {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItem {
    type Args = PacketSetScoreEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.scoreboard_id as i64).encode(buf)?;
        self.objective_name.encode(buf)?;
        self.score.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let score = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match args.action {
            Change => {
                Some(
                    Box::new(
                        <PacketSetScoreEntriesItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            objective_name,
            score,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScore {
    pub action: PacketSetScoreAction,
    pub entries: Vec<PacketSetScoreEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScore {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <PacketSetScoreAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSetScoreEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketSetScoreEntriesItemArgs {
                                action: action as i32,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { action, entries })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum PacketSetScoreboardIdentityAction {
    RegisterIdentity = 0,
    ClearIdentity = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentityAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetScoreboardIdentityAction::RegisterIdentity),
            1 => Ok(PacketSetScoreboardIdentityAction::ClearIdentity),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreboardIdentityAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentityEntriesItem {
    pub scoreboard_id: i64,
    pub entity_unique_id: Option<i64>,
}
#[derive(Debug, Clone)]
pub struct PacketSetScoreboardIdentityEntriesItemArgs {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentityEntriesItem {
    type Args = PacketSetScoreboardIdentityEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.scoreboard_id as i64).encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let entity_unique_id = match args.action {
            RegisterIdentity => {
                Some(
                    <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as i64,
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentity {
    pub action: PacketSetScoreboardIdentityAction,
    pub entries: Vec<PacketSetScoreboardIdentityEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <PacketSetScoreboardIdentityAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSetScoreboardIdentityEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketSetScoreboardIdentityEntriesItemArgs {
                                action: action as i32,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { action, entries })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetSpawnPositionSpawnType {
    Player = 0,
    World = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPositionSpawnType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetSpawnPositionSpawnType::Player),
            1 => Ok(PacketSetSpawnPositionSpawnType::World),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetSpawnPositionSpawnType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetSpawnPosition {
    pub spawn_type: PacketSetSpawnPositionSpawnType,
    pub player_position: BlockCoordinates,
    pub dimension: i32,
    pub world_position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPosition {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.spawn_type.encode(buf)?;
        self.player_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension as i32).encode(buf)?;
        self.world_position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let spawn_type = <PacketSetSpawnPositionSpawnType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let world_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            spawn_type,
            player_position,
            dimension,
            world_position,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetTime {
    pub time: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTime {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.time as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { time })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetTitleType {
    Clear = 0,
    Reset = 1,
    SetTitle = 2,
    SetSubtitle = 3,
    ActionBarMessage = 4,
    SetDurations = 5,
    SetTitleJson = 6,
    SetSubtitleJson = 7,
    ActionBarMessageJson = 8,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTitleType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetTitleType::Clear),
            1 => Ok(PacketSetTitleType::Reset),
            2 => Ok(PacketSetTitleType::SetTitle),
            3 => Ok(PacketSetTitleType::SetSubtitle),
            4 => Ok(PacketSetTitleType::ActionBarMessage),
            5 => Ok(PacketSetTitleType::SetDurations),
            6 => Ok(PacketSetTitleType::SetTitleJson),
            7 => Ok(PacketSetTitleType::SetSubtitleJson),
            8 => Ok(PacketSetTitleType::ActionBarMessageJson),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetTitleType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetTitle {
    pub type_: PacketSetTitleType,
    pub text: String,
    pub fade_in_time: i32,
    pub stay_time: i32,
    pub fade_out_time: i32,
    pub xuid: String,
    pub platform_online_id: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTitle {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.text.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.fade_in_time as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.stay_time as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.fade_out_time as i32).encode(buf)?;
        self.xuid.encode(buf)?;
        self.platform_online_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketSetTitleType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let fade_in_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let stay_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let fade_out_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let platform_online_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            type_,
            text,
            fade_in_time,
            stay_time,
            fade_out_time,
            xuid,
            platform_online_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSettingsCommand {
    pub command_line: String,
    pub suppress_output: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketSettingsCommand {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.command_line.encode(buf)?;
        self.suppress_output.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let command_line = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let suppress_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            command_line,
            suppress_output,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowCredits {
    pub runtime_entity_id: i64,
    pub status: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowCredits {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.status as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let status = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { runtime_entity_id, status })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowProfile {
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowProfile {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.xuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { xuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowStoreOffer {
    pub offer_id: String,
    pub show_all: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowStoreOffer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.offer_id.encode(buf)?;
        self.show_all.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let offer_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let show_all = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { offer_id, show_all })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketSimpleEventEventType {
    UninitializedSubtype = 0,
    EnableCommands = 1,
    DisableCommands = 2,
    UnlockWorldTemplateSettings = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimpleEventEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSimpleEventEventType::UninitializedSubtype),
            1 => Ok(PacketSimpleEventEventType::EnableCommands),
            2 => Ok(PacketSimpleEventEventType::DisableCommands),
            3 => Ok(PacketSimpleEventEventType::UnlockWorldTemplateSettings),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSimpleEventEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSimpleEvent {
    pub event_type: PacketSimpleEventEventType,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimpleEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event_type = <PacketSimpleEventEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { event_type })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketSimulationTypeType {
    Game = 0,
    Editor = 1,
    Test = 2,
    Invalid = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimulationTypeType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSimulationTypeType::Game),
            1 => Ok(PacketSimulationTypeType::Editor),
            2 => Ok(PacketSimulationTypeType::Test),
            3 => Ok(PacketSimulationTypeType::Invalid),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSimulationTypeType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSimulationType {
    pub type_: PacketSimulationTypeType,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimulationType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketSimulationTypeType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { type_ })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnExperienceOrb {
    pub position: Vec3F,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnExperienceOrb {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.count as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { position, count })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnParticleEffect {
    pub dimension: u8,
    pub entity_id: i64,
    pub position: Vec3F,
    pub particle_name: String,
    pub molang_variables: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnParticleEffect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_id as i64).encode(buf)?;
        self.position.encode(buf)?;
        self.particle_name.encode(buf)?;
        match &self.molang_variables {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let particle_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let molang_variables = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        Ok(Self {
            dimension,
            entity_id,
            position,
            particle_name,
            molang_variables,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketStartGameDimension {
    Overworld = 0,
    Nether = 1,
    End = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameDimension {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketStartGameDimension::Overworld),
            1 => Ok(PacketStartGameDimension::Nether),
            2 => Ok(PacketStartGameDimension::End),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameDimension), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketStartGameEditorWorldType {
    NotEditor = 0,
    Project = 1,
    TestLevel = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameEditorWorldType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketStartGameEditorWorldType::NotEditor),
            1 => Ok(PacketStartGameEditorWorldType::Project),
            2 => Ok(PacketStartGameEditorWorldType::TestLevel),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameEditorWorldType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketStartGameChatRestrictionLevel {
    None = 0,
    Dropped = 1,
    Disabled = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameChatRestrictionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketStartGameChatRestrictionLevel::None),
            1 => Ok(PacketStartGameChatRestrictionLevel::Dropped),
            2 => Ok(PacketStartGameChatRestrictionLevel::Disabled),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameChatRestrictionLevel), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketStartGameMovementAuthority {
    Client = 0,
    Server = 1,
    ServerWithRewind = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameMovementAuthority {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketStartGameMovementAuthority::Client),
            1 => Ok(PacketStartGameMovementAuthority::Server),
            2 => Ok(PacketStartGameMovementAuthority::ServerWithRewind),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameMovementAuthority), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStartGame {
    pub entity_id: i64,
    pub runtime_entity_id: i64,
    pub player_gamemode: GameMode,
    pub player_position: Vec3F,
    pub rotation: Vec2F,
    pub seed: u64,
    pub biome_type: i16,
    pub biome_name: String,
    pub dimension: PacketStartGameDimension,
    pub generator: i32,
    pub world_gamemode: GameMode,
    pub difficulty: i32,
    pub spawn_position: BlockCoordinates,
    pub achievements_disabled: bool,
    pub editor_world_type: PacketStartGameEditorWorldType,
    pub created_in_editor: bool,
    pub exported_from_editor: bool,
    pub day_cycle_stop_time: i32,
    pub edu_offer: i32,
    pub edu_features_enabled: bool,
    pub edu_product_uuid: String,
    pub rain_level: f32,
    pub lightning_level: f32,
    pub has_confirmed_platform_locked_content: bool,
    pub is_multiplayer: bool,
    pub broadcast_to_lan: bool,
    pub xbox_live_broadcast_mode: i32,
    pub platform_broadcast_mode: i32,
    pub enable_commands: bool,
    pub is_texturepacks_required: bool,
    pub gamerules: GameRules,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
    pub bonus_chest: bool,
    pub map_enabled: bool,
    pub permission_level: PermissionLevel,
    pub server_chunk_tick_range: i32,
    pub has_locked_behavior_pack: bool,
    pub has_locked_resource_pack: bool,
    pub is_from_locked_world_template: bool,
    pub msa_gamertags_only: bool,
    pub is_from_world_template: bool,
    pub is_world_template_option_locked: bool,
    pub only_spawn_v_1_villagers: bool,
    pub persona_disabled: bool,
    pub custom_skins_disabled: bool,
    pub emote_chat_muted: bool,
    pub game_version: String,
    pub limited_world_width: i32,
    pub limited_world_length: i32,
    pub is_new_nether: bool,
    pub edu_resource_uri: EducationSharedResourceUri,
    pub experimental_gameplay_override: bool,
    pub chat_restriction_level: PacketStartGameChatRestrictionLevel,
    pub disable_player_interactions: bool,
    pub level_id: String,
    pub world_name: String,
    pub premium_world_template_id: String,
    pub is_trial: bool,
    pub movement_authority: PacketStartGameMovementAuthority,
    pub rewind_history_size: i32,
    pub server_authoritative_block_breaking: bool,
    pub current_tick: i64,
    pub enchantment_seed: i32,
    pub block_properties: BlockProperties,
    pub itemstates: Itemstates,
    pub multiplayer_correlation_id: String,
    pub server_authoritative_inventory: bool,
    pub engine: String,
    pub property_data: Vec<u8>,
    pub block_pallette_checksum: u64,
    pub world_template_id: uuid::Uuid,
    pub client_side_generation: bool,
    pub block_network_ids_are_hashes: bool,
    pub server_controlled_sound: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGame {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id as i64).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.player_gamemode.encode(buf)?;
        self.player_position.encode(buf)?;
        self.rotation.encode(buf)?;
        self.seed.encode(buf)?;
        self.biome_type.encode(buf)?;
        self.biome_name.encode(buf)?;
        self.dimension.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.generator as i32).encode(buf)?;
        self.world_gamemode.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.difficulty as i32).encode(buf)?;
        self.spawn_position.encode(buf)?;
        self.achievements_disabled.encode(buf)?;
        self.editor_world_type.encode(buf)?;
        self.created_in_editor.encode(buf)?;
        self.exported_from_editor.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.day_cycle_stop_time as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.edu_offer as i32).encode(buf)?;
        self.edu_features_enabled.encode(buf)?;
        self.edu_product_uuid.encode(buf)?;
        self.rain_level.encode(buf)?;
        self.lightning_level.encode(buf)?;
        self.has_confirmed_platform_locked_content.encode(buf)?;
        self.is_multiplayer.encode(buf)?;
        self.broadcast_to_lan.encode(buf)?;
        crate::bedrock::codec::VarInt(self.xbox_live_broadcast_mode as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.platform_broadcast_mode as i32).encode(buf)?;
        self.enable_commands.encode(buf)?;
        self.is_texturepacks_required.encode(buf)?;
        self.gamerules.encode(buf)?;
        self.experiments.encode(buf)?;
        self.experiments_previously_used.encode(buf)?;
        self.bonus_chest.encode(buf)?;
        self.map_enabled.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.server_chunk_tick_range.encode(buf)?;
        self.has_locked_behavior_pack.encode(buf)?;
        self.has_locked_resource_pack.encode(buf)?;
        self.is_from_locked_world_template.encode(buf)?;
        self.msa_gamertags_only.encode(buf)?;
        self.is_from_world_template.encode(buf)?;
        self.is_world_template_option_locked.encode(buf)?;
        self.only_spawn_v_1_villagers.encode(buf)?;
        self.persona_disabled.encode(buf)?;
        self.custom_skins_disabled.encode(buf)?;
        self.emote_chat_muted.encode(buf)?;
        self.game_version.encode(buf)?;
        self.limited_world_width.encode(buf)?;
        self.limited_world_length.encode(buf)?;
        self.is_new_nether.encode(buf)?;
        self.edu_resource_uri.encode(buf)?;
        self.experimental_gameplay_override.encode(buf)?;
        self.chat_restriction_level.encode(buf)?;
        self.disable_player_interactions.encode(buf)?;
        self.level_id.encode(buf)?;
        self.world_name.encode(buf)?;
        self.premium_world_template_id.encode(buf)?;
        self.is_trial.encode(buf)?;
        self.movement_authority.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.rewind_history_size as i32).encode(buf)?;
        self.server_authoritative_block_breaking.encode(buf)?;
        self.current_tick.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.enchantment_seed as i32).encode(buf)?;
        self.block_properties.encode(buf)?;
        self.itemstates.encode(buf)?;
        self.multiplayer_correlation_id.encode(buf)?;
        self.server_authoritative_inventory.encode(buf)?;
        self.engine.encode(buf)?;
        self.property_data.encode(buf)?;
        self.block_pallette_checksum.encode(buf)?;
        self.world_template_id.encode(buf)?;
        self.client_side_generation.encode(buf)?;
        self.block_network_ids_are_hashes.encode(buf)?;
        self.server_controlled_sound.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let player_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let seed = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let biome_type = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let biome_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <PacketStartGameDimension as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let generator = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let world_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let difficulty = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let spawn_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let achievements_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let editor_world_type = <PacketStartGameEditorWorldType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let created_in_editor = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let exported_from_editor = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let day_cycle_stop_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let edu_offer = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let edu_features_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let edu_product_uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rain_level = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let lightning_level = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_confirmed_platform_locked_content = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_multiplayer = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let broadcast_to_lan = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let xbox_live_broadcast_mode = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let platform_broadcast_mode = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let enable_commands = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_texturepacks_required = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let gamerules = {
            let res: GameRules = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <GameRule as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments = {
            let res: Experiments = {
                let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Experiment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments_previously_used = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bonus_chest = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let map_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server_chunk_tick_range = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_locked_behavior_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_locked_resource_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_from_locked_world_template = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let msa_gamertags_only = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_from_world_template = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_world_template_option_locked = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let only_spawn_v_1_villagers = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let persona_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let custom_skins_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let emote_chat_muted = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let game_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let limited_world_width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let limited_world_length = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_new_nether = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let edu_resource_uri = <EducationSharedResourceUri as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let experimental_gameplay_override = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let chat_restriction_level = <PacketStartGameChatRestrictionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let disable_player_interactions = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let level_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let world_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let premium_world_template_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_trial = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let movement_authority = <PacketStartGameMovementAuthority as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rewind_history_size = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let server_authoritative_block_breaking = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let current_tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let enchantment_seed = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let block_properties = {
            let res: BlockProperties = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <BlockPropertiesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let itemstates = {
            let res: Itemstates = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemstatesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let multiplayer_correlation_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server_authoritative_inventory = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let engine = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let property_data = <Vec<
            u8,
        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_pallette_checksum = <u64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let world_template_id = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_side_generation = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_network_ids_are_hashes = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server_controlled_sound = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id,
            runtime_entity_id,
            player_gamemode,
            player_position,
            rotation,
            seed,
            biome_type,
            biome_name,
            dimension,
            generator,
            world_gamemode,
            difficulty,
            spawn_position,
            achievements_disabled,
            editor_world_type,
            created_in_editor,
            exported_from_editor,
            day_cycle_stop_time,
            edu_offer,
            edu_features_enabled,
            edu_product_uuid,
            rain_level,
            lightning_level,
            has_confirmed_platform_locked_content,
            is_multiplayer,
            broadcast_to_lan,
            xbox_live_broadcast_mode,
            platform_broadcast_mode,
            enable_commands,
            is_texturepacks_required,
            gamerules,
            experiments,
            experiments_previously_used,
            bonus_chest,
            map_enabled,
            permission_level,
            server_chunk_tick_range,
            has_locked_behavior_pack,
            has_locked_resource_pack,
            is_from_locked_world_template,
            msa_gamertags_only,
            is_from_world_template,
            is_world_template_option_locked,
            only_spawn_v_1_villagers,
            persona_disabled,
            custom_skins_disabled,
            emote_chat_muted,
            game_version,
            limited_world_width,
            limited_world_length,
            is_new_nether,
            edu_resource_uri,
            experimental_gameplay_override,
            chat_restriction_level,
            disable_player_interactions,
            level_id,
            world_name,
            premium_world_template_id,
            is_trial,
            movement_authority,
            rewind_history_size,
            server_authoritative_block_breaking,
            current_tick,
            enchantment_seed,
            block_properties,
            itemstates,
            multiplayer_correlation_id,
            server_authoritative_inventory,
            engine,
            property_data,
            block_pallette_checksum,
            world_template_id,
            client_side_generation,
            block_network_ids_are_hashes,
            server_controlled_sound,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStopSound {
    pub name: String,
    pub stop_all: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStopSound {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.stop_all.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stop_all = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, stop_all })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureBlockUpdate {
    pub position: BlockCoordinates,
    pub structure_name: String,
    pub data_field: String,
    pub include_players: bool,
    pub show_bounding_box: bool,
    pub structure_block_type: i32,
    pub settings: StructureBlockSettings,
    pub redstone_save_mode: i32,
    pub should_trigger: bool,
    pub water_logged: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStructureBlockUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.structure_name.encode(buf)?;
        self.data_field.encode(buf)?;
        self.include_players.encode(buf)?;
        self.show_bounding_box.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.structure_block_type as i32).encode(buf)?;
        self.settings.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.redstone_save_mode as i32).encode(buf)?;
        self.should_trigger.encode(buf)?;
        self.water_logged.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let structure_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data_field = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let include_players = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let show_bounding_box = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let structure_block_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let settings = <StructureBlockSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let redstone_save_mode = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let should_trigger = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let water_logged = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            position,
            structure_name,
            data_field,
            include_players,
            show_bounding_box,
            structure_block_type,
            settings,
            redstone_save_mode,
            should_trigger,
            water_logged,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketStructureTemplateDataExportRequestRequestType {
    ExportFromSave = 1,
    ExportFromLoad = 2,
    QuerySavedStructure = 3,
    ImportFromSave = 4,
}
impl crate::bedrock::codec::BedrockCodec
for PacketStructureTemplateDataExportRequestRequestType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketStructureTemplateDataExportRequestRequestType::ExportFromSave),
            2 => Ok(PacketStructureTemplateDataExportRequestRequestType::ExportFromLoad),
            3 => {
                Ok(
                    PacketStructureTemplateDataExportRequestRequestType::QuerySavedStructure,
                )
            }
            4 => Ok(PacketStructureTemplateDataExportRequestRequestType::ImportFromSave),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStructureTemplateDataExportRequestRequestType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportRequest {
    pub name: String,
    pub position: BlockCoordinates,
    pub settings: StructureBlockSettings,
    pub request_type: PacketStructureTemplateDataExportRequestRequestType,
}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.position.encode(buf)?;
        self.settings.encode(buf)?;
        self.request_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let settings = <StructureBlockSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let request_type = <PacketStructureTemplateDataExportRequestRequestType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            name,
            position,
            settings,
            request_type,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketStructureTemplateDataExportResponseResponseType {
    Export = 1,
    Query = 2,
    Import = 3,
}
impl crate::bedrock::codec::BedrockCodec
for PacketStructureTemplateDataExportResponseResponseType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketStructureTemplateDataExportResponseResponseType::Export),
            2 => Ok(PacketStructureTemplateDataExportResponseResponseType::Query),
            3 => Ok(PacketStructureTemplateDataExportResponseResponseType::Import),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStructureTemplateDataExportResponseResponseType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportResponse {
    pub name: String,
    pub nbt: Option<Vec<u8>>,
    pub response_type: PacketStructureTemplateDataExportResponseResponseType,
}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let val = self.nbt.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        self.response_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let success = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = if success {
            Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let response_type = <PacketStructureTemplateDataExportResponseResponseType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { name, nbt, response_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubClientLogin {
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubClientLogin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.tokens.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let tokens = <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { tokens })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketSubchunkEntries {
    False(SubChunkEntryWithoutCaching),
    True(SubChunkEntryWithCaching),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunk {
    pub dimension: i32,
    pub origin: Vec3I,
    pub entries: Option<PacketSubchunkEntries>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunk {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.entries.is_none();
        val.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension as i32).encode(buf)?;
        self.origin.encode(buf)?;
        if let Some(v) = &self.entries {
            match v {
                PacketSubchunkEntries::False(v) => {
                    v.encode(buf)?;
                }
                PacketSubchunkEntries::True(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entries = if cache_enabled {
            Some(
                PacketSubchunkEntries::True({
                    let res: SubChunkEntryWithCaching = {
                        let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )? as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <SubChunkEntryWithCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?,
                                );
                        }
                        tmp_vec
                    };
                    res
                }),
            )
        } else {
            Some(
                PacketSubchunkEntries::False({
                    let res: SubChunkEntryWithoutCaching = {
                        let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )? as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <SubChunkEntryWithoutCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?,
                                );
                        }
                        tmp_vec
                    };
                    res
                }),
            )
        };
        Ok(Self { dimension, origin, entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunkRequestRequestsItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequestRequestsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { dx, dy, dz })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunkRequest {
    pub dimension: i32,
    pub origin: Vec3I,
    pub requests: Vec<PacketSubchunkRequestRequestsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.dimension as i32).encode(buf)?;
        self.origin.encode(buf)?;
        let len = self.requests.len();
        (len as u32).encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let requests = {
            let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSubchunkRequestRequestsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            dimension,
            origin,
            requests,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSyncEntityProperty {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSyncEntityProperty {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTakeItemEntity {
    pub runtime_entity_id: i64,
    pub target: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketTakeItemEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        crate::bedrock::codec::VarInt(self.target as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let target = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { runtime_entity_id, target })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketTextType {
    Raw = 0,
    Chat = 1,
    Translation = 2,
    Popup = 3,
    JukeboxPopup = 4,
    Tip = 5,
    System = 6,
    Whisper = 7,
    Announcement = 8,
    JsonWhisper = 9,
    Json = 10,
    JsonAnnouncement = 11,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketTextType::Raw),
            1 => Ok(PacketTextType::Chat),
            2 => Ok(PacketTextType::Translation),
            3 => Ok(PacketTextType::Popup),
            4 => Ok(PacketTextType::JukeboxPopup),
            5 => Ok(PacketTextType::Tip),
            6 => Ok(PacketTextType::System),
            7 => Ok(PacketTextType::Whisper),
            8 => Ok(PacketTextType::Announcement),
            9 => Ok(PacketTextType::JsonWhisper),
            10 => Ok(PacketTextType::Json),
            11 => Ok(PacketTextType::JsonAnnouncement),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(PacketTextType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTextContentAnnouncement {
    pub source_name: String,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextContentAnnouncement {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source_name.encode(buf)?;
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let source_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { source_name, message })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTextContentJson {
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextContentJson {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { message })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTextContentJukeboxPopup {
    pub message: String,
    pub parameters: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextContentJukeboxPopup {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.message.encode(buf)?;
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let parameters = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { message, parameters })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketTextContent {
    Announcement(PacketTextContentAnnouncement),
    Chat(PacketTextContentAnnouncement),
    Json(PacketTextContentJson),
    JsonAnnouncement(PacketTextContentJson),
    JsonWhisper(PacketTextContentJson),
    JukeboxPopup(PacketTextContentJukeboxPopup),
    Popup(PacketTextContentJukeboxPopup),
    Raw(PacketTextContentJson),
    System(PacketTextContentJson),
    Tip(PacketTextContentJson),
    Translation(PacketTextContentJukeboxPopup),
    Whisper(PacketTextContentAnnouncement),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketText {
    pub type_: PacketTextType,
    pub needs_translation: bool,
    pub content: Option<PacketTextContent>,
    pub xuid: String,
    pub platform_chat_id: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketText {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.needs_translation.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketTextContent::Announcement(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Chat(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Json(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::JsonAnnouncement(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::JsonWhisper(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::JukeboxPopup(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Popup(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Raw(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::System(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Tip(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Translation(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Whisper(v) => {
                    v.encode(buf)?;
                }
            }
        }
        self.xuid.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketTextType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let needs_translation = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            PacketTextType::Announcement => {
                Some(
                    PacketTextContent::Announcement(
                        <PacketTextContentAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Chat => {
                Some(
                    PacketTextContent::Chat(
                        <PacketTextContentAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Json => {
                Some(
                    PacketTextContent::Json(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::JsonAnnouncement => {
                Some(
                    PacketTextContent::JsonAnnouncement(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::JsonWhisper => {
                Some(
                    PacketTextContent::JsonWhisper(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::JukeboxPopup => {
                Some(
                    PacketTextContent::JukeboxPopup(
                        <PacketTextContentJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Popup => {
                Some(
                    PacketTextContent::Popup(
                        <PacketTextContentJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Raw => {
                Some(
                    PacketTextContent::Raw(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::System => {
                Some(
                    PacketTextContent::System(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Tip => {
                Some(
                    PacketTextContent::Tip(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Translation => {
                Some(
                    PacketTextContent::Translation(
                        <PacketTextContentJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Whisper => {
                Some(
                    PacketTextContent::Whisper(
                        <PacketTextContentAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            type_,
            needs_translation,
            content,
            xuid,
            platform_chat_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTickSync {
    pub request_time: i64,
    pub response_time: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketTickSync {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_time.encode(buf)?;
        self.response_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let request_time = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let response_time = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            request_time,
            response_time,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTickingAreasLoadStatus {
    pub preload: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketTickingAreasLoadStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.preload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let preload = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { preload })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketToastRequest {
    pub title: String,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketToastRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { title, message })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTransfer {
    pub server_address: String,
    pub port: u16,
}
impl crate::bedrock::codec::BedrockCodec for PacketTransfer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server_address.encode(buf)?;
        self.port.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let server_address = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let port = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { server_address, port })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTrimDataPatternsItem {
    pub item_name: String,
    pub pattern: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTrimDataPatternsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.item_name.encode(buf)?;
        self.pattern.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let item_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let pattern = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { item_name, pattern })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTrimDataMaterialsItem {
    pub material: String,
    pub color: String,
    pub item_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTrimDataMaterialsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.material.encode(buf)?;
        self.color.encode(buf)?;
        self.item_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let material = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let color = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let item_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { material, color, item_name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTrimData {
    pub patterns: Vec<PacketTrimDataPatternsItem>,
    pub materials: Vec<PacketTrimDataMaterialsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketTrimData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.patterns.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.patterns {
            item.encode(buf)?;
        }
        let len = self.materials.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.materials {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let patterns = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketTrimDataPatternsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let materials = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketTrimDataMaterialsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { patterns, materials })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum PacketUnlockedRecipesUnlockType {
    Empty = 0,
    InitiallyUnlocked = 1,
    NewlyUnlocked = 2,
    RemoveUnlocked = 3,
    RemoveAllUnlocked = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketUnlockedRecipesUnlockType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketUnlockedRecipesUnlockType::Empty),
            1 => Ok(PacketUnlockedRecipesUnlockType::InitiallyUnlocked),
            2 => Ok(PacketUnlockedRecipesUnlockType::NewlyUnlocked),
            3 => Ok(PacketUnlockedRecipesUnlockType::RemoveUnlocked),
            4 => Ok(PacketUnlockedRecipesUnlockType::RemoveAllUnlocked),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketUnlockedRecipesUnlockType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUnlockedRecipes {
    pub unlock_type: PacketUnlockedRecipesUnlockType,
    pub recipes: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUnlockedRecipes {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.unlock_type.encode(buf)?;
        let len = self.recipes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.recipes {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let unlock_type = <PacketUnlockedRecipesUnlockType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipes = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { unlock_type, recipes })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAbilities {
    pub entity_unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAbilities {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_unique_id.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            entity_unique_id,
            permission_level,
            command_permission,
            abilities,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAdventureSettings {
    pub no_pvm: bool,
    pub no_mvp: bool,
    pub immutable_world: bool,
    pub show_name_tags: bool,
    pub auto_jump: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAdventureSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.no_pvm.encode(buf)?;
        self.no_mvp.encode(buf)?;
        self.immutable_world.encode(buf)?;
        self.show_name_tags.encode(buf)?;
        self.auto_jump.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let no_pvm = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let no_mvp = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let immutable_world = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let show_name_tags = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let auto_jump = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            no_pvm,
            no_mvp,
            immutable_world,
            show_name_tags,
            auto_jump,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAttributes {
    pub runtime_entity_id: i64,
    pub attributes: PlayerAttributes,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAttributes {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id as i64).encode(buf)?;
        self.attributes.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let attributes = {
            let res: PlayerAttributes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PlayerAttributesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let tick = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self {
            runtime_entity_id,
            attributes,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlock {
    pub position: BlockCoordinates,
    pub block_runtime_id: i32,
    pub flags: UpdateBlockFlags,
    pub layer: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlock {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id as i32).encode(buf)?;
        self.flags.encode(buf)?;
        crate::bedrock::codec::VarInt(self.layer as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let flags = <UpdateBlockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let layer = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            position,
            block_runtime_id,
            flags,
            layer,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlockProperties {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockProperties {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketUpdateBlockSyncedTransitionType {
    Entity = 0,
    Create = 1,
    Destroy = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockSyncedTransitionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketUpdateBlockSyncedTransitionType::Entity),
            1 => Ok(PacketUpdateBlockSyncedTransitionType::Create),
            2 => Ok(PacketUpdateBlockSyncedTransitionType::Destroy),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketUpdateBlockSyncedTransitionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlockSynced {
    pub position: BlockCoordinates,
    pub block_runtime_id: i32,
    pub flags: UpdateBlockFlags,
    pub layer: i32,
    pub entity_unique_id: i64,
    pub transition_type: PacketUpdateBlockSyncedTransitionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockSynced {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id as i32).encode(buf)?;
        self.flags.encode(buf)?;
        crate::bedrock::codec::VarInt(self.layer as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id as i64).encode(buf)?;
        self.transition_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let flags = <UpdateBlockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let layer = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let transition_type = <PacketUpdateBlockSyncedTransitionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            position,
            block_runtime_id,
            flags,
            layer,
            entity_unique_id,
            transition_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateClientInputLocks {
    pub locks: InputLockFlags,
    pub position: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateClientInputLocks {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.locks.encode(buf)?;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let locks = <InputLockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { locks, position })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateEquipment {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub size: u8,
    pub entity_id: i64,
    pub inventory: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateEquipment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.size.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_id as i64).encode(buf)?;
        self.inventory.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let size = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let inventory = <Vec<
            u8,
        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            window_id,
            window_type,
            size,
            entity_id,
            inventory,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdatePlayerGameType {
    pub gamemode: GameMode,
    pub player_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdatePlayerGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.player_unique_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { gamemode, player_unique_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketUpdateSoftEnumActionType {
    Add = 0,
    Remove = 1,
    Update = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateSoftEnumActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketUpdateSoftEnumActionType::Add),
            1 => Ok(PacketUpdateSoftEnumActionType::Remove),
            2 => Ok(PacketUpdateSoftEnumActionType::Update),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketUpdateSoftEnumActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateSoftEnum {
    pub enum_type: String,
    pub options: Vec<String>,
    pub action_type: PacketUpdateSoftEnumActionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateSoftEnum {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enum_type.encode(buf)?;
        let len = self.options.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.options {
            item.encode(buf)?;
        }
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let enum_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let options = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let action_type = <PacketUpdateSoftEnumActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            enum_type,
            options,
            action_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateSubchunkBlocks {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub blocks: Vec<BlockUpdate>,
    pub extra: Vec<BlockUpdate>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateSubchunkBlocks {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z as i32).encode(buf)?;
        let len = self.blocks.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.blocks {
            item.encode(buf)?;
        }
        let len = self.extra.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.extra {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let blocks = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let extra = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { x, y, z, blocks, extra })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateTrade {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub size: i32,
    pub trade_tier: i32,
    pub villager_unique_id: i64,
    pub entity_unique_id: i64,
    pub display_name: String,
    pub new_trading_ui: bool,
    pub economic_trades: bool,
    pub offers: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateTrade {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        crate::bedrock::codec::VarInt(self.size as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.trade_tier as i32).encode(buf)?;
        crate::bedrock::codec::VarLong(self.villager_unique_id as i64).encode(buf)?;
        crate::bedrock::codec::VarLong(self.entity_unique_id as i64).encode(buf)?;
        self.display_name.encode(buf)?;
        self.new_trading_ui.encode(buf)?;
        self.economic_trades.encode(buf)?;
        self.offers.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let size = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let trade_tier = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let villager_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let new_trading_ui = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let economic_trades = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let offers = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            window_id,
            window_type,
            size,
            trade_tier,
            villager_unique_id,
            entity_unique_id,
            display_name,
            new_trading_ui,
            economic_trades,
            offers,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketVideoStreamConnectAction {
    None = 1,
    Close = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketVideoStreamConnectAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketVideoStreamConnectAction::None),
            2 => Ok(PacketVideoStreamConnectAction::Close),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketVideoStreamConnectAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketVideoStreamConnect {
    pub server_uri: String,
    pub frame_send_frequency: f32,
    pub action: PacketVideoStreamConnectAction,
    pub resolution_x: i32,
    pub resolution_y: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketVideoStreamConnect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server_uri.encode(buf)?;
        self.frame_send_frequency.encode(buf)?;
        self.action.encode(buf)?;
        self.resolution_x.encode(buf)?;
        self.resolution_y.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let server_uri = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let frame_send_frequency = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let action = <PacketVideoStreamConnectAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resolution_x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resolution_y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            server_uri,
            frame_send_frequency,
            action,
            resolution_x,
            resolution_y,
        })
    }
}
