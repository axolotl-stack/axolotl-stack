// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommands {
    pub values_len: i32,
    pub enum_type: i32,
    pub enum_values: Vec<String>,
    pub suffixes: Vec<String>,
    pub enums: Vec<PacketAvailableCommandsEnumsItem>,
    pub command_data: Vec<PacketAvailableCommandsCommandDataItem>,
    pub dynamic_enums: Vec<PacketAvailableCommandsDynamicEnumsItem>,
    pub enum_constraints: Vec<PacketAvailableCommandsEnumConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommands {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.values_len.encode(buf)?;
        self.enum_type.encode(buf)?;
        let len = self.enum_values.len() as i32;
        len.encode(buf)?;
        for item in &self.enum_values {
            item.encode(buf)?;
        }
        let len = self.suffixes.len() as i32;
        len.encode(buf)?;
        for item in &self.suffixes {
            item.encode(buf)?;
        }
        let len = self.enums.len() as i32;
        len.encode(buf)?;
        for item in &self.enums {
            item.encode(buf)?;
        }
        let len = self.command_data.len() as i32;
        len.encode(buf)?;
        for item in &self.command_data {
            item.encode(buf)?;
        }
        let len = self.dynamic_enums.len() as i32;
        len.encode(buf)?;
        for item in &self.dynamic_enums {
            item.encode(buf)?;
        }
        let len = self.enum_constraints.len() as i32;
        len.encode(buf)?;
        for item in &self.enum_constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let values_len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enum_type = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enum_values = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let suffixes = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let enums = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let command_data = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let dynamic_enums = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsDynamicEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let enum_constraints = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            values_len,
            enum_type,
            enum_values,
            suffixes,
            enums,
            command_data,
            dynamic_enums,
            enum_constraints,
        })
    }
}
