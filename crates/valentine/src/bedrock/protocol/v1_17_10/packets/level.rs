// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventOld {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: i32,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventOld {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.entity_type).encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketLevelEventEvent {
    SoundClick = 1000,
    SoundClickFail = 1001,
    SoundShoot = 1002,
    SoundDoor = 1003,
    SoundFizz = 1004,
    SoundIgnite = 1005,
    SoundGhast = 1007,
    SoundGhastShoot = 1008,
    SoundBlazeShoot = 1009,
    SoundDoorBump = 1010,
    SoundDoorCrash = 1012,
    SoundEndermanTeleport = 1018,
    SoundAnvilBreak = 1020,
    SoundAnvilUse = 1021,
    SoundAnvilFall = 1022,
    SoundPop = 1030,
    SoundPortal = 1032,
    SoundItemframeAddItem = 1040,
    SoundItemframeRemove = 1041,
    SoundItemframePlace = 1042,
    SoundItemframeRemoveItem = 1043,
    SoundItemframeRotateItem = 1044,
    SoundCamera = 1050,
    SoundOrb = 1051,
    SoundTotem = 1052,
    SoundArmorStandBreak = 1060,
    SoundArmorStandHit = 1061,
    SoundArmorStandFall = 1062,
    SoundArmorStandPlace = 1063,
    PointedDripstoneLand = 1064,
    DyeUsed = 1065,
    InkSackUsed = 1066,
    ParticleShoot = 2000,
    ParticleDestroy = 2001,
    ParticleSplash = 2002,
    ParticleEyeDespawn = 2003,
    ParticleSpawn = 2004,
    ParticleCropGrowth = 2005,
    ParticleGuardianCurse = 2006,
    ParticleDeathSmoke = 2007,
    ParticleBlockForceField = 2008,
    ParticleProjectileHit = 2009,
    ParticleDragonEggTeleport = 2010,
    ParticleCropEaten = 2011,
    ParticleCritical = 2012,
    ParticleEndermanTeleport = 2013,
    ParticlePunchBlock = 2014,
    ParticleBubble = 2015,
    ParticleEvaporate = 2016,
    ParticleDestroyArmorStand = 2017,
    ParticleBreakingEgg = 2018,
    ParticleDestroyEgg = 2019,
    ParticleEvaporateWater = 2020,
    ParticleDestroyBlockNoSound = 2021,
    ParticleKnockbackRoar = 2022,
    ParticleTeleportTrail = 2023,
    ParticlePointCloud = 2024,
    ParticleExplosion = 2025,
    ParticleBlockExplosion = 2026,
    ParticleVibrationSignal = 2027,
    ParticleDripstoneDrip = 2028,
    ParticleFizzEffect = 2029,
    ParticleWaxOn = 2030,
    ParticleWaxOff = 2031,
    ParticleScrape = 2032,
    ParticleElectricSpark = 2033,
    StartRain = 3001,
    StartThunder = 3002,
    StopRain = 3003,
    StopThunder = 3004,
    PauseGame = 3005,
    PauseGameNoScreen = 3006,
    SetGameSpeed = 3007,
    RedstoneTrigger = 3500,
    CauldronExplode = 3501,
    CauldronDyeArmor = 3502,
    CauldronCleanArmor = 3503,
    CauldronFillPotion = 3504,
    CauldronTakePotion = 3505,
    CauldronFillWater = 3506,
    CauldronTakeWater = 3507,
    CauldronAddDye = 3508,
    CauldronCleanBanner = 3509,
    BlockStartBreak = 3600,
    BlockStopBreak = 3601,
    SetData = 4000,
    PlayersSleeping = 9800,
    AddParticleMask = 16384,
    AddParticleBubble = 16385,
    AddParticleBubbleManual = 16386,
    AddParticleCritical = 16387,
    AddParticleBlockForceField = 16388,
    AddParticleSmoke = 16389,
    AddParticleExplode = 16390,
    AddParticleEvaporation = 16391,
    AddParticleFlame = 16392,
    AddParticleCandleFlame = 16393,
    AddParticleLava = 16394,
    AddParticleLargeSmoke = 16395,
    AddParticleRedstone = 16396,
    AddParticleRisingRedDust = 16397,
    AddParticleItemBreak = 16398,
    AddParticleSnowballPoof = 16399,
    AddParticleHugeExplode = 16400,
    AddParticleHugeExplodeSeed = 16401,
    AddParticleMobFlame = 16402,
    AddParticleHeart = 16403,
    AddParticleTerrain = 16404,
    AddParticleTownAura = 16405,
    AddParticlePortal = 16406,
    AddParticleWaterSplash = 16408,
    AddParticleWaterSplashManual = 16409,
    AddParticleWaterWake = 16410,
    AddParticleDripWater = 16411,
    AddParticleDripLava = 16412,
    AddParticleDripHoney = 16413,
    AddParticleStalactiteDripWater = 16414,
    AddParticleStalactiteDripLava = 16415,
    AddParticleFallingDust = 16416,
    AddParticleMobSpell = 16417,
    AddParticleMobSpellAmbient = 16418,
    AddParticleMobSpellInstantaneous = 16419,
    AddParticleInk = 16420,
    AddParticleSlime = 16421,
    AddParticleRainSplash = 16422,
    AddParticleVillagerAngry = 16423,
    AddParticleVillagerHappy = 16424,
    AddParticleEnchantmentTable = 16425,
    AddParticleTrackingEmitter = 16426,
    AddParticleNote = 16427,
    AddParticleWitchSpell = 16428,
    AddParticleCarrot = 16429,
    AddParticleMobAppearance = 16430,
    AddParticleEndRod = 16431,
    AddParticleDragonsBreath = 16432,
    AddParticleSpit = 16433,
    AddParticleTotem = 16434,
    AddParticleFood = 16435,
    AddParticleFireworksStarter = 16436,
    AddParticleFireworksSpark = 16437,
    AddParticleFireworksOverlay = 16438,
    AddParticleBalloonGas = 16439,
    AddParticleColoredFlame = 16440,
    AddParticleSparkler = 16441,
    AddParticleConduit = 16442,
    AddParticleBubbleColumnUp = 16443,
    AddParticleBubbleColumnDown = 16444,
    AddParticleSneeze = 16445,
    AddParticleShulkerBullet = 16446,
    AddParticleBleach = 16447,
    AddParticleDragonDestroyBlock = 16448,
    AddParticleMyceliumDust = 16449,
    AddParticleFallingRedDust = 16450,
    AddParticleCampfireSmoke = 16451,
    AddParticleTallCampfireSmoke = 16452,
    AddParticleDragonBreathFire = 16453,
    AddParticleDragonBreathTrail = 16454,
    AddParticleBlueFlame = 16455,
    AddParticleSoul = 16456,
    AddParticleObsidianTear = 16457,
    AddParticlePortalReverse = 16458,
    AddParticleSnowflake = 16459,
    AddParticleVibrationSignal = 16460,
    AddParticleSculkSensorRedstone = 16461,
    AddParticleSporeBlossomShower = 16462,
    AddParticleSporeBlossomAmbient = 16463,
    AddParticleWax = 16464,
    AddParticleElectricSpark = 16465,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1000 => Ok(PacketLevelEventEvent::SoundClick),
            1001 => Ok(PacketLevelEventEvent::SoundClickFail),
            1002 => Ok(PacketLevelEventEvent::SoundShoot),
            1003 => Ok(PacketLevelEventEvent::SoundDoor),
            1004 => Ok(PacketLevelEventEvent::SoundFizz),
            1005 => Ok(PacketLevelEventEvent::SoundIgnite),
            1007 => Ok(PacketLevelEventEvent::SoundGhast),
            1008 => Ok(PacketLevelEventEvent::SoundGhastShoot),
            1009 => Ok(PacketLevelEventEvent::SoundBlazeShoot),
            1010 => Ok(PacketLevelEventEvent::SoundDoorBump),
            1012 => Ok(PacketLevelEventEvent::SoundDoorCrash),
            1018 => Ok(PacketLevelEventEvent::SoundEndermanTeleport),
            1020 => Ok(PacketLevelEventEvent::SoundAnvilBreak),
            1021 => Ok(PacketLevelEventEvent::SoundAnvilUse),
            1022 => Ok(PacketLevelEventEvent::SoundAnvilFall),
            1030 => Ok(PacketLevelEventEvent::SoundPop),
            1032 => Ok(PacketLevelEventEvent::SoundPortal),
            1040 => Ok(PacketLevelEventEvent::SoundItemframeAddItem),
            1041 => Ok(PacketLevelEventEvent::SoundItemframeRemove),
            1042 => Ok(PacketLevelEventEvent::SoundItemframePlace),
            1043 => Ok(PacketLevelEventEvent::SoundItemframeRemoveItem),
            1044 => Ok(PacketLevelEventEvent::SoundItemframeRotateItem),
            1050 => Ok(PacketLevelEventEvent::SoundCamera),
            1051 => Ok(PacketLevelEventEvent::SoundOrb),
            1052 => Ok(PacketLevelEventEvent::SoundTotem),
            1060 => Ok(PacketLevelEventEvent::SoundArmorStandBreak),
            1061 => Ok(PacketLevelEventEvent::SoundArmorStandHit),
            1062 => Ok(PacketLevelEventEvent::SoundArmorStandFall),
            1063 => Ok(PacketLevelEventEvent::SoundArmorStandPlace),
            1064 => Ok(PacketLevelEventEvent::PointedDripstoneLand),
            1065 => Ok(PacketLevelEventEvent::DyeUsed),
            1066 => Ok(PacketLevelEventEvent::InkSackUsed),
            2000 => Ok(PacketLevelEventEvent::ParticleShoot),
            2001 => Ok(PacketLevelEventEvent::ParticleDestroy),
            2002 => Ok(PacketLevelEventEvent::ParticleSplash),
            2003 => Ok(PacketLevelEventEvent::ParticleEyeDespawn),
            2004 => Ok(PacketLevelEventEvent::ParticleSpawn),
            2005 => Ok(PacketLevelEventEvent::ParticleCropGrowth),
            2006 => Ok(PacketLevelEventEvent::ParticleGuardianCurse),
            2007 => Ok(PacketLevelEventEvent::ParticleDeathSmoke),
            2008 => Ok(PacketLevelEventEvent::ParticleBlockForceField),
            2009 => Ok(PacketLevelEventEvent::ParticleProjectileHit),
            2010 => Ok(PacketLevelEventEvent::ParticleDragonEggTeleport),
            2011 => Ok(PacketLevelEventEvent::ParticleCropEaten),
            2012 => Ok(PacketLevelEventEvent::ParticleCritical),
            2013 => Ok(PacketLevelEventEvent::ParticleEndermanTeleport),
            2014 => Ok(PacketLevelEventEvent::ParticlePunchBlock),
            2015 => Ok(PacketLevelEventEvent::ParticleBubble),
            2016 => Ok(PacketLevelEventEvent::ParticleEvaporate),
            2017 => Ok(PacketLevelEventEvent::ParticleDestroyArmorStand),
            2018 => Ok(PacketLevelEventEvent::ParticleBreakingEgg),
            2019 => Ok(PacketLevelEventEvent::ParticleDestroyEgg),
            2020 => Ok(PacketLevelEventEvent::ParticleEvaporateWater),
            2021 => Ok(PacketLevelEventEvent::ParticleDestroyBlockNoSound),
            2022 => Ok(PacketLevelEventEvent::ParticleKnockbackRoar),
            2023 => Ok(PacketLevelEventEvent::ParticleTeleportTrail),
            2024 => Ok(PacketLevelEventEvent::ParticlePointCloud),
            2025 => Ok(PacketLevelEventEvent::ParticleExplosion),
            2026 => Ok(PacketLevelEventEvent::ParticleBlockExplosion),
            2027 => Ok(PacketLevelEventEvent::ParticleVibrationSignal),
            2028 => Ok(PacketLevelEventEvent::ParticleDripstoneDrip),
            2029 => Ok(PacketLevelEventEvent::ParticleFizzEffect),
            2030 => Ok(PacketLevelEventEvent::ParticleWaxOn),
            2031 => Ok(PacketLevelEventEvent::ParticleWaxOff),
            2032 => Ok(PacketLevelEventEvent::ParticleScrape),
            2033 => Ok(PacketLevelEventEvent::ParticleElectricSpark),
            3001 => Ok(PacketLevelEventEvent::StartRain),
            3002 => Ok(PacketLevelEventEvent::StartThunder),
            3003 => Ok(PacketLevelEventEvent::StopRain),
            3004 => Ok(PacketLevelEventEvent::StopThunder),
            3005 => Ok(PacketLevelEventEvent::PauseGame),
            3006 => Ok(PacketLevelEventEvent::PauseGameNoScreen),
            3007 => Ok(PacketLevelEventEvent::SetGameSpeed),
            3500 => Ok(PacketLevelEventEvent::RedstoneTrigger),
            3501 => Ok(PacketLevelEventEvent::CauldronExplode),
            3502 => Ok(PacketLevelEventEvent::CauldronDyeArmor),
            3503 => Ok(PacketLevelEventEvent::CauldronCleanArmor),
            3504 => Ok(PacketLevelEventEvent::CauldronFillPotion),
            3505 => Ok(PacketLevelEventEvent::CauldronTakePotion),
            3506 => Ok(PacketLevelEventEvent::CauldronFillWater),
            3507 => Ok(PacketLevelEventEvent::CauldronTakeWater),
            3508 => Ok(PacketLevelEventEvent::CauldronAddDye),
            3509 => Ok(PacketLevelEventEvent::CauldronCleanBanner),
            3600 => Ok(PacketLevelEventEvent::BlockStartBreak),
            3601 => Ok(PacketLevelEventEvent::BlockStopBreak),
            4000 => Ok(PacketLevelEventEvent::SetData),
            9800 => Ok(PacketLevelEventEvent::PlayersSleeping),
            16384 => Ok(PacketLevelEventEvent::AddParticleMask),
            16385 => Ok(PacketLevelEventEvent::AddParticleBubble),
            16386 => Ok(PacketLevelEventEvent::AddParticleBubbleManual),
            16387 => Ok(PacketLevelEventEvent::AddParticleCritical),
            16388 => Ok(PacketLevelEventEvent::AddParticleBlockForceField),
            16389 => Ok(PacketLevelEventEvent::AddParticleSmoke),
            16390 => Ok(PacketLevelEventEvent::AddParticleExplode),
            16391 => Ok(PacketLevelEventEvent::AddParticleEvaporation),
            16392 => Ok(PacketLevelEventEvent::AddParticleFlame),
            16393 => Ok(PacketLevelEventEvent::AddParticleCandleFlame),
            16394 => Ok(PacketLevelEventEvent::AddParticleLava),
            16395 => Ok(PacketLevelEventEvent::AddParticleLargeSmoke),
            16396 => Ok(PacketLevelEventEvent::AddParticleRedstone),
            16397 => Ok(PacketLevelEventEvent::AddParticleRisingRedDust),
            16398 => Ok(PacketLevelEventEvent::AddParticleItemBreak),
            16399 => Ok(PacketLevelEventEvent::AddParticleSnowballPoof),
            16400 => Ok(PacketLevelEventEvent::AddParticleHugeExplode),
            16401 => Ok(PacketLevelEventEvent::AddParticleHugeExplodeSeed),
            16402 => Ok(PacketLevelEventEvent::AddParticleMobFlame),
            16403 => Ok(PacketLevelEventEvent::AddParticleHeart),
            16404 => Ok(PacketLevelEventEvent::AddParticleTerrain),
            16405 => Ok(PacketLevelEventEvent::AddParticleTownAura),
            16406 => Ok(PacketLevelEventEvent::AddParticlePortal),
            16408 => Ok(PacketLevelEventEvent::AddParticleWaterSplash),
            16409 => Ok(PacketLevelEventEvent::AddParticleWaterSplashManual),
            16410 => Ok(PacketLevelEventEvent::AddParticleWaterWake),
            16411 => Ok(PacketLevelEventEvent::AddParticleDripWater),
            16412 => Ok(PacketLevelEventEvent::AddParticleDripLava),
            16413 => Ok(PacketLevelEventEvent::AddParticleDripHoney),
            16414 => Ok(PacketLevelEventEvent::AddParticleStalactiteDripWater),
            16415 => Ok(PacketLevelEventEvent::AddParticleStalactiteDripLava),
            16416 => Ok(PacketLevelEventEvent::AddParticleFallingDust),
            16417 => Ok(PacketLevelEventEvent::AddParticleMobSpell),
            16418 => Ok(PacketLevelEventEvent::AddParticleMobSpellAmbient),
            16419 => Ok(PacketLevelEventEvent::AddParticleMobSpellInstantaneous),
            16420 => Ok(PacketLevelEventEvent::AddParticleInk),
            16421 => Ok(PacketLevelEventEvent::AddParticleSlime),
            16422 => Ok(PacketLevelEventEvent::AddParticleRainSplash),
            16423 => Ok(PacketLevelEventEvent::AddParticleVillagerAngry),
            16424 => Ok(PacketLevelEventEvent::AddParticleVillagerHappy),
            16425 => Ok(PacketLevelEventEvent::AddParticleEnchantmentTable),
            16426 => Ok(PacketLevelEventEvent::AddParticleTrackingEmitter),
            16427 => Ok(PacketLevelEventEvent::AddParticleNote),
            16428 => Ok(PacketLevelEventEvent::AddParticleWitchSpell),
            16429 => Ok(PacketLevelEventEvent::AddParticleCarrot),
            16430 => Ok(PacketLevelEventEvent::AddParticleMobAppearance),
            16431 => Ok(PacketLevelEventEvent::AddParticleEndRod),
            16432 => Ok(PacketLevelEventEvent::AddParticleDragonsBreath),
            16433 => Ok(PacketLevelEventEvent::AddParticleSpit),
            16434 => Ok(PacketLevelEventEvent::AddParticleTotem),
            16435 => Ok(PacketLevelEventEvent::AddParticleFood),
            16436 => Ok(PacketLevelEventEvent::AddParticleFireworksStarter),
            16437 => Ok(PacketLevelEventEvent::AddParticleFireworksSpark),
            16438 => Ok(PacketLevelEventEvent::AddParticleFireworksOverlay),
            16439 => Ok(PacketLevelEventEvent::AddParticleBalloonGas),
            16440 => Ok(PacketLevelEventEvent::AddParticleColoredFlame),
            16441 => Ok(PacketLevelEventEvent::AddParticleSparkler),
            16442 => Ok(PacketLevelEventEvent::AddParticleConduit),
            16443 => Ok(PacketLevelEventEvent::AddParticleBubbleColumnUp),
            16444 => Ok(PacketLevelEventEvent::AddParticleBubbleColumnDown),
            16445 => Ok(PacketLevelEventEvent::AddParticleSneeze),
            16446 => Ok(PacketLevelEventEvent::AddParticleShulkerBullet),
            16447 => Ok(PacketLevelEventEvent::AddParticleBleach),
            16448 => Ok(PacketLevelEventEvent::AddParticleDragonDestroyBlock),
            16449 => Ok(PacketLevelEventEvent::AddParticleMyceliumDust),
            16450 => Ok(PacketLevelEventEvent::AddParticleFallingRedDust),
            16451 => Ok(PacketLevelEventEvent::AddParticleCampfireSmoke),
            16452 => Ok(PacketLevelEventEvent::AddParticleTallCampfireSmoke),
            16453 => Ok(PacketLevelEventEvent::AddParticleDragonBreathFire),
            16454 => Ok(PacketLevelEventEvent::AddParticleDragonBreathTrail),
            16455 => Ok(PacketLevelEventEvent::AddParticleBlueFlame),
            16456 => Ok(PacketLevelEventEvent::AddParticleSoul),
            16457 => Ok(PacketLevelEventEvent::AddParticleObsidianTear),
            16458 => Ok(PacketLevelEventEvent::AddParticlePortalReverse),
            16459 => Ok(PacketLevelEventEvent::AddParticleSnowflake),
            16460 => Ok(PacketLevelEventEvent::AddParticleVibrationSignal),
            16461 => Ok(PacketLevelEventEvent::AddParticleSculkSensorRedstone),
            16462 => Ok(PacketLevelEventEvent::AddParticleSporeBlossomShower),
            16463 => Ok(PacketLevelEventEvent::AddParticleSporeBlossomAmbient),
            16464 => Ok(PacketLevelEventEvent::AddParticleWax),
            16465 => Ok(PacketLevelEventEvent::AddParticleElectricSpark),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLevelEventEvent), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEvent {
    pub event: PacketLevelEventEvent,
    pub position: Vec3F,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.event.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let event = <PacketLevelEventEvent as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { event, position, data })
    }
}
pub use crate::bedrock::protocol::v1_16_201::PacketLevelChunkBlobs as PacketLevelChunkBlobs;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunk {
    pub x: i32,
    pub z: i32,
    pub sub_chunk_count: i32,
    pub blobs: Option<PacketLevelChunkBlobs>,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunk {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        crate::bedrock::codec::VarInt(self.sub_chunk_count).encode(buf)?;
        let val = self.blobs.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.blobs {
            v.encode(buf)?;
        }
        let len = self.payload.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.payload {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let sub_chunk_count = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let blobs = if cache_enabled {
            Some(
                <PacketLevelChunkBlobs as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let payload = {
            let res: ByteArray = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            "array length cannot be negative",
                        ),
                    );
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            x,
            z,
            sub_chunk_count,
            blobs,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventV2 {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventV2 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.entity_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.entity_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        "string length cannot be negative",
                    ),
                );
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(
                    std::io::Error::new(
                        std::io::ErrorKind::UnexpectedEof,
                        format!(
                            "string declared length {} exceeds remaining {}", len, buf
                            .remaining()
                        ),
                    ),
                );
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEvent {
    pub sound_id: SoundType,
    pub position: Vec3F,
    pub extra_data: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.extra_data).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.entity_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.entity_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let sound_id = <SoundType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let extra_data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        "string length cannot be negative",
                    ),
                );
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(
                    std::io::Error::new(
                        std::io::ErrorKind::UnexpectedEof,
                        format!(
                            "string declared length {} exceeds remaining {}", len, buf
                            .remaining()
                        ),
                    ),
                );
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            extra_data,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEventGeneric {
    pub event_id: i32,
    pub nbt: NbtLoop,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventGeneric {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.event_id).encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let event_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let nbt = <NbtLoop as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { event_id, nbt })
    }
}
