// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionInstructionSetSome {
    pub runtime_id: i32,
    pub ease_data: Option<PacketCameraInstructionInstructionSetSomeEaseDataSome>,
    pub position: Option<Vec3F>,
    pub rotation: Option<Vec2F>,
    pub facing: Option<Vec3F>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub default: Option<bool>,
    pub remove_ignore_starting_values: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstructionInstructionSetSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        match &self.ease_data {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.position {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.rotation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.facing {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.default {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.remove_ignore_starting_values.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ease_data = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetSomeEaseDataSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let position = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let rotation = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let facing = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let default = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let remove_ignore_starting_values = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_id,
            ease_data,
            position,
            rotation,
            facing,
            offset,
            entity_offset,
            default,
            remove_ignore_starting_values,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstruction {
    pub instruction_set: Option<PacketCameraInstructionInstructionSetSome>,
    pub clear: Option<bool>,
    pub fade: Option<PacketCameraInstructionFadeSome>,
    pub target: Option<PacketCameraInstructionTargetSome>,
    pub remove_target: Option<bool>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstruction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.instruction_set {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.clear {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fade {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.remove_target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let instruction_set = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let clear = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let fade = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionFadeSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionTargetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let remove_target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            instruction_set,
            clear,
            fade,
            target,
            remove_target,
        })
    }
}
