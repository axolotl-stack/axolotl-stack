// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentMineBlock {
    pub hotbar_slot: crate::bedrock::codec::ZigZag32,
    pub predicted_durability: crate::bedrock::codec::ZigZag32,
    pub network_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentMineBlock {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.hotbar_slot.encode(buf)?;
        self.predicted_durability.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let predicted_durability = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            hotbar_slot,
            predicted_durability,
            network_id,
        })
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct UpdateBlockFlags : u32
    {}
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak {
    pub position: Vec3I,
    pub face: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.face.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { position, face })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketPlayerAuthInputBlockActionSomeItemContent {
    AbortBreak(PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak),
    ContinueBreak(PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak),
    CrackBreak(PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak),
    PredictBreak(PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak),
    StartBreak(PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInputBlockActionSomeItem {
    pub action: Action,
    pub content: Option<PacketPlayerAuthInputBlockActionSomeItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputBlockActionSomeItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketPlayerAuthInputBlockActionSomeItemContent::AbortBreak(v) => {
                    v.encode(buf)?
                }
                PacketPlayerAuthInputBlockActionSomeItemContent::ContinueBreak(v) => {
                    v.encode(buf)?
                }
                PacketPlayerAuthInputBlockActionSomeItemContent::CrackBreak(v) => {
                    v.encode(buf)?
                }
                PacketPlayerAuthInputBlockActionSomeItemContent::PredictBreak(v) => {
                    v.encode(buf)?
                }
                PacketPlayerAuthInputBlockActionSomeItemContent::StartBreak(v) => {
                    v.encode(buf)?
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action = <Action as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content = match action {
            _ => {
                Some(
                    PacketPlayerAuthInputBlockActionSomeItemContent::AbortBreak(
                        <PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketPlayerAuthInputBlockActionSomeItemContent::ContinueBreak(
                        <PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketPlayerAuthInputBlockActionSomeItemContent::CrackBreak(
                        <PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketPlayerAuthInputBlockActionSomeItemContent::PredictBreak(
                        <PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketPlayerAuthInputBlockActionSomeItemContent::StartBreak(
                        <PacketPlayerAuthInputBlockActionSomeItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { action, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlock {
    pub position: BlockCoordinates,
    pub block_runtime_id: i32,
    pub flags: UpdateBlockFlags,
    pub layer: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlock {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        self.flags.encode(buf)?;
        self.layer.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <UpdateBlockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let layer = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            position,
            block_runtime_id,
            flags,
            layer,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i64)]
pub enum PacketUpdateBlockSyncedTransitionType {
    Entity = 0,
    Create = 1,
    Destroy = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockSyncedTransitionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i64;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketUpdateBlockSyncedTransitionType::Entity),
            1 => Ok(PacketUpdateBlockSyncedTransitionType::Create),
            2 => Ok(PacketUpdateBlockSyncedTransitionType::Destroy),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketUpdateBlockSyncedTransitionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlockSynced {
    pub position: BlockCoordinates,
    pub block_runtime_id: i32,
    pub flags: UpdateBlockFlags,
    pub layer: i32,
    pub entity_unique_id: crate::bedrock::codec::ZigZag64,
    pub transition_type: PacketUpdateBlockSyncedTransitionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockSynced {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        self.flags.encode(buf)?;
        self.layer.encode(buf)?;
        self.entity_unique_id.encode(buf)?;
        self.transition_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <UpdateBlockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let layer = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let transition_type = <PacketUpdateBlockSyncedTransitionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            position,
            block_runtime_id,
            flags,
            layer,
            entity_unique_id,
            transition_type,
        })
    }
}
