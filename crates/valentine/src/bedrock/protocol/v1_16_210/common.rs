// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum Action {
    StartBreak = 0,
    AbortBreak = 1,
    StopBreak = 2,
    GetUpdatedBlock = 3,
    DropItem = 4,
    StartSleeping = 5,
    StopSleeping = 6,
    Respawn = 7,
    Jump = 8,
    StartSprint = 9,
    StopSprint = 10,
    StartSneak = 11,
    StopSneak = 12,
    CreativePlayerDestroyBlock = 13,
    DimensionChangeAck = 14,
    StartGlide = 15,
    StopGlide = 16,
    BuildDenied = 17,
    CrackBreak = 18,
    ChangeSkin = 19,
    SetEnchatnmentSeed = 20,
    Swimming = 21,
    StopSwimming = 22,
    StartSpinAttack = 23,
    StopSpinAttack = 24,
    InteractBlock = 25,
    PredictBreak = 26,
    ContinueBreak = 27,
}
impl crate::bedrock::codec::BedrockCodec for Action {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(Action::StartBreak),
            1 => Ok(Action::AbortBreak),
            2 => Ok(Action::StopBreak),
            3 => Ok(Action::GetUpdatedBlock),
            4 => Ok(Action::DropItem),
            5 => Ok(Action::StartSleeping),
            6 => Ok(Action::StopSleeping),
            7 => Ok(Action::Respawn),
            8 => Ok(Action::Jump),
            9 => Ok(Action::StartSprint),
            10 => Ok(Action::StopSprint),
            11 => Ok(Action::StartSneak),
            12 => Ok(Action::StopSneak),
            13 => Ok(Action::CreativePlayerDestroyBlock),
            14 => Ok(Action::DimensionChangeAck),
            15 => Ok(Action::StartGlide),
            16 => Ok(Action::StopGlide),
            17 => Ok(Action::BuildDenied),
            18 => Ok(Action::CrackBreak),
            19 => Ok(Action::ChangeSkin),
            20 => Ok(Action::SetEnchatnmentSeed),
            21 => Ok(Action::Swimming),
            22 => Ok(Action::StopSwimming),
            23 => Ok(Action::StartSpinAttack),
            24 => Ok(Action::StopSpinAttack),
            25 => Ok(Action::InteractBlock),
            26 => Ok(Action::PredictBreak),
            27 => Ok(Action::ContinueBreak),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!("Invalid enum value for {}: {}", stringify!(Action), val),
                    ),
                )
            }
        }
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct InputFlag : u64 { const
    ASCEND = 1; const DESCEND = 2; const NORTHJUMP = 4; const JUMPDOWN = 8; const
    SPRINTDOWN = 16; const CHANGEHEIGHT = 32; const JUMPING = 64; const
    AUTOJUMPINGINWATER = 128; const SNEAKING = 256; const SNEAKDOWN = 512; const UP =
    1024; const DOWN = 2048; const LEFT = 4096; const RIGHT = 8192; const UPLEFT = 16384;
    const UPRIGHT = 32768; const WANTUP = 65536; const WANTDOWN = 131072; const
    WANTDOWNSLOW = 262144; const WANTUPSLOW = 524288; const SPRINTING = 1048576; const
    ASCENDSCAFFOLDING = 2097152; const DESCENDSCAFFOLDING = 4194304; const
    SNEAKTOGGLEDOWN = 8388608; const PERSISTSNEAK = 16777216; const STARTSPRINTING =
    33554432; const STOPSPRINTING = 67108864; const STARTSNEAKING = 134217728; const
    STOPSNEAKING = 268435456; const STARTSWIMMING = 536870912; const STOPSWIMMING =
    1073741824; const STARTJUMPING = 2147483648; const STARTGLIDING = 4294967296; const
    STOPGLIDING = 8589934592; const ITEMINTERACT = 17179869184; const BLOCKACTION =
    34359738368; const ITEMSTACKREQUEST = 68719476736; }
}
#[derive(Debug, Clone, PartialEq)]
pub struct StackRequestSlotInfo {
    pub slot_type: ContainerSlotType,
    pub slot: u8,
    pub stack_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for StackRequestSlotInfo {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_type.encode(buf)?;
        self.slot.encode(buf)?;
        self.stack_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot_type = <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { slot_type, slot, stack_id })
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct MetadataFlags1 : u64 {
    const ONFIRE = 1; const SNEAKING = 2; const RIDING = 4; const SPRINTING = 8; const
    ACTION = 16; const INVISIBLE = 32; const TEMPTED = 64; const INLOVE = 128; const
    SADDLED = 256; const POWERED = 512; const IGNITED = 1024; const BABY = 2048; const
    CONVERTING = 4096; const CRITICAL = 8192; const CANSHOWNAMETAG = 16384; const
    ALWAYSSHOWNAMETAG = 32768; const NOAI = 65536; const SILENT = 131072; const
    WALLCLIMBING = 262144; const CANCLIMB = 524288; const SWIMMER = 1048576; const CANFLY
    = 2097152; const WALKER = 4194304; const RESTING = 8388608; const SITTING = 16777216;
    const ANGRY = 33554432; const INTERESTED = 67108864; const CHARGED = 134217728; const
    TAMED = 268435456; const ORPHANED = 536870912; const LEASHED = 1073741824; const
    SHEARED = 2147483648; const GLIDING = 4294967296; const ELDER = 8589934592; const
    MOVING = 17179869184; const BREATHING = 34359738368; const CHESTED = 68719476736;
    const STACKABLE = 137438953472; const SHOWBASE = 274877906944; const REARING =
    549755813888; const VIBRATING = 1099511627776; const IDLING = 2199023255552; const
    EVOKERSPELL = 4398046511104; const CHARGEATTACK = 8796093022208; const WASDCONTROLLED
    = 17592186044416; const CANPOWERJUMP = 35184372088832; const LINGER = 70368744177664;
    const HASCOLLISION = 140737488355328; const AFFECTEDBYGRAVITY = 281474976710656;
    const FIREIMMUNE = 562949953421312; const DANCING = 1125899906842624; const ENCHANTED
    = 2251799813685248; const SHOWTRIDENTROPE = 4503599627370496; const CONTAINERPRIVATE
    = 9007199254740992; const TRANSFORMING = 18014398509481984; const SPINATTACK =
    36028797018963968; const SWIMMING = 72057594037927936; const BRIBED =
    144115188075855872; const PREGNANT = 288230376151711744; const LAYINGEGG =
    576460752303423488; const RIDERCANPICK = 1152921504606846976; const TRANSITIONSITTING
    = 2305843009213693952; const EATING = 4611686018427387904; const LAYINGDOWN =
    9223372036854775808; }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct MetadataFlags2 : u64 {
    const SNEEZING = 1; const TRUSTING = 2; const ROLLING = 4; const SCARED = 8; const
    INSCAFFOLDING = 16; const OVERSCAFFOLDING = 32; const FALLTHROUGHSCAFFOLDING = 64;
    const BLOCKING = 128; const TRANSITIONBLOCKING = 256; const BLOCKEDUSINGSHIELD = 512;
    const BLOCKEDUSINGDAMAGEDSHIELD = 1024; const SLEEPING = 2048; const WANTSTOWAKE =
    4096; const TRADEINTEREST = 8192; const DOORBREAKER = 16384; const
    BREAKINGOBSTRUCTION = 32768; const DOOROPENER = 65536; const ILLAGERCAPTAIN = 131072;
    const STUNNED = 262144; const ROARING = 524288; const DELAYEDATTACKING = 1048576;
    const AVOIDINGMOBS = 2097152; const AVOIDINGBLOCK = 4194304; const
    FACINGTARGETTORANGEATTACK = 8388608; const HIDDENWHENINVISIBLE = 16777216; const
    ISINUI = 33554432; const STALKING = 67108864; const EMOTING = 134217728; const
    CELEBRATING = 268435456; const ADMIRING = 536870912; const CELEBRATINGSPECIAL =
    1073741824; }
}
pub type MetadataDictionary = Vec<MetadataDictionaryItem>;
pub type Recipes = Vec<RecipesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacy {
    pub legacy_transactions: Option<Vec<TransactionLegacyLegacyTransactionsItem>>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacy {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.legacy_transactions.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.legacy_transactions {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let legacy_request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let legacy_transactions = match legacy_request_id {
            crate::bedrock::codec::ZigZag32(0) => None,
            _ => {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <TransactionLegacyLegacyTransactionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
        };
        Ok(Self { legacy_transactions })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActions {
    pub network_ids: bool,
    pub actions: Vec<TransactionActionsActionsItem>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActions {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.network_ids.encode(buf)?;
        let len = self.actions.len() as i32;
        len.encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_ids = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionActionsActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { network_ids, actions })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionTransactionData {
    InventoryMismatch,
    ItemRelease(Box<TransactionTransactionDataItemRelease>),
    ItemUse(Box<TransactionUseItem>),
    ItemUseOnEntity(Box<TransactionTransactionDataItemUseOnEntity>),
    Normal,
}
#[derive(Debug, Clone, PartialEq)]
pub struct Transaction {
    pub legacy: TransactionLegacy,
    pub transaction_type: TransactionTransactionType,
    pub actions: TransactionActions,
    pub transaction_data: Option<TransactionTransactionData>,
}
impl crate::bedrock::codec::BedrockCodec for Transaction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.legacy.encode(buf)?;
        self.transaction_type.encode(buf)?;
        self.actions.encode(buf)?;
        if let Some(v) = &self.transaction_data {
            match v {
                TransactionTransactionData::InventoryMismatch => {}
                TransactionTransactionData::ItemRelease(v) => v.encode(buf)?,
                TransactionTransactionData::ItemUse(v) => v.encode(buf)?,
                TransactionTransactionData::ItemUseOnEntity(v) => v.encode(buf)?,
                TransactionTransactionData::Normal => {}
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let legacy = <TransactionLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let transaction_type = <TransactionTransactionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = <TransactionActions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let transaction_data = match transaction_type {
            _ => Some(TransactionTransactionData::InventoryMismatch),
            _ => {
                Some(
                    TransactionTransactionData::ItemRelease(
                        Box::new(
                            <TransactionTransactionDataItemRelease as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    TransactionTransactionData::ItemUse(
                        Box::new(
                            <TransactionUseItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    TransactionTransactionData::ItemUseOnEntity(
                        Box::new(
                            <TransactionTransactionDataItemUseOnEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => Some(TransactionTransactionData::Normal),
            _ => None,
        };
        Ok(Self {
            legacy,
            transaction_type,
            actions,
            transaction_data,
        })
    }
}
