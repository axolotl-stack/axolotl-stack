// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub entity_type: String,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.attributes.encode(buf)?;
        self.metadata.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let attributes = <EntityAttributes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            entity_type,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            pitch,
            yaw,
            head_yaw,
            attributes,
            metadata,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddItemEntity {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub item: Item,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub metadata: MetadataDictionary,
    pub is_from_fishing: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddItemEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.item.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.metadata.encode(buf)?;
        self.is_from_fishing.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let is_from_fishing = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            item,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            metadata,
            is_from_fishing,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub platform_chat_id: String,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub metadata: MetadataDictionary,
    pub flags: i32,
    pub command_permission: i32,
    pub action_permissions: i32,
    pub permission_level: i32,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
    pub links: Links,
    pub device_id: String,
    pub device_os: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.held_item.encode(buf)?;
        self.metadata.encode(buf)?;
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.custom_stored_permissions.encode(buf)?;
        self.user_id.encode(buf)?;
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let command_permission = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let permission_level = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let custom_stored_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_os = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            username,
            entity_id_self,
            runtime_entity_id,
            platform_chat_id,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            pitch,
            yaw,
            head_yaw,
            held_item,
            metadata,
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    Int = 1,
    Float = 2,
    Value = 3,
    WildcardInt = 4,
    Operator = 5,
    Target = 6,
    FilePath = 16,
    String = 32,
    Position = 40,
    Message = 44,
    RawText = 46,
    Json = 50,
    Command = 63,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Int,
                )
            }
            2 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Float,
                )
            }
            3 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Value,
                )
            }
            4 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardInt,
                )
            }
            5 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Operator,
                )
            }
            6 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Target,
                )
            }
            16 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::FilePath,
                )
            }
            32 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::String,
                )
            }
            40 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Position,
                )
            }
            44 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Message,
                )
            }
            46 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::RawText,
                )
            }
            50 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Json,
                )
            }
            63 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Command,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    pub parameter_name: String,
    pub value_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType,
    pub enum_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType,
    pub optional: bool,
    pub options: CommandFlags,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.parameter_name.encode(buf)?;
        self.value_type.encode(buf)?;
        self.enum_type.encode(buf)?;
        self.optional.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameter_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let enum_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let optional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let options = <CommandFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            parameter_name,
            value_type,
            enum_type,
            optional,
            options,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItem {
    pub parameters: Vec<
        PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem,
    >,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.parameters.len() as i32;
        len.encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameters = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { parameters })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCameraShakeAction {
    Add = 0,
    Stop = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraShakeAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCameraShakeAction::Add),
            1 => Ok(PacketCameraShakeAction::Stop),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCameraShakeAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraShake {
    pub intensity: f32,
    pub duration: f32,
    pub type_: u8,
    pub action: PacketCameraShakeAction,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraShake {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.intensity.encode(buf)?;
        self.duration.encode(buf)?;
        self.type_.encode(buf)?;
        self.action.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let intensity = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let action = <PacketCameraShakeAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            intensity,
            duration,
            type_,
            action,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i64,
    pub event_id: PacketEntityEventEventID,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketEntityEventEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobArmorEquipment {
    pub runtime_entity_id: i64,
    pub helmet: Item,
    pub chestplate: Item,
    pub leggings: Item,
    pub boots: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobArmorEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.helmet.encode(buf)?;
        self.chestplate.encode(buf)?;
        self.leggings.encode(buf)?;
        self.boots.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let helmet = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chestplate = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let leggings = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let boots = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            helmet,
            chestplate,
            leggings,
            boots,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEffect {
    pub runtime_entity_id: i64,
    pub event_id: PacketMobEffectEventID,
    pub effect_id: crate::bedrock::codec::ZigZag32,
    pub amplifier: crate::bedrock::codec::ZigZag32,
    pub particles: bool,
    pub duration: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.effect_id.encode(buf)?;
        self.amplifier.encode(buf)?;
        self.particles.encode(buf)?;
        self.duration.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketMobEffectEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let effect_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let amplifier = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let particles = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            effect_id,
            amplifier,
            particles,
            duration,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEquipment {
    pub runtime_entity_id: i64,
    pub item: Item,
    pub slot: u8,
    pub selected_slot: u8,
    pub window_id: WindowID,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.item.encode(buf)?;
        self.slot.encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.window_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            item,
            slot,
            selected_slot,
            window_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntity {
    pub runtime_entity_id: i64,
    pub flags: u8,
    pub position: Vec3F,
    pub rotation: Rotation,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.flags.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation = <Rotation as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            flags,
            position,
            rotation,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcRequest {
    pub runtime_entity_id: i64,
    pub unknown0: u8,
    pub unknown1: String,
    pub unknown2: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.unknown0.encode(buf)?;
        self.unknown1.encode(buf)?;
        self.unknown2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let unknown0 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown1 = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            unknown0,
            unknown1,
            unknown2,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAction {
    pub runtime_entity_id: i64,
    pub action: Action,
    pub position: BlockCoordinates,
    pub face: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.action.encode(buf)?;
        self.position.encode(buf)?;
        self.face.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action = <Action as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            action,
            position,
            face,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerArmorDamage {
    pub type_: ArmorDamageType,
    pub helmet_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub chestplate_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub leggings_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub boots_damage: Option<crate::bedrock::codec::ZigZag32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerArmorDamage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.helmet_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.chestplate_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.leggings_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.boots_damage {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <ArmorDamageType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let helmet_damage = match type_head {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let chestplate_damage = match type_chest {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let leggings_damage = match type_legs {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let boots_damage = match type_feet {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            helmet_damage,
            chestplate_damage,
            leggings_damage,
            boots_damage,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputInputMode {
    Unknown = 0,
    Mouse = 1,
    Touch = 2,
    GamePad = 3,
    MotionController = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputInputMode {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerAuthInputInputMode::Unknown),
            1 => Ok(PacketPlayerAuthInputInputMode::Mouse),
            2 => Ok(PacketPlayerAuthInputInputMode::Touch),
            3 => Ok(PacketPlayerAuthInputInputMode::GamePad),
            4 => Ok(PacketPlayerAuthInputInputMode::MotionController),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputInputMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInputTransactionSome {
    pub legacy: TransactionLegacy,
    pub actions: TransactionActions,
    pub data: TransactionUseItem,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputTransactionSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.legacy.encode(buf)?;
        self.actions.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let legacy = <TransactionLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = <TransactionActions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <TransactionUseItem as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { legacy, actions, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub gaze_direction: Option<Vec3F>,
    pub tick: i64,
    pub delta: Vec3F,
    pub transaction: Option<PacketPlayerAuthInputTransactionSome>,
    pub item_stack_request: Option<ItemStackRequest>,
    pub block_action: Option<Vec<PacketPlayerAuthInputBlockActionSomeItem>>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        if let Some(v) = &self.gaze_direction {
            v.encode(buf)?;
        }
        self.tick.encode(buf)?;
        self.delta.encode(buf)?;
        if let Some(v) = &self.transaction {
            v.encode(buf)?;
        }
        if let Some(v) = &self.item_stack_request {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_action {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let gaze_direction = match play_mode {
            _ => Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let transaction = match input_data_item_interact {
            true => {
                Some(
                    <PacketPlayerAuthInputTransactionSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let item_stack_request = match input_data_item_stack_request {
            true => {
                Some(
                    <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let block_action = match input_data_block_action {
            true => {
                Some({
                    let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )? as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <PacketPlayerAuthInputBlockActionSomeItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            gaze_direction,
            tick,
            delta,
            transaction,
            item_stack_request,
            block_action,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityData {
    pub runtime_entity_id: i64,
    pub metadata: MetadataDictionary,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.metadata.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            metadata,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityMotion {
    pub runtime_entity_id: i64,
    pub velocity: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityMotion {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.velocity.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            velocity,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketStartGameMovementAuthority {
    Client = 0,
    Server = 1,
    ServerWithRewind = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameMovementAuthority {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketStartGameMovementAuthority::Client),
            1 => Ok(PacketStartGameMovementAuthority::Server),
            2 => Ok(PacketStartGameMovementAuthority::ServerWithRewind),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameMovementAuthority), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTakeItemEntity {
    pub runtime_entity_id: i64,
    pub target: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketTakeItemEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.target.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let target = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { runtime_entity_id, target })
    }
}
