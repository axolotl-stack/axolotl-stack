// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ContainerSlotType {
    AnvilInput = 0,
    AnvilMaterial = 1,
    AnvilResult = 2,
    SmithingTableInput = 3,
    SmithingTableMaterial = 4,
    SmithingTableResult = 5,
    Armor = 6,
    Container = 7,
    BeaconPayment = 8,
    BrewingInput = 9,
    BrewingResult = 10,
    BrewingFuel = 11,
    HotbarAndInventory = 12,
    CraftingInput = 13,
    CraftingOutput = 14,
    RecipeConstruction = 15,
    RecipeNature = 16,
    RecipeItems = 17,
    RecipeSearch = 18,
    RecipeSearchBar = 19,
    RecipeEquipment = 20,
    EnchantingInput = 21,
    EnchantingLapis = 22,
    FurnaceFuel = 23,
    FurnaceIngredient = 24,
    FurnaceOutput = 25,
    HorseEquip = 26,
    Hotbar = 27,
    Inventory = 28,
    Shulker = 29,
    TradeIngredient1 = 30,
    TradeIngredient2 = 31,
    TradeResult = 32,
    Offhand = 33,
    CompcreateInput = 34,
    CompcreateOutput = 35,
    ElemconstructOutput = 36,
    MatreduceInput = 37,
    MatreduceOutput = 38,
    LabtableInput = 39,
    LoomInput = 40,
    LoomDye = 41,
    LoomMaterial = 42,
    LoomResult = 43,
    BlastFurnaceIngredient = 44,
    SmokerIngredient = 45,
    Trade2Ingredient1 = 46,
    Trade2Ingredient2 = 47,
    Trade2Result = 48,
    GrindstoneInput = 49,
    GrindstoneAdditional = 50,
    GrindstoneResult = 51,
    StonecutterInput = 52,
    StonecutterResult = 53,
    CartographyInput = 54,
    CartographyAdditional = 55,
    CartographyResult = 56,
    Barrel = 57,
    Cursor = 58,
    CreativeOutput = 59,
}
impl crate::bedrock::codec::BedrockCodec for ContainerSlotType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ContainerSlotType::AnvilInput),
            1 => Ok(ContainerSlotType::AnvilMaterial),
            2 => Ok(ContainerSlotType::AnvilResult),
            3 => Ok(ContainerSlotType::SmithingTableInput),
            4 => Ok(ContainerSlotType::SmithingTableMaterial),
            5 => Ok(ContainerSlotType::SmithingTableResult),
            6 => Ok(ContainerSlotType::Armor),
            7 => Ok(ContainerSlotType::Container),
            8 => Ok(ContainerSlotType::BeaconPayment),
            9 => Ok(ContainerSlotType::BrewingInput),
            10 => Ok(ContainerSlotType::BrewingResult),
            11 => Ok(ContainerSlotType::BrewingFuel),
            12 => Ok(ContainerSlotType::HotbarAndInventory),
            13 => Ok(ContainerSlotType::CraftingInput),
            14 => Ok(ContainerSlotType::CraftingOutput),
            15 => Ok(ContainerSlotType::RecipeConstruction),
            16 => Ok(ContainerSlotType::RecipeNature),
            17 => Ok(ContainerSlotType::RecipeItems),
            18 => Ok(ContainerSlotType::RecipeSearch),
            19 => Ok(ContainerSlotType::RecipeSearchBar),
            20 => Ok(ContainerSlotType::RecipeEquipment),
            21 => Ok(ContainerSlotType::EnchantingInput),
            22 => Ok(ContainerSlotType::EnchantingLapis),
            23 => Ok(ContainerSlotType::FurnaceFuel),
            24 => Ok(ContainerSlotType::FurnaceIngredient),
            25 => Ok(ContainerSlotType::FurnaceOutput),
            26 => Ok(ContainerSlotType::HorseEquip),
            27 => Ok(ContainerSlotType::Hotbar),
            28 => Ok(ContainerSlotType::Inventory),
            29 => Ok(ContainerSlotType::Shulker),
            30 => Ok(ContainerSlotType::TradeIngredient1),
            31 => Ok(ContainerSlotType::TradeIngredient2),
            32 => Ok(ContainerSlotType::TradeResult),
            33 => Ok(ContainerSlotType::Offhand),
            34 => Ok(ContainerSlotType::CompcreateInput),
            35 => Ok(ContainerSlotType::CompcreateOutput),
            36 => Ok(ContainerSlotType::ElemconstructOutput),
            37 => Ok(ContainerSlotType::MatreduceInput),
            38 => Ok(ContainerSlotType::MatreduceOutput),
            39 => Ok(ContainerSlotType::LabtableInput),
            40 => Ok(ContainerSlotType::LoomInput),
            41 => Ok(ContainerSlotType::LoomDye),
            42 => Ok(ContainerSlotType::LoomMaterial),
            43 => Ok(ContainerSlotType::LoomResult),
            44 => Ok(ContainerSlotType::BlastFurnaceIngredient),
            45 => Ok(ContainerSlotType::SmokerIngredient),
            46 => Ok(ContainerSlotType::Trade2Ingredient1),
            47 => Ok(ContainerSlotType::Trade2Ingredient2),
            48 => Ok(ContainerSlotType::Trade2Result),
            49 => Ok(ContainerSlotType::GrindstoneInput),
            50 => Ok(ContainerSlotType::GrindstoneAdditional),
            51 => Ok(ContainerSlotType::GrindstoneResult),
            52 => Ok(ContainerSlotType::StonecutterInput),
            53 => Ok(ContainerSlotType::StonecutterResult),
            54 => Ok(ContainerSlotType::CartographyInput),
            55 => Ok(ContainerSlotType::CartographyAdditional),
            56 => Ok(ContainerSlotType::CartographyResult),
            57 => Ok(ContainerSlotType::Barrel),
            58 => Ok(ContainerSlotType::Cursor),
            59 => Ok(ContainerSlotType::CreativeOutput),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ContainerSlotType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStack {
    pub stack_id: i32,
    pub item: Item,
}
impl crate::bedrock::codec::BedrockCodec for ItemStack {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.stack_id.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let stack_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { stack_id, item })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackRequestActionsItemTypeID {
    Take = 0,
    Place = 1,
    Swap = 2,
    Drop = 3,
    Destroy = 4,
    Consume = 5,
    Create = 6,
    LabTableCombine = 7,
    BeaconPayment = 8,
    MineBlock = 9,
    CraftRecipe = 10,
    CraftRecipeAuto = 11,
    CraftCreative = 12,
    Optional = 13,
    NonImplemented = 14,
    ResultsDeprecated = 15,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemTypeID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ItemStackRequestActionsItemTypeID::Take),
            1 => Ok(ItemStackRequestActionsItemTypeID::Place),
            2 => Ok(ItemStackRequestActionsItemTypeID::Swap),
            3 => Ok(ItemStackRequestActionsItemTypeID::Drop),
            4 => Ok(ItemStackRequestActionsItemTypeID::Destroy),
            5 => Ok(ItemStackRequestActionsItemTypeID::Consume),
            6 => Ok(ItemStackRequestActionsItemTypeID::Create),
            7 => Ok(ItemStackRequestActionsItemTypeID::LabTableCombine),
            8 => Ok(ItemStackRequestActionsItemTypeID::BeaconPayment),
            9 => Ok(ItemStackRequestActionsItemTypeID::MineBlock),
            10 => Ok(ItemStackRequestActionsItemTypeID::CraftRecipe),
            11 => Ok(ItemStackRequestActionsItemTypeID::CraftRecipeAuto),
            12 => Ok(ItemStackRequestActionsItemTypeID::CraftCreative),
            13 => Ok(ItemStackRequestActionsItemTypeID::Optional),
            14 => Ok(ItemStackRequestActionsItemTypeID::NonImplemented),
            15 => Ok(ItemStackRequestActionsItemTypeID::ResultsDeprecated),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackRequestActionsItemTypeID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentBeaconPayment {
    pub primary_effect: crate::bedrock::codec::ZigZag32,
    pub secondary_effect: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentBeaconPayment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.primary_effect.encode(buf)?;
        self.secondary_effect.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let primary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let secondary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            primary_effect,
            secondary_effect,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentConsume {
    pub count: u8,
    pub source: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentConsume {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { count, source })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftCreative {
    pub item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftCreative {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.item_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let item_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { item_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipe {
    pub recipe_network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipe {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { recipe_network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipeAuto {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipeAuto {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCreate {
    pub result_slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCreate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.result_slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let result_slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { result_slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentDrop {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub randomly: bool,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentDrop {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.randomly.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let randomly = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { count, source, randomly })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentOptional {
    pub recipe_network_id: i32,
    pub filtered_string_index: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentOptional {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.filtered_string_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let filtered_string_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            recipe_network_id,
            filtered_string_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentPlace {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentPlace {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { count, source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentResultsDeprecated {
    pub result_items: Vec<Item>,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentResultsDeprecated {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.result_items.len() as i32;
        len.encode(buf)?;
        for item in &self.result_items {
            item.encode(buf)?;
        }
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let result_items = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            result_items,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentSwap {
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentSwap {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(ItemStackRequestActionsItemContentCraftRecipeAuto),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeID,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Consume(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftCreative(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipe(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Create(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Destroy(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Drop(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::MineBlock(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Place(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::Swap(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Take(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestActionsItemTypeID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_id {
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => Some(ItemStackRequestActionsItemContent::NonImplemented),
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequest {
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        let len = self.actions.len() as i32;
        len.encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len() as i32;
        len.encode(buf)?;
        for item in &self.custom_names {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            request_id,
            actions,
            custom_names,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackResponsesItemStatus {
    Ok = 0,
    Error = 1,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemStatus {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ItemStackResponsesItemStatus::Ok),
            1 => Ok(ItemStackResponsesItemStatus::Error),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackResponsesItemStatus), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSomeContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: i32,
    pub custom_name: String,
    pub durability_correction: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentSomeContainersItemSlotsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        self.item_stack_id.encode(buf)?;
        self.custom_name.encode(buf)?;
        self.durability_correction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item_stack_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let durability_correction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
            durability_correction,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSomeContainersItem {
    pub slot_type: ContainerSlotType,
    pub slots: Vec<ItemStackResponsesItemContentSomeContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentSomeContainersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_type.encode(buf)?;
        let len = self.slots.len() as i32;
        len.encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot_type = <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slots = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { slot_type, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSome {
    pub containers: Vec<ItemStackResponsesItemContentSomeContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContentSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.containers.len() as i32;
        len.encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let containers = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { containers })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub status: ItemStackResponsesItemStatus,
    pub request_id: i32,
    pub content: Option<ItemStackResponsesItemContentSome>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let status = <ItemStackResponsesItemStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let request_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content = match status {
            _ => {
                Some(
                    <ItemStackResponsesItemContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            status,
            request_id,
            content,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Flags = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    HorseType = 19,
    CreeperSwell = 20,
    CreeperSwellDirection = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeID = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinID = 40,
    URLTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    WitherAerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    RiderSeatRotationOffset = 60,
    AreaEffectCloudRadius = 61,
    AreaEffectCloudWaiting = 62,
    AreaEffectCloudParticleID = 63,
    ShulkerPeekID = 64,
    ShulkerAttachFace = 65,
    ShulkerAttached = 66,
    ShulkerAttachPos = 67,
    TradingPlayerEid = 68,
    TradingCareer = 69,
    HasCommandBlock = 70,
    CommandBlockCommand = 71,
    CommandBlockLastOutput = 72,
    CommandBlockTrackOutput = 73,
    ControllingRiderSeatNumber = 74,
    Strength = 75,
    MaxStrength = 76,
    EvokerSpellCastingColor = 77,
    LimitedLife = 78,
    ArmorStandPoseIndex = 79,
    EnderCrystalTimeOffset = 80,
    AlwaysShowNametag = 81,
    Color2 = 82,
    NameAuthor = 83,
    ScoreTag = 84,
    BalloonAttachedEntity = 85,
    PufferfishSize = 86,
    BubbleTime = 87,
    Agent = 88,
    SittingAmount = 89,
    SittingAmountPrevious = 90,
    EatingCounter = 91,
    FlagsExtended = 92,
    LayingAmount = 93,
    LayingAmountPrevious = 94,
    AreaEffectCloudDuration = 95,
    AreaEffectCloudSpawnTime = 96,
    AreaEffectCloudChangeRate = 97,
    AreaEffectCloudChangeOnPickup = 98,
    AreaEffectCloudPickupCount = 99,
    InteractText = 100,
    TradeTier = 101,
    MaxTradeTier = 102,
    TradeExperience = 103,
    SkinID = 104,
    SpawningFrames = 105,
    CommandBlockTickDelay = 106,
    CommandBlockExecuteOnFirstTick = 107,
    AmbientSoundInterval = 108,
    AmbientSoundIntervalRange = 109,
    AmbientSoundEventName = 110,
    FallDamageMultiplier = 111,
    NameRawText = 112,
    CanRideTarget = 113,
    LowTierCuredDiscount = 114,
    HighTierCuredDiscount = 115,
    NearbyCuredDiscount = 116,
    NearbyCuredDiscountTimestamp = 117,
    Hitbox = 118,
    IsBuoyant = 119,
    BuoyancyData = 120,
    GoatHornCount = 121,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Flags),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            19 => Ok(MetadataDictionaryItemKey::HorseType),
            20 => Ok(MetadataDictionaryItemKey::CreeperSwell),
            21 => Ok(MetadataDictionaryItemKey::CreeperSwellDirection),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeID),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinID),
            41 => Ok(MetadataDictionaryItemKey::URLTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::WitherAerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::RiderSeatRotationOffset),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            63 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleID),
            64 => Ok(MetadataDictionaryItemKey::ShulkerPeekID),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            67 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            68 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            69 => Ok(MetadataDictionaryItemKey::TradingCareer),
            70 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            73 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            74 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            75 => Ok(MetadataDictionaryItemKey::Strength),
            76 => Ok(MetadataDictionaryItemKey::MaxStrength),
            77 => Ok(MetadataDictionaryItemKey::EvokerSpellCastingColor),
            78 => Ok(MetadataDictionaryItemKey::LimitedLife),
            79 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            80 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            81 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            82 => Ok(MetadataDictionaryItemKey::Color2),
            83 => Ok(MetadataDictionaryItemKey::NameAuthor),
            84 => Ok(MetadataDictionaryItemKey::ScoreTag),
            85 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            86 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            87 => Ok(MetadataDictionaryItemKey::BubbleTime),
            88 => Ok(MetadataDictionaryItemKey::Agent),
            89 => Ok(MetadataDictionaryItemKey::SittingAmount),
            90 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            91 => Ok(MetadataDictionaryItemKey::EatingCounter),
            92 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            93 => Ok(MetadataDictionaryItemKey::LayingAmount),
            94 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            95 => Ok(MetadataDictionaryItemKey::AreaEffectCloudDuration),
            96 => Ok(MetadataDictionaryItemKey::AreaEffectCloudSpawnTime),
            97 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeRate),
            98 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeOnPickup),
            99 => Ok(MetadataDictionaryItemKey::AreaEffectCloudPickupCount),
            100 => Ok(MetadataDictionaryItemKey::InteractText),
            101 => Ok(MetadataDictionaryItemKey::TradeTier),
            102 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            103 => Ok(MetadataDictionaryItemKey::TradeExperience),
            104 => Ok(MetadataDictionaryItemKey::SkinID),
            105 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            107 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            110 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            111 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            112 => Ok(MetadataDictionaryItemKey::NameRawText),
            113 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            114 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            117 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            118 => Ok(MetadataDictionaryItemKey::Hitbox),
            119 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            120 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            121 => Ok(MetadataDictionaryItemKey::GoatHornCount),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValueDefault {
    Byte(i8),
    Compound(Vec<u8>),
    Float(f32),
    Int(crate::bedrock::codec::ZigZag32),
    Long(crate::bedrock::codec::ZigZag64),
    Short(i16),
    String(String),
    Vec3F(Vec3F),
    Vec3I(Vec3I),
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Default(Box<Option<MetadataDictionaryItemValueDefault>>),
    Flags(MetadataFlags1),
    FlagsExtended(MetadataFlags2),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: MetadataDictionaryItemValue,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        match &self.value {
            MetadataDictionaryItemValue::Flags(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::FlagsExtended(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::Default(v) => v.encode(buf)?,
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value = match key {
            _ => {
                MetadataDictionaryItemValue::Flags(
                    <MetadataFlags1 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::FlagsExtended(
                    <MetadataFlags2 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::Default(
                    Box::new(
                        match type_ {
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Byte(
                                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Compound(
                                        <Vec<
                                            u8,
                                        > as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Float(
                                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Int(
                                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Long(
                                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Short(
                                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::String(
                                        <String as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3F(
                                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3I(
                                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeMulti {
    pub uuid: uuid::Uuid,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeMulti {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { uuid, network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShaped {
    pub recipe_id: LatinString,
    pub width: crate::bedrock::codec::ZigZag32,
    pub height: crate::bedrock::codec::ZigZag32,
    pub input: Vec<Vec<RecipeIngredient>>,
    pub output: Vec<Item>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: crate::bedrock::codec::ZigZag32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShaped {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        let len = self.input.len() as i32;
        len.encode(buf)?;
        for item in &self.input {
            let len = item.len() as i32;
            len.encode(buf)?;
            for item in &item {
                item.encode(buf)?;
            }
        }
        let len = self.output.len() as i32;
        len.encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        self.priority.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let width = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )? as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                    )?,
                                );
                        }
                        tmp_vec
                    });
            }
            tmp_vec
        };
        let output = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_id,
            width,
            height,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShapeless {
    pub recipe_id: LatinString,
    pub input: Vec<RecipeIngredient>,
    pub output: Vec<Item>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: crate::bedrock::codec::ZigZag32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShapeless {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        let len = self.input.len() as i32;
        len.encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.output.len() as i32;
        len.encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        self.priority.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let output = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_id,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipesItemRecipe {
    Furnace(Box<RecipesItemRecipeFurnace>),
    FurnaceWithMetadata(Box<RecipesItemRecipeFurnaceWithMetadata>),
    Multi(RecipesItemRecipeMulti),
    Shaped(Box<RecipesItemRecipeShaped>),
    ShapedChemistry(Box<RecipesItemRecipeShaped>),
    Shapeless(Box<RecipesItemRecipeShapeless>),
    ShapelessChemistry(Box<RecipesItemRecipeShapeless>),
    ShulkerBox(Box<RecipesItemRecipeShapeless>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItem {
    pub type_: RecipesItemType,
    pub recipe: Option<RecipesItemRecipe>,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.recipe {
            match v {
                RecipesItemRecipe::Furnace(v) => v.encode(buf)?,
                RecipesItemRecipe::FurnaceWithMetadata(v) => v.encode(buf)?,
                RecipesItemRecipe::Multi(v) => v.encode(buf)?,
                RecipesItemRecipe::Shaped(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapedChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::Shapeless(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapelessChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::ShulkerBox(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <RecipesItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let recipe = match type_ {
            _ => {
                Some(
                    RecipesItemRecipe::Furnace(
                        Box::new(
                            <RecipesItemRecipeFurnace as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::FurnaceWithMetadata(
                        Box::new(
                            <RecipesItemRecipeFurnaceWithMetadata as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Multi(
                        <RecipesItemRecipeMulti as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Shaped(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShapedChemistry(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Shapeless(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShapelessChemistry(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShulkerBox(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, recipe })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyLegacyTransactionsItemChangedSlotsItem {
    pub slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionLegacyLegacyTransactionsItemChangedSlotsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyLegacyTransactionsItem {
    pub container_id: u8,
    pub changed_slots: Vec<TransactionLegacyLegacyTransactionsItemChangedSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacyLegacyTransactionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        let len = self.changed_slots.len() as i32;
        len.encode(buf)?;
        for item in &self.changed_slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let changed_slots = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionLegacyLegacyTransactionsItemChangedSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            container_id,
            changed_slots,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionActionsActionsItemSourceType {
    Container = 0,
    Global = 1,
    WorldInteraction = 2,
    Creative = 3,
    CraftSlot = 100,
    Craft = 99999,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsActionsItemSourceType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionActionsActionsItemSourceType::Container),
            1 => Ok(TransactionActionsActionsItemSourceType::Global),
            2 => Ok(TransactionActionsActionsItemSourceType::WorldInteraction),
            3 => Ok(TransactionActionsActionsItemSourceType::Creative),
            100 => Ok(TransactionActionsActionsItemSourceType::CraftSlot),
            99999 => Ok(TransactionActionsActionsItemSourceType::Craft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionActionsActionsItemSourceType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsActionsItemContentContainer {
    pub inventory_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionActionsActionsItemContentContainer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.inventory_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let inventory_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { inventory_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsActionsItemContentCraft {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsActionsItemContentCraft {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { action })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsActionsItemContentWorldInteraction {
    pub flags: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionActionsActionsItemContentWorldInteraction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.flags.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionActionsActionsItemContent {
    Container(TransactionActionsActionsItemContentContainer),
    Craft(TransactionActionsActionsItemContentCraft),
    CraftSlot(TransactionActionsActionsItemContentCraft),
    WorldInteraction(TransactionActionsActionsItemContentWorldInteraction),
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsActionsItem {
    pub source_type: TransactionActionsActionsItemSourceType,
    pub content: Option<TransactionActionsActionsItemContent>,
    pub slot: i32,
    pub old_item: Item,
    pub new_item: Item,
    pub new_item_stack_id: Option<crate::bedrock::codec::ZigZag32>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsActionsItem {
    fn encode<B: bytes::BufMut>(&self, _buf: &mut B) -> Result<(), std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to encode",
            ),
        )
    }
    fn decode<B: bytes::Buf>(_buf: &mut B) -> Result<Self, std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to decode",
            ),
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionUseItemActionType {
    ClickBlock = 0,
    ClickAir = 1,
    BreakBlock = 2,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItemActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionUseItemActionType::ClickBlock),
            1 => Ok(TransactionUseItemActionType::ClickAir),
            2 => Ok(TransactionUseItemActionType::BreakBlock),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionUseItemActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionUseItem {
    pub action_type: TransactionUseItemActionType,
    pub block_position: BlockCoordinates,
    pub face: crate::bedrock::codec::ZigZag32,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
    pub block_runtime_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.block_position.encode(buf)?;
        self.face.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_type = <TransactionUseItemActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let hotbar_slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            action_type,
            block_position,
            face,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
            block_runtime_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum WindowType {
    None = -9,
    Inventory = -1,
    Container = 0,
    Workbench = 1,
    Furnace = 2,
    Enchantment = 3,
    BrewingStand = 4,
    Anvil = 5,
    Dispenser = 6,
    Dropper = 7,
    Hopper = 8,
    Cauldron = 9,
    MinecartChest = 10,
    MinecartHopper = 11,
    Horse = 12,
    Beacon = 13,
    StructureEditor = 14,
    Trading = 15,
    CommandBlock = 16,
    Jukebox = 17,
    Armor = 18,
    Hand = 19,
    CompoundCreator = 20,
    ElementConstructor = 21,
    MaterialReducer = 22,
    LabTable = 23,
    Loom = 24,
    Lectern = 25,
    Grindstone = 26,
    BlastFurnace = 27,
    Smoker = 28,
    Stonecutter = 29,
    Cartography = 30,
    Hud = 31,
    JigsawEditor = 32,
    SmithingTable = 33,
}
impl crate::bedrock::codec::BedrockCodec for WindowType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            -9 => Ok(WindowType::None),
            -1 => Ok(WindowType::Inventory),
            0 => Ok(WindowType::Container),
            1 => Ok(WindowType::Workbench),
            2 => Ok(WindowType::Furnace),
            3 => Ok(WindowType::Enchantment),
            4 => Ok(WindowType::BrewingStand),
            5 => Ok(WindowType::Anvil),
            6 => Ok(WindowType::Dispenser),
            7 => Ok(WindowType::Dropper),
            8 => Ok(WindowType::Hopper),
            9 => Ok(WindowType::Cauldron),
            10 => Ok(WindowType::MinecartChest),
            11 => Ok(WindowType::MinecartHopper),
            12 => Ok(WindowType::Horse),
            13 => Ok(WindowType::Beacon),
            14 => Ok(WindowType::StructureEditor),
            15 => Ok(WindowType::Trading),
            16 => Ok(WindowType::CommandBlock),
            17 => Ok(WindowType::Jukebox),
            18 => Ok(WindowType::Armor),
            19 => Ok(WindowType::Hand),
            20 => Ok(WindowType::CompoundCreator),
            21 => Ok(WindowType::ElementConstructor),
            22 => Ok(WindowType::MaterialReducer),
            23 => Ok(WindowType::LabTable),
            24 => Ok(WindowType::Loom),
            25 => Ok(WindowType::Lectern),
            26 => Ok(WindowType::Grindstone),
            27 => Ok(WindowType::BlastFurnace),
            28 => Ok(WindowType::Smoker),
            29 => Ok(WindowType::Stonecutter),
            30 => Ok(WindowType::Cartography),
            31 => Ok(WindowType::Hud),
            32 => Ok(WindowType::JigsawEditor),
            33 => Ok(WindowType::SmithingTable),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItem {
    pub name: String,
    pub description: String,
    pub flags: u8,
    pub permission_level: u8,
    pub alias: i32,
    pub overloads: Vec<PacketAvailableCommandsCommandDataItemOverloadsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsCommandDataItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.description.encode(buf)?;
        self.flags.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.alias.encode(buf)?;
        let len = self.overloads.len() as i32;
        len.encode(buf)?;
        for item in &self.overloads {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let description = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let permission_level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let alias = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let overloads = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            name,
            description,
            flags,
            permission_level,
            alias,
            overloads,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGuiDataPickItem {
    pub item_name: String,
    pub item_effects: String,
    pub hotbar_slot: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketGuiDataPickItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.item_name.encode(buf)?;
        self.item_effects.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let item_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item_effects = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hotbar_slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            item_name,
            item_effects,
            hotbar_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryContent {
    pub window_id: WindowIDVarint,
    pub input: ItemStacks,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.input.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = <ItemStacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { window_id, input })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemStackRequest {
    pub requests: Vec<ItemStackRequest>,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemStackRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.requests.len() as i32;
        len.encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let requests = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { requests })
    }
}
