// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct CameraPresets {
    pub name: String,
    pub parent: String,
    pub position: Vec3Fopts,
    pub rotation: Vec2Fopts,
    pub rotation_speed: Option<f32>,
    pub snap_to_target: Option<bool>,
    pub horizontal_rotation_limit: Option<Vec2F>,
    pub vertical_rotation_limit: Option<Vec2F>,
    pub continue_targeting: Option<bool>,
    pub tracking_radius: Option<f32>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub radius: Option<f32>,
    pub yaw_limit_min: Option<f32>,
    pub yaw_limit_max: Option<f32>,
    pub audio_listener: Option<u8>,
    pub player_effects: Option<bool>,
    pub align_target_and_camera_forward: Option<bool>,
    pub aim_assist: Option<CameraPresetsAimAssistSome>,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresets {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.parent.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        match &self.rotation_speed {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.snap_to_target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.horizontal_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.vertical_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.continue_targeting {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.tracking_radius {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.radius {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.yaw_limit_min {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.yaw_limit_max {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.audio_listener {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.player_effects {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.align_target_and_camera_forward {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.aim_assist {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let parent = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation = <Vec2Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation_speed = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let snap_to_target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let horizontal_rotation_limit = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let vertical_rotation_limit = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let continue_targeting = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let tracking_radius = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let radius = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let yaw_limit_min = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let yaw_limit_max = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let audio_listener = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let player_effects = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let align_target_and_camera_forward = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let aim_assist = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <CameraPresetsAimAssistSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        Ok(Self {
            name,
            parent,
            position,
            rotation,
            rotation_speed,
            snap_to_target,
            horizontal_rotation_limit,
            vertical_rotation_limit,
            continue_targeting,
            tracking_radius,
            offset,
            entity_offset,
            radius,
            yaw_limit_min,
            yaw_limit_max,
            audio_listener,
            player_effects,
            align_target_and_camera_forward,
            aim_assist,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraAimAssist {
    pub preset_id: String,
    pub view_angle: Vec2F,
    pub distance: f32,
    pub target_mode: PacketCameraAimAssistTargetMode,
    pub action: PacketCameraAimAssistAction,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssist {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.preset_id.encode(buf)?;
        self.view_angle.encode(buf)?;
        self.distance.encode(buf)?;
        self.target_mode.encode(buf)?;
        self.action.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let preset_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let view_angle = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let distance = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let target_mode = <PacketCameraAimAssistTargetMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action = <PacketCameraAimAssistAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            preset_id,
            view_angle,
            distance,
            target_mode,
            action,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientMovementPredictionSync {
    pub data_flags: i64,
    pub bounding_box: PacketClientMovementPredictionSyncBoundingBox,
    pub movement_speed: f32,
    pub underwater_movement_speed: f32,
    pub lava_movement_speed: f32,
    pub jump_strength: f32,
    pub health: f32,
    pub hunger: f32,
    pub entity_runtime_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientMovementPredictionSync {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.data_flags.encode(buf)?;
        self.bounding_box.encode(buf)?;
        self.movement_speed.encode(buf)?;
        self.underwater_movement_speed.encode(buf)?;
        self.lava_movement_speed.encode(buf)?;
        self.jump_strength.encode(buf)?;
        self.health.encode(buf)?;
        self.hunger.encode(buf)?;
        self.entity_runtime_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let data_flags = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let bounding_box = <PacketClientMovementPredictionSyncBoundingBox as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let movement_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let underwater_movement_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let lava_movement_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let jump_strength = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let health = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hunger = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            data_flags,
            bounding_box,
            movement_speed,
            underwater_movement_speed,
            lava_movement_speed,
            jump_strength,
            health,
            hunger,
            entity_runtime_id,
        })
    }
}
