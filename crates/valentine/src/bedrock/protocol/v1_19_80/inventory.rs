// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ContainerSlotType {
    AnvilInput = 0,
    AnvilMaterial = 1,
    AnvilResult = 2,
    SmithingTableInput = 3,
    SmithingTableMaterial = 4,
    SmithingTableResult = 5,
    Armor = 6,
    Container = 7,
    BeaconPayment = 8,
    BrewingInput = 9,
    BrewingResult = 10,
    BrewingFuel = 11,
    HotbarAndInventory = 12,
    CraftingInput = 13,
    CraftingOutput = 14,
    RecipeConstruction = 15,
    RecipeNature = 16,
    RecipeItems = 17,
    RecipeSearch = 18,
    RecipeSearchBar = 19,
    RecipeEquipment = 20,
    RecipeBook = 21,
    EnchantingInput = 22,
    EnchantingLapis = 23,
    FurnaceFuel = 24,
    FurnaceIngredient = 25,
    FurnaceOutput = 26,
    HorseEquip = 27,
    Hotbar = 28,
    Inventory = 29,
    Shulker = 30,
    TradeIngredient1 = 31,
    TradeIngredient2 = 32,
    TradeResult = 33,
    Offhand = 34,
    CompcreateInput = 35,
    CompcreateOutput = 36,
    ElemconstructOutput = 37,
    MatreduceInput = 38,
    MatreduceOutput = 39,
    LabtableInput = 40,
    LoomInput = 41,
    LoomDye = 42,
    LoomMaterial = 43,
    LoomResult = 44,
    BlastFurnaceIngredient = 45,
    SmokerIngredient = 46,
    Trade2Ingredient1 = 47,
    Trade2Ingredient2 = 48,
    Trade2Result = 49,
    GrindstoneInput = 50,
    GrindstoneAdditional = 51,
    GrindstoneResult = 52,
    StonecutterInput = 53,
    StonecutterResult = 54,
    CartographyInput = 55,
    CartographyAdditional = 56,
    CartographyResult = 57,
    Barrel = 58,
    Cursor = 59,
    CreativeOutput = 60,
    SmithingTableTemplate = 61,
}
impl crate::bedrock::codec::BedrockCodec for ContainerSlotType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ContainerSlotType::AnvilInput),
            1 => Ok(ContainerSlotType::AnvilMaterial),
            2 => Ok(ContainerSlotType::AnvilResult),
            3 => Ok(ContainerSlotType::SmithingTableInput),
            4 => Ok(ContainerSlotType::SmithingTableMaterial),
            5 => Ok(ContainerSlotType::SmithingTableResult),
            6 => Ok(ContainerSlotType::Armor),
            7 => Ok(ContainerSlotType::Container),
            8 => Ok(ContainerSlotType::BeaconPayment),
            9 => Ok(ContainerSlotType::BrewingInput),
            10 => Ok(ContainerSlotType::BrewingResult),
            11 => Ok(ContainerSlotType::BrewingFuel),
            12 => Ok(ContainerSlotType::HotbarAndInventory),
            13 => Ok(ContainerSlotType::CraftingInput),
            14 => Ok(ContainerSlotType::CraftingOutput),
            15 => Ok(ContainerSlotType::RecipeConstruction),
            16 => Ok(ContainerSlotType::RecipeNature),
            17 => Ok(ContainerSlotType::RecipeItems),
            18 => Ok(ContainerSlotType::RecipeSearch),
            19 => Ok(ContainerSlotType::RecipeSearchBar),
            20 => Ok(ContainerSlotType::RecipeEquipment),
            21 => Ok(ContainerSlotType::RecipeBook),
            22 => Ok(ContainerSlotType::EnchantingInput),
            23 => Ok(ContainerSlotType::EnchantingLapis),
            24 => Ok(ContainerSlotType::FurnaceFuel),
            25 => Ok(ContainerSlotType::FurnaceIngredient),
            26 => Ok(ContainerSlotType::FurnaceOutput),
            27 => Ok(ContainerSlotType::HorseEquip),
            28 => Ok(ContainerSlotType::Hotbar),
            29 => Ok(ContainerSlotType::Inventory),
            30 => Ok(ContainerSlotType::Shulker),
            31 => Ok(ContainerSlotType::TradeIngredient1),
            32 => Ok(ContainerSlotType::TradeIngredient2),
            33 => Ok(ContainerSlotType::TradeResult),
            34 => Ok(ContainerSlotType::Offhand),
            35 => Ok(ContainerSlotType::CompcreateInput),
            36 => Ok(ContainerSlotType::CompcreateOutput),
            37 => Ok(ContainerSlotType::ElemconstructOutput),
            38 => Ok(ContainerSlotType::MatreduceInput),
            39 => Ok(ContainerSlotType::MatreduceOutput),
            40 => Ok(ContainerSlotType::LabtableInput),
            41 => Ok(ContainerSlotType::LoomInput),
            42 => Ok(ContainerSlotType::LoomDye),
            43 => Ok(ContainerSlotType::LoomMaterial),
            44 => Ok(ContainerSlotType::LoomResult),
            45 => Ok(ContainerSlotType::BlastFurnaceIngredient),
            46 => Ok(ContainerSlotType::SmokerIngredient),
            47 => Ok(ContainerSlotType::Trade2Ingredient1),
            48 => Ok(ContainerSlotType::Trade2Ingredient2),
            49 => Ok(ContainerSlotType::Trade2Result),
            50 => Ok(ContainerSlotType::GrindstoneInput),
            51 => Ok(ContainerSlotType::GrindstoneAdditional),
            52 => Ok(ContainerSlotType::GrindstoneResult),
            53 => Ok(ContainerSlotType::StonecutterInput),
            54 => Ok(ContainerSlotType::StonecutterResult),
            55 => Ok(ContainerSlotType::CartographyInput),
            56 => Ok(ContainerSlotType::CartographyAdditional),
            57 => Ok(ContainerSlotType::CartographyResult),
            58 => Ok(ContainerSlotType::Barrel),
            59 => Ok(ContainerSlotType::Cursor),
            60 => Ok(ContainerSlotType::CreativeOutput),
            61 => Ok(ContainerSlotType::SmithingTableTemplate),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ContainerSlotType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum RecipesItemType {
    Shapeless = 0,
    Shaped = 1,
    Furnace = 2,
    FurnaceWithMetadata = 3,
    Multi = 4,
    ShulkerBox = 5,
    ShapelessChemistry = 6,
    ShapedChemistry = 7,
    SmithingTransform = 8,
    SmithingTrim = 9,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(RecipesItemType::Shapeless),
            1 => Ok(RecipesItemType::Shaped),
            2 => Ok(RecipesItemType::Furnace),
            3 => Ok(RecipesItemType::FurnaceWithMetadata),
            4 => Ok(RecipesItemType::Multi),
            5 => Ok(RecipesItemType::ShulkerBox),
            6 => Ok(RecipesItemType::ShapelessChemistry),
            7 => Ok(RecipesItemType::ShapedChemistry),
            8 => Ok(RecipesItemType::SmithingTransform),
            9 => Ok(RecipesItemType::SmithingTrim),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(RecipesItemType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeSmithingTransform {
    pub recipe_id: LatinString,
    pub template: RecipeIngredient,
    pub base: RecipeIngredient,
    pub addition: RecipeIngredient,
    pub result: ItemLegacy,
    pub tag: String,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeSmithingTransform {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        self.template.encode(buf)?;
        self.base.encode(buf)?;
        self.addition.encode(buf)?;
        self.result.encode(buf)?;
        self.tag.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let template = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let base = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let addition = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let result = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let tag = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_id,
            template,
            base,
            addition,
            result,
            tag,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeSmithingTrim {
    pub recipe_id: LatinString,
    pub template: RecipeIngredient,
    pub input: RecipeIngredient,
    pub addition: RecipeIngredient,
    pub block: String,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeSmithingTrim {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        self.template.encode(buf)?;
        self.input.encode(buf)?;
        self.addition.encode(buf)?;
        self.block.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let template = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let addition = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_id,
            template,
            input,
            addition,
            block,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipesItemRecipe {
    Furnace(Box<RecipesItemRecipeFurnace>),
    FurnaceWithMetadata(Box<RecipesItemRecipeFurnaceWithMetadata>),
    Multi(RecipesItemRecipeMulti),
    Shaped(Box<RecipesItemRecipeShaped>),
    ShapedChemistry(Box<RecipesItemRecipeShaped>),
    Shapeless(Box<RecipesItemRecipeShapeless>),
    ShapelessChemistry(Box<RecipesItemRecipeShapeless>),
    ShulkerBox(Box<RecipesItemRecipeShapeless>),
    SmithingTransform(Box<RecipesItemRecipeSmithingTransform>),
    SmithingTrim(Box<RecipesItemRecipeSmithingTrim>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItem {
    pub type_: RecipesItemType,
    pub recipe: Option<RecipesItemRecipe>,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.recipe {
            match v {
                RecipesItemRecipe::Furnace(v) => v.encode(buf)?,
                RecipesItemRecipe::FurnaceWithMetadata(v) => v.encode(buf)?,
                RecipesItemRecipe::Multi(v) => v.encode(buf)?,
                RecipesItemRecipe::Shaped(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapedChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::Shapeless(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapelessChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::ShulkerBox(v) => v.encode(buf)?,
                RecipesItemRecipe::SmithingTransform(v) => v.encode(buf)?,
                RecipesItemRecipe::SmithingTrim(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <RecipesItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let recipe = match type_ {
            _ => {
                Some(
                    RecipesItemRecipe::Furnace(
                        Box::new(
                            <RecipesItemRecipeFurnace as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::FurnaceWithMetadata(
                        Box::new(
                            <RecipesItemRecipeFurnaceWithMetadata as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Multi(
                        <RecipesItemRecipeMulti as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Shaped(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShapedChemistry(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Shapeless(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShapelessChemistry(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShulkerBox(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::SmithingTransform(
                        Box::new(
                            <RecipesItemRecipeSmithingTransform as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::SmithingTrim(
                        Box::new(
                            <RecipesItemRecipeSmithingTrim as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, recipe })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItem {
    pub name: String,
    pub description: String,
    pub flags: u16,
    pub permission_level: u8,
    pub alias: i32,
    pub overloads: Vec<PacketAvailableCommandsCommandDataItemOverloadsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsCommandDataItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.description.encode(buf)?;
        self.flags.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.alias.encode(buf)?;
        let len = self.overloads.len() as i32;
        len.encode(buf)?;
        for item in &self.overloads {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let description = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let flags = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let permission_level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let alias = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let overloads = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            name,
            description,
            flags,
            permission_level,
            alias,
            overloads,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTrimDataPatternsItem {
    pub item_name: String,
    pub pattern: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTrimDataPatternsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.item_name.encode(buf)?;
        self.pattern.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let item_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pattern = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { item_name, pattern })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTrimDataMaterialsItem {
    pub material: String,
    pub color: String,
    pub item_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTrimDataMaterialsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.material.encode(buf)?;
        self.color.encode(buf)?;
        self.item_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let material = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let color = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { material, color, item_name })
    }
}
