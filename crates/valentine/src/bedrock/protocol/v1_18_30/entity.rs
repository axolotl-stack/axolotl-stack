// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub unique_entity_id: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub platform_chat_id: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub gamemode: GameMode,
    pub metadata: MetadataDictionary,
    pub flags: i32,
    pub command_permission: i32,
    pub action_permissions: i32,
    pub permission_level: i32,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
    pub links: Links,
    pub device_id: String,
    pub device_os: DeviceOs,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        self.unique_entity_id.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.held_item.encode(buf)?;
        self.gamemode.encode(buf)?;
        self.metadata.encode(buf)?;
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.custom_stored_permissions.encode(buf)?;
        self.user_id.encode(buf)?;
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unique_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let command_permission = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let permission_level = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let custom_stored_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_os = <DeviceOs as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            username,
            unique_entity_id,
            runtime_entity_id,
            platform_chat_id,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            held_item,
            gamemode,
            metadata,
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddVolumeEntityBounds {
    pub min: BlockCoordinates,
    pub max: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddVolumeEntityBounds {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let min = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let max = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { min, max })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddVolumeEntity {
    pub runtime_id: i64,
    pub nbt: Vec<u8>,
    pub encoding_identifier: String,
    pub instance_name: String,
    pub bounds: PacketAddVolumeEntityBounds,
    pub dimension: crate::bedrock::codec::ZigZag32,
    pub engine_version: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddVolumeEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        self.nbt.encode(buf)?;
        self.encoding_identifier.encode(buf)?;
        self.instance_name.encode(buf)?;
        self.bounds.encode(buf)?;
        self.dimension.encode(buf)?;
        self.engine_version.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let encoding_identifier = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let instance_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let bounds = <PacketAddVolumeEntityBounds as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let engine_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_id,
            nbt,
            encoding_identifier,
            instance_name,
            bounds,
            dimension,
            engine_version,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAgentActionActionType {
    None = 0,
    Attack = 1,
    Collect = 2,
    Destroy = 3,
    DetectRedstone = 4,
    DetectObstacle = 5,
    Drop = 6,
    DropAll = 7,
    Inspect = 8,
    InspectData = 9,
    InspectItemCount = 10,
    InspectItemDetail = 11,
    InspectItemSpace = 12,
    Interact = 13,
    Move = 14,
    PlaceBlock = 15,
    Till = 16,
    TransferItemTo = 17,
    Turn = 18,
}
impl crate::bedrock::codec::BedrockCodec for PacketAgentActionActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketAgentActionActionType::None),
            1 => Ok(PacketAgentActionActionType::Attack),
            2 => Ok(PacketAgentActionActionType::Collect),
            3 => Ok(PacketAgentActionActionType::Destroy),
            4 => Ok(PacketAgentActionActionType::DetectRedstone),
            5 => Ok(PacketAgentActionActionType::DetectObstacle),
            6 => Ok(PacketAgentActionActionType::Drop),
            7 => Ok(PacketAgentActionActionType::DropAll),
            8 => Ok(PacketAgentActionActionType::Inspect),
            9 => Ok(PacketAgentActionActionType::InspectData),
            10 => Ok(PacketAgentActionActionType::InspectItemCount),
            11 => Ok(PacketAgentActionActionType::InspectItemDetail),
            12 => Ok(PacketAgentActionActionType::InspectItemSpace),
            13 => Ok(PacketAgentActionActionType::Interact),
            14 => Ok(PacketAgentActionActionType::Move),
            15 => Ok(PacketAgentActionActionType::PlaceBlock),
            16 => Ok(PacketAgentActionActionType::Till),
            17 => Ok(PacketAgentActionActionType::TransferItemTo),
            18 => Ok(PacketAgentActionActionType::Turn),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAgentActionActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAgentAction {
    pub request_id: String,
    pub action_type: PacketAgentActionActionType,
    pub body: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAgentAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        self.action_type.encode(buf)?;
        self.body.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let action_type = <PacketAgentActionActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let body = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            request_id,
            action_type,
            body,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    Int = 1,
    Float = 2,
    Value = 3,
    WildcardInt = 4,
    Operator = 5,
    Target = 7,
    Wildcard = 9,
    FilePath = 16,
    String = 38,
    BlockPosition = 46,
    Position = 47,
    Message = 50,
    RawText = 52,
    Json = 56,
    Command = 69,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Int,
                )
            }
            2 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Float,
                )
            }
            3 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Value,
                )
            }
            4 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardInt,
                )
            }
            5 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Operator,
                )
            }
            7 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Target,
                )
            }
            9 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Wildcard,
                )
            }
            16 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::FilePath,
                )
            }
            38 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::String,
                )
            }
            46 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::BlockPosition,
                )
            }
            47 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Position,
                )
            }
            50 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Message,
                )
            }
            52 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::RawText,
                )
            }
            56 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Json,
                )
            }
            69 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Command,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    pub parameter_name: String,
    pub value_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType,
    pub enum_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType,
    pub optional: bool,
    pub options: CommandFlags,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.parameter_name.encode(buf)?;
        self.value_type.encode(buf)?;
        self.enum_type.encode(buf)?;
        self.optional.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameter_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let enum_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let optional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let options = <CommandFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            parameter_name,
            value_type,
            enum_type,
            optional,
            options,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItem {
    pub parameters: Vec<
        PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem,
    >,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.parameters.len() as i32;
        len.encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameters = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { parameters })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChangeMobProperty {
    pub entity_unique_id: crate::bedrock::codec::ZigZag64,
    pub property: String,
    pub bool_value: bool,
    pub string_value: String,
    pub int_value: crate::bedrock::codec::ZigZag32,
    pub float_value: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketChangeMobProperty {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_unique_id.encode(buf)?;
        self.property.encode(buf)?;
        self.bool_value.encode(buf)?;
        self.string_value.encode(buf)?;
        self.int_value.encode(buf)?;
        self.float_value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let property = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let bool_value = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let string_value = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let int_value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let float_value = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_unique_id,
            property,
            bool_value,
            string_value,
            int_value,
            float_value,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEntityEventEventID {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    Caravan = 64,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
    GrowUp = 76,
    VibrationDetected = 77,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEventEventID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketEntityEventEventID::Jump),
            2 => Ok(PacketEntityEventEventID::HurtAnimation),
            3 => Ok(PacketEntityEventEventID::DeathAnimation),
            4 => Ok(PacketEntityEventEventID::ArmSwing),
            5 => Ok(PacketEntityEventEventID::StopAttack),
            6 => Ok(PacketEntityEventEventID::TameFail),
            7 => Ok(PacketEntityEventEventID::TameSuccess),
            8 => Ok(PacketEntityEventEventID::ShakeWet),
            9 => Ok(PacketEntityEventEventID::UseItem),
            10 => Ok(PacketEntityEventEventID::EatGrassAnimation),
            11 => Ok(PacketEntityEventEventID::FishHookBubble),
            12 => Ok(PacketEntityEventEventID::FishHookPosition),
            13 => Ok(PacketEntityEventEventID::FishHookHook),
            14 => Ok(PacketEntityEventEventID::FishHookTease),
            15 => Ok(PacketEntityEventEventID::SquidInkCloud),
            16 => Ok(PacketEntityEventEventID::ZombieVillagerCure),
            18 => Ok(PacketEntityEventEventID::Respawn),
            19 => Ok(PacketEntityEventEventID::IronGolemOfferFlower),
            20 => Ok(PacketEntityEventEventID::IronGolemWithdrawFlower),
            21 => Ok(PacketEntityEventEventID::LoveParticles),
            22 => Ok(PacketEntityEventEventID::VillagerAngry),
            23 => Ok(PacketEntityEventEventID::VillagerHappy),
            24 => Ok(PacketEntityEventEventID::WitchSpellParticles),
            25 => Ok(PacketEntityEventEventID::FireworkParticles),
            26 => Ok(PacketEntityEventEventID::InLoveParticles),
            27 => Ok(PacketEntityEventEventID::SilverfishSpawnAnimation),
            28 => Ok(PacketEntityEventEventID::GuardianAttack),
            29 => Ok(PacketEntityEventEventID::WitchDrinkPotion),
            30 => Ok(PacketEntityEventEventID::WitchThrowPotion),
            31 => Ok(PacketEntityEventEventID::MinecartTntPrimeFuse),
            32 => Ok(PacketEntityEventEventID::CreeperPrimeFuse),
            33 => Ok(PacketEntityEventEventID::AirSupplyExpired),
            34 => Ok(PacketEntityEventEventID::PlayerAddXpLevels),
            35 => Ok(PacketEntityEventEventID::ElderGuardianCurse),
            36 => Ok(PacketEntityEventEventID::AgentArmSwing),
            37 => Ok(PacketEntityEventEventID::EnderDragonDeath),
            38 => Ok(PacketEntityEventEventID::DustParticles),
            39 => Ok(PacketEntityEventEventID::ArrowShake),
            57 => Ok(PacketEntityEventEventID::EatingItem),
            60 => Ok(PacketEntityEventEventID::BabyAnimalFeed),
            61 => Ok(PacketEntityEventEventID::DeathSmokeCloud),
            62 => Ok(PacketEntityEventEventID::CompleteTrade),
            63 => Ok(PacketEntityEventEventID::RemoveLeash),
            64 => Ok(PacketEntityEventEventID::Caravan),
            65 => Ok(PacketEntityEventEventID::ConsumeTotem),
            66 => Ok(PacketEntityEventEventID::PlayerCheckTreasureHunterAchievement),
            67 => Ok(PacketEntityEventEventID::EntitySpawn),
            68 => Ok(PacketEntityEventEventID::DragonPuke),
            69 => Ok(PacketEntityEventEventID::ItemEntityMerge),
            70 => Ok(PacketEntityEventEventID::StartSwim),
            71 => Ok(PacketEntityEventEventID::BalloonPop),
            72 => Ok(PacketEntityEventEventID::TreasureHunt),
            73 => Ok(PacketEntityEventEventID::AgentSummon),
            74 => Ok(PacketEntityEventEventID::ChargedItem),
            75 => Ok(PacketEntityEventEventID::Fall),
            76 => Ok(PacketEntityEventEventID::GrowUp),
            77 => Ok(PacketEntityEventEventID::VibrationDetected),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEntityEventEventID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i64,
    pub event_id: PacketEntityEventEventID,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketEntityEventEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnParticleEffect {
    pub dimension: u8,
    pub entity_id: crate::bedrock::codec::ZigZag64,
    pub position: Vec3F,
    pub particle_name: String,
    pub molang_variables: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnParticleEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension.encode(buf)?;
        self.entity_id.encode(buf)?;
        self.position.encode(buf)?;
        self.particle_name.encode(buf)?;
        match &self.molang_variables {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let particle_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let molang_variables = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            dimension,
            entity_id,
            position,
            particle_name,
            molang_variables,
        })
    }
}
