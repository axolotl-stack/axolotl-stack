// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ContainerSlotType {
    AnvilInput = 0,
    AnvilMaterial = 1,
    AnvilResult = 2,
    SmithingTableInput = 3,
    SmithingTableMaterial = 4,
    SmithingTableResult = 5,
    Armor = 6,
    Container = 7,
    BeaconPayment = 8,
    BrewingInput = 9,
    BrewingResult = 10,
    BrewingFuel = 11,
    HotbarAndInventory = 12,
    CraftingInput = 13,
    CraftingOutput = 14,
    RecipeConstruction = 15,
    RecipeNature = 16,
    RecipeItems = 17,
    RecipeSearch = 18,
    RecipeSearchBar = 19,
    RecipeEquipment = 20,
    RecipeBook = 21,
    EnchantingInput = 22,
    EnchantingLapis = 23,
    FurnaceFuel = 24,
    FurnaceIngredient = 25,
    FurnaceOutput = 26,
    HorseEquip = 27,
    Hotbar = 28,
    Inventory = 29,
    Shulker = 30,
    TradeIngredient1 = 31,
    TradeIngredient2 = 32,
    TradeResult = 33,
    Offhand = 34,
    CompcreateInput = 35,
    CompcreateOutput = 36,
    ElemconstructOutput = 37,
    MatreduceInput = 38,
    MatreduceOutput = 39,
    LabtableInput = 40,
    LoomInput = 41,
    LoomDye = 42,
    LoomMaterial = 43,
    LoomResult = 44,
    BlastFurnaceIngredient = 45,
    SmokerIngredient = 46,
    Trade2Ingredient1 = 47,
    Trade2Ingredient2 = 48,
    Trade2Result = 49,
    GrindstoneInput = 50,
    GrindstoneAdditional = 51,
    GrindstoneResult = 52,
    StonecutterInput = 53,
    StonecutterResult = 54,
    CartographyInput = 55,
    CartographyAdditional = 56,
    CartographyResult = 57,
    Barrel = 58,
    Cursor = 59,
    CreativeOutput = 60,
    SmithingTableTemplate = 61,
    Crafter = 62,
    Dynamic = 63,
    Registry = 64,
}
impl crate::bedrock::codec::BedrockCodec for ContainerSlotType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ContainerSlotType::AnvilInput),
            1 => Ok(ContainerSlotType::AnvilMaterial),
            2 => Ok(ContainerSlotType::AnvilResult),
            3 => Ok(ContainerSlotType::SmithingTableInput),
            4 => Ok(ContainerSlotType::SmithingTableMaterial),
            5 => Ok(ContainerSlotType::SmithingTableResult),
            6 => Ok(ContainerSlotType::Armor),
            7 => Ok(ContainerSlotType::Container),
            8 => Ok(ContainerSlotType::BeaconPayment),
            9 => Ok(ContainerSlotType::BrewingInput),
            10 => Ok(ContainerSlotType::BrewingResult),
            11 => Ok(ContainerSlotType::BrewingFuel),
            12 => Ok(ContainerSlotType::HotbarAndInventory),
            13 => Ok(ContainerSlotType::CraftingInput),
            14 => Ok(ContainerSlotType::CraftingOutput),
            15 => Ok(ContainerSlotType::RecipeConstruction),
            16 => Ok(ContainerSlotType::RecipeNature),
            17 => Ok(ContainerSlotType::RecipeItems),
            18 => Ok(ContainerSlotType::RecipeSearch),
            19 => Ok(ContainerSlotType::RecipeSearchBar),
            20 => Ok(ContainerSlotType::RecipeEquipment),
            21 => Ok(ContainerSlotType::RecipeBook),
            22 => Ok(ContainerSlotType::EnchantingInput),
            23 => Ok(ContainerSlotType::EnchantingLapis),
            24 => Ok(ContainerSlotType::FurnaceFuel),
            25 => Ok(ContainerSlotType::FurnaceIngredient),
            26 => Ok(ContainerSlotType::FurnaceOutput),
            27 => Ok(ContainerSlotType::HorseEquip),
            28 => Ok(ContainerSlotType::Hotbar),
            29 => Ok(ContainerSlotType::Inventory),
            30 => Ok(ContainerSlotType::Shulker),
            31 => Ok(ContainerSlotType::TradeIngredient1),
            32 => Ok(ContainerSlotType::TradeIngredient2),
            33 => Ok(ContainerSlotType::TradeResult),
            34 => Ok(ContainerSlotType::Offhand),
            35 => Ok(ContainerSlotType::CompcreateInput),
            36 => Ok(ContainerSlotType::CompcreateOutput),
            37 => Ok(ContainerSlotType::ElemconstructOutput),
            38 => Ok(ContainerSlotType::MatreduceInput),
            39 => Ok(ContainerSlotType::MatreduceOutput),
            40 => Ok(ContainerSlotType::LabtableInput),
            41 => Ok(ContainerSlotType::LoomInput),
            42 => Ok(ContainerSlotType::LoomDye),
            43 => Ok(ContainerSlotType::LoomMaterial),
            44 => Ok(ContainerSlotType::LoomResult),
            45 => Ok(ContainerSlotType::BlastFurnaceIngredient),
            46 => Ok(ContainerSlotType::SmokerIngredient),
            47 => Ok(ContainerSlotType::Trade2Ingredient1),
            48 => Ok(ContainerSlotType::Trade2Ingredient2),
            49 => Ok(ContainerSlotType::Trade2Result),
            50 => Ok(ContainerSlotType::GrindstoneInput),
            51 => Ok(ContainerSlotType::GrindstoneAdditional),
            52 => Ok(ContainerSlotType::GrindstoneResult),
            53 => Ok(ContainerSlotType::StonecutterInput),
            54 => Ok(ContainerSlotType::StonecutterResult),
            55 => Ok(ContainerSlotType::CartographyInput),
            56 => Ok(ContainerSlotType::CartographyAdditional),
            57 => Ok(ContainerSlotType::CartographyResult),
            58 => Ok(ContainerSlotType::Barrel),
            59 => Ok(ContainerSlotType::Cursor),
            60 => Ok(ContainerSlotType::CreativeOutput),
            61 => Ok(ContainerSlotType::SmithingTableTemplate),
            62 => Ok(ContainerSlotType::Crafter),
            63 => Ok(ContainerSlotType::Dynamic),
            64 => Ok(ContainerSlotType::Registry),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ContainerSlotType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct FullContainerName {
    pub container_id: ContainerSlotType,
    pub dynamic_container_id: Option<u32>,
}
impl crate::bedrock::codec::BedrockCodec for FullContainerName {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        match &self.dynamic_container_id {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let container_id = <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dynamic_container_id = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            container_id,
            dynamic_container_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftCreative {
    pub item_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftCreative {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.item_id.encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let item_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { item_id, times_crafted })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftGrindstoneRequest {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
    pub cost: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftGrindstoneRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.times_crafted.encode(buf)?;
        self.cost.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let cost = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
            cost,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftLoomRequest {
    pub pattern: String,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftLoomRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pattern.encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pattern = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { pattern, times_crafted })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipe {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipe {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipeAuto {
    pub recipe_network_id: i32,
    pub times_crafted_2: u8,
    pub times_crafted: u8,
    pub ingredients: Vec<RecipeIngredient>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipeAuto {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.times_crafted_2.encode(buf)?;
        self.times_crafted.encode(buf)?;
        let len = self.ingredients.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.ingredients {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let times_crafted_2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ingredients = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            recipe_network_id,
            times_crafted_2,
            times_crafted,
            ingredients,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftGrindstoneRequest(ItemStackRequestActionsItemContentCraftGrindstoneRequest),
    CraftLoomRequest(ItemStackRequestActionsItemContentCraftLoomRequest),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(Box<ItemStackRequestActionsItemContentCraftRecipeAuto>),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    PlaceInContainer(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
    TakeOutContainer(ItemStackRequestActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeID,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Consume(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftCreative(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftGrindstoneRequest(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::CraftLoomRequest(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipe(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Create(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Destroy(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Drop(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::MineBlock(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Place(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::PlaceInContainer(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::Swap(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Take(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::TakeOutContainer(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestActionsItemTypeID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_id {
            ItemStackRequestActionsItemTypeID::BeaconPayment => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Consume => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftCreative => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftGrindstoneRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftGrindstoneRequest(
                        <ItemStackRequestActionsItemContentCraftGrindstoneRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftLoomRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftLoomRequest(
                        <ItemStackRequestActionsItemContentCraftLoomRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftRecipe => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftRecipeAuto => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        Box::new(
                            <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Create => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Destroy => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Drop => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::MineBlock => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::NonImplemented => {
                Some(ItemStackRequestActionsItemContent::NonImplemented)
            }
            ItemStackRequestActionsItemTypeID::Optional => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Place => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::PlaceInContainer => {
                Some(
                    ItemStackRequestActionsItemContent::PlaceInContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::ResultsDeprecated => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Swap => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Take => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::TakeOutContainer => {
                Some(
                    ItemStackRequestActionsItemContent::TakeOutContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequest {
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
    pub cause: ItemStackRequestCause,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.custom_names {
            item.encode(buf)?;
        }
        self.cause.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let cause = <ItemStackRequestCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            request_id,
            actions,
            custom_names,
            cause,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSomeContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: crate::bedrock::codec::ZigZag32,
    pub custom_name: String,
    pub filtered_custom_name: String,
    pub durability_correction: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentSomeContainersItemSlotsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        self.item_stack_id.encode(buf)?;
        self.custom_name.encode(buf)?;
        self.filtered_custom_name.encode(buf)?;
        self.durability_correction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item_stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let filtered_custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let durability_correction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
            filtered_custom_name,
            durability_correction,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSomeContainersItem {
    pub slot_type: FullContainerName,
    pub slots: Vec<ItemStackResponsesItemContentSomeContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentSomeContainersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_type.encode(buf)?;
        let len = self.slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot_type = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slots = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { slot_type, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSome {
    pub containers: Vec<ItemStackResponsesItemContentSomeContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContentSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let containers = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { containers })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub status: ItemStackResponsesItemStatus,
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub content: Option<ItemStackResponsesItemContentSome>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let status = <ItemStackResponsesItemStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match status {
            ItemStackResponsesItemStatus::Ok => {
                Some(
                    <ItemStackResponsesItemContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            status,
            request_id,
            content,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ItemstatesItemVersion {
    Legacy = 0,
    DataDriven = 1,
    None = 2,
}
impl crate::bedrock::codec::BedrockCodec for ItemstatesItemVersion {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ItemstatesItemVersion::Legacy),
            1 => Ok(ItemstatesItemVersion::DataDriven),
            2 => Ok(ItemstatesItemVersion::None),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemstatesItemVersion), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemstatesItem {
    pub name: String,
    pub runtime_id: i16,
    pub component_based: bool,
    pub version: ItemstatesItemVersion,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemstatesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.runtime_id.encode(buf)?;
        self.component_based.encode(buf)?;
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let runtime_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let component_based = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let version = <ItemstatesItemVersion as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            name,
            runtime_id,
            component_based,
            version,
            nbt,
        })
    }
}
pub type Itemstates = Vec<ItemstatesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Flags = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    HorseType = 19,
    CreeperSwell = 20,
    CreeperSwellDirection = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeID = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinID = 40,
    URLTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    WitherAerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    RiderSeatRotationOffset = 60,
    AreaEffectCloudRadius = 61,
    AreaEffectCloudWaiting = 62,
    AreaEffectCloudParticleID = 63,
    ShulkerPeekID = 64,
    ShulkerAttachFace = 65,
    ShulkerAttached = 66,
    ShulkerAttachPos = 67,
    TradingPlayerEid = 68,
    TradingCareer = 69,
    HasCommandBlock = 70,
    CommandBlockCommand = 71,
    CommandBlockLastOutput = 72,
    CommandBlockTrackOutput = 73,
    ControllingRiderSeatNumber = 74,
    Strength = 75,
    MaxStrength = 76,
    EvokerSpellCastingColor = 77,
    LimitedLife = 78,
    ArmorStandPoseIndex = 79,
    EnderCrystalTimeOffset = 80,
    AlwaysShowNametag = 81,
    Color2 = 82,
    NameAuthor = 83,
    ScoreTag = 84,
    BalloonAttachedEntity = 85,
    PufferfishSize = 86,
    BubbleTime = 87,
    Agent = 88,
    SittingAmount = 89,
    SittingAmountPrevious = 90,
    EatingCounter = 91,
    FlagsExtended = 92,
    LayingAmount = 93,
    LayingAmountPrevious = 94,
    AreaEffectCloudDuration = 95,
    AreaEffectCloudSpawnTime = 96,
    AreaEffectCloudChangeRate = 97,
    AreaEffectCloudChangeOnPickup = 98,
    AreaEffectCloudPickupCount = 99,
    InteractText = 100,
    TradeTier = 101,
    MaxTradeTier = 102,
    TradeExperience = 103,
    SkinID = 104,
    SpawningFrames = 105,
    CommandBlockTickDelay = 106,
    CommandBlockExecuteOnFirstTick = 107,
    AmbientSoundInterval = 108,
    AmbientSoundIntervalRange = 109,
    AmbientSoundEventName = 110,
    FallDamageMultiplier = 111,
    NameRawText = 112,
    CanRideTarget = 113,
    LowTierCuredDiscount = 114,
    HighTierCuredDiscount = 115,
    NearbyCuredDiscount = 116,
    NearbyCuredDiscountTimestamp = 117,
    Hitbox = 118,
    IsBuoyant = 119,
    FreezingEffectStrength = 120,
    BuoyancyData = 121,
    GoatHornCount = 122,
    UpdateProperties = 123,
    MovementSoundDistanceOffset = 124,
    HeartbeatIntervalTicks = 125,
    HeartbeatSoundEvent = 126,
    PlayerLastDeathPosition = 127,
    PlayerLastDeathDimension = 128,
    PlayerHasDied = 129,
    CollisionBox = 130,
    VisibleMobEffects = 131,
    FilteredName = 132,
    BedEnterPosition = 133,
    SeatThirdPersonCameraRadius = 134,
    SeatCameraRelaxDistanceSmoothing = 135,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Flags),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            19 => Ok(MetadataDictionaryItemKey::HorseType),
            20 => Ok(MetadataDictionaryItemKey::CreeperSwell),
            21 => Ok(MetadataDictionaryItemKey::CreeperSwellDirection),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeID),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinID),
            41 => Ok(MetadataDictionaryItemKey::URLTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::WitherAerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::RiderSeatRotationOffset),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            63 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleID),
            64 => Ok(MetadataDictionaryItemKey::ShulkerPeekID),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            67 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            68 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            69 => Ok(MetadataDictionaryItemKey::TradingCareer),
            70 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            73 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            74 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            75 => Ok(MetadataDictionaryItemKey::Strength),
            76 => Ok(MetadataDictionaryItemKey::MaxStrength),
            77 => Ok(MetadataDictionaryItemKey::EvokerSpellCastingColor),
            78 => Ok(MetadataDictionaryItemKey::LimitedLife),
            79 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            80 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            81 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            82 => Ok(MetadataDictionaryItemKey::Color2),
            83 => Ok(MetadataDictionaryItemKey::NameAuthor),
            84 => Ok(MetadataDictionaryItemKey::ScoreTag),
            85 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            86 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            87 => Ok(MetadataDictionaryItemKey::BubbleTime),
            88 => Ok(MetadataDictionaryItemKey::Agent),
            89 => Ok(MetadataDictionaryItemKey::SittingAmount),
            90 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            91 => Ok(MetadataDictionaryItemKey::EatingCounter),
            92 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            93 => Ok(MetadataDictionaryItemKey::LayingAmount),
            94 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            95 => Ok(MetadataDictionaryItemKey::AreaEffectCloudDuration),
            96 => Ok(MetadataDictionaryItemKey::AreaEffectCloudSpawnTime),
            97 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeRate),
            98 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeOnPickup),
            99 => Ok(MetadataDictionaryItemKey::AreaEffectCloudPickupCount),
            100 => Ok(MetadataDictionaryItemKey::InteractText),
            101 => Ok(MetadataDictionaryItemKey::TradeTier),
            102 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            103 => Ok(MetadataDictionaryItemKey::TradeExperience),
            104 => Ok(MetadataDictionaryItemKey::SkinID),
            105 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            107 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            110 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            111 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            112 => Ok(MetadataDictionaryItemKey::NameRawText),
            113 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            114 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            117 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            118 => Ok(MetadataDictionaryItemKey::Hitbox),
            119 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            120 => Ok(MetadataDictionaryItemKey::FreezingEffectStrength),
            121 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            122 => Ok(MetadataDictionaryItemKey::GoatHornCount),
            123 => Ok(MetadataDictionaryItemKey::UpdateProperties),
            124 => Ok(MetadataDictionaryItemKey::MovementSoundDistanceOffset),
            125 => Ok(MetadataDictionaryItemKey::HeartbeatIntervalTicks),
            126 => Ok(MetadataDictionaryItemKey::HeartbeatSoundEvent),
            127 => Ok(MetadataDictionaryItemKey::PlayerLastDeathPosition),
            128 => Ok(MetadataDictionaryItemKey::PlayerLastDeathDimension),
            129 => Ok(MetadataDictionaryItemKey::PlayerHasDied),
            130 => Ok(MetadataDictionaryItemKey::CollisionBox),
            131 => Ok(MetadataDictionaryItemKey::VisibleMobEffects),
            132 => Ok(MetadataDictionaryItemKey::FilteredName),
            133 => Ok(MetadataDictionaryItemKey::BedEnterPosition),
            134 => Ok(MetadataDictionaryItemKey::SeatThirdPersonCameraRadius),
            135 => Ok(MetadataDictionaryItemKey::SeatCameraRelaxDistanceSmoothing),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Default(Box<Option<MetadataDictionaryItemValueDefault>>),
    Flags(MetadataFlags1),
    FlagsExtended(MetadataFlags2),
    SeatCameraRelaxDistanceSmoothing(f32),
    SeatThirdPersonCameraRadius(f32),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: MetadataDictionaryItemValue,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        match &self.value {
            MetadataDictionaryItemValue::Flags(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::FlagsExtended(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::SeatCameraRelaxDistanceSmoothing(v) => {
                v.encode(buf)?
            }
            MetadataDictionaryItemValue::SeatThirdPersonCameraRadius(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::Default(v) => v.encode(buf)?,
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value = match key {
            MetadataDictionaryItemKey::Flags => {
                MetadataDictionaryItemValue::Flags(
                    <MetadataFlags1 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            MetadataDictionaryItemKey::FlagsExtended => {
                MetadataDictionaryItemValue::FlagsExtended(
                    <MetadataFlags2 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            MetadataDictionaryItemKey::SeatCameraRelaxDistanceSmoothing => {
                MetadataDictionaryItemValue::SeatCameraRelaxDistanceSmoothing(
                    <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            MetadataDictionaryItemKey::SeatThirdPersonCameraRadius => {
                MetadataDictionaryItemValue::SeatThirdPersonCameraRadius(
                    <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::Default(
                    Box::new(
                        match type_ {
                            MetadataDictionaryItemType::Byte => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Byte(
                                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Compound => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Compound(
                                        <Vec<
                                            u8,
                                        > as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Float => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Float(
                                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Int => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Int(
                                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Long => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Long(
                                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Short => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Short(
                                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::String => {
                                Some(
                                    MetadataDictionaryItemValueDefault::String(
                                        <String as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3F => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3F(
                                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3I => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3I(
                                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionUseItemTriggerType {
    Unknown = 0,
    PlayerInput = 1,
    SimulationTick = 2,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItemTriggerType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionUseItemTriggerType::Unknown),
            1 => Ok(TransactionUseItemTriggerType::PlayerInput),
            2 => Ok(TransactionUseItemTriggerType::SimulationTick),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionUseItemTriggerType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionUseItemClientPrediction {
    Failure = 0,
    Success = 1,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItemClientPrediction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionUseItemClientPrediction::Failure),
            1 => Ok(TransactionUseItemClientPrediction::Success),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionUseItemClientPrediction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionUseItem {
    pub action_type: TransactionUseItemActionType,
    pub trigger_type: TransactionUseItemTriggerType,
    pub block_position: BlockCoordinates,
    pub face: crate::bedrock::codec::ZigZag32,
    pub hotbar_slot: crate::bedrock::codec::ZigZag32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
    pub block_runtime_id: i32,
    pub client_prediction: TransactionUseItemClientPrediction,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.trigger_type.encode(buf)?;
        self.block_position.encode(buf)?;
        self.face.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        self.client_prediction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_type = <TransactionUseItemActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let trigger_type = <TransactionUseItemTriggerType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let client_prediction = <TransactionUseItemClientPrediction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            action_type,
            trigger_type,
            block_position,
            face,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
            block_runtime_id,
            client_prediction,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerRegistryCleanup {
    pub removed_containers: Vec<FullContainerName>,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerRegistryCleanup {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.removed_containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.removed_containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let removed_containers = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { removed_containers })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCreativeContentGroupsItemCategory {
    All = 0,
    Construction = 1,
    Nature = 2,
    Equipment = 3,
    Items = 4,
    ItemCommandOnly = 5,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContentGroupsItemCategory {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCreativeContentGroupsItemCategory::All),
            1 => Ok(PacketCreativeContentGroupsItemCategory::Construction),
            2 => Ok(PacketCreativeContentGroupsItemCategory::Nature),
            3 => Ok(PacketCreativeContentGroupsItemCategory::Equipment),
            4 => Ok(PacketCreativeContentGroupsItemCategory::Items),
            5 => Ok(PacketCreativeContentGroupsItemCategory::ItemCommandOnly),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCreativeContentGroupsItemCategory), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContentGroupsItem {
    pub category: PacketCreativeContentGroupsItemCategory,
    pub name: String,
    pub icon_item: ItemLegacy,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContentGroupsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.category.encode(buf)?;
        self.name.encode(buf)?;
        self.icon_item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let category = <PacketCreativeContentGroupsItemCategory as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let icon_item = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { category, name, icon_item })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContentItemsItem {
    pub entry_id: i32,
    pub item: ItemLegacy,
    pub group_index: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContentItemsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entry_id.encode(buf)?;
        self.item.encode(buf)?;
        self.group_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entry_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let group_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entry_id,
            item,
            group_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryContent {
    pub window_id: WindowIDVarint,
    pub input: ItemStacks,
    pub container: FullContainerName,
    pub storage_item: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.input.encode(buf)?;
        self.container.encode(buf)?;
        self.storage_item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = <ItemStacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let container = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let storage_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            window_id,
            input,
            container,
            storage_item,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventorySlot {
    pub window_id: WindowIDVarint,
    pub slot: i32,
    pub container: FullContainerName,
    pub storage_item: Item,
    pub item: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventorySlot {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.slot.encode(buf)?;
        self.container.encode(buf)?;
        self.storage_item.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let container = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let storage_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            window_id,
            slot,
            container,
            storage_item,
            item,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemRegistry {
    pub itemstates: Itemstates,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemRegistry {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.itemstates.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let itemstates = <Itemstates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { itemstates })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketServerScriptDebugDrawerShapesItemShapeTypeSome {
    Line = 0,
    Box = 1,
    Sphere = 2,
    Circle = 3,
    Text = 4,
    Arrow = 5,
}
impl crate::bedrock::codec::BedrockCodec
for PacketServerScriptDebugDrawerShapesItemShapeTypeSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketServerScriptDebugDrawerShapesItemShapeTypeSome::Line),
            1 => Ok(PacketServerScriptDebugDrawerShapesItemShapeTypeSome::Box),
            2 => Ok(PacketServerScriptDebugDrawerShapesItemShapeTypeSome::Sphere),
            3 => Ok(PacketServerScriptDebugDrawerShapesItemShapeTypeSome::Circle),
            4 => Ok(PacketServerScriptDebugDrawerShapesItemShapeTypeSome::Text),
            5 => Ok(PacketServerScriptDebugDrawerShapesItemShapeTypeSome::Arrow),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketServerScriptDebugDrawerShapesItemShapeTypeSome),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerScriptDebugDrawerShapesItem {
    pub network_id: i64,
    pub shape_type: Option<PacketServerScriptDebugDrawerShapesItemShapeTypeSome>,
    pub location: Option<Vec3F>,
    pub scale: Option<f32>,
    pub rotation: Option<Vec3F>,
    pub time_left: Option<f32>,
    pub color: Option<i32>,
    pub text: Option<String>,
    pub box_bound: Option<Vec3F>,
    pub line_end_location: Option<Vec3F>,
    pub arrow_head_length: Option<f32>,
    pub arrow_head_radius: Option<f32>,
    pub segment_count: Option<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerScriptDebugDrawerShapesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.network_id.encode(buf)?;
        match &self.shape_type {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.location {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.scale {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.rotation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.time_left {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.color {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.text {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.box_bound {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.line_end_location {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.arrow_head_length {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.arrow_head_radius {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.segment_count {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let shape_type = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketServerScriptDebugDrawerShapesItemShapeTypeSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let location = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let scale = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let rotation = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let time_left = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let color = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let text = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let box_bound = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let line_end_location = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let arrow_head_length = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let arrow_head_radius = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let segment_count = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            network_id,
            shape_type,
            location,
            scale,
            rotation,
            time_left,
            color,
            text,
            box_bound,
            line_end_location,
            arrow_head_length,
            arrow_head_radius,
            segment_count,
        })
    }
}
