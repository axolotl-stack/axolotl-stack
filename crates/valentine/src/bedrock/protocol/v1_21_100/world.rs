// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeCappedSurface {
    pub floor_blocks: Vec<i32>,
    pub ceiling_blocks: Vec<i32>,
    pub sea_block: Option<u32>,
    pub foundation_block: Option<u32>,
    pub beach_block: Option<u32>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeCappedSurface {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.floor_blocks.len() as i32;
        len.encode(buf)?;
        for item in &self.floor_blocks {
            item.encode(buf)?;
        }
        let len = self.ceiling_blocks.len() as i32;
        len.encode(buf)?;
        for item in &self.ceiling_blocks {
            item.encode(buf)?;
        }
        match &self.sea_block {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.foundation_block {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.beach_block {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let floor_blocks = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let ceiling_blocks = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let sea_block = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let foundation_block = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let beach_block = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            floor_blocks,
            ceiling_blocks,
            sea_block,
            foundation_block,
            beach_block,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeClimate {
    pub temperature: f32,
    pub downfall: f32,
    pub red_spore_density: f32,
    pub blue_spore_density: f32,
    pub ash_density: f32,
    pub white_ash_density: f32,
    pub snow_accumulation_min: f32,
    pub snow_accumulation_max: f32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeClimate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.temperature.encode(buf)?;
        self.downfall.encode(buf)?;
        self.red_spore_density.encode(buf)?;
        self.blue_spore_density.encode(buf)?;
        self.ash_density.encode(buf)?;
        self.white_ash_density.encode(buf)?;
        self.snow_accumulation_min.encode(buf)?;
        self.snow_accumulation_max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let temperature = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let downfall = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let red_spore_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let blue_spore_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let ash_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let white_ash_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let snow_accumulation_min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let snow_accumulation_max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            temperature,
            downfall,
            red_spore_density,
            blue_spore_density,
            ash_density,
            white_ash_density,
            snow_accumulation_min,
            snow_accumulation_max,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BiomeCoordinateDistribution {
    SingleValued = 0,
    Uniform = 1,
    Gaussian = 2,
    InverseGaussian = 3,
    FixedGrid = 4,
    JitteredGrid = 5,
    Triangle = 6,
}
impl crate::bedrock::codec::BedrockCodec for BiomeCoordinateDistribution {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(BiomeCoordinateDistribution::SingleValued),
            1 => Ok(BiomeCoordinateDistribution::Uniform),
            2 => Ok(BiomeCoordinateDistribution::Gaussian),
            3 => Ok(BiomeCoordinateDistribution::InverseGaussian),
            4 => Ok(BiomeCoordinateDistribution::FixedGrid),
            5 => Ok(BiomeCoordinateDistribution::JitteredGrid),
            6 => Ok(BiomeCoordinateDistribution::Triangle),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(BiomeCoordinateDistribution), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeCoordinate {
    pub min_value_type: crate::bedrock::codec::ZigZag32,
    pub min_value: i16,
    pub max_value_type: crate::bedrock::codec::ZigZag32,
    pub max_value: i16,
    pub grid_offset: u32,
    pub grid_step_size: u32,
    pub distribution: BiomeCoordinateDistribution,
}
impl crate::bedrock::codec::BedrockCodec for BiomeCoordinate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.min_value_type.encode(buf)?;
        self.min_value.encode(buf)?;
        self.max_value_type.encode(buf)?;
        self.max_value.encode(buf)?;
        self.grid_offset.encode(buf)?;
        self.grid_step_size.encode(buf)?;
        self.distribution.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let min_value_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let min_value = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let max_value_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let max_value = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let grid_offset = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let grid_step_size = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let distribution = <BiomeCoordinateDistribution as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            min_value_type,
            min_value,
            max_value_type,
            max_value,
            grid_offset,
            grid_step_size,
            distribution,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BiomeScatterParameterEvaluationOrder {
    Xyz = 0,
    Xzy = 1,
    Yxz = 2,
    Yzx = 3,
    Zxy = 4,
    Zyx = 5,
}
impl crate::bedrock::codec::BedrockCodec for BiomeScatterParameterEvaluationOrder {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(BiomeScatterParameterEvaluationOrder::Xyz),
            1 => Ok(BiomeScatterParameterEvaluationOrder::Xzy),
            2 => Ok(BiomeScatterParameterEvaluationOrder::Yxz),
            3 => Ok(BiomeScatterParameterEvaluationOrder::Yzx),
            4 => Ok(BiomeScatterParameterEvaluationOrder::Zxy),
            5 => Ok(BiomeScatterParameterEvaluationOrder::Zyx),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(BiomeScatterParameterEvaluationOrder), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeScatterParameter {
    pub coordinates: Vec<BiomeCoordinate>,
    pub evaluation_order: BiomeScatterParameterEvaluationOrder,
    pub chance_percent_type: crate::bedrock::codec::ZigZag32,
    pub chance_percent: i16,
    pub chance_numerator: i32,
    pub chance_denominator: i32,
    pub iterations_type: crate::bedrock::codec::ZigZag32,
    pub iterations: i16,
}
impl crate::bedrock::codec::BedrockCodec for BiomeScatterParameter {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.coordinates.len() as i32;
        len.encode(buf)?;
        for item in &self.coordinates {
            item.encode(buf)?;
        }
        self.evaluation_order.encode(buf)?;
        self.chance_percent_type.encode(buf)?;
        self.chance_percent.encode(buf)?;
        self.chance_numerator.encode(buf)?;
        self.chance_denominator.encode(buf)?;
        self.iterations_type.encode(buf)?;
        self.iterations.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let coordinates = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeCoordinate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let evaluation_order = <BiomeScatterParameterEvaluationOrder as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let chance_percent_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let chance_percent = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chance_numerator = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let chance_denominator = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let iterations_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let iterations = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            coordinates,
            evaluation_order,
            chance_percent_type,
            chance_percent,
            chance_numerator,
            chance_denominator,
            iterations_type,
            iterations,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeConsolidatedFeature {
    pub scatter: BiomeScatterParameter,
    pub feature: i16,
    pub identifier: i16,
    pub pass: i16,
    pub can_use_internal: bool,
}
impl crate::bedrock::codec::BedrockCodec for BiomeConsolidatedFeature {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.scatter.encode(buf)?;
        self.feature.encode(buf)?;
        self.identifier.encode(buf)?;
        self.pass.encode(buf)?;
        self.can_use_internal.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let scatter = <BiomeScatterParameter as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let feature = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let identifier = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pass = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let can_use_internal = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            scatter,
            feature,
            identifier,
            pass,
            can_use_internal,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeMountainParameters {
    pub steep_block: i32,
    pub north_slopes: bool,
    pub south_slopes: bool,
    pub west_slopes: bool,
    pub east_slopes: bool,
    pub top_slide_enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for BiomeMountainParameters {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.steep_block.encode(buf)?;
        self.north_slopes.encode(buf)?;
        self.south_slopes.encode(buf)?;
        self.west_slopes.encode(buf)?;
        self.east_slopes.encode(buf)?;
        self.top_slide_enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let steep_block = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let north_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let south_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let west_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let east_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let top_slide_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            steep_block,
            north_slopes,
            south_slopes,
            west_slopes,
            east_slopes,
            top_slide_enabled,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeSurfaceMaterial {
    pub top_block: i32,
    pub mid_block: i32,
    pub sea_floor_block: i32,
    pub foundation_block: i32,
    pub sea_block: i32,
    pub sea_floor_depth: i32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeSurfaceMaterial {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.top_block.encode(buf)?;
        self.mid_block.encode(buf)?;
        self.sea_floor_block.encode(buf)?;
        self.foundation_block.encode(buf)?;
        self.sea_block.encode(buf)?;
        self.sea_floor_depth.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let top_block = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let mid_block = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let sea_floor_block = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let foundation_block = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let sea_block = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let sea_floor_depth = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            top_block,
            mid_block,
            sea_floor_block,
            foundation_block,
            sea_block,
            sea_floor_depth,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeElementData {
    pub noise_frequency_scale: f32,
    pub noise_lower_bound: f32,
    pub noise_upper_bound: f32,
    pub height_min_type: crate::bedrock::codec::ZigZag32,
    pub height_min: i16,
    pub height_max_type: crate::bedrock::codec::ZigZag32,
    pub height_max: i16,
    pub adjusted_materials: BiomeSurfaceMaterial,
}
impl crate::bedrock::codec::BedrockCodec for BiomeElementData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.noise_frequency_scale.encode(buf)?;
        self.noise_lower_bound.encode(buf)?;
        self.noise_upper_bound.encode(buf)?;
        self.height_min_type.encode(buf)?;
        self.height_min.encode(buf)?;
        self.height_max_type.encode(buf)?;
        self.height_max.encode(buf)?;
        self.adjusted_materials.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let noise_frequency_scale = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let noise_lower_bound = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let noise_upper_bound = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let height_min_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let height_min = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let height_max_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let height_max = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let adjusted_materials = <BiomeSurfaceMaterial as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            noise_frequency_scale,
            noise_lower_bound,
            noise_upper_bound,
            height_min_type,
            height_min,
            height_max_type,
            height_max,
            adjusted_materials,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeMesaSurface {
    pub clay_material: u32,
    pub hard_clay_material: u32,
    pub bryce_pillars: bool,
    pub has_forest: bool,
}
impl crate::bedrock::codec::BedrockCodec for BiomeMesaSurface {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.clay_material.encode(buf)?;
        self.hard_clay_material.encode(buf)?;
        self.bryce_pillars.encode(buf)?;
        self.has_forest.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let clay_material = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hard_clay_material = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let bryce_pillars = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let has_forest = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            clay_material,
            hard_clay_material,
            bryce_pillars,
            has_forest,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeWeight {
    pub biome: i16,
    pub weight: u32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeWeight {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.biome.encode(buf)?;
        self.weight.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let biome = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let weight = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { biome, weight })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeConditionalTransformation {
    pub weighted_biomes: Vec<BiomeWeight>,
    pub condition_json: i16,
    pub min_passing_neighbours: u32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeConditionalTransformation {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.weighted_biomes.len() as i32;
        len.encode(buf)?;
        for item in &self.weighted_biomes {
            item.encode(buf)?;
        }
        self.condition_json.encode(buf)?;
        self.min_passing_neighbours.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let weighted_biomes = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let condition_json = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let min_passing_neighbours = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            weighted_biomes,
            condition_json,
            min_passing_neighbours,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeTemperatureWeight {
    pub temperature: crate::bedrock::codec::ZigZag32,
    pub weight: u32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeTemperatureWeight {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.temperature.encode(buf)?;
        self.weight.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let temperature = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let weight = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { temperature, weight })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeOverworldRules {
    pub hills_transformations: Vec<BiomeWeight>,
    pub mutate_transformations: Vec<BiomeWeight>,
    pub river_transformations: Vec<BiomeWeight>,
    pub shore_transformations: Vec<BiomeWeight>,
    pub pre_hills_edge_transformations: Vec<BiomeConditionalTransformation>,
    pub post_shore_edge_transformations: Vec<BiomeConditionalTransformation>,
    pub climate_transformations: Vec<BiomeTemperatureWeight>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeOverworldRules {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.hills_transformations.len() as i32;
        len.encode(buf)?;
        for item in &self.hills_transformations {
            item.encode(buf)?;
        }
        let len = self.mutate_transformations.len() as i32;
        len.encode(buf)?;
        for item in &self.mutate_transformations {
            item.encode(buf)?;
        }
        let len = self.river_transformations.len() as i32;
        len.encode(buf)?;
        for item in &self.river_transformations {
            item.encode(buf)?;
        }
        let len = self.shore_transformations.len() as i32;
        len.encode(buf)?;
        for item in &self.shore_transformations {
            item.encode(buf)?;
        }
        let len = self.pre_hills_edge_transformations.len() as i32;
        len.encode(buf)?;
        for item in &self.pre_hills_edge_transformations {
            item.encode(buf)?;
        }
        let len = self.post_shore_edge_transformations.len() as i32;
        len.encode(buf)?;
        for item in &self.post_shore_edge_transformations {
            item.encode(buf)?;
        }
        let len = self.climate_transformations.len() as i32;
        len.encode(buf)?;
        for item in &self.climate_transformations {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let hills_transformations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let mutate_transformations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let river_transformations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let shore_transformations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let pre_hills_edge_transformations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeConditionalTransformation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let post_shore_edge_transformations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeConditionalTransformation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let climate_transformations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeTemperatureWeight as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            hills_transformations,
            mutate_transformations,
            river_transformations,
            shore_transformations,
            pre_hills_edge_transformations,
            post_shore_edge_transformations,
            climate_transformations,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeMultiNoiseRules {
    pub temperature: f32,
    pub humidity: f32,
    pub altitude: f32,
    pub weirdness: f32,
    pub weight: f32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeMultiNoiseRules {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.temperature.encode(buf)?;
        self.humidity.encode(buf)?;
        self.altitude.encode(buf)?;
        self.weirdness.encode(buf)?;
        self.weight.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let temperature = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let humidity = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let altitude = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let weirdness = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let weight = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            temperature,
            humidity,
            altitude,
            weirdness,
            weight,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeChunkGeneration {
    pub climate: Option<BiomeClimate>,
    pub consolidated_features: Option<Vec<BiomeConsolidatedFeature>>,
    pub mountain_parameters: Option<BiomeMountainParameters>,
    pub surface_material_adjustments: Option<Vec<BiomeElementData>>,
    pub surface_materials: Option<BiomeSurfaceMaterial>,
    pub has_swamp_surface: bool,
    pub has_frozen_ocean_surface: bool,
    pub has_end_surface: bool,
    pub mesa_surface: Option<BiomeMesaSurface>,
    pub capped_surface: Option<BiomeCappedSurface>,
    pub overworld_rules: Option<BiomeOverworldRules>,
    pub multi_noise_rules: Option<BiomeMultiNoiseRules>,
    pub legacy_rules: Option<Vec<BiomeConditionalTransformation>>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeChunkGeneration {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.climate {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.consolidated_features {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len() as i32;
                len.encode(buf)?;
                for item in &v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        match &self.mountain_parameters {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.surface_material_adjustments {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len() as i32;
                len.encode(buf)?;
                for item in &v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        match &self.surface_materials {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.has_swamp_surface.encode(buf)?;
        self.has_frozen_ocean_surface.encode(buf)?;
        self.has_end_surface.encode(buf)?;
        match &self.mesa_surface {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.capped_surface {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.overworld_rules {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.multi_noise_rules {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.legacy_rules {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len() as i32;
                len.encode(buf)?;
                for item in &v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let climate = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<BiomeClimate as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let consolidated_features = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <BiomeConsolidatedFeature as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        let mountain_parameters = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <BiomeMountainParameters as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let surface_material_adjustments = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <BiomeElementData as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        let surface_materials = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <BiomeSurfaceMaterial as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let has_swamp_surface = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let has_frozen_ocean_surface = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let has_end_surface = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let mesa_surface = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <BiomeMesaSurface as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let capped_surface = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <BiomeCappedSurface as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let overworld_rules = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <BiomeOverworldRules as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let multi_noise_rules = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <BiomeMultiNoiseRules as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let legacy_rules = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <BiomeConditionalTransformation as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        Ok(Self {
            climate,
            consolidated_features,
            mountain_parameters,
            surface_material_adjustments,
            surface_materials,
            has_swamp_surface,
            has_frozen_ocean_surface,
            has_end_surface,
            mesa_surface,
            capped_surface,
            overworld_rules,
            multi_noise_rules,
            legacy_rules,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BiomeDefinition {
    pub name_index: i16,
    pub biome_id: u16,
    pub temperature: f32,
    pub downfall: f32,
    pub red_spore_density: f32,
    pub blue_spore_density: f32,
    pub ash_density: f32,
    pub white_ash_density: f32,
    pub depth: f32,
    pub scale: f32,
    pub map_water_colour: i32,
    pub rain: bool,
    pub tags: Option<Vec<u16>>,
    pub chunk_generation: Option<BiomeChunkGeneration>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeDefinition {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name_index.encode(buf)?;
        self.biome_id.encode(buf)?;
        self.temperature.encode(buf)?;
        self.downfall.encode(buf)?;
        self.red_spore_density.encode(buf)?;
        self.blue_spore_density.encode(buf)?;
        self.ash_density.encode(buf)?;
        self.white_ash_density.encode(buf)?;
        self.depth.encode(buf)?;
        self.scale.encode(buf)?;
        self.map_water_colour.encode(buf)?;
        self.rain.encode(buf)?;
        match &self.tags {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len() as i32;
                len.encode(buf)?;
                for item in &v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        match &self.chunk_generation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name_index = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let biome_id = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let temperature = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let downfall = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let red_spore_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let blue_spore_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let ash_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let white_ash_density = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let depth = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let scale = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let map_water_colour = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let rain = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let tags = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                            );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        let chunk_generation = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <BiomeChunkGeneration as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        Ok(Self {
            name_index,
            biome_id,
            temperature,
            downfall,
            red_spore_density,
            blue_spore_density,
            ash_density,
            white_ash_density,
            depth,
            scale,
            map_water_colour,
            rain,
            tags,
            chunk_generation,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum HeightMapDataType {
    NoData = 0,
    HasData = 1,
    TooHigh = 2,
    TooLow = 3,
    AllCopied = 4,
}
impl crate::bedrock::codec::BedrockCodec for HeightMapDataType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(HeightMapDataType::NoData),
            1 => Ok(HeightMapDataType::HasData),
            2 => Ok(HeightMapDataType::TooHigh),
            3 => Ok(HeightMapDataType::TooLow),
            4 => Ok(HeightMapDataType::AllCopied),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(HeightMapDataType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SubChunkEntryWithCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub payload: Option<ByteArray>,
    pub heightmap_type: HeightMapDataType,
    pub heightmap: Option<Vec<u8>>,
    pub render_heightmap_type: HeightMapDataType,
    pub render_heightmap: Option<Vec<u8>>,
    pub blob_id: u64,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        let val = self.payload.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.payload {
            v.encode(buf)?;
        }
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            v.encode(buf)?;
        }
        self.render_heightmap_type.encode(buf)?;
        if let Some(v) = &self.render_heightmap {
            v.encode(buf)?;
        }
        self.blob_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let result = <SubChunkEntryWithCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let payload = match result {
            _ => None,
            _ => Some(<ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
        };
        let heightmap_type = <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let heightmap = match heightmap_type {
            _ => Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let render_heightmap_type = <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let render_heightmap = match render_heightmap_type {
            _ => Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let blob_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            dx,
            dy,
            dz,
            payload,
            heightmap_type,
            heightmap,
            render_heightmap_type,
            render_heightmap,
            blob_id,
        })
    }
}
pub type SubChunkEntryWithCaching = Vec<SubChunkEntryWithCachingItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct SubChunkEntryWithoutCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub result: SubChunkEntryWithoutCachingItemResult,
    pub payload: ByteArray,
    pub heightmap_type: HeightMapDataType,
    pub heightmap: Option<Vec<u8>>,
    pub render_heightmap_type: HeightMapDataType,
    pub render_heightmap: Option<Vec<u8>>,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithoutCachingItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        self.result.encode(buf)?;
        self.payload.encode(buf)?;
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            v.encode(buf)?;
        }
        self.render_heightmap_type.encode(buf)?;
        if let Some(v) = &self.render_heightmap {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let result = <SubChunkEntryWithoutCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let heightmap_type = <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let heightmap = match heightmap_type {
            _ => Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let render_heightmap_type = <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let render_heightmap = match render_heightmap_type {
            _ => Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        Ok(Self {
            dx,
            dy,
            dz,
            result,
            payload,
            heightmap_type,
            heightmap,
            render_heightmap_type,
            render_heightmap,
        })
    }
}
pub type SubChunkEntryWithoutCaching = Vec<SubChunkEntryWithoutCachingItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBiomeDefinitionList {
    pub biome_definitions: Vec<BiomeDefinition>,
    pub string_list: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBiomeDefinitionList {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.biome_definitions.len() as i32;
        len.encode(buf)?;
        for item in &self.biome_definitions {
            item.encode(buf)?;
        }
        let len = self.string_list.len() as i32;
        len.encode(buf)?;
        for item in &self.string_list {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let biome_definitions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeDefinition as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let string_list = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            biome_definitions,
            string_list,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChangeDimension {
    pub dimension: crate::bedrock::codec::ZigZag32,
    pub position: Vec3F,
    pub respawn: bool,
    pub loading_screen_id: Option<u32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketChangeDimension {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension.encode(buf)?;
        self.position.encode(buf)?;
        self.respawn.encode(buf)?;
        match &self.loading_screen_id {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let respawn = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let loading_screen_id = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            dimension,
            position,
            respawn,
            loading_screen_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdate {
    pub is_block: bool,
    pub content: Option<PacketCommandBlockUpdateContent>,
    pub command: String,
    pub last_output: String,
    pub name: String,
    pub filtered_name: String,
    pub should_track_output: bool,
    pub tick_delay: i32,
    pub execute_on_first_tick: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.is_block.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketCommandBlockUpdateContent::False(v) => v.encode(buf)?,
                PacketCommandBlockUpdateContent::True(v) => v.encode(buf)?,
            }
        }
        self.command.encode(buf)?;
        self.last_output.encode(buf)?;
        self.name.encode(buf)?;
        self.filtered_name.encode(buf)?;
        self.should_track_output.encode(buf)?;
        self.tick_delay.encode(buf)?;
        self.execute_on_first_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let is_block = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content = match is_block {
            false => {
                Some(
                    PacketCommandBlockUpdateContent::False(
                        <PacketCommandBlockUpdateContentFalse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            true => {
                Some(
                    PacketCommandBlockUpdateContent::True(
                        Box::new(
                            <PacketCommandBlockUpdateContentTrue as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let last_output = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let filtered_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let should_track_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick_delay = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let execute_on_first_tick = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            is_block,
            content,
            command,
            last_output,
            name,
            filtered_name,
            should_track_output,
            tick_delay,
            execute_on_first_tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCompressedBiomeDefinitions {
    pub raw_payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompressedBiomeDefinitions {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.raw_payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let raw_payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { raw_payload })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCurrentStructureFeature {
    pub current_feature: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketCurrentStructureFeature {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.current_feature.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let current_feature = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { current_feature })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketJigsawStructureData {
    pub structure_data: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketJigsawStructureData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.structure_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let structure_data = <Vec<
            u8,
        > as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { structure_data })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketLevelEventEvent {
    SoundClick = 1000,
    SoundClickFail = 1001,
    SoundShoot = 1002,
    SoundDoor = 1003,
    SoundFizz = 1004,
    SoundIgnite = 1005,
    SoundGhast = 1007,
    SoundGhastShoot = 1008,
    SoundBlazeShoot = 1009,
    SoundDoorBump = 1010,
    SoundDoorCrash = 1012,
    SoundEndermanTeleport = 1018,
    SoundAnvilBreak = 1020,
    SoundAnvilUse = 1021,
    SoundAnvilFall = 1022,
    SoundPop = 1030,
    SoundPortal = 1032,
    SoundItemframeAddItem = 1040,
    SoundItemframeRemove = 1041,
    SoundItemframePlace = 1042,
    SoundItemframeRemoveItem = 1043,
    SoundItemframeRotateItem = 1044,
    SoundCamera = 1050,
    SoundOrb = 1051,
    SoundTotem = 1052,
    SoundArmorStandBreak = 1060,
    SoundArmorStandHit = 1061,
    SoundArmorStandFall = 1062,
    SoundArmorStandPlace = 1063,
    PointedDripstoneLand = 1064,
    DyeUsed = 1065,
    InkSackUsed = 1066,
    ParticleShoot = 2000,
    ParticleDestroy = 2001,
    ParticleSplash = 2002,
    ParticleEyeDespawn = 2003,
    ParticleSpawn = 2004,
    ParticleCropGrowth = 2005,
    ParticleGuardianCurse = 2006,
    ParticleDeathSmoke = 2007,
    ParticleBlockForceField = 2008,
    ParticleProjectileHit = 2009,
    ParticleDragonEggTeleport = 2010,
    ParticleCropEaten = 2011,
    ParticleCritical = 2012,
    ParticleEndermanTeleport = 2013,
    ParticlePunchBlock = 2014,
    ParticleBubble = 2015,
    ParticleEvaporate = 2016,
    ParticleDestroyArmorStand = 2017,
    ParticleBreakingEgg = 2018,
    ParticleDestroyEgg = 2019,
    ParticleEvaporateWater = 2020,
    ParticleDestroyBlockNoSound = 2021,
    ParticleKnockbackRoar = 2022,
    ParticleTeleportTrail = 2023,
    ParticlePointCloud = 2024,
    ParticleExplosion = 2025,
    ParticleBlockExplosion = 2026,
    ParticleVibrationSignal = 2027,
    ParticleDripstoneDrip = 2028,
    ParticleFizzEffect = 2029,
    ParticleWaxOn = 2030,
    ParticleWaxOff = 2031,
    ParticleScrape = 2032,
    ParticleElectricSpark = 2033,
    ParticleTurtleEgg = 2034,
    ParticleSculkShriek = 2035,
    SculkCatalystBloom = 2036,
    SculkCharge = 2037,
    SculkChargePop = 2038,
    SonicExplosion = 2039,
    DustPlume = 2040,
    StartRain = 3001,
    StartThunder = 3002,
    StopRain = 3003,
    StopThunder = 3004,
    PauseGame = 3005,
    PauseGameNoScreen = 3006,
    SetGameSpeed = 3007,
    RedstoneTrigger = 3500,
    CauldronExplode = 3501,
    CauldronDyeArmor = 3502,
    CauldronCleanArmor = 3503,
    CauldronFillPotion = 3504,
    CauldronTakePotion = 3505,
    CauldronFillWater = 3506,
    CauldronTakeWater = 3507,
    CauldronAddDye = 3508,
    CauldronCleanBanner = 3509,
    BlockStartBreak = 3600,
    BlockStopBreak = 3601,
    BlockBreakSpeed = 3602,
    ParticlePunchBlockDown = 3603,
    ParticlePunchBlockUp = 3604,
    ParticlePunchBlockNorth = 3605,
    ParticlePunchBlockSouth = 3606,
    ParticlePunchBlockWest = 3607,
    ParticlePunchBlockEast = 3608,
    ParticleShootWhiteSmoke = 3609,
    ParticleBreezeWindExplosion = 3610,
    ParticleTrialSpawnerDetection = 3611,
    ParticleTrialSpawnerSpawning = 3612,
    ParticleTrialSpawnerEjecting = 3613,
    ParticleWindExplosion = 3614,
    ParticleWolfArmorBreak = 3615,
    SetData = 4000,
    PlayersSleeping = 9800,
    SleepingPlayers = 9801,
    JumpPrevented = 9810,
    AnimationVaultActivate = 9811,
    AnimationVaultDeactivate = 9812,
    AnimationVaultEjectItem = 9813,
    AnimationSpawnCobweb = 9814,
    AddParticleSmashAttackGroundDust = 9815,
    AddParticleCreakingHeartTrail = 9816,
    AddParticleMask = 16384,
    AddParticleBubble = 16385,
    AddParticleBubbleManual = 16386,
    AddParticleCritical = 16387,
    AddParticleBlockForceField = 16388,
    AddParticleSmoke = 16389,
    AddParticleExplode = 16390,
    AddParticleEvaporation = 16391,
    AddParticleFlame = 16392,
    AddParticleCandleFlame = 16393,
    AddParticleLava = 16394,
    AddParticleLargeSmoke = 16395,
    AddParticleRedstone = 16396,
    AddParticleRisingRedDust = 16397,
    AddParticleItemBreak = 16398,
    AddParticleSnowballPoof = 16399,
    AddParticleHugeExplode = 16400,
    AddParticleHugeExplodeSeed = 16401,
    AddParticleMobFlame = 16402,
    AddParticleHeart = 16403,
    AddParticleTerrain = 16404,
    AddParticleTownAura = 16405,
    AddParticlePortal = 16406,
    AddParticleWaterSplash = 16408,
    AddParticleWaterSplashManual = 16409,
    AddParticleWaterWake = 16410,
    AddParticleDripWater = 16411,
    AddParticleDripLava = 16412,
    AddParticleDripHoney = 16413,
    AddParticleStalactiteDripWater = 16414,
    AddParticleStalactiteDripLava = 16415,
    AddParticleFallingDust = 16416,
    AddParticleMobSpell = 16417,
    AddParticleMobSpellAmbient = 16418,
    AddParticleMobSpellInstantaneous = 16419,
    AddParticleInk = 16420,
    AddParticleSlime = 16421,
    AddParticleRainSplash = 16422,
    AddParticleVillagerAngry = 16423,
    AddParticleVillagerHappy = 16424,
    AddParticleEnchantmentTable = 16425,
    AddParticleTrackingEmitter = 16426,
    AddParticleNote = 16427,
    AddParticleWitchSpell = 16428,
    AddParticleCarrot = 16429,
    AddParticleMobAppearance = 16430,
    AddParticleEndRod = 16431,
    AddParticleDragonsBreath = 16432,
    AddParticleSpit = 16433,
    AddParticleTotem = 16434,
    AddParticleFood = 16435,
    AddParticleFireworksStarter = 16436,
    AddParticleFireworksSpark = 16437,
    AddParticleFireworksOverlay = 16438,
    AddParticleBalloonGas = 16439,
    AddParticleColoredFlame = 16440,
    AddParticleSparkler = 16441,
    AddParticleConduit = 16442,
    AddParticleBubbleColumnUp = 16443,
    AddParticleBubbleColumnDown = 16444,
    AddParticleSneeze = 16445,
    AddParticleShulkerBullet = 16446,
    AddParticleBleach = 16447,
    AddParticleDragonDestroyBlock = 16448,
    AddParticleMyceliumDust = 16449,
    AddParticleFallingRedDust = 16450,
    AddParticleCampfireSmoke = 16451,
    AddParticleTallCampfireSmoke = 16452,
    AddParticleDragonBreathFire = 16453,
    AddParticleDragonBreathTrail = 16454,
    AddParticleBlueFlame = 16455,
    AddParticleSoul = 16456,
    AddParticleObsidianTear = 16457,
    AddParticlePortalReverse = 16458,
    AddParticleSnowflake = 16459,
    AddParticleVibrationSignal = 16460,
    AddParticleSculkSensorRedstone = 16461,
    AddParticleSporeBlossomShower = 16462,
    AddParticleSporeBlossomAmbient = 16463,
    AddParticleWax = 16464,
    AddParticleElectricSpark = 16465,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1000 => Ok(PacketLevelEventEvent::SoundClick),
            1001 => Ok(PacketLevelEventEvent::SoundClickFail),
            1002 => Ok(PacketLevelEventEvent::SoundShoot),
            1003 => Ok(PacketLevelEventEvent::SoundDoor),
            1004 => Ok(PacketLevelEventEvent::SoundFizz),
            1005 => Ok(PacketLevelEventEvent::SoundIgnite),
            1007 => Ok(PacketLevelEventEvent::SoundGhast),
            1008 => Ok(PacketLevelEventEvent::SoundGhastShoot),
            1009 => Ok(PacketLevelEventEvent::SoundBlazeShoot),
            1010 => Ok(PacketLevelEventEvent::SoundDoorBump),
            1012 => Ok(PacketLevelEventEvent::SoundDoorCrash),
            1018 => Ok(PacketLevelEventEvent::SoundEndermanTeleport),
            1020 => Ok(PacketLevelEventEvent::SoundAnvilBreak),
            1021 => Ok(PacketLevelEventEvent::SoundAnvilUse),
            1022 => Ok(PacketLevelEventEvent::SoundAnvilFall),
            1030 => Ok(PacketLevelEventEvent::SoundPop),
            1032 => Ok(PacketLevelEventEvent::SoundPortal),
            1040 => Ok(PacketLevelEventEvent::SoundItemframeAddItem),
            1041 => Ok(PacketLevelEventEvent::SoundItemframeRemove),
            1042 => Ok(PacketLevelEventEvent::SoundItemframePlace),
            1043 => Ok(PacketLevelEventEvent::SoundItemframeRemoveItem),
            1044 => Ok(PacketLevelEventEvent::SoundItemframeRotateItem),
            1050 => Ok(PacketLevelEventEvent::SoundCamera),
            1051 => Ok(PacketLevelEventEvent::SoundOrb),
            1052 => Ok(PacketLevelEventEvent::SoundTotem),
            1060 => Ok(PacketLevelEventEvent::SoundArmorStandBreak),
            1061 => Ok(PacketLevelEventEvent::SoundArmorStandHit),
            1062 => Ok(PacketLevelEventEvent::SoundArmorStandFall),
            1063 => Ok(PacketLevelEventEvent::SoundArmorStandPlace),
            1064 => Ok(PacketLevelEventEvent::PointedDripstoneLand),
            1065 => Ok(PacketLevelEventEvent::DyeUsed),
            1066 => Ok(PacketLevelEventEvent::InkSackUsed),
            2000 => Ok(PacketLevelEventEvent::ParticleShoot),
            2001 => Ok(PacketLevelEventEvent::ParticleDestroy),
            2002 => Ok(PacketLevelEventEvent::ParticleSplash),
            2003 => Ok(PacketLevelEventEvent::ParticleEyeDespawn),
            2004 => Ok(PacketLevelEventEvent::ParticleSpawn),
            2005 => Ok(PacketLevelEventEvent::ParticleCropGrowth),
            2006 => Ok(PacketLevelEventEvent::ParticleGuardianCurse),
            2007 => Ok(PacketLevelEventEvent::ParticleDeathSmoke),
            2008 => Ok(PacketLevelEventEvent::ParticleBlockForceField),
            2009 => Ok(PacketLevelEventEvent::ParticleProjectileHit),
            2010 => Ok(PacketLevelEventEvent::ParticleDragonEggTeleport),
            2011 => Ok(PacketLevelEventEvent::ParticleCropEaten),
            2012 => Ok(PacketLevelEventEvent::ParticleCritical),
            2013 => Ok(PacketLevelEventEvent::ParticleEndermanTeleport),
            2014 => Ok(PacketLevelEventEvent::ParticlePunchBlock),
            2015 => Ok(PacketLevelEventEvent::ParticleBubble),
            2016 => Ok(PacketLevelEventEvent::ParticleEvaporate),
            2017 => Ok(PacketLevelEventEvent::ParticleDestroyArmorStand),
            2018 => Ok(PacketLevelEventEvent::ParticleBreakingEgg),
            2019 => Ok(PacketLevelEventEvent::ParticleDestroyEgg),
            2020 => Ok(PacketLevelEventEvent::ParticleEvaporateWater),
            2021 => Ok(PacketLevelEventEvent::ParticleDestroyBlockNoSound),
            2022 => Ok(PacketLevelEventEvent::ParticleKnockbackRoar),
            2023 => Ok(PacketLevelEventEvent::ParticleTeleportTrail),
            2024 => Ok(PacketLevelEventEvent::ParticlePointCloud),
            2025 => Ok(PacketLevelEventEvent::ParticleExplosion),
            2026 => Ok(PacketLevelEventEvent::ParticleBlockExplosion),
            2027 => Ok(PacketLevelEventEvent::ParticleVibrationSignal),
            2028 => Ok(PacketLevelEventEvent::ParticleDripstoneDrip),
            2029 => Ok(PacketLevelEventEvent::ParticleFizzEffect),
            2030 => Ok(PacketLevelEventEvent::ParticleWaxOn),
            2031 => Ok(PacketLevelEventEvent::ParticleWaxOff),
            2032 => Ok(PacketLevelEventEvent::ParticleScrape),
            2033 => Ok(PacketLevelEventEvent::ParticleElectricSpark),
            2034 => Ok(PacketLevelEventEvent::ParticleTurtleEgg),
            2035 => Ok(PacketLevelEventEvent::ParticleSculkShriek),
            2036 => Ok(PacketLevelEventEvent::SculkCatalystBloom),
            2037 => Ok(PacketLevelEventEvent::SculkCharge),
            2038 => Ok(PacketLevelEventEvent::SculkChargePop),
            2039 => Ok(PacketLevelEventEvent::SonicExplosion),
            2040 => Ok(PacketLevelEventEvent::DustPlume),
            3001 => Ok(PacketLevelEventEvent::StartRain),
            3002 => Ok(PacketLevelEventEvent::StartThunder),
            3003 => Ok(PacketLevelEventEvent::StopRain),
            3004 => Ok(PacketLevelEventEvent::StopThunder),
            3005 => Ok(PacketLevelEventEvent::PauseGame),
            3006 => Ok(PacketLevelEventEvent::PauseGameNoScreen),
            3007 => Ok(PacketLevelEventEvent::SetGameSpeed),
            3500 => Ok(PacketLevelEventEvent::RedstoneTrigger),
            3501 => Ok(PacketLevelEventEvent::CauldronExplode),
            3502 => Ok(PacketLevelEventEvent::CauldronDyeArmor),
            3503 => Ok(PacketLevelEventEvent::CauldronCleanArmor),
            3504 => Ok(PacketLevelEventEvent::CauldronFillPotion),
            3505 => Ok(PacketLevelEventEvent::CauldronTakePotion),
            3506 => Ok(PacketLevelEventEvent::CauldronFillWater),
            3507 => Ok(PacketLevelEventEvent::CauldronTakeWater),
            3508 => Ok(PacketLevelEventEvent::CauldronAddDye),
            3509 => Ok(PacketLevelEventEvent::CauldronCleanBanner),
            3600 => Ok(PacketLevelEventEvent::BlockStartBreak),
            3601 => Ok(PacketLevelEventEvent::BlockStopBreak),
            3602 => Ok(PacketLevelEventEvent::BlockBreakSpeed),
            3603 => Ok(PacketLevelEventEvent::ParticlePunchBlockDown),
            3604 => Ok(PacketLevelEventEvent::ParticlePunchBlockUp),
            3605 => Ok(PacketLevelEventEvent::ParticlePunchBlockNorth),
            3606 => Ok(PacketLevelEventEvent::ParticlePunchBlockSouth),
            3607 => Ok(PacketLevelEventEvent::ParticlePunchBlockWest),
            3608 => Ok(PacketLevelEventEvent::ParticlePunchBlockEast),
            3609 => Ok(PacketLevelEventEvent::ParticleShootWhiteSmoke),
            3610 => Ok(PacketLevelEventEvent::ParticleBreezeWindExplosion),
            3611 => Ok(PacketLevelEventEvent::ParticleTrialSpawnerDetection),
            3612 => Ok(PacketLevelEventEvent::ParticleTrialSpawnerSpawning),
            3613 => Ok(PacketLevelEventEvent::ParticleTrialSpawnerEjecting),
            3614 => Ok(PacketLevelEventEvent::ParticleWindExplosion),
            3615 => Ok(PacketLevelEventEvent::ParticleWolfArmorBreak),
            4000 => Ok(PacketLevelEventEvent::SetData),
            9800 => Ok(PacketLevelEventEvent::PlayersSleeping),
            9801 => Ok(PacketLevelEventEvent::SleepingPlayers),
            9810 => Ok(PacketLevelEventEvent::JumpPrevented),
            9811 => Ok(PacketLevelEventEvent::AnimationVaultActivate),
            9812 => Ok(PacketLevelEventEvent::AnimationVaultDeactivate),
            9813 => Ok(PacketLevelEventEvent::AnimationVaultEjectItem),
            9814 => Ok(PacketLevelEventEvent::AnimationSpawnCobweb),
            9815 => Ok(PacketLevelEventEvent::AddParticleSmashAttackGroundDust),
            9816 => Ok(PacketLevelEventEvent::AddParticleCreakingHeartTrail),
            16384 => Ok(PacketLevelEventEvent::AddParticleMask),
            16385 => Ok(PacketLevelEventEvent::AddParticleBubble),
            16386 => Ok(PacketLevelEventEvent::AddParticleBubbleManual),
            16387 => Ok(PacketLevelEventEvent::AddParticleCritical),
            16388 => Ok(PacketLevelEventEvent::AddParticleBlockForceField),
            16389 => Ok(PacketLevelEventEvent::AddParticleSmoke),
            16390 => Ok(PacketLevelEventEvent::AddParticleExplode),
            16391 => Ok(PacketLevelEventEvent::AddParticleEvaporation),
            16392 => Ok(PacketLevelEventEvent::AddParticleFlame),
            16393 => Ok(PacketLevelEventEvent::AddParticleCandleFlame),
            16394 => Ok(PacketLevelEventEvent::AddParticleLava),
            16395 => Ok(PacketLevelEventEvent::AddParticleLargeSmoke),
            16396 => Ok(PacketLevelEventEvent::AddParticleRedstone),
            16397 => Ok(PacketLevelEventEvent::AddParticleRisingRedDust),
            16398 => Ok(PacketLevelEventEvent::AddParticleItemBreak),
            16399 => Ok(PacketLevelEventEvent::AddParticleSnowballPoof),
            16400 => Ok(PacketLevelEventEvent::AddParticleHugeExplode),
            16401 => Ok(PacketLevelEventEvent::AddParticleHugeExplodeSeed),
            16402 => Ok(PacketLevelEventEvent::AddParticleMobFlame),
            16403 => Ok(PacketLevelEventEvent::AddParticleHeart),
            16404 => Ok(PacketLevelEventEvent::AddParticleTerrain),
            16405 => Ok(PacketLevelEventEvent::AddParticleTownAura),
            16406 => Ok(PacketLevelEventEvent::AddParticlePortal),
            16408 => Ok(PacketLevelEventEvent::AddParticleWaterSplash),
            16409 => Ok(PacketLevelEventEvent::AddParticleWaterSplashManual),
            16410 => Ok(PacketLevelEventEvent::AddParticleWaterWake),
            16411 => Ok(PacketLevelEventEvent::AddParticleDripWater),
            16412 => Ok(PacketLevelEventEvent::AddParticleDripLava),
            16413 => Ok(PacketLevelEventEvent::AddParticleDripHoney),
            16414 => Ok(PacketLevelEventEvent::AddParticleStalactiteDripWater),
            16415 => Ok(PacketLevelEventEvent::AddParticleStalactiteDripLava),
            16416 => Ok(PacketLevelEventEvent::AddParticleFallingDust),
            16417 => Ok(PacketLevelEventEvent::AddParticleMobSpell),
            16418 => Ok(PacketLevelEventEvent::AddParticleMobSpellAmbient),
            16419 => Ok(PacketLevelEventEvent::AddParticleMobSpellInstantaneous),
            16420 => Ok(PacketLevelEventEvent::AddParticleInk),
            16421 => Ok(PacketLevelEventEvent::AddParticleSlime),
            16422 => Ok(PacketLevelEventEvent::AddParticleRainSplash),
            16423 => Ok(PacketLevelEventEvent::AddParticleVillagerAngry),
            16424 => Ok(PacketLevelEventEvent::AddParticleVillagerHappy),
            16425 => Ok(PacketLevelEventEvent::AddParticleEnchantmentTable),
            16426 => Ok(PacketLevelEventEvent::AddParticleTrackingEmitter),
            16427 => Ok(PacketLevelEventEvent::AddParticleNote),
            16428 => Ok(PacketLevelEventEvent::AddParticleWitchSpell),
            16429 => Ok(PacketLevelEventEvent::AddParticleCarrot),
            16430 => Ok(PacketLevelEventEvent::AddParticleMobAppearance),
            16431 => Ok(PacketLevelEventEvent::AddParticleEndRod),
            16432 => Ok(PacketLevelEventEvent::AddParticleDragonsBreath),
            16433 => Ok(PacketLevelEventEvent::AddParticleSpit),
            16434 => Ok(PacketLevelEventEvent::AddParticleTotem),
            16435 => Ok(PacketLevelEventEvent::AddParticleFood),
            16436 => Ok(PacketLevelEventEvent::AddParticleFireworksStarter),
            16437 => Ok(PacketLevelEventEvent::AddParticleFireworksSpark),
            16438 => Ok(PacketLevelEventEvent::AddParticleFireworksOverlay),
            16439 => Ok(PacketLevelEventEvent::AddParticleBalloonGas),
            16440 => Ok(PacketLevelEventEvent::AddParticleColoredFlame),
            16441 => Ok(PacketLevelEventEvent::AddParticleSparkler),
            16442 => Ok(PacketLevelEventEvent::AddParticleConduit),
            16443 => Ok(PacketLevelEventEvent::AddParticleBubbleColumnUp),
            16444 => Ok(PacketLevelEventEvent::AddParticleBubbleColumnDown),
            16445 => Ok(PacketLevelEventEvent::AddParticleSneeze),
            16446 => Ok(PacketLevelEventEvent::AddParticleShulkerBullet),
            16447 => Ok(PacketLevelEventEvent::AddParticleBleach),
            16448 => Ok(PacketLevelEventEvent::AddParticleDragonDestroyBlock),
            16449 => Ok(PacketLevelEventEvent::AddParticleMyceliumDust),
            16450 => Ok(PacketLevelEventEvent::AddParticleFallingRedDust),
            16451 => Ok(PacketLevelEventEvent::AddParticleCampfireSmoke),
            16452 => Ok(PacketLevelEventEvent::AddParticleTallCampfireSmoke),
            16453 => Ok(PacketLevelEventEvent::AddParticleDragonBreathFire),
            16454 => Ok(PacketLevelEventEvent::AddParticleDragonBreathTrail),
            16455 => Ok(PacketLevelEventEvent::AddParticleBlueFlame),
            16456 => Ok(PacketLevelEventEvent::AddParticleSoul),
            16457 => Ok(PacketLevelEventEvent::AddParticleObsidianTear),
            16458 => Ok(PacketLevelEventEvent::AddParticlePortalReverse),
            16459 => Ok(PacketLevelEventEvent::AddParticleSnowflake),
            16460 => Ok(PacketLevelEventEvent::AddParticleVibrationSignal),
            16461 => Ok(PacketLevelEventEvent::AddParticleSculkSensorRedstone),
            16462 => Ok(PacketLevelEventEvent::AddParticleSporeBlossomShower),
            16463 => Ok(PacketLevelEventEvent::AddParticleSporeBlossomAmbient),
            16464 => Ok(PacketLevelEventEvent::AddParticleWax),
            16465 => Ok(PacketLevelEventEvent::AddParticleElectricSpark),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLevelEventEvent), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEvent {
    pub event: PacketLevelEventEvent,
    pub position: Vec3F,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event.encode(buf)?;
        self.position.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let event = <PacketLevelEventEvent as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { event, position, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEvent {
    pub sound_id: SoundType,
    pub position: Vec3F,
    pub extra_data: crate::bedrock::codec::ZigZag32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
    pub entity_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        self.extra_data.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        self.entity_unique_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let sound_id = <SoundType as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let extra_data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            sound_id,
            position,
            extra_data,
            entity_type,
            is_baby_mob,
            is_global,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureBlockUpdate {
    pub position: BlockCoordinates,
    pub structure_name: String,
    pub filtered_structure_name: String,
    pub data_field: String,
    pub include_players: bool,
    pub show_bounding_box: bool,
    pub structure_block_type: crate::bedrock::codec::ZigZag32,
    pub settings: StructureBlockSettings,
    pub redstone_save_mode: crate::bedrock::codec::ZigZag32,
    pub should_trigger: bool,
    pub water_logged: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStructureBlockUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.structure_name.encode(buf)?;
        self.filtered_structure_name.encode(buf)?;
        self.data_field.encode(buf)?;
        self.include_players.encode(buf)?;
        self.show_bounding_box.encode(buf)?;
        self.structure_block_type.encode(buf)?;
        self.settings.encode(buf)?;
        self.redstone_save_mode.encode(buf)?;
        self.should_trigger.encode(buf)?;
        self.water_logged.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let structure_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let filtered_structure_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data_field = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let include_players = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let show_bounding_box = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let structure_block_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let settings = <StructureBlockSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let redstone_save_mode = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let should_trigger = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let water_logged = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            position,
            structure_name,
            filtered_structure_name,
            data_field,
            include_players,
            show_bounding_box,
            structure_block_type,
            settings,
            redstone_save_mode,
            should_trigger,
            water_logged,
        })
    }
}
