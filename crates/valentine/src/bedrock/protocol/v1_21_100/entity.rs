// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CameraPresetsAimAssistSomeTargetModeSome {
    Angle = 0,
    Distance = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresetsAimAssistSomeTargetModeSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(CameraPresetsAimAssistSomeTargetModeSome::Angle),
            1 => Ok(CameraPresetsAimAssistSomeTargetModeSome::Distance),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CameraPresetsAimAssistSomeTargetModeSome), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct CameraPresetsAimAssistSome {
    pub preset_id: Option<String>,
    pub target_mode: Option<CameraPresetsAimAssistSomeTargetModeSome>,
    pub angle: Option<Vec2F>,
    pub distance: Option<f32>,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresetsAimAssistSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.preset_id {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.target_mode {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.angle {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.distance {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let preset_id = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let target_mode = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <CameraPresetsAimAssistSomeTargetModeSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let angle = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let distance = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            preset_id,
            target_mode,
            angle,
            distance,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraPresetsControlSchemeSome {
    LockedPlayerRelativeStrafe = 0,
    CameraRelative = 1,
    CameraRelativeStrafe = 2,
    PlayerRelative = 3,
    PlayerRelativeStrafe = 4,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresetsControlSchemeSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(CameraPresetsControlSchemeSome::LockedPlayerRelativeStrafe),
            1 => Ok(CameraPresetsControlSchemeSome::CameraRelative),
            2 => Ok(CameraPresetsControlSchemeSome::CameraRelativeStrafe),
            3 => Ok(CameraPresetsControlSchemeSome::PlayerRelative),
            4 => Ok(CameraPresetsControlSchemeSome::PlayerRelativeStrafe),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CameraPresetsControlSchemeSome), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct CameraPresets {
    pub name: String,
    pub parent: String,
    pub position: Vec3Fopts,
    pub rotation: Vec2Fopts,
    pub rotation_speed: Option<f32>,
    pub snap_to_target: Option<bool>,
    pub horizontal_rotation_limit: Option<Vec2F>,
    pub vertical_rotation_limit: Option<Vec2F>,
    pub continue_targeting: Option<bool>,
    pub tracking_radius: Option<f32>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub radius: Option<f32>,
    pub yaw_limit_min: Option<f32>,
    pub yaw_limit_max: Option<f32>,
    pub audio_listener: Option<u8>,
    pub player_effects: Option<bool>,
    pub aim_assist: Option<CameraPresetsAimAssistSome>,
    pub control_scheme: Option<CameraPresetsControlSchemeSome>,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresets {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.parent.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        match &self.rotation_speed {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.snap_to_target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.horizontal_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.vertical_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.continue_targeting {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.tracking_radius {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.radius {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.yaw_limit_min {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.yaw_limit_max {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.audio_listener {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.player_effects {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.aim_assist {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.control_scheme {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let parent = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation = <Vec2Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation_speed = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let snap_to_target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let horizontal_rotation_limit = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let vertical_rotation_limit = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let continue_targeting = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let tracking_radius = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let radius = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let yaw_limit_min = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let yaw_limit_max = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let audio_listener = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let player_effects = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let aim_assist = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <CameraPresetsAimAssistSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let control_scheme = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <CameraPresetsControlSchemeSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        Ok(Self {
            name,
            parent,
            position,
            rotation,
            rotation_speed,
            snap_to_target,
            horizontal_rotation_limit,
            vertical_rotation_limit,
            continue_targeting,
            tracking_radius,
            offset,
            entity_offset,
            radius,
            yaw_limit_min,
            yaw_limit_max,
            audio_listener,
            player_effects,
            aim_assist,
            control_scheme,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MovementEffectType {
    Invalid = -1,
    GlideBoost = 0,
}
impl crate::bedrock::codec::BedrockCodec for MovementEffectType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            -1 => Ok(MovementEffectType::Invalid),
            0 => Ok(MovementEffectType::GlideBoost),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MovementEffectType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerAttributesItem {
    pub min: f32,
    pub max: f32,
    pub current: f32,
    pub default_min: f32,
    pub default_max: f32,
    pub default: f32,
    pub name: String,
    pub modifiers: Vec<PlayerAttributesItemModifiersItem>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        self.current.encode(buf)?;
        self.default_min.encode(buf)?;
        self.default_max.encode(buf)?;
        self.default.encode(buf)?;
        self.name.encode(buf)?;
        let len = self.modifiers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.modifiers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let current = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let default_min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let default_max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let default = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let modifiers = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PlayerAttributesItemModifiersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            min,
            max,
            current,
            default_min,
            default_max,
            default,
            name,
            modifiers,
        })
    }
}
pub type PlayerAttributes = Vec<PlayerAttributesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemAdd {
    pub uuid: uuid::Uuid,
    pub entity_unique_id: crate::bedrock::codec::ZigZag64,
    pub username: String,
    pub xbox_user_id: String,
    pub platform_chat_id: String,
    pub build_platform: i32,
    pub skin_data: Skin,
    pub is_teacher: bool,
    pub is_host: bool,
    pub is_subclient: bool,
    pub player_color: i32,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemAdd {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.entity_unique_id.encode(buf)?;
        self.username.encode(buf)?;
        self.xbox_user_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.build_platform.encode(buf)?;
        self.skin_data.encode(buf)?;
        self.is_teacher.encode(buf)?;
        self.is_host.encode(buf)?;
        self.is_subclient.encode(buf)?;
        self.player_color.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let xbox_user_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let build_platform = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_data = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_teacher = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_host = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_subclient = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_color = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            entity_unique_id,
            username,
            xbox_user_id,
            platform_chat_id,
            build_platform,
            skin_data,
            is_teacher,
            is_host,
            is_subclient,
            player_color,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerRecordsRecordsItem {
    Add(Box<PlayerRecordsRecordsItemAdd>),
    Remove(PlayerRecordsRecordsItemRemove),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Option<Vec<bool>>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.records_count.encode(buf)?;
        let len = self.records.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.records {
            if let Some(v) = &item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => v.encode(buf)?,
                    PlayerRecordsRecordsItem::Remove(v) => v.encode(buf)?,
                }
            }
        }
        if let Some(v) = &self.verified {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let records_count = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let records = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            PlayerRecordsType::Add => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            PlayerRecordsType::Remove => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        let verified = match type_ {
            PlayerRecordsType::Add => {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        .0 as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCameraAimAssistTargetMode {
    Angle = 0,
    Distance = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssistTargetMode {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCameraAimAssistTargetMode::Angle),
            1 => Ok(PacketCameraAimAssistTargetMode::Distance),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCameraAimAssistTargetMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCameraAimAssistAction {
    Set = 0,
    Clear = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssistAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCameraAimAssistAction::Set),
            1 => Ok(PacketCameraAimAssistAction::Clear),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCameraAimAssistAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraAimAssist {
    pub preset_id: String,
    pub view_angle: Vec2F,
    pub distance: f32,
    pub target_mode: PacketCameraAimAssistTargetMode,
    pub action: PacketCameraAimAssistAction,
    pub show_debug_render: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssist {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.preset_id.encode(buf)?;
        self.view_angle.encode(buf)?;
        self.distance.encode(buf)?;
        self.target_mode.encode(buf)?;
        self.action.encode(buf)?;
        self.show_debug_render.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let preset_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let view_angle = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let distance = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let target_mode = <PacketCameraAimAssistTargetMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action = <PacketCameraAimAssistAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let show_debug_render = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            preset_id,
            view_angle,
            distance,
            target_mode,
            action,
            show_debug_render,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraAimAssistPresetsCategoriesItemEntityPrioritiesItem {
    pub id: String,
    pub priority: i32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketCameraAimAssistPresetsCategoriesItemEntityPrioritiesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        self.priority.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let priority = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { id, priority })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraAimAssistPresetsCategoriesItem {
    pub name: String,
    pub entity_priorities: Vec<
        PacketCameraAimAssistPresetsCategoriesItemEntityPrioritiesItem,
    >,
    pub block_priorities: Vec<
        PacketCameraAimAssistPresetsCategoriesItemEntityPrioritiesItem,
    >,
    pub entity_default: Option<i32>,
    pub block_default: Option<i32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssistPresetsCategoriesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.entity_priorities.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entity_priorities {
            item.encode(buf)?;
        }
        let len = self.block_priorities.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.block_priorities {
            item.encode(buf)?;
        }
        match &self.entity_default {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.block_default {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_priorities = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCameraAimAssistPresetsCategoriesItemEntityPrioritiesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let block_priorities = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCameraAimAssistPresetsCategoriesItemEntityPrioritiesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let entity_default = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let block_default = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            name,
            entity_priorities,
            block_priorities,
            entity_default,
            block_default,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraAimAssistPresetsPresetsItemItemSettingsItem {
    pub id: String,
    pub category: String,
}
impl crate::bedrock::codec::BedrockCodec
for PacketCameraAimAssistPresetsPresetsItemItemSettingsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        self.category.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let category = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { id, category })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraAimAssistPresetsPresetsItem {
    pub id: String,
    pub exclude_blocks: Vec<String>,
    pub target_liquids: Vec<String>,
    pub item_settings: Vec<PacketCameraAimAssistPresetsPresetsItemItemSettingsItem>,
    pub default_item_settings: Option<String>,
    pub hand_settings: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssistPresetsPresetsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        let len = self.exclude_blocks.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.exclude_blocks {
            item.encode(buf)?;
        }
        let len = self.target_liquids.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.target_liquids {
            item.encode(buf)?;
        }
        let len = self.item_settings.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.item_settings {
            item.encode(buf)?;
        }
        match &self.default_item_settings {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.hand_settings {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let exclude_blocks = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let target_liquids = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let item_settings = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCameraAimAssistPresetsPresetsItemItemSettingsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let default_item_settings = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let hand_settings = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        Ok(Self {
            id,
            exclude_blocks,
            target_liquids,
            item_settings,
            default_item_settings,
            hand_settings,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketCameraAimAssistPresetsOperation {
    Set = 0,
    AddToExisting = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssistPresetsOperation {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCameraAimAssistPresetsOperation::Set),
            1 => Ok(PacketCameraAimAssistPresetsOperation::AddToExisting),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCameraAimAssistPresetsOperation), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraAimAssistPresets {
    pub categories: Vec<PacketCameraAimAssistPresetsCategoriesItem>,
    pub presets: Vec<PacketCameraAimAssistPresetsPresetsItem>,
    pub operation: PacketCameraAimAssistPresetsOperation,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraAimAssistPresets {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.categories.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.categories {
            item.encode(buf)?;
        }
        let len = self.presets.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.presets {
            item.encode(buf)?;
        }
        self.operation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let categories = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCameraAimAssistPresetsCategoriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let presets = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCameraAimAssistPresetsPresetsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let operation = <PacketCameraAimAssistPresetsOperation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            categories,
            presets,
            operation,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionInstructionSetSomeEaseDataSome {
    pub type_: EaseType,
    pub duration: f32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketCameraInstructionInstructionSetSomeEaseDataSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.duration.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <EaseType as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { type_, duration })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionInstructionSetSome {
    pub runtime_id: i32,
    pub ease_data: Option<PacketCameraInstructionInstructionSetSomeEaseDataSome>,
    pub position: Option<Vec3F>,
    pub rotation: Option<Vec2F>,
    pub facing: Option<Vec3F>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub default: Option<bool>,
    pub remove_ignore_starting_values: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstructionInstructionSetSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        match &self.ease_data {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.position {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.rotation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.facing {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.default {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.remove_ignore_starting_values.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ease_data = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetSomeEaseDataSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let position = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let rotation = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let facing = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let default = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let remove_ignore_starting_values = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_id,
            ease_data,
            position,
            rotation,
            facing,
            offset,
            entity_offset,
            default,
            remove_ignore_starting_values,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionTargetSome {
    pub offset: Option<Vec3F>,
    pub entity_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstructionTargetSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.entity_unique_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let offset = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { offset, entity_unique_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstructionFovSome {
    pub field_of_view: f32,
    pub ease_time: f32,
    pub ease_type: EaseType,
    pub clear: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstructionFovSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.field_of_view.encode(buf)?;
        self.ease_time.encode(buf)?;
        self.ease_type.encode(buf)?;
        self.clear.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let field_of_view = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ease_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ease_type = <EaseType as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let clear = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            field_of_view,
            ease_time,
            ease_type,
            clear,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraInstruction {
    pub instruction_set: Option<PacketCameraInstructionInstructionSetSome>,
    pub clear: Option<bool>,
    pub fade: Option<PacketCameraInstructionFadeSome>,
    pub target: Option<PacketCameraInstructionTargetSome>,
    pub remove_target: Option<bool>,
    pub fov: Option<PacketCameraInstructionFovSome>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraInstruction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        match &self.instruction_set {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.clear {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fade {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.remove_target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fov {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let instruction_set = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionInstructionSetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let clear = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let fade = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionFadeSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionTargetSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        let remove_target = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let fov = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(
                    <PacketCameraInstructionFovSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            } else {
                None
            }
        };
        Ok(Self {
            instruction_set,
            clear,
            fade,
            target,
            remove_target,
            fov,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketClientCameraAimAssistAction {
    SetFromCameraPreset = 0,
    Clear = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCameraAimAssistAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketClientCameraAimAssistAction::SetFromCameraPreset),
            1 => Ok(PacketClientCameraAimAssistAction::Clear),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketClientCameraAimAssistAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCameraAimAssist {
    pub preset_id: String,
    pub action: PacketClientCameraAimAssistAction,
    pub allow_aim_assist: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCameraAimAssist {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.preset_id.encode(buf)?;
        self.action.encode(buf)?;
        self.allow_aim_assist.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let preset_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let action = <PacketClientCameraAimAssistAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let allow_aim_assist = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            preset_id,
            action,
            allow_aim_assist,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientMovementPredictionSyncBoundingBox {
    pub scale: f32,
    pub width: f32,
    pub height: f32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketClientMovementPredictionSyncBoundingBox {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.scale.encode(buf)?;
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let scale = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let width = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let height = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { scale, width, height })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientMovementPredictionSync {
    pub data_flags: i64,
    pub bounding_box: PacketClientMovementPredictionSyncBoundingBox,
    pub movement_speed: f32,
    pub underwater_movement_speed: f32,
    pub lava_movement_speed: f32,
    pub jump_strength: f32,
    pub health: f32,
    pub hunger: f32,
    pub entity_runtime_id: i64,
    pub is_flying: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientMovementPredictionSync {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.data_flags.encode(buf)?;
        self.bounding_box.encode(buf)?;
        self.movement_speed.encode(buf)?;
        self.underwater_movement_speed.encode(buf)?;
        self.lava_movement_speed.encode(buf)?;
        self.jump_strength.encode(buf)?;
        self.health.encode(buf)?;
        self.hunger.encode(buf)?;
        self.entity_runtime_id.encode(buf)?;
        self.is_flying.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let data_flags = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let bounding_box = <PacketClientMovementPredictionSyncBoundingBox as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let movement_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let underwater_movement_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let lava_movement_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let jump_strength = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let health = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hunger = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let is_flying = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            data_flags,
            bounding_box,
            movement_speed,
            underwater_movement_speed,
            lava_movement_speed,
            jump_strength,
            health,
            hunger,
            entity_runtime_id,
            is_flying,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCorrectPlayerMovePrediction {
    pub prediction_type: PacketCorrectPlayerMovePredictionPredictionType,
    pub position: Vec3F,
    pub delta: Vec3F,
    pub rotation: Vec2F,
    pub angular_velocity: Option<f32>,
    pub on_ground: bool,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCorrectPlayerMovePrediction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.prediction_type.encode(buf)?;
        self.position.encode(buf)?;
        self.delta.encode(buf)?;
        self.rotation.encode(buf)?;
        match &self.angular_velocity {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.on_ground.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let prediction_type = <PacketCorrectPlayerMovePredictionPredictionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let angular_velocity = {
            let present = u8::decode(buf)?;
            if present != 0 {
                Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            } else {
                None
            }
        };
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            prediction_type,
            position,
            delta,
            rotation,
            angular_velocity,
            on_ground,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobArmorEquipment {
    pub runtime_entity_id: i64,
    pub helmet: Item,
    pub chestplate: Item,
    pub leggings: Item,
    pub boots: Item,
    pub body: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobArmorEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.helmet.encode(buf)?;
        self.chestplate.encode(buf)?;
        self.leggings.encode(buf)?;
        self.boots.encode(buf)?;
        self.body.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let helmet = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chestplate = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let leggings = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let boots = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let body = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            helmet,
            chestplate,
            leggings,
            boots,
            body,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEffect {
    pub runtime_entity_id: i64,
    pub event_id: PacketMobEffectEventID,
    pub effect_id: crate::bedrock::codec::ZigZag32,
    pub amplifier: crate::bedrock::codec::ZigZag32,
    pub particles: bool,
    pub duration: crate::bedrock::codec::ZigZag32,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.effect_id.encode(buf)?;
        self.amplifier.encode(buf)?;
        self.particles.encode(buf)?;
        self.duration.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketMobEffectEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let effect_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let amplifier = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let particles = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            effect_id,
            amplifier,
            particles,
            duration,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovementEffect {
    pub runtime_id: i64,
    pub effect_type: MovementEffectType,
    pub effect_duration: i32,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovementEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        self.effect_type.encode(buf)?;
        self.effect_duration.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let effect_type = <MovementEffectType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let effect_duration = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_id,
            effect_type,
            effect_duration,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerArmorDamage {
    pub type_: ArmorDamageType,
    pub helmet_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub chestplate_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub leggings_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub boots_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub body_damage: Option<crate::bedrock::codec::ZigZag32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerArmorDamage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.helmet_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.chestplate_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.leggings_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.boots_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.body_damage {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <ArmorDamageType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let helmet_damage = match type_.contains(ArmorDamageType::HEAD) {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let chestplate_damage = match type_.contains(ArmorDamageType::CHEST) {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let leggings_damage = match type_.contains(ArmorDamageType::LEGS) {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let boots_damage = match type_.contains(ArmorDamageType::FEET) {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let body_damage = match type_.contains(ArmorDamageType::BODY) {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            helmet_damage,
            chestplate_damage,
            leggings_damage,
            boots_damage,
            body_damage,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub interaction_model: PacketPlayerAuthInputInteractionModel,
    pub interact_rotation: Vec2F,
    pub tick: i64,
    pub delta: Vec3F,
    pub transaction: Option<PacketPlayerAuthInputTransactionSome>,
    pub item_stack_request: Option<ItemStackRequest>,
    pub content: Option<PacketPlayerAuthInputContentSome>,
    pub block_action: Option<Vec<PacketPlayerAuthInputBlockActionSomeItem>>,
    pub analogue_move_vector: Vec2F,
    pub camera_orientation: Vec3F,
    pub raw_move_vector: Vec2F,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        self.interaction_model.encode(buf)?;
        self.interact_rotation.encode(buf)?;
        self.tick.encode(buf)?;
        self.delta.encode(buf)?;
        if let Some(v) = &self.transaction {
            v.encode(buf)?;
        }
        if let Some(v) = &self.item_stack_request {
            v.encode(buf)?;
        }
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_action {
            v.encode(buf)?;
        }
        self.analogue_move_vector.encode(buf)?;
        self.camera_orientation.encode(buf)?;
        self.raw_move_vector.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let interaction_model = <PacketPlayerAuthInputInteractionModel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let interact_rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let transaction = match input_data.contains(InputFlag::ITEM_INTERACT) {
            true => {
                Some(
                    <PacketPlayerAuthInputTransactionSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let item_stack_request = match input_data.contains(InputFlag::ITEM_STACK_REQUEST)
        {
            true => {
                Some(
                    <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let content = match input_data.contains(InputFlag::CLIENT_PREDICTED_VEHICLE) {
            true => {
                Some(
                    <PacketPlayerAuthInputContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let block_action = match input_data.contains(InputFlag::BLOCK_ACTION) {
            true => {
                Some({
                    let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?
                        .0 as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <PacketPlayerAuthInputBlockActionSomeItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        let analogue_move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let camera_orientation = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let raw_move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            interaction_model,
            interact_rotation,
            tick,
            delta,
            transaction,
            item_stack_request,
            content,
            block_action,
            analogue_move_vector,
            camera_orientation,
            raw_move_vector,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerLocationType {
    Coordinates = 0,
    TypeHide = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerLocationType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerLocationType::Coordinates),
            1 => Ok(PacketPlayerLocationType::TypeHide),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerLocationType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerLocation {
    pub type_: PacketPlayerLocationType,
    pub entity_unique_id: i64,
    pub position: Option<Vec3F>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerLocation {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.entity_unique_id.encode(buf)?;
        if let Some(v) = &self.position {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <PacketPlayerLocationType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = match type_ {
            PacketPlayerLocationType::Coordinates => {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            }
            _ => None,
        };
        Ok(Self {
            type_,
            entity_unique_id,
            position,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPlayerUpdateEntityOverridesType {
    ClearAll = 0,
    Remove = 1,
    SetInt = 2,
    SetFloat = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerUpdateEntityOverridesType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerUpdateEntityOverridesType::ClearAll),
            1 => Ok(PacketPlayerUpdateEntityOverridesType::Remove),
            2 => Ok(PacketPlayerUpdateEntityOverridesType::SetInt),
            3 => Ok(PacketPlayerUpdateEntityOverridesType::SetFloat),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerUpdateEntityOverridesType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketPlayerUpdateEntityOverridesValue {
    SetFloat(f32),
    SetInt(i32),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerUpdateEntityOverrides {
    pub runtime_id: i64,
    pub property_index: i32,
    pub type_: PacketPlayerUpdateEntityOverridesType,
    pub value: Option<PacketPlayerUpdateEntityOverridesValue>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerUpdateEntityOverrides {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        self.property_index.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                PacketPlayerUpdateEntityOverridesValue::SetFloat(v) => v.encode(buf)?,
                PacketPlayerUpdateEntityOverridesValue::SetInt(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let property_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let type_ = <PacketPlayerUpdateEntityOverridesType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value = match type_ {
            PacketPlayerUpdateEntityOverridesType::SetFloat => {
                Some(
                    PacketPlayerUpdateEntityOverridesValue::SetFloat(
                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            PacketPlayerUpdateEntityOverridesType::SetInt => {
                Some(
                    PacketPlayerUpdateEntityOverridesValue::SetInt(
                        <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            runtime_id,
            property_index,
            type_,
            value,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPlayerVideoCaptureAction {
    Stop = 0,
    Start = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerVideoCaptureAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerVideoCaptureAction::Stop),
            1 => Ok(PacketPlayerVideoCaptureAction::Start),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerVideoCaptureAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerVideoCaptureContentSome {
    pub frame_rate: i32,
    pub file_prefix: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerVideoCaptureContentSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.frame_rate.encode(buf)?;
        self.file_prefix.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let frame_rate = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let file_prefix = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { frame_rate, file_prefix })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerVideoCapture {
    pub action: PacketPlayerVideoCaptureAction,
    pub content: Option<PacketPlayerVideoCaptureContentSome>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerVideoCapture {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action = <PacketPlayerVideoCaptureAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match action {
            PacketPlayerVideoCaptureAction::Start => {
                Some(
                    <PacketPlayerVideoCaptureContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self { action, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketSetMovementAuthorityMovementAuthority {
    Client = 0,
    Server = 1,
    ServerWithRewind = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketSetMovementAuthorityMovementAuthority {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketSetMovementAuthorityMovementAuthority::Client),
            1 => Ok(PacketSetMovementAuthorityMovementAuthority::Server),
            2 => Ok(PacketSetMovementAuthorityMovementAuthority::ServerWithRewind),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetMovementAuthorityMovementAuthority), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetMovementAuthority {
    pub movement_authority: PacketSetMovementAuthorityMovementAuthority,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetMovementAuthority {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.movement_authority.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let movement_authority = <PacketSetMovementAuthorityMovementAuthority as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { movement_authority })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdatePlayerGameType {
    pub gamemode: GameMode,
    pub player_unique_id: crate::bedrock::codec::ZigZag64,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdatePlayerGameType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        self.player_unique_id.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            gamemode,
            player_unique_id,
            tick,
        })
    }
}
