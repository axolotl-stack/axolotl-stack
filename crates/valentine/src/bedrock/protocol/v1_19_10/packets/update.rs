// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
pub use crate::bedrock::protocol::v1_16_210::PacketUpdateBlock as PacketUpdateBlock;
pub use crate::bedrock::protocol::v1_16_201::PacketUpdateAttributes as PacketUpdateAttributes;
pub use crate::bedrock::protocol::v1_16_210::PacketUpdateTrade as PacketUpdateTrade;
pub use crate::bedrock::protocol::v1_16_210::PacketUpdateEquipment as PacketUpdateEquipment;
pub use crate::bedrock::protocol::v1_17_30::PacketUpdateBlockSynced as PacketUpdateBlockSynced;
pub use crate::bedrock::protocol::v1_17_30::PacketUpdateBlockSyncedTransitionType as PacketUpdateBlockSyncedTransitionType;
pub use crate::bedrock::protocol::v1_16_201::PacketUpdateSoftEnum as PacketUpdateSoftEnum;
pub use crate::bedrock::protocol::v1_16_201::PacketUpdateSoftEnumActionType as PacketUpdateSoftEnumActionType;
pub use crate::bedrock::protocol::v1_16_201::PacketUpdateBlockProperties as PacketUpdateBlockProperties;
pub use crate::bedrock::protocol::v1_18_30::PacketUpdatePlayerGameType as PacketUpdatePlayerGameType;
pub use crate::bedrock::protocol::v1_17_30::PacketUpdateSubchunkBlocks as PacketUpdateSubchunkBlocks;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAbilities {
    pub entity_unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAbilities {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I64LE(self.entity_unique_id).encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let entity_unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = (<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            entity_unique_id,
            permission_level,
            command_permission,
            abilities,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAdventureSettings {
    pub no_pvm: bool,
    pub no_mvp: bool,
    pub immutable_world: bool,
    pub show_name_tags: bool,
    pub auto_jump: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAdventureSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.no_pvm.encode(buf)?;
        self.no_mvp.encode(buf)?;
        self.immutable_world.encode(buf)?;
        self.show_name_tags.encode(buf)?;
        self.auto_jump.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let no_pvm = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let no_mvp = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let immutable_world = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let show_name_tags = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let auto_jump = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            no_pvm,
            no_mvp,
            immutable_world,
            show_name_tags,
            auto_jump,
        })
    }
}
