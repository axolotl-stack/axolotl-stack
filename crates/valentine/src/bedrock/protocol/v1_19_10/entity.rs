// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub unique_id: crate::bedrock::codec::ZigZag64,
    pub runtime_id: i64,
    pub entity_type: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub body_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.unique_id.encode(buf)?;
        self.runtime_id.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.body_yaw.encode(buf)?;
        self.attributes.encode(buf)?;
        self.metadata.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let body_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let attributes = <EntityAttributes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            unique_id,
            runtime_id,
            entity_type,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            body_yaw,
            attributes,
            metadata,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub runtime_id: i64,
    pub platform_chat_id: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub gamemode: GameMode,
    pub metadata: MetadataDictionary,
    pub unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
    pub links: Links,
    pub device_id: String,
    pub device_os: DeviceOs,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        self.runtime_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.held_item.encode(buf)?;
        self.gamemode.encode(buf)?;
        self.metadata.encode(buf)?;
        self.unique_id.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let abilities = {
            let len = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_os = <DeviceOs as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            username,
            runtime_id,
            platform_chat_id,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            held_item,
            gamemode,
            metadata,
            unique_id,
            permission_level,
            command_permission,
            abilities,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEntityEventEventID {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    Caravan = 64,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
    GrowUp = 76,
    VibrationDetected = 77,
    DrinkMilk = 78,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEventEventID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketEntityEventEventID::Jump),
            2 => Ok(PacketEntityEventEventID::HurtAnimation),
            3 => Ok(PacketEntityEventEventID::DeathAnimation),
            4 => Ok(PacketEntityEventEventID::ArmSwing),
            5 => Ok(PacketEntityEventEventID::StopAttack),
            6 => Ok(PacketEntityEventEventID::TameFail),
            7 => Ok(PacketEntityEventEventID::TameSuccess),
            8 => Ok(PacketEntityEventEventID::ShakeWet),
            9 => Ok(PacketEntityEventEventID::UseItem),
            10 => Ok(PacketEntityEventEventID::EatGrassAnimation),
            11 => Ok(PacketEntityEventEventID::FishHookBubble),
            12 => Ok(PacketEntityEventEventID::FishHookPosition),
            13 => Ok(PacketEntityEventEventID::FishHookHook),
            14 => Ok(PacketEntityEventEventID::FishHookTease),
            15 => Ok(PacketEntityEventEventID::SquidInkCloud),
            16 => Ok(PacketEntityEventEventID::ZombieVillagerCure),
            18 => Ok(PacketEntityEventEventID::Respawn),
            19 => Ok(PacketEntityEventEventID::IronGolemOfferFlower),
            20 => Ok(PacketEntityEventEventID::IronGolemWithdrawFlower),
            21 => Ok(PacketEntityEventEventID::LoveParticles),
            22 => Ok(PacketEntityEventEventID::VillagerAngry),
            23 => Ok(PacketEntityEventEventID::VillagerHappy),
            24 => Ok(PacketEntityEventEventID::WitchSpellParticles),
            25 => Ok(PacketEntityEventEventID::FireworkParticles),
            26 => Ok(PacketEntityEventEventID::InLoveParticles),
            27 => Ok(PacketEntityEventEventID::SilverfishSpawnAnimation),
            28 => Ok(PacketEntityEventEventID::GuardianAttack),
            29 => Ok(PacketEntityEventEventID::WitchDrinkPotion),
            30 => Ok(PacketEntityEventEventID::WitchThrowPotion),
            31 => Ok(PacketEntityEventEventID::MinecartTntPrimeFuse),
            32 => Ok(PacketEntityEventEventID::CreeperPrimeFuse),
            33 => Ok(PacketEntityEventEventID::AirSupplyExpired),
            34 => Ok(PacketEntityEventEventID::PlayerAddXpLevels),
            35 => Ok(PacketEntityEventEventID::ElderGuardianCurse),
            36 => Ok(PacketEntityEventEventID::AgentArmSwing),
            37 => Ok(PacketEntityEventEventID::EnderDragonDeath),
            38 => Ok(PacketEntityEventEventID::DustParticles),
            39 => Ok(PacketEntityEventEventID::ArrowShake),
            57 => Ok(PacketEntityEventEventID::EatingItem),
            60 => Ok(PacketEntityEventEventID::BabyAnimalFeed),
            61 => Ok(PacketEntityEventEventID::DeathSmokeCloud),
            62 => Ok(PacketEntityEventEventID::CompleteTrade),
            63 => Ok(PacketEntityEventEventID::RemoveLeash),
            64 => Ok(PacketEntityEventEventID::Caravan),
            65 => Ok(PacketEntityEventEventID::ConsumeTotem),
            66 => Ok(PacketEntityEventEventID::PlayerCheckTreasureHunterAchievement),
            67 => Ok(PacketEntityEventEventID::EntitySpawn),
            68 => Ok(PacketEntityEventEventID::DragonPuke),
            69 => Ok(PacketEntityEventEventID::ItemEntityMerge),
            70 => Ok(PacketEntityEventEventID::StartSwim),
            71 => Ok(PacketEntityEventEventID::BalloonPop),
            72 => Ok(PacketEntityEventEventID::TreasureHunt),
            73 => Ok(PacketEntityEventEventID::AgentSummon),
            74 => Ok(PacketEntityEventEventID::ChargedItem),
            75 => Ok(PacketEntityEventEventID::Fall),
            76 => Ok(PacketEntityEventEventID::GrowUp),
            77 => Ok(PacketEntityEventEventID::VibrationDetected),
            78 => Ok(PacketEntityEventEventID::DrinkMilk),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEntityEventEventID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i64,
    pub event_id: PacketEntityEventEventID,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketEntityEventEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
