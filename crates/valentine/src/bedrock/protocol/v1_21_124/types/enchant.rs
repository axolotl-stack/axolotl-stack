// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::packets::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct Enchant {
    pub id: u8,
    pub level: u8,
}
impl crate::bedrock::codec::BedrockCodec for Enchant {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.id.encode(buf)?;
        self.level.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { id, level })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EnchantOption {
    pub cost: i32,
    pub slot_flags: i32,
    pub equip_enchants: Vec<Enchant>,
    pub held_enchants: Vec<Enchant>,
    pub self_enchants: Vec<Enchant>,
    pub name: String,
    pub option_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for EnchantOption {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.cost).encode(buf)?;
        self.slot_flags.encode(buf)?;
        let len = self.equip_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.equip_enchants {
            item.encode(buf)?;
        }
        let len = self.held_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.held_enchants {
            item.encode(buf)?;
        }
        let len = self.self_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.self_enchants {
            item.encode(buf)?;
        }
        self.name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.option_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let cost = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let slot_flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let equip_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let held_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let self_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let option_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            cost,
            slot_flags,
            equip_enchants,
            held_enchants,
            self_enchants,
            name,
            option_id,
        })
    }
}
