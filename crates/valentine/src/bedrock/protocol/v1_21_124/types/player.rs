// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use super::*;
use super::super::packets::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerAttributesItemModifiersItem {
    pub id: String,
    pub name: String,
    pub amount: f32,
    pub operation: i32,
    pub operand: i32,
    pub serializable: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItemModifiersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.id.encode(buf)?;
        self.name.encode(buf)?;
        crate::bedrock::codec::F32LE(self.amount).encode(buf)?;
        crate::bedrock::codec::I32LE(self.operation).encode(buf)?;
        crate::bedrock::codec::I32LE(self.operand).encode(buf)?;
        self.serializable.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let amount = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let operation = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let operand = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let serializable = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            id,
            name,
            amount,
            operation,
            operand,
            serializable,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerAttributesItem {
    pub min: f32,
    pub max: f32,
    pub current: f32,
    pub default_min: f32,
    pub default_max: f32,
    pub default: f32,
    pub name: String,
    pub modifiers: Vec<PlayerAttributesItemModifiersItem>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.min).encode(buf)?;
        crate::bedrock::codec::F32LE(self.max).encode(buf)?;
        crate::bedrock::codec::F32LE(self.current).encode(buf)?;
        crate::bedrock::codec::F32LE(self.default_min).encode(buf)?;
        crate::bedrock::codec::F32LE(self.default_max).encode(buf)?;
        crate::bedrock::codec::F32LE(self.default).encode(buf)?;
        self.name.encode(buf)?;
        let len = self.modifiers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.modifiers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let min = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let max = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let current = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let default_min = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let default_max = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let default = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let modifiers = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PlayerAttributesItemModifiersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            min,
            max,
            current,
            default_min,
            default_max,
            default,
            name,
            modifiers,
        })
    }
}
pub type PlayerAttributes = Vec<PlayerAttributesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PlayerRecordsType {
    Add = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PlayerRecordsType::Add),
            1 => Ok(PlayerRecordsType::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PlayerRecordsType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemAdd {
    pub uuid: uuid::Uuid,
    pub entity_unique_id: i64,
    pub username: String,
    pub xbox_user_id: String,
    pub platform_chat_id: String,
    pub build_platform: i32,
    pub skin_data: Skin,
    pub is_teacher: bool,
    pub is_host: bool,
    pub is_subclient: bool,
    pub player_color: i32,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemAdd {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id).encode(buf)?;
        self.username.encode(buf)?;
        self.xbox_user_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        crate::bedrock::codec::I32LE(self.build_platform).encode(buf)?;
        self.skin_data.encode(buf)?;
        self.is_teacher.encode(buf)?;
        self.is_host.encode(buf)?;
        self.is_subclient.encode(buf)?;
        crate::bedrock::codec::I32LE(self.player_color).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let xbox_user_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let build_platform = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let skin_data = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_teacher = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_host = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_subclient = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_color = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            uuid,
            entity_unique_id,
            username,
            xbox_user_id,
            platform_chat_id,
            build_platform,
            skin_data,
            is_teacher,
            is_host,
            is_subclient,
            player_color,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemRemove {
    pub uuid: uuid::Uuid,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemRemove {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { uuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerRecordsRecordsItem {
    Add(Box<PlayerRecordsRecordsItemAdd>),
    Remove(PlayerRecordsRecordsItemRemove),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Option<Vec<bool>>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        crate::bedrock::codec::VarInt(self.records_count).encode(buf)?;
        let len = self.records.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.records {
            if let Some(v) = item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => {
                        v.encode(buf)?;
                    }
                    PlayerRecordsRecordsItem::Remove(v) => {
                        v.encode(buf)?;
                    }
                }
            }
        }
        if let Some(v) = &self.verified {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let records_count = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let records = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            PlayerRecordsType::Add => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            PlayerRecordsType::Remove => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                        },
                    );
            }
            tmp_vec
        };
        let verified = match type_ {
            PlayerRecordsType::Add => {
                Some({
                    let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <bool as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
