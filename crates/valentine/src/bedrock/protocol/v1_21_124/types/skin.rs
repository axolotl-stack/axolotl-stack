// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::packets::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct SkinImage {
    pub width: i32,
    pub height: i32,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for SkinImage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let height = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { width, height, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinAnimationsItem {
    pub skin_image: SkinImage,
    pub animation_type: i32,
    pub animation_frames: f32,
    pub expression_type: f32,
}
impl crate::bedrock::codec::BedrockCodec for SkinAnimationsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.skin_image.encode(buf)?;
        self.animation_type.encode(buf)?;
        self.animation_frames.encode(buf)?;
        self.expression_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let skin_image = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_type = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_frames = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let expression_type = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            skin_image,
            animation_type,
            animation_frames,
            expression_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPersonalPiecesItem {
    pub piece_id: String,
    pub piece_type: String,
    pub pack_id: String,
    pub is_default_piece: bool,
    pub product_id: String,
}
impl crate::bedrock::codec::BedrockCodec for SkinPersonalPiecesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.piece_id.encode(buf)?;
        self.piece_type.encode(buf)?;
        self.pack_id.encode(buf)?;
        self.is_default_piece.encode(buf)?;
        self.product_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let piece_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_default_piece = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let product_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            piece_id,
            piece_type,
            pack_id,
            is_default_piece,
            product_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPieceTintColorsItem {
    pub piece_type: String,
    pub colors: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for SkinPieceTintColorsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.piece_type.encode(buf)?;
        let len = self.colors.len();
        (len as i32).encode(buf)?;
        for item in &self.colors {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { piece_type, colors })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Skin {
    pub skin_id: String,
    pub play_fab_id: String,
    pub skin_resource_pack: String,
    pub skin_data: SkinImage,
    pub animations: Vec<SkinAnimationsItem>,
    pub cape_data: SkinImage,
    pub geometry_data: String,
    pub geometry_data_version: String,
    pub animation_data: String,
    pub cape_id: String,
    pub full_skin_id: String,
    pub arm_size: String,
    pub skin_color: String,
    pub personal_pieces: Vec<SkinPersonalPiecesItem>,
    pub piece_tint_colors: Vec<SkinPieceTintColorsItem>,
    pub premium: bool,
    pub persona: bool,
    pub cape_on_classic: bool,
    pub primary_user: bool,
    pub overriding_player_appearance: bool,
}
impl crate::bedrock::codec::BedrockCodec for Skin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.skin_id.encode(buf)?;
        self.play_fab_id.encode(buf)?;
        self.skin_resource_pack.encode(buf)?;
        self.skin_data.encode(buf)?;
        let len = self.animations.len();
        (len as i32).encode(buf)?;
        for item in &self.animations {
            item.encode(buf)?;
        }
        self.cape_data.encode(buf)?;
        self.geometry_data.encode(buf)?;
        self.geometry_data_version.encode(buf)?;
        self.animation_data.encode(buf)?;
        self.cape_id.encode(buf)?;
        self.full_skin_id.encode(buf)?;
        self.arm_size.encode(buf)?;
        self.skin_color.encode(buf)?;
        let len = self.personal_pieces.len();
        (len as i32).encode(buf)?;
        for item in &self.personal_pieces {
            item.encode(buf)?;
        }
        let len = self.piece_tint_colors.len();
        (len as i32).encode(buf)?;
        for item in &self.piece_tint_colors {
            item.encode(buf)?;
        }
        self.premium.encode(buf)?;
        self.persona.encode(buf)?;
        self.cape_on_classic.encode(buf)?;
        self.primary_user.encode(buf)?;
        self.overriding_player_appearance.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let play_fab_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let skin_resource_pack = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let skin_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinAnimationsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let cape_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let geometry_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let geometry_data_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let cape_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let full_skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let arm_size = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin_color = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let personal_pieces = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPersonalPiecesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let piece_tint_colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPieceTintColorsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let persona = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let cape_on_classic = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let primary_user = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let overriding_player_appearance = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            skin_id,
            play_fab_id,
            skin_resource_pack,
            skin_data,
            animations,
            cape_data,
            geometry_data,
            geometry_data_version,
            animation_data,
            cape_id,
            full_skin_id,
            arm_size,
            skin_color,
            personal_pieces,
            piece_tint_colors,
            premium,
            persona,
            cape_on_classic,
            primary_user,
            overriding_player_appearance,
        })
    }
}
