// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::packets::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithoutBlockingTickNbt {
    pub version: u8,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTickNbt {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { version, nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithoutBlockingTick {
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNbt>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTick {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = self.nbt.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_place_on {
            item.encode(buf)?;
        }
        let len = self.can_destroy.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_destroy {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let has_nbt = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = if has_nbt {
            Some(
                <ItemExtraDataWithoutBlockingTickNbt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let can_place_on = {
            let len = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            nbt,
            can_place_on,
            can_destroy,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithBlockingTick {
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNbt>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
    pub blocking_tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithBlockingTick {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = self.nbt.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_place_on {
            item.encode(buf)?;
        }
        let len = self.can_destroy.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_destroy {
            item.encode(buf)?;
        }
        crate::bedrock::codec::I64LE(self.blocking_tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let has_nbt = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = if has_nbt {
            Some(
                <ItemExtraDataWithoutBlockingTickNbt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let can_place_on = {
            let len = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let blocking_tick = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            nbt,
            can_place_on,
            can_destroy,
            blocking_tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemContentExtra {
    Default(Box<ItemExtraDataWithoutBlockingTick>),
    ShieldItemId(Box<ItemExtraDataWithBlockingTick>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContent {
    pub count: u16,
    pub metadata: i32,
    pub stack_id: Option<i32>,
    pub block_runtime_id: i32,
    pub extra: ItemContentExtra,
}
#[derive(Debug, Clone)]
pub struct ItemContentArgs {
    pub network_id: i32,
    pub shield_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemContent {
    type Args = ItemContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U16LE(self.count).encode(buf)?;
        crate::bedrock::codec::VarInt(self.metadata).encode(buf)?;
        let val = self.stack_id.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.stack_id {
            v.encode(buf)?;
        }
        crate::bedrock::codec::ZigZag32(self.block_runtime_id).encode(buf)?;
        match &self.extra {
            ItemContentExtra::ShieldItemId(v) => {
                v.encode(buf)?;
            }
            ItemContentExtra::Default(v) => {
                (&**v).encode(buf)?;
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let count = <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let metadata = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_stack_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stack_id = if (has_stack_id) != 0 {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let extra = match args.network_id {
            x if x == args.shield_item_id => {
                ItemContentExtra::ShieldItemId(
                    Box::new(
                        <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => {
                ItemContentExtra::Default(
                    Box::new(
                        <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
        };
        Ok(Self {
            count,
            metadata,
            stack_id,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Item {
    pub content: Option<Box<ItemContent>>,
}
#[derive(Debug, Clone)]
pub struct ItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for Item {
    type Args = ItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = if (network_id) != 0 {
            Some(
                Box::new(
                    <ItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        ItemContentArgs {
                            network_id: network_id,
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        Ok(Self { content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemLegacyContentExtra {
    Default(Box<ItemExtraDataWithoutBlockingTick>),
    ShieldItemId(Box<ItemExtraDataWithBlockingTick>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemLegacyContent {
    pub count: u16,
    pub metadata: i32,
    pub block_runtime_id: i32,
    pub extra: ItemLegacyContentExtra,
}
#[derive(Debug, Clone)]
pub struct ItemLegacyContentArgs {
    pub network_id: i32,
    pub shield_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacyContent {
    type Args = ItemLegacyContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U16LE(self.count).encode(buf)?;
        crate::bedrock::codec::VarInt(self.metadata).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_runtime_id).encode(buf)?;
        match &self.extra {
            ItemLegacyContentExtra::ShieldItemId(v) => {
                v.encode(buf)?;
            }
            ItemLegacyContentExtra::Default(v) => {
                (&**v).encode(buf)?;
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let count = <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let metadata = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let extra = match args.network_id {
            x if x == args.shield_item_id => {
                ItemLegacyContentExtra::ShieldItemId(
                    Box::new(
                        <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => {
                ItemLegacyContentExtra::Default(
                    Box::new(
                        <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
        };
        Ok(Self {
            count,
            metadata,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemLegacy {
    pub content: Option<Box<ItemLegacyContent>>,
}
#[derive(Debug, Clone)]
pub struct ItemLegacyArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemLegacyArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacy {
    type Args = ItemLegacyArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = if (network_id) != 0 {
            Some(
                Box::new(
                    <ItemLegacyContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        ItemLegacyContentArgs {
                            network_id: network_id,
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        Ok(Self { content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackRequestActionsItemTypeId {
    Take = 0,
    Place = 1,
    Swap = 2,
    Drop = 3,
    Destroy = 4,
    Consume = 5,
    Create = 6,
    PlaceInContainer = 7,
    TakeOutContainer = 8,
    LabTableCombine = 9,
    BeaconPayment = 10,
    MineBlock = 11,
    CraftRecipe = 12,
    CraftRecipeAuto = 13,
    CraftCreative = 14,
    Optional = 15,
    CraftGrindstoneRequest = 16,
    CraftLoomRequest = 17,
    NonImplemented = 18,
    ResultsDeprecated = 19,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemTypeId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackRequestActionsItemTypeId::Take),
            1 => Ok(ItemStackRequestActionsItemTypeId::Place),
            2 => Ok(ItemStackRequestActionsItemTypeId::Swap),
            3 => Ok(ItemStackRequestActionsItemTypeId::Drop),
            4 => Ok(ItemStackRequestActionsItemTypeId::Destroy),
            5 => Ok(ItemStackRequestActionsItemTypeId::Consume),
            6 => Ok(ItemStackRequestActionsItemTypeId::Create),
            7 => Ok(ItemStackRequestActionsItemTypeId::PlaceInContainer),
            8 => Ok(ItemStackRequestActionsItemTypeId::TakeOutContainer),
            9 => Ok(ItemStackRequestActionsItemTypeId::LabTableCombine),
            10 => Ok(ItemStackRequestActionsItemTypeId::BeaconPayment),
            11 => Ok(ItemStackRequestActionsItemTypeId::MineBlock),
            12 => Ok(ItemStackRequestActionsItemTypeId::CraftRecipe),
            13 => Ok(ItemStackRequestActionsItemTypeId::CraftRecipeAuto),
            14 => Ok(ItemStackRequestActionsItemTypeId::CraftCreative),
            15 => Ok(ItemStackRequestActionsItemTypeId::Optional),
            16 => Ok(ItemStackRequestActionsItemTypeId::CraftGrindstoneRequest),
            17 => Ok(ItemStackRequestActionsItemTypeId::CraftLoomRequest),
            18 => Ok(ItemStackRequestActionsItemTypeId::NonImplemented),
            19 => Ok(ItemStackRequestActionsItemTypeId::ResultsDeprecated),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackRequestActionsItemTypeId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentBeaconPayment {
    pub primary_effect: i32,
    pub secondary_effect: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentBeaconPayment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.primary_effect).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.secondary_effect).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let primary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let secondary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            primary_effect,
            secondary_effect,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentConsume {
    pub count: u8,
    pub source: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentConsume {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { count, source })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftCreative {
    pub item_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftCreative {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.item_id).encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let item_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { item_id, times_crafted })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftGrindstoneRequest {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
    pub cost: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftGrindstoneRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.times_crafted.encode(buf)?;
        crate::bedrock::codec::VarInt(self.cost).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let recipe_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let cost = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_network_id,
            times_crafted,
            cost,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftLoomRequest {
    pub pattern: String,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftLoomRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.pattern.encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let pattern = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { pattern, times_crafted })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipe {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipe {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let recipe_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipeAuto {
    pub recipe_network_id: i32,
    pub times_crafted_2: u8,
    pub times_crafted: u8,
    pub ingredients: Vec<RecipeIngredient>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipeAuto {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.times_crafted_2.encode(buf)?;
        self.times_crafted.encode(buf)?;
        let len = self.ingredients.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.ingredients {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let recipe_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted_2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let ingredients = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            recipe_network_id,
            times_crafted_2,
            times_crafted,
            ingredients,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCreate {
    pub result_slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCreate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.result_slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let result_slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { result_slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentDrop {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub randomly: bool,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentDrop {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.randomly.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let randomly = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { count, source, randomly })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentMineBlock {
    pub hotbar_slot: i32,
    pub predicted_durability: i32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentMineBlock {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.predicted_durability).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let predicted_durability = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            hotbar_slot,
            predicted_durability,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentOptional {
    pub recipe_network_id: i32,
    pub filtered_string_index: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentOptional {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        crate::bedrock::codec::I32LE(self.filtered_string_index).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let recipe_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let filtered_string_index = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_network_id,
            filtered_string_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentPlace {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentPlace {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { count, source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentResultsDeprecated {
    pub result_items: Vec<ItemLegacy>,
    pub times_crafted: u8,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestActionsItemContentResultsDeprecatedArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for ItemStackRequestActionsItemContentResultsDeprecatedArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentResultsDeprecated {
    type Args = ItemStackRequestActionsItemContentResultsDeprecatedArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.result_items.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result_items {
            item.encode(buf)?;
        }
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let result_items = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemLegacyArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            result_items,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentSwap {
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentSwap {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftGrindstoneRequest(ItemStackRequestActionsItemContentCraftGrindstoneRequest),
    CraftLoomRequest(ItemStackRequestActionsItemContentCraftLoomRequest),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(Box<ItemStackRequestActionsItemContentCraftRecipeAuto>),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    PlaceInContainer(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
    TakeOutContainer(ItemStackRequestActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeId,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestActionsItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for ItemStackRequestActionsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    type Args = ItemStackRequestActionsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Consume(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftCreative(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftGrindstoneRequest(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftLoomRequest(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftRecipe(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Create(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Destroy(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Drop(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::MineBlock(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Place(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::PlaceInContainer(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Swap(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Take(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::TakeOutContainer(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let type_id = <ItemStackRequestActionsItemTypeId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_id {
            ItemStackRequestActionsItemTypeId::BeaconPayment => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Consume => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftCreative => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftGrindstoneRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftGrindstoneRequest(
                        <ItemStackRequestActionsItemContentCraftGrindstoneRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftLoomRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftLoomRequest(
                        <ItemStackRequestActionsItemContentCraftLoomRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftRecipe => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftRecipeAuto => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        Box::new(
                            <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Create => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Destroy => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Drop => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::MineBlock => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::NonImplemented => {
                Some(ItemStackRequestActionsItemContent::NonImplemented)
            }
            ItemStackRequestActionsItemTypeId::Optional => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Place => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::PlaceInContainer => {
                Some(
                    ItemStackRequestActionsItemContent::PlaceInContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::ResultsDeprecated => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemStackRequestActionsItemContentResultsDeprecatedArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Swap => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Take => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::TakeOutContainer => {
                Some(
                    ItemStackRequestActionsItemContent::TakeOutContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ItemStackRequestCause {
    ChatPublic = 0,
    ChatWhisper = 1,
    SignText = 2,
    AnvilText = 3,
    BookAndQuillText = 4,
    CommandBlockText = 5,
    BlockActorDataText = 6,
    JoinEventText = 7,
    LeaveEventText = 8,
    SlashCommandChat = 9,
    CartographyText = 10,
    KickCommand = 11,
    TitleCommand = 12,
    SummonCommand = 13,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestCause {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackRequestCause::ChatPublic),
            1 => Ok(ItemStackRequestCause::ChatWhisper),
            2 => Ok(ItemStackRequestCause::SignText),
            3 => Ok(ItemStackRequestCause::AnvilText),
            4 => Ok(ItemStackRequestCause::BookAndQuillText),
            5 => Ok(ItemStackRequestCause::CommandBlockText),
            6 => Ok(ItemStackRequestCause::BlockActorDataText),
            7 => Ok(ItemStackRequestCause::JoinEventText),
            8 => Ok(ItemStackRequestCause::LeaveEventText),
            9 => Ok(ItemStackRequestCause::SlashCommandChat),
            10 => Ok(ItemStackRequestCause::CartographyText),
            11 => Ok(ItemStackRequestCause::KickCommand),
            12 => Ok(ItemStackRequestCause::TitleCommand),
            13 => Ok(ItemStackRequestCause::SummonCommand),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackRequestCause), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequest {
    pub request_id: i32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
    pub cause: ItemStackRequestCause,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemStackRequestArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    type Args = ItemStackRequestArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.request_id).encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.custom_names {
            (*item).encode(buf)?;
        }
        self.cause.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let actions = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemStackRequestActionsItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let cause = <ItemStackRequestCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            request_id,
            actions,
            custom_names,
            cause,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackResponsesItemStatus {
    Ok = 0,
    Error = 1,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackResponsesItemStatus::Ok),
            1 => Ok(ItemStackResponsesItemStatus::Error),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackResponsesItemStatus), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: i32,
    pub custom_name: String,
    pub filtered_custom_name: String,
    pub durability_correction: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentContainersItemSlotsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.item_stack_id).encode(buf)?;
        self.custom_name.encode(buf)?;
        self.filtered_custom_name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.durability_correction).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let item_stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let filtered_custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let durability_correction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
            filtered_custom_name,
            durability_correction,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentContainersItem {
    pub slot_type: FullContainerName,
    pub slots: Vec<ItemStackResponsesItemContentContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentContainersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.slot_type.encode(buf)?;
        let len = self.slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let slot_type = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slots = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { slot_type, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContent {
    pub containers: Vec<ItemStackResponsesItemContentContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let containers = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { containers })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub status: ItemStackResponsesItemStatus,
    pub request_id: i32,
    pub content: Option<ItemStackResponsesItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.status.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.request_id).encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let status = <ItemStackResponsesItemStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = match status {
            ItemStackResponsesItemStatus::Ok => {
                Some(
                    <ItemStackResponsesItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            status,
            request_id,
            content,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
pub type ItemStacks = Vec<Item>;
