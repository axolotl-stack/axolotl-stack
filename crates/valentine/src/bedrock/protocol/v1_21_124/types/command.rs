// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::packets::*;
use crate::bedrock::codec::BedrockCodec;
pub type CommandFlags = u8;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CommandOriginType {
    Player = 0,
    Block = 1,
    MinecartBlock = 2,
    DevConsole = 3,
    Test = 4,
    AutomationPlayer = 5,
    ClientAutomation = 6,
    DedicatedServer = 7,
    Entity = 8,
    Virtual = 9,
    GameArgument = 10,
    EntityServer = 11,
    Precompiled = 12,
    GameDirectorEntityServer = 13,
    Script = 14,
    Executor = 15,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandOriginType::Player),
            1 => Ok(CommandOriginType::Block),
            2 => Ok(CommandOriginType::MinecartBlock),
            3 => Ok(CommandOriginType::DevConsole),
            4 => Ok(CommandOriginType::Test),
            5 => Ok(CommandOriginType::AutomationPlayer),
            6 => Ok(CommandOriginType::ClientAutomation),
            7 => Ok(CommandOriginType::DedicatedServer),
            8 => Ok(CommandOriginType::Entity),
            9 => Ok(CommandOriginType::Virtual),
            10 => Ok(CommandOriginType::GameArgument),
            11 => Ok(CommandOriginType::EntityServer),
            12 => Ok(CommandOriginType::Precompiled),
            13 => Ok(CommandOriginType::GameDirectorEntityServer),
            14 => Ok(CommandOriginType::Script),
            15 => Ok(CommandOriginType::Executor),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CommandOriginType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOriginPlayerEntityIdDevConsole {
    pub player_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginPlayerEntityIdDevConsole {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.player_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let player_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { player_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum CommandOriginPlayerEntityId {
    DevConsole(CommandOriginPlayerEntityIdDevConsole),
    Test(CommandOriginPlayerEntityIdDevConsole),
}
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOrigin {
    pub type_: CommandOriginType,
    pub uuid: uuid::Uuid,
    pub request_id: String,
    pub player_entity_id: Option<CommandOriginPlayerEntityId>,
}
impl crate::bedrock::codec::BedrockCodec for CommandOrigin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        self.uuid.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.player_entity_id {
            match v {
                CommandOriginPlayerEntityId::DevConsole(v) => {
                    v.encode(buf)?;
                }
                CommandOriginPlayerEntityId::Test(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let type_ = <CommandOriginType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let request_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_entity_id = match type_ {
            CommandOriginType::DevConsole => {
                Some(
                    CommandOriginPlayerEntityId::DevConsole(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            CommandOriginType::Test => {
                Some(
                    CommandOriginPlayerEntityId::Test(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            uuid,
            request_id,
            player_entity_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CommandPermissionLevel {
    Normal = 0,
    Operator = 1,
    Automation = 2,
    Host = 3,
    Owner = 4,
    Internal = 5,
}
impl crate::bedrock::codec::BedrockCodec for CommandPermissionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandPermissionLevel::Normal),
            1 => Ok(CommandPermissionLevel::Operator),
            2 => Ok(CommandPermissionLevel::Automation),
            3 => Ok(CommandPermissionLevel::Host),
            4 => Ok(CommandPermissionLevel::Owner),
            5 => Ok(CommandPermissionLevel::Internal),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CommandPermissionLevel), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CommandPermissionLevelVarint {
    Normal = 0,
    Operator = 1,
    Automation = 2,
    Host = 3,
    Owner = 4,
    Internal = 5,
}
impl crate::bedrock::codec::BedrockCodec for CommandPermissionLevelVarint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandPermissionLevelVarint::Normal),
            1 => Ok(CommandPermissionLevelVarint::Operator),
            2 => Ok(CommandPermissionLevelVarint::Automation),
            3 => Ok(CommandPermissionLevelVarint::Host),
            4 => Ok(CommandPermissionLevelVarint::Owner),
            5 => Ok(CommandPermissionLevelVarint::Internal),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CommandPermissionLevelVarint), val
                        ),
                    ),
                )
            }
        }
    }
}
