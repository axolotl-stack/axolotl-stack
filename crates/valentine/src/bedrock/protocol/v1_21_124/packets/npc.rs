// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketNpcDialogueActionType {
    Open = 0,
    Close = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcDialogueActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketNpcDialogueActionType::Open),
            1 => Ok(PacketNpcDialogueActionType::Close),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNpcDialogueActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcDialogue {
    pub entity_id: u64,
    pub action_type: PacketNpcDialogueActionType,
    pub dialogue: String,
    pub screen_name: String,
    pub npc_name: String,
    pub action_json: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcDialogue {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.entity_id.encode(buf)?;
        self.action_type.encode(buf)?;
        self.dialogue.encode(buf)?;
        self.screen_name.encode(buf)?;
        self.npc_name.encode(buf)?;
        self.action_json.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let entity_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action_type = <PacketNpcDialogueActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dialogue = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let screen_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let npc_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action_json = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id,
            action_type,
            dialogue,
            screen_name,
            npc_name,
            action_json,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketNpcRequestRequestType {
    SetActions = 0,
    ExecuteAction = 1,
    ExecuteClosingCommands = 2,
    SetName = 3,
    SetSkin = 4,
    SetInteractionText = 5,
    ExecuteOpeningCommands = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequestRequestType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketNpcRequestRequestType::SetActions),
            1 => Ok(PacketNpcRequestRequestType::ExecuteAction),
            2 => Ok(PacketNpcRequestRequestType::ExecuteClosingCommands),
            3 => Ok(PacketNpcRequestRequestType::SetName),
            4 => Ok(PacketNpcRequestRequestType::SetSkin),
            5 => Ok(PacketNpcRequestRequestType::SetInteractionText),
            6 => Ok(PacketNpcRequestRequestType::ExecuteOpeningCommands),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNpcRequestRequestType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketNpcRequestActionType {
    SetActions = 0,
    ExecuteAction = 1,
    ExecuteClosingCommands = 2,
    SetName = 3,
    SetSkin = 4,
    SetInteractText = 5,
    ExecuteOpeningCommands = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequestActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketNpcRequestActionType::SetActions),
            1 => Ok(PacketNpcRequestActionType::ExecuteAction),
            2 => Ok(PacketNpcRequestActionType::ExecuteClosingCommands),
            3 => Ok(PacketNpcRequestActionType::SetName),
            4 => Ok(PacketNpcRequestActionType::SetSkin),
            5 => Ok(PacketNpcRequestActionType::SetInteractText),
            6 => Ok(PacketNpcRequestActionType::ExecuteOpeningCommands),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNpcRequestActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcRequest {
    pub runtime_entity_id: i64,
    pub request_type: PacketNpcRequestRequestType,
    pub command: String,
    pub action_type: PacketNpcRequestActionType,
    pub scene_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.request_type.encode(buf)?;
        self.command.encode(buf)?;
        self.action_type.encode(buf)?;
        self.scene_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let request_type = <PacketNpcRequestRequestType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action_type = <PacketNpcRequestActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let scene_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            request_type,
            command,
            action_type,
            scene_name,
        })
    }
}
