// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameRulesChanged {
    pub rules: Vec<GameRuleI32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameRulesChanged {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.rules.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.rules {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let rules = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <GameRuleI32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { rules })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketGameTestRequestRotation {
    T0Deg = 0,
    T90Deg = 1,
    T180Deg = 2,
    T270Deg = 3,
    T360Deg = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameTestRequestRotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketGameTestRequestRotation::T0Deg),
            1 => Ok(PacketGameTestRequestRotation::T90Deg),
            2 => Ok(PacketGameTestRequestRotation::T180Deg),
            3 => Ok(PacketGameTestRequestRotation::T270Deg),
            4 => Ok(PacketGameTestRequestRotation::T360Deg),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketGameTestRequestRotation), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameTestRequest {
    pub max_tests_per_batch: i32,
    pub repetitions: i32,
    pub rotation: PacketGameTestRequestRotation,
    pub stop_on_error: bool,
    pub position: BlockCoordinates,
    pub tests_per_row: i32,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameTestRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.max_tests_per_batch).encode(buf)?;
        crate::bedrock::codec::VarInt(self.repetitions).encode(buf)?;
        self.rotation.encode(buf)?;
        self.stop_on_error.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.tests_per_row).encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let max_tests_per_batch = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let repetitions = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let rotation = <PacketGameTestRequestRotation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let stop_on_error = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tests_per_row = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            max_tests_per_batch,
            repetitions,
            rotation,
            stop_on_error,
            position,
            tests_per_row,
            name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameTestResults {
    pub succeeded: bool,
    pub error: String,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameTestResults {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.succeeded.encode(buf)?;
        self.error.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let succeeded = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let error = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { succeeded, error, name })
    }
}
