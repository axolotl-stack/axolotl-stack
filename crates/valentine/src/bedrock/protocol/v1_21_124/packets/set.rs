// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetCommandsEnabled {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetCommandsEnabled {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDefaultGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDefaultGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDifficulty {
    pub difficulty: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDifficulty {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.difficulty).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let difficulty = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { difficulty })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDisplayObjective {
    pub display_slot: String,
    pub objective_name: String,
    pub display_name: String,
    pub criteria_name: String,
    pub sort_order: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDisplayObjective {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.display_slot.encode(buf)?;
        self.objective_name.encode(buf)?;
        self.display_name.encode(buf)?;
        self.criteria_name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.sort_order).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let display_slot = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let criteria_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let sort_order = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            display_slot,
            objective_name,
            display_name,
            criteria_name,
            sort_order,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityData {
    pub runtime_entity_id: i64,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.metadata.encode(buf)?;
        self.properties.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            metadata,
            properties,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityLink {
    pub link: Link,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityLink {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.link.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let link = <Link as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { link })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityMotion {
    pub runtime_entity_id: i64,
    pub velocity: Vec3F,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityMotion {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.velocity.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            velocity,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetHealth {
    pub health: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetHealth {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.health).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let health = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { health })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetHudVisibility {
    Hide = 0,
    Reset = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetHudVisibility {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetHudVisibility::Hide),
            1 => Ok(PacketSetHudVisibility::Reset),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetHudVisibility), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetHud {
    pub elements: Vec<Element>,
    pub visibility: PacketSetHudVisibility,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetHud {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.elements.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.elements {
            item.encode(buf)?;
        }
        self.visibility.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let elements = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Element as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let visibility = <PacketSetHudVisibility as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { elements, visibility })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLastHurtBy {
    pub entity_type: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLastHurtBy {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.entity_type).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let entity_type = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { entity_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLocalPlayerAsInitialized {
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLocalPlayerAsInitialized {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { runtime_entity_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketSetMovementAuthorityMovementAuthority {
    Client = 0,
    Server = 1,
    ServerWithRewind = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketSetMovementAuthorityMovementAuthority {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetMovementAuthorityMovementAuthority::Client),
            1 => Ok(PacketSetMovementAuthorityMovementAuthority::Server),
            2 => Ok(PacketSetMovementAuthorityMovementAuthority::ServerWithRewind),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetMovementAuthorityMovementAuthority), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetMovementAuthority {
    pub movement_authority: PacketSetMovementAuthorityMovementAuthority,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetMovementAuthority {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.movement_authority.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let movement_authority = <PacketSetMovementAuthorityMovementAuthority as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { movement_authority })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetPlayerGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetPlayerInventoryOptionsLeftTab {
    None = 0,
    Construction = 1,
    Equipment = 2,
    Items = 3,
    Nature = 4,
    Search = 5,
    Survival = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerInventoryOptionsLeftTab {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetPlayerInventoryOptionsLeftTab::None),
            1 => Ok(PacketSetPlayerInventoryOptionsLeftTab::Construction),
            2 => Ok(PacketSetPlayerInventoryOptionsLeftTab::Equipment),
            3 => Ok(PacketSetPlayerInventoryOptionsLeftTab::Items),
            4 => Ok(PacketSetPlayerInventoryOptionsLeftTab::Nature),
            5 => Ok(PacketSetPlayerInventoryOptionsLeftTab::Search),
            6 => Ok(PacketSetPlayerInventoryOptionsLeftTab::Survival),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetPlayerInventoryOptionsLeftTab), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetPlayerInventoryOptionsRightTab {
    None = 0,
    Fullscreen = 1,
    Crafting = 2,
    Armor = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerInventoryOptionsRightTab {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetPlayerInventoryOptionsRightTab::None),
            1 => Ok(PacketSetPlayerInventoryOptionsRightTab::Fullscreen),
            2 => Ok(PacketSetPlayerInventoryOptionsRightTab::Crafting),
            3 => Ok(PacketSetPlayerInventoryOptionsRightTab::Armor),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetPlayerInventoryOptionsRightTab), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetPlayerInventoryOptionsLayout {
    None = 0,
    Survival = 1,
    RecipeBook = 2,
    Creative = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerInventoryOptionsLayout {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetPlayerInventoryOptionsLayout::None),
            1 => Ok(PacketSetPlayerInventoryOptionsLayout::Survival),
            2 => Ok(PacketSetPlayerInventoryOptionsLayout::RecipeBook),
            3 => Ok(PacketSetPlayerInventoryOptionsLayout::Creative),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetPlayerInventoryOptionsLayout), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetPlayerInventoryOptionsCraftingLayout {
    None = 0,
    Survival = 1,
    RecipeBook = 2,
    Creative = 3,
}
impl crate::bedrock::codec::BedrockCodec
for PacketSetPlayerInventoryOptionsCraftingLayout {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetPlayerInventoryOptionsCraftingLayout::None),
            1 => Ok(PacketSetPlayerInventoryOptionsCraftingLayout::Survival),
            2 => Ok(PacketSetPlayerInventoryOptionsCraftingLayout::RecipeBook),
            3 => Ok(PacketSetPlayerInventoryOptionsCraftingLayout::Creative),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetPlayerInventoryOptionsCraftingLayout),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetPlayerInventoryOptions {
    pub left_tab: PacketSetPlayerInventoryOptionsLeftTab,
    pub right_tab: PacketSetPlayerInventoryOptionsRightTab,
    pub filtering: bool,
    pub layout: PacketSetPlayerInventoryOptionsLayout,
    pub crafting_layout: PacketSetPlayerInventoryOptionsCraftingLayout,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerInventoryOptions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.left_tab.encode(buf)?;
        self.right_tab.encode(buf)?;
        self.filtering.encode(buf)?;
        self.layout.encode(buf)?;
        self.crafting_layout.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let left_tab = <PacketSetPlayerInventoryOptionsLeftTab as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let right_tab = <PacketSetPlayerInventoryOptionsRightTab as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let filtering = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let layout = <PacketSetPlayerInventoryOptionsLayout as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let crafting_layout = <PacketSetPlayerInventoryOptionsCraftingLayout as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            left_tab,
            right_tab,
            filtering,
            layout,
            crafting_layout,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketSetScoreAction {
    Change = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetScoreAction::Change),
            1 => Ok(PacketSetScoreAction::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum PacketSetScoreEntriesItemContentEntryType {
    Player = 1,
    Entity = 2,
    FakePlayer = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItemContentEntryType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketSetScoreEntriesItemContentEntryType::Player),
            2 => Ok(PacketSetScoreEntriesItemContentEntryType::Entity),
            3 => Ok(PacketSetScoreEntriesItemContentEntryType::FakePlayer),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreEntriesItemContentEntryType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketSetScoreEntriesItemContentEntityUniqueId {
    Entity(i64),
    Player(i64),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreEntriesItemContent {
    pub entry_type: PacketSetScoreEntriesItemContentEntryType,
    pub entity_unique_id: Option<PacketSetScoreEntriesItemContentEntityUniqueId>,
    pub custom_name: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.entry_type.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            match v {
                PacketSetScoreEntriesItemContentEntityUniqueId::Entity(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
                PacketSetScoreEntriesItemContentEntityUniqueId::Player(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
            }
        }
        if let Some(v) = &self.custom_name {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let entry_type = <PacketSetScoreEntriesItemContentEntryType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_unique_id = match entry_type {
            PacketSetScoreEntriesItemContentEntryType::Entity => {
                Some(
                    PacketSetScoreEntriesItemContentEntityUniqueId::Entity(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            PacketSetScoreEntriesItemContentEntryType::Player => {
                Some(
                    PacketSetScoreEntriesItemContentEntityUniqueId::Player(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            _ => None,
        };
        let custom_name = match entry_type {
            PacketSetScoreEntriesItemContentEntryType::FakePlayer => {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        Ok(Self {
            entry_type,
            entity_unique_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreEntriesItem {
    pub scoreboard_id: i64,
    pub objective_name: String,
    pub score: i32,
    pub content: Option<Box<PacketSetScoreEntriesItemContent>>,
}
#[derive(Debug, Clone)]
pub struct PacketSetScoreEntriesItemArgs {
    pub action: PacketSetScoreAction,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItem {
    type Args = PacketSetScoreEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.scoreboard_id).encode(buf)?;
        self.objective_name.encode(buf)?;
        crate::bedrock::codec::I32LE(self.score).encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let score = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = match args.action {
            PacketSetScoreAction::Change => {
                Some(
                    Box::new(
                        <PacketSetScoreEntriesItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            objective_name,
            score,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScore {
    pub action: PacketSetScoreAction,
    pub entries: Vec<PacketSetScoreEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScore {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let action = <PacketSetScoreAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSetScoreEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketSetScoreEntriesItemArgs {
                                action: action,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { action, entries })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum PacketSetScoreboardIdentityAction {
    RegisterIdentity = 0,
    ClearIdentity = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentityAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetScoreboardIdentityAction::RegisterIdentity),
            1 => Ok(PacketSetScoreboardIdentityAction::ClearIdentity),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreboardIdentityAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentityEntriesItem {
    pub scoreboard_id: i64,
    pub entity_unique_id: Option<i64>,
}
#[derive(Debug, Clone)]
pub struct PacketSetScoreboardIdentityEntriesItemArgs {
    pub action: PacketSetScoreboardIdentityAction,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentityEntriesItem {
    type Args = PacketSetScoreboardIdentityEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.scoreboard_id).encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_unique_id = match args.action {
            PacketSetScoreboardIdentityAction::RegisterIdentity => {
                Some(
                    <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentity {
    pub action: PacketSetScoreboardIdentityAction,
    pub entries: Vec<PacketSetScoreboardIdentityEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let action = <PacketSetScoreboardIdentityAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSetScoreboardIdentityEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketSetScoreboardIdentityEntriesItemArgs {
                                action: action,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { action, entries })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetSpawnPositionSpawnType {
    Player = 0,
    World = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPositionSpawnType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetSpawnPositionSpawnType::Player),
            1 => Ok(PacketSetSpawnPositionSpawnType::World),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetSpawnPositionSpawnType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetSpawnPosition {
    pub spawn_type: PacketSetSpawnPositionSpawnType,
    pub player_position: BlockCoordinates,
    pub dimension: i32,
    pub world_position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPosition {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.spawn_type.encode(buf)?;
        self.player_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.world_position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let spawn_type = <PacketSetSpawnPositionSpawnType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let world_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            spawn_type,
            player_position,
            dimension,
            world_position,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetTime {
    pub time: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTime {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.time).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { time })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetTitleType {
    Clear = 0,
    Reset = 1,
    SetTitle = 2,
    SetSubtitle = 3,
    ActionBarMessage = 4,
    SetDurations = 5,
    SetTitleJson = 6,
    SetSubtitleJson = 7,
    ActionBarMessageJson = 8,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTitleType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetTitleType::Clear),
            1 => Ok(PacketSetTitleType::Reset),
            2 => Ok(PacketSetTitleType::SetTitle),
            3 => Ok(PacketSetTitleType::SetSubtitle),
            4 => Ok(PacketSetTitleType::ActionBarMessage),
            5 => Ok(PacketSetTitleType::SetDurations),
            6 => Ok(PacketSetTitleType::SetTitleJson),
            7 => Ok(PacketSetTitleType::SetSubtitleJson),
            8 => Ok(PacketSetTitleType::ActionBarMessageJson),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetTitleType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetTitle {
    pub type_: PacketSetTitleType,
    pub text: String,
    pub fade_in_time: i32,
    pub stay_time: i32,
    pub fade_out_time: i32,
    pub xuid: String,
    pub platform_online_id: String,
    pub filtered_message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTitle {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        self.text.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.fade_in_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.stay_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.fade_out_time).encode(buf)?;
        self.xuid.encode(buf)?;
        self.platform_online_id.encode(buf)?;
        self.filtered_message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let type_ = <PacketSetTitleType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let fade_in_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let stay_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let fade_out_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let platform_online_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let filtered_message = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            type_,
            text,
            fade_in_time,
            stay_time,
            fade_out_time,
            xuid,
            platform_online_id,
            filtered_message,
        })
    }
}
