// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use ::bitflags::bitflags;
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddBehaviorTree {
    pub behaviortree: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddBehaviorTree {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.behaviortree.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let behaviortree = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { behaviortree })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub unique_id: i64,
    pub runtime_id: i64,
    pub entity_type: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub body_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.unique_id).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        self.entity_type.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        crate::bedrock::codec::F32LE(self.pitch).encode(buf)?;
        crate::bedrock::codec::F32LE(self.yaw).encode(buf)?;
        crate::bedrock::codec::F32LE(self.head_yaw).encode(buf)?;
        crate::bedrock::codec::F32LE(self.body_yaw).encode(buf)?;
        self.attributes.encode(buf)?;
        self.metadata.encode(buf)?;
        self.properties.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let head_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let body_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let attributes = {
            let res: EntityAttributes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <EntityAttributesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let links = {
            let res: Links = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            unique_id,
            runtime_id,
            entity_type,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            body_yaw,
            attributes,
            metadata,
            properties,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddItemEntity {
    pub entity_id_self: i64,
    pub runtime_entity_id: i64,
    pub item: Item,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub metadata: MetadataDictionary,
    pub is_from_fishing: bool,
}
#[derive(Debug, Clone)]
pub struct PacketAddItemEntityArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketAddItemEntityArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketAddItemEntity {
    type Args = PacketAddItemEntityArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.item.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.metadata.encode(buf)?;
        self.is_from_fishing.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let is_from_fishing = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            item,
            position,
            velocity,
            metadata,
            is_from_fishing,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPainting {
    pub entity_id_self: i64,
    pub runtime_entity_id: i64,
    pub coordinates: Vec3F,
    pub direction: i32,
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPainting {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.direction).encode(buf)?;
        self.title.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let coordinates = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let direction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            coordinates,
            direction,
            title,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub runtime_id: i64,
    pub platform_chat_id: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub gamemode: GameMode,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
    pub links: Links,
    pub device_id: String,
    pub device_os: DeviceOs,
}
#[derive(Debug, Clone)]
pub struct PacketAddPlayerArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for PacketAddPlayerArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    type Args = PacketAddPlayerArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        crate::bedrock::codec::F32LE(self.pitch).encode(buf)?;
        crate::bedrock::codec::F32LE(self.yaw).encode(buf)?;
        crate::bedrock::codec::F32LE(self.head_yaw).encode(buf)?;
        self.held_item.encode(buf)?;
        self.gamemode.encode(buf)?;
        self.metadata.encode(buf)?;
        self.properties.encode(buf)?;
        crate::bedrock::codec::I64LE(self.unique_id).encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let head_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let links = {
            let res: Links = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let device_os = <DeviceOs as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            username,
            runtime_id,
            platform_chat_id,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            held_item,
            gamemode,
            metadata,
            properties,
            unique_id,
            permission_level,
            command_permission,
            abilities,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddVolumeEntityBounds {
    pub min: BlockCoordinates,
    pub max: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddVolumeEntityBounds {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let min = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let max = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { min, max })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddVolumeEntity {
    pub runtime_id: i64,
    pub nbt: Vec<u8>,
    pub encoding_identifier: String,
    pub instance_name: String,
    pub bounds: PacketAddVolumeEntityBounds,
    pub dimension: i32,
    pub engine_version: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddVolumeEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        self.nbt.encode(buf)?;
        self.encoding_identifier.encode(buf)?;
        self.instance_name.encode(buf)?;
        self.bounds.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.engine_version.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let encoding_identifier = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let instance_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bounds = <PacketAddVolumeEntityBounds as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let engine_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_id,
            nbt,
            encoding_identifier,
            instance_name,
            bounds,
            dimension,
            engine_version,
        })
    }
}
