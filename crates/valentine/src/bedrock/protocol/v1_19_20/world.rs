// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemData {
    pub map_id: crate::bedrock::codec::ZigZag64,
    pub update_flags: UpdateMapFlags,
    pub dimension: u8,
    pub locked: bool,
    pub origin: Vec3I,
    pub included_in: Option<Vec<crate::bedrock::codec::ZigZag64>>,
    pub scale: Option<u8>,
    pub tracked: Option<PacketClientboundMapItemDataTrackedSome>,
    pub texture: Option<PacketClientboundMapItemDataTextureSome>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.map_id.encode(buf)?;
        self.update_flags.encode(buf)?;
        self.dimension.encode(buf)?;
        self.locked.encode(buf)?;
        self.origin.encode(buf)?;
        if let Some(v) = &self.included_in {
            v.encode(buf)?;
        }
        if let Some(v) = &self.scale {
            v.encode(buf)?;
        }
        if let Some(v) = &self.tracked {
            v.encode(buf)?;
        }
        if let Some(v) = &self.texture {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let update_flags = <UpdateMapFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let locked = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let included_in = match update_flags.contains(UpdateMapFlags::INITIALISATION) {
            true => {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        .0 as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        let scale = match update_flags
            .contains(UpdateMapFlags::INITIALISATION_UPDATE_FLAGS)
        {
            true => Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let tracked = match update_flags.contains(UpdateMapFlags::DECORATION) {
            true => {
                Some(
                    <PacketClientboundMapItemDataTrackedSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let texture = match update_flags.contains(UpdateMapFlags::TEXTURE) {
            true => {
                Some(
                    <PacketClientboundMapItemDataTextureSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            map_id,
            update_flags,
            dimension,
            locked,
            origin,
            included_in,
            scale,
            tracked,
            texture,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapInfoRequestClientPixelsItem {
    pub rgba: i32,
    pub index: u16,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapInfoRequestClientPixelsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.rgba.encode(buf)?;
        self.index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let rgba = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let index = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { rgba, index })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapInfoRequest {
    pub map_id: crate::bedrock::codec::ZigZag64,
    pub client_pixels: Vec<PacketMapInfoRequestClientPixelsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapInfoRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.map_id.encode(buf)?;
        let len = self.client_pixels.len();
        (len as u32).encode(buf)?;
        for item in &self.client_pixels {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let client_pixels = {
            let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketMapInfoRequestClientPixelsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { map_id, client_pixels })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkChunkPublisherUpdateSavedChunksItem {
    pub x: crate::bedrock::codec::ZigZag32,
    pub z: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for PacketNetworkChunkPublisherUpdateSavedChunksItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { x, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkChunkPublisherUpdate {
    pub coordinates: BlockCoordinates,
    pub radius: i32,
    pub saved_chunks: Vec<PacketNetworkChunkPublisherUpdateSavedChunksItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkChunkPublisherUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        self.radius.encode(buf)?;
        let len = self.saved_chunks.len();
        (len as u32).encode(buf)?;
        for item in &self.saved_chunks {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let radius = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let saved_chunks = {
            let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketNetworkChunkPublisherUpdateSavedChunksItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            coordinates,
            radius,
            saved_chunks,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketStartGameChatRestrictionLevel {
    None = 0,
    Dropped = 1,
    Disabled = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameChatRestrictionLevel {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketStartGameChatRestrictionLevel::None),
            1 => Ok(PacketStartGameChatRestrictionLevel::Dropped),
            2 => Ok(PacketStartGameChatRestrictionLevel::Disabled),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameChatRestrictionLevel), val
                        ),
                    ),
                )
            }
        }
    }
}
