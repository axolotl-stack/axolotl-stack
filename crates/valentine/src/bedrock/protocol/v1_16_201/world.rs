// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct BlockCoordinates {
    pub x: crate::bedrock::codec::ZigZag32,
    pub y: i32,
    pub z: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for BlockCoordinates {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BlockPaletteItem {
    pub name: String,
    pub state: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for BlockPaletteItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.state.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let state = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { name, state })
    }
}
pub type BlockPalette = Vec<BlockPaletteItem>;
pub type MapInfo = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAdventureSettingsPermissionLevel {
    Visitor = 0,
    Member = 1,
    Operator = 2,
    Custom = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketAdventureSettingsPermissionLevel {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketAdventureSettingsPermissionLevel::Visitor),
            1 => Ok(PacketAdventureSettingsPermissionLevel::Member),
            2 => Ok(PacketAdventureSettingsPermissionLevel::Operator),
            3 => Ok(PacketAdventureSettingsPermissionLevel::Custom),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAdventureSettingsPermissionLevel), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBiomeDefinitionList {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBiomeDefinitionList {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockEntityData {
    pub position: BlockCoordinates,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEntityData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { position, nbt })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketBlockEventType {
    Sound = 0,
    ChangeState = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEventType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketBlockEventType::Sound),
            1 => Ok(PacketBlockEventType::ChangeState),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBlockEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockEvent {
    pub position: BlockCoordinates,
    pub type_: PacketBlockEventType,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.type_.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <PacketBlockEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { position, type_, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockPickRequest {
    pub x: crate::bedrock::codec::ZigZag32,
    pub y: crate::bedrock::codec::ZigZag32,
    pub z: crate::bedrock::codec::ZigZag32,
    pub add_user_data: bool,
    pub selected_slot: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockPickRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.add_user_data.encode(buf)?;
        self.selected_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let add_user_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            x,
            y,
            z,
            add_user_data,
            selected_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChangeDimension {
    pub dimension: crate::bedrock::codec::ZigZag32,
    pub position: Vec3F,
    pub respawn: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketChangeDimension {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension.encode(buf)?;
        self.position.encode(buf)?;
        self.respawn.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let respawn = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            dimension,
            position,
            respawn,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChunkRadiusUpdate {
    pub chunk_radius: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketChunkRadiusUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.chunk_radius.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { chunk_radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemData {
    pub mapinfo: MapInfo,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.mapinfo.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let mapinfo = <MapInfo as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { mapinfo })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdateContentFalse {
    pub minecart_entity_runtime_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentFalse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.minecart_entity_runtime_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let minecart_entity_runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { minecart_entity_runtime_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCommandBlockUpdateContentTrueMode {
    Impulse = 0,
    Repeat = 1,
    Chain = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentTrueMode {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCommandBlockUpdateContentTrueMode::Impulse),
            1 => Ok(PacketCommandBlockUpdateContentTrueMode::Repeat),
            2 => Ok(PacketCommandBlockUpdateContentTrueMode::Chain),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCommandBlockUpdateContentTrueMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdateContentTrue {
    pub position: BlockCoordinates,
    pub mode: PacketCommandBlockUpdateContentTrueMode,
    pub needs_redstone: bool,
    pub conditional: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentTrue {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.mode.encode(buf)?;
        self.needs_redstone.encode(buf)?;
        self.conditional.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let mode = <PacketCommandBlockUpdateContentTrueMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let needs_redstone = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let conditional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            position,
            mode,
            needs_redstone,
            conditional,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketCommandBlockUpdateContent {
    False(PacketCommandBlockUpdateContentFalse),
    True(Box<PacketCommandBlockUpdateContentTrue>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdate {
    pub is_block: bool,
    pub content: Option<PacketCommandBlockUpdateContent>,
    pub command: String,
    pub last_output: String,
    pub name: String,
    pub should_track_output: bool,
    pub tick_delay: i32,
    pub execute_on_first_tick: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.is_block.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketCommandBlockUpdateContent::False(v) => v.encode(buf)?,
                PacketCommandBlockUpdateContent::True(v) => v.encode(buf)?,
            }
        }
        self.command.encode(buf)?;
        self.last_output.encode(buf)?;
        self.name.encode(buf)?;
        self.should_track_output.encode(buf)?;
        self.tick_delay.encode(buf)?;
        self.execute_on_first_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let is_block = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content = match is_block {
            false => {
                Some(
                    PacketCommandBlockUpdateContent::False(
                        <PacketCommandBlockUpdateContentFalse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            true => {
                Some(
                    PacketCommandBlockUpdateContent::True(
                        Box::new(
                            <PacketCommandBlockUpdateContentTrue as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let last_output = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let should_track_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick_delay = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let execute_on_first_tick = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            is_block,
            content,
            command,
            last_output,
            name,
            should_track_output,
            tick_delay,
            execute_on_first_tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunkBlobsSome {
    pub hashes: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunkBlobsSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.hashes.len() as i32;
        len.encode(buf)?;
        for item in &self.hashes {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let hashes = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self { hashes })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunk {
    pub x: crate::bedrock::codec::ZigZag32,
    pub z: crate::bedrock::codec::ZigZag32,
    pub sub_chunk_count: i32,
    pub cache_enabled: bool,
    pub blobs: Option<PacketLevelChunkBlobsSome>,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunk {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.z.encode(buf)?;
        self.sub_chunk_count.encode(buf)?;
        self.cache_enabled.encode(buf)?;
        if let Some(v) = &self.blobs {
            v.encode(buf)?;
        }
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let sub_chunk_count = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let blobs = match cache_enabled {
            true => {
                Some(
                    <PacketLevelChunkBlobsSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            x,
            z,
            sub_chunk_count,
            cache_enabled,
            blobs,
            payload,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketLevelEventEvent {
    SoundClick = 1000,
    SoundClickFail = 1001,
    SoundShoot = 1002,
    SoundDoor = 1003,
    SoundFizz = 1004,
    SoundIgnite = 1005,
    SoundGhast = 1007,
    SoundGhastShoot = 1008,
    SoundBlazeShoot = 1009,
    SoundDoorBump = 1010,
    SoundDoorCrash = 1012,
    SoundEndermanTeleport = 1018,
    SoundAnvilBreak = 1020,
    SoundAnvilUse = 1021,
    SoundAnvilFall = 1022,
    SoundPop = 1030,
    SoundPortal = 1032,
    SoundItemframeAddItem = 1040,
    SoundItemframeRemove = 1041,
    SoundItemframePlace = 1042,
    SoundItemframeRemoveItem = 1043,
    SoundItemframeRotateItem = 1044,
    SoundCamera = 1050,
    SoundOrb = 1051,
    SoundTotem = 1052,
    SoundArmorStandBreak = 1060,
    SoundArmorStandHit = 1061,
    SoundArmorStandFall = 1062,
    SoundArmorStandPlace = 1063,
    ParticleShoot = 2000,
    ParticleDestroy = 2001,
    ParticleSplash = 2002,
    ParticleEyeDespawn = 2003,
    ParticleSpawn = 2004,
    GuardianCurse = 2006,
    ParticleBlockForceField = 2008,
    ParticleProjectileHit = 2009,
    ParticleEndermanTeleport = 2013,
    ParticlePunchBlock = 2014,
    StartRain = 3001,
    StartThunder = 3002,
    StopRain = 3003,
    StopThunder = 3004,
    PauseGame = 3005,
    PauseGameNoScreen = 3006,
    SetGameSpeed = 3007,
    RedstoneTrigger = 3500,
    CauldronExplode = 3501,
    CauldronDyeArmor = 3502,
    CauldronCleanArmor = 3503,
    CauldronFillPotion = 3504,
    CauldronTakePotion = 3505,
    CauldronFillWater = 3506,
    CauldronTakeWater = 3507,
    CauldronAddDye = 3508,
    CauldronCleanBanner = 3509,
    BlockStartBreak = 3600,
    BlockStopBreak = 3601,
    SetData = 4000,
    PlayersSleeping = 9800,
    AddParticleMask = 16384,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1000 => Ok(PacketLevelEventEvent::SoundClick),
            1001 => Ok(PacketLevelEventEvent::SoundClickFail),
            1002 => Ok(PacketLevelEventEvent::SoundShoot),
            1003 => Ok(PacketLevelEventEvent::SoundDoor),
            1004 => Ok(PacketLevelEventEvent::SoundFizz),
            1005 => Ok(PacketLevelEventEvent::SoundIgnite),
            1007 => Ok(PacketLevelEventEvent::SoundGhast),
            1008 => Ok(PacketLevelEventEvent::SoundGhastShoot),
            1009 => Ok(PacketLevelEventEvent::SoundBlazeShoot),
            1010 => Ok(PacketLevelEventEvent::SoundDoorBump),
            1012 => Ok(PacketLevelEventEvent::SoundDoorCrash),
            1018 => Ok(PacketLevelEventEvent::SoundEndermanTeleport),
            1020 => Ok(PacketLevelEventEvent::SoundAnvilBreak),
            1021 => Ok(PacketLevelEventEvent::SoundAnvilUse),
            1022 => Ok(PacketLevelEventEvent::SoundAnvilFall),
            1030 => Ok(PacketLevelEventEvent::SoundPop),
            1032 => Ok(PacketLevelEventEvent::SoundPortal),
            1040 => Ok(PacketLevelEventEvent::SoundItemframeAddItem),
            1041 => Ok(PacketLevelEventEvent::SoundItemframeRemove),
            1042 => Ok(PacketLevelEventEvent::SoundItemframePlace),
            1043 => Ok(PacketLevelEventEvent::SoundItemframeRemoveItem),
            1044 => Ok(PacketLevelEventEvent::SoundItemframeRotateItem),
            1050 => Ok(PacketLevelEventEvent::SoundCamera),
            1051 => Ok(PacketLevelEventEvent::SoundOrb),
            1052 => Ok(PacketLevelEventEvent::SoundTotem),
            1060 => Ok(PacketLevelEventEvent::SoundArmorStandBreak),
            1061 => Ok(PacketLevelEventEvent::SoundArmorStandHit),
            1062 => Ok(PacketLevelEventEvent::SoundArmorStandFall),
            1063 => Ok(PacketLevelEventEvent::SoundArmorStandPlace),
            2000 => Ok(PacketLevelEventEvent::ParticleShoot),
            2001 => Ok(PacketLevelEventEvent::ParticleDestroy),
            2002 => Ok(PacketLevelEventEvent::ParticleSplash),
            2003 => Ok(PacketLevelEventEvent::ParticleEyeDespawn),
            2004 => Ok(PacketLevelEventEvent::ParticleSpawn),
            2006 => Ok(PacketLevelEventEvent::GuardianCurse),
            2008 => Ok(PacketLevelEventEvent::ParticleBlockForceField),
            2009 => Ok(PacketLevelEventEvent::ParticleProjectileHit),
            2013 => Ok(PacketLevelEventEvent::ParticleEndermanTeleport),
            2014 => Ok(PacketLevelEventEvent::ParticlePunchBlock),
            3001 => Ok(PacketLevelEventEvent::StartRain),
            3002 => Ok(PacketLevelEventEvent::StartThunder),
            3003 => Ok(PacketLevelEventEvent::StopRain),
            3004 => Ok(PacketLevelEventEvent::StopThunder),
            3005 => Ok(PacketLevelEventEvent::PauseGame),
            3006 => Ok(PacketLevelEventEvent::PauseGameNoScreen),
            3007 => Ok(PacketLevelEventEvent::SetGameSpeed),
            3500 => Ok(PacketLevelEventEvent::RedstoneTrigger),
            3501 => Ok(PacketLevelEventEvent::CauldronExplode),
            3502 => Ok(PacketLevelEventEvent::CauldronDyeArmor),
            3503 => Ok(PacketLevelEventEvent::CauldronCleanArmor),
            3504 => Ok(PacketLevelEventEvent::CauldronFillPotion),
            3505 => Ok(PacketLevelEventEvent::CauldronTakePotion),
            3506 => Ok(PacketLevelEventEvent::CauldronFillWater),
            3507 => Ok(PacketLevelEventEvent::CauldronTakeWater),
            3508 => Ok(PacketLevelEventEvent::CauldronAddDye),
            3509 => Ok(PacketLevelEventEvent::CauldronCleanBanner),
            3600 => Ok(PacketLevelEventEvent::BlockStartBreak),
            3601 => Ok(PacketLevelEventEvent::BlockStopBreak),
            4000 => Ok(PacketLevelEventEvent::SetData),
            9800 => Ok(PacketLevelEventEvent::PlayersSleeping),
            16384 => Ok(PacketLevelEventEvent::AddParticleMask),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLevelEventEvent), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEvent {
    pub event: PacketLevelEventEvent,
    pub position: Vec3F,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event.encode(buf)?;
        self.position.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let event = <PacketLevelEventEvent as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { event, position, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEventGeneric {
    pub event_id: i32,
    pub nbt: NBTLoop,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventGeneric {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event_id.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let event_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let nbt = <NBTLoop as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { event_id, nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEvent {
    pub sound_id: i32,
    pub position: Vec3F,
    pub block_id: crate::bedrock::codec::ZigZag32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        self.block_id.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let sound_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventOld {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: crate::bedrock::codec::ZigZag32,
    pub entity_type: crate::bedrock::codec::ZigZag32,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventOld {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        self.block_id.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventV2 {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: crate::bedrock::codec::ZigZag32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventV2 {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        self.block_id.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapCreateLockedCopy {}
impl crate::bedrock::codec::BedrockCodec for PacketMapCreateLockedCopy {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapInfoRequest {
    pub map_id: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapInfoRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.map_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { map_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkChunkPublisherUpdate {
    pub coordinates: BlockCoordinates,
    pub radius: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkChunkPublisherUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        self.radius.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let radius = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { coordinates, radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRequestChunkRadius {
    pub chunk_radius: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestChunkRadius {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.chunk_radius.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { chunk_radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureBlockUpdate {}
impl crate::bedrock::codec::BedrockCodec for PacketStructureBlockUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportRequest {}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportResponse {}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportResponse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTickSync {
    pub request_time: i64,
    pub response_time: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketTickSync {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_time.encode(buf)?;
        self.response_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_time = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let response_time = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            request_time,
            response_time,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlock {
    pub coordinates: BlockCoordinates,
    pub block_runtime_id: i32,
    pub block_priority: i32,
    pub storage: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlock {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        self.block_priority.encode(buf)?;
        self.storage.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_priority = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let storage = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            coordinates,
            block_runtime_id,
            block_priority,
            storage,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlockProperties {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockProperties {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlockSynced {
    pub coordinates: BlockCoordinates,
    pub block_runtime_id: i32,
    pub block_priority: i32,
    pub data_layer_id: i32,
    pub unknown0: i32,
    pub unknown1: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockSynced {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        self.block_priority.encode(buf)?;
        self.data_layer_id.encode(buf)?;
        self.unknown0.encode(buf)?;
        self.unknown1.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_priority = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data_layer_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown0 = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown1 = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            coordinates,
            block_runtime_id,
            block_priority,
            data_layer_id,
            unknown0,
            unknown1,
        })
    }
}
