// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct BehaviourPackInfosItem {
    pub uuid: String,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
}
impl crate::bedrock::codec::BedrockCodec for BehaviourPackInfosItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.size.encode(buf)?;
        self.content_key.encode(buf)?;
        self.sub_pack_name.encode(buf)?;
        self.content_identity.encode(buf)?;
        self.has_scripts.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content_key = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let sub_pack_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content_identity = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Enchant {
    pub id: u8,
    pub level: u8,
}
impl crate::bedrock::codec::BedrockCodec for Enchant {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        self.level.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { id, level })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EnchantOptionsItem {
    pub cost: i32,
    pub slot_flags: i32,
    pub equip_enchants: Vec<Enchant>,
    pub held_enchants: Vec<Enchant>,
    pub self_enchants: Vec<Enchant>,
    pub name: String,
    pub option_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for EnchantOptionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cost.encode(buf)?;
        self.slot_flags.encode(buf)?;
        let len = self.equip_enchants.len() as i32;
        len.encode(buf)?;
        for item in &self.equip_enchants {
            item.encode(buf)?;
        }
        let len = self.held_enchants.len() as i32;
        len.encode(buf)?;
        for item in &self.held_enchants {
            item.encode(buf)?;
        }
        let len = self.self_enchants.len() as i32;
        len.encode(buf)?;
        for item in &self.self_enchants {
            item.encode(buf)?;
        }
        self.name.encode(buf)?;
        self.option_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let cost = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slot_flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let equip_enchants = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let held_enchants = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let self_enchants = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let option_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            cost,
            slot_flags,
            equip_enchants,
            held_enchants,
            self_enchants,
            name,
            option_id,
        })
    }
}
pub type EnchantOptions = Vec<EnchantOptionsItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum ItemContentHasNBT {
    False = 0,
    True = 65535,
}
impl crate::bedrock::codec::BedrockCodec for ItemContentHasNBT {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ItemContentHasNBT::False),
            65535 => Ok(ItemContentHasNBT::True),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemContentHasNBT), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContentNBTSome {
    pub version: u8,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemContentNBTSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { version, nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContent {
    pub auxiliary_value: crate::bedrock::codec::ZigZag32,
    pub has_nbt: ItemContentHasNBT,
    pub nbt: Option<ItemContentNBTSome>,
    pub can_place_on: Vec<String>,
    pub can_destroy: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for ItemContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.auxiliary_value.encode(buf)?;
        self.has_nbt.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len() as crate::bedrock::codec::ZigZag32;
        len.encode(buf)?;
        for item in &self.can_place_on {
            item.encode(buf)?;
        }
        let len = self.can_destroy.len() as crate::bedrock::codec::ZigZag32;
        len.encode(buf)?;
        for item in &self.can_destroy {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let auxiliary_value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let has_nbt = <ItemContentHasNBT as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let nbt = match has_nbt {
            true => {
                Some(
                    <ItemContentNBTSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let can_place_on = {
            let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
            )? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
            )? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            auxiliary_value,
            has_nbt,
            nbt,
            can_place_on,
            can_destroy,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContent2Some {
    pub blocking_tick: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for ItemContent2Some {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.blocking_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let blocking_tick = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { blocking_tick })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Item {
    pub content: Option<ItemContent>,
    pub content_2: Option<ItemContent2Some>,
}
impl crate::bedrock::codec::BedrockCodec for Item {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        if let Some(v) = &self.content_2 {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match network_id {
            crate::bedrock::codec::ZigZag32(0) => None,
            _ => Some(<ItemContent as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
        };
        let content_2 = match network_id {
            crate::bedrock::codec::ZigZag32(355) => {
                Some(
                    <ItemContent2Some as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self { content, content_2 })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemComponentListItem {
    pub name: String,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemComponentListItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { name, nbt })
    }
}
pub type ItemComponentList = Vec<ItemComponentListItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStack {
    pub runtime_id: crate::bedrock::codec::ZigZag32,
    pub item: Item,
}
impl crate::bedrock::codec::BedrockCodec for ItemStack {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { runtime_id, item })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackRequestsItemActionsItemTypeID {
    Take = 0,
    Place = 1,
    Swap = 2,
    Drop = 3,
    Destroy = 4,
    Consume = 5,
    Create = 6,
    LabTableCombine = 7,
    BeaconPayment = 8,
    CraftRecipe = 9,
    CraftRecipeAuto = 10,
    CraftCreative = 11,
    Optional = 12,
    NonImplemented = 13,
    ResultsDeprecated = 14,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestsItemActionsItemTypeID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ItemStackRequestsItemActionsItemTypeID::Take),
            1 => Ok(ItemStackRequestsItemActionsItemTypeID::Place),
            2 => Ok(ItemStackRequestsItemActionsItemTypeID::Swap),
            3 => Ok(ItemStackRequestsItemActionsItemTypeID::Drop),
            4 => Ok(ItemStackRequestsItemActionsItemTypeID::Destroy),
            5 => Ok(ItemStackRequestsItemActionsItemTypeID::Consume),
            6 => Ok(ItemStackRequestsItemActionsItemTypeID::Create),
            7 => Ok(ItemStackRequestsItemActionsItemTypeID::LabTableCombine),
            8 => Ok(ItemStackRequestsItemActionsItemTypeID::BeaconPayment),
            9 => Ok(ItemStackRequestsItemActionsItemTypeID::CraftRecipe),
            10 => Ok(ItemStackRequestsItemActionsItemTypeID::CraftRecipeAuto),
            11 => Ok(ItemStackRequestsItemActionsItemTypeID::CraftCreative),
            12 => Ok(ItemStackRequestsItemActionsItemTypeID::Optional),
            13 => Ok(ItemStackRequestsItemActionsItemTypeID::NonImplemented),
            14 => Ok(ItemStackRequestsItemActionsItemTypeID::ResultsDeprecated),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackRequestsItemActionsItemTypeID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentBeaconPayment {
    pub primary_effect: crate::bedrock::codec::ZigZag32,
    pub secondary_effect: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentBeaconPayment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.primary_effect.encode(buf)?;
        self.secondary_effect.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let primary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let secondary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            primary_effect,
            secondary_effect,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentConsume {
    pub count: u8,
    pub source: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentConsume {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { count, source })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCraftCreative {
    pub creative_item_network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCraftCreative {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.creative_item_network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let creative_item_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { creative_item_network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCraftRecipe {
    pub recipe_network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCraftRecipe {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { recipe_network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCraftRecipeAuto {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCraftRecipeAuto {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCreate {
    pub result_slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCreate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.result_slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let result_slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { result_slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentDrop {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub randomly: bool,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentDrop {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.randomly.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let randomly = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { count, source, randomly })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentOptional {
    pub recipe_network_id: i32,
    pub filtered_string_index: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentOptional {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.filtered_string_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let filtered_string_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            recipe_network_id,
            filtered_string_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentPlace {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentPlace {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { count, source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentResultsDeprecated {
    pub result_items: Vec<Item>,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentResultsDeprecated {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.result_items.len() as i32;
        len.encode(buf)?;
        for item in &self.result_items {
            item.encode(buf)?;
        }
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let result_items = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            result_items,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentSwap {
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentSwap {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestsItemActionsItemContent {
    BeaconPayment(ItemStackRequestsItemActionsItemContentBeaconPayment),
    Consume(ItemStackRequestsItemActionsItemContentConsume),
    CraftCreative(ItemStackRequestsItemActionsItemContentCraftCreative),
    CraftRecipe(ItemStackRequestsItemActionsItemContentCraftRecipe),
    CraftRecipeAuto(ItemStackRequestsItemActionsItemContentCraftRecipeAuto),
    Create(ItemStackRequestsItemActionsItemContentCreate),
    Destroy(ItemStackRequestsItemActionsItemContentConsume),
    Drop(ItemStackRequestsItemActionsItemContentDrop),
    NonImplemented,
    Optional(ItemStackRequestsItemActionsItemContentOptional),
    Place(ItemStackRequestsItemActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestsItemActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestsItemActionsItemContentSwap),
    Take(ItemStackRequestsItemActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItem {
    pub type_id: ItemStackRequestsItemActionsItemTypeID,
    pub content: Option<ItemStackRequestsItemActionsItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestsItemActionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestsItemActionsItemContent::BeaconPayment(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestsItemActionsItemContent::Consume(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::CraftCreative(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestsItemActionsItemContent::CraftRecipe(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::CraftRecipeAuto(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestsItemActionsItemContent::Create(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::Destroy(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::Drop(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::NonImplemented => {}
                ItemStackRequestsItemActionsItemContent::Optional(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::Place(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestsItemActionsItemContent::Swap(v) => v.encode(buf)?,
                ItemStackRequestsItemActionsItemContent::Take(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestsItemActionsItemTypeID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_id {
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::BeaconPayment(
                        <ItemStackRequestsItemActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Consume(
                        <ItemStackRequestsItemActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::CraftCreative(
                        <ItemStackRequestsItemActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::CraftRecipe(
                        <ItemStackRequestsItemActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::CraftRecipeAuto(
                        <ItemStackRequestsItemActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Create(
                        <ItemStackRequestsItemActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Destroy(
                        <ItemStackRequestsItemActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Drop(
                        <ItemStackRequestsItemActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => Some(ItemStackRequestsItemActionsItemContent::NonImplemented),
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Optional(
                        <ItemStackRequestsItemActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Place(
                        <ItemStackRequestsItemActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestsItemActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Swap(
                        <ItemStackRequestsItemActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Take(
                        <ItemStackRequestsItemActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItem {
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub actions: Vec<ItemStackRequestsItemActionsItem>,
    pub custom_names: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        let len = self.actions.len() as i32;
        len.encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len() as i32;
        len.encode(buf)?;
        for item in &self.custom_names {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestsItemActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            request_id,
            actions,
            custom_names,
        })
    }
}
pub type ItemStackRequests = Vec<ItemStackRequestsItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: i32,
    pub custom_name: String,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContainersItemSlotsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        self.item_stack_id.encode(buf)?;
        self.custom_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item_stack_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContainersItem {
    pub container_id: u8,
    pub slots: Vec<ItemStackResponsesItemContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContainersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        let len = self.slots.len() as i32;
        len.encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slots = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { container_id, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub result: u8,
    pub request_id: i32,
    pub containers: Vec<ItemStackResponsesItemContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.result.encode(buf)?;
        self.request_id.encode(buf)?;
        let len = self.containers.len() as i32;
        len.encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let result = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let request_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let containers = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            result,
            request_id,
            containers,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
pub type ItemStacks = Vec<ItemStack>;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemstatesItem {
    pub name: String,
    pub runtime_id: i16,
    pub component_based: bool,
}
impl crate::bedrock::codec::BedrockCodec for ItemstatesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.runtime_id.encode(buf)?;
        self.component_based.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let runtime_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let component_based = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            name,
            runtime_id,
            component_based,
        })
    }
}
pub type Itemstates = Vec<ItemstatesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Index = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    OldSwell = 20,
    SwellDir = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeID = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinID = 40,
    URLTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    AerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    AreaEffectCloudRadius = 60,
    AreaEffectCloudWaiting = 61,
    AreaEffectCloudParticleID = 62,
    ShulkerPeekID = 63,
    ShulkerAttachFace = 64,
    ShulkerAttached = 65,
    ShulkerAttachPos = 66,
    TradingPlayerEid = 67,
    TradingCareer = 68,
    HasCommandBlock = 69,
    CommandBlockCommand = 70,
    CommandBlockLastOutput = 71,
    CommandBlockTrackOutput = 72,
    ControllingRiderSeatNumber = 73,
    Strength = 74,
    MaxStrength = 75,
    SpellCastingColor = 76,
    LimitedLife = 77,
    ArmorStandPoseIndex = 78,
    EnderCrystalTimeOffset = 79,
    AlwaysShowNametag = 80,
    Color2 = 81,
    NameAuthor = 82,
    ScoreTag = 83,
    BalloonAttachedEntity = 84,
    PufferfishSize = 85,
    BubbleTime = 86,
    Agent = 87,
    SittingAmount = 88,
    SittingAmountPrevious = 89,
    EatingCounter = 90,
    FlagsExtended = 91,
    LayingAmount = 92,
    LayingAmountPrevious = 93,
    Duration = 94,
    SpawnTime = 95,
    ChangeRate = 96,
    ChangeOnPickup = 97,
    PickupCount = 98,
    InteractText = 99,
    TradeTier = 100,
    MaxTradeTier = 101,
    TradeExperience = 102,
    SkinID = 103,
    SpawningFrames = 104,
    CommandBlockTickDelay = 105,
    CommandBlockExecuteOnFirstTick = 106,
    AmbientSoundInterval = 107,
    AmbientSoundIntervalRange = 108,
    AmbientSoundEventName = 109,
    FallDamageMultiplier = 110,
    NameRawText = 111,
    CanRideTarget = 112,
    LowTierCuredDiscount = 113,
    HighTierCuredDiscount = 114,
    NearbyCuredDiscount = 115,
    NearbyCuredDiscountTimestamp = 116,
    Hitbox = 117,
    IsBuoyant = 118,
    BuoyancyData = 119,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Index),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            20 => Ok(MetadataDictionaryItemKey::OldSwell),
            21 => Ok(MetadataDictionaryItemKey::SwellDir),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeID),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinID),
            41 => Ok(MetadataDictionaryItemKey::URLTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::AerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleID),
            63 => Ok(MetadataDictionaryItemKey::ShulkerPeekID),
            64 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            67 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            68 => Ok(MetadataDictionaryItemKey::TradingCareer),
            69 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            70 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            73 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            74 => Ok(MetadataDictionaryItemKey::Strength),
            75 => Ok(MetadataDictionaryItemKey::MaxStrength),
            76 => Ok(MetadataDictionaryItemKey::SpellCastingColor),
            77 => Ok(MetadataDictionaryItemKey::LimitedLife),
            78 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            79 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            80 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            81 => Ok(MetadataDictionaryItemKey::Color2),
            82 => Ok(MetadataDictionaryItemKey::NameAuthor),
            83 => Ok(MetadataDictionaryItemKey::ScoreTag),
            84 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            85 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            86 => Ok(MetadataDictionaryItemKey::BubbleTime),
            87 => Ok(MetadataDictionaryItemKey::Agent),
            88 => Ok(MetadataDictionaryItemKey::SittingAmount),
            89 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            90 => Ok(MetadataDictionaryItemKey::EatingCounter),
            91 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            92 => Ok(MetadataDictionaryItemKey::LayingAmount),
            93 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            94 => Ok(MetadataDictionaryItemKey::Duration),
            95 => Ok(MetadataDictionaryItemKey::SpawnTime),
            96 => Ok(MetadataDictionaryItemKey::ChangeRate),
            97 => Ok(MetadataDictionaryItemKey::ChangeOnPickup),
            98 => Ok(MetadataDictionaryItemKey::PickupCount),
            99 => Ok(MetadataDictionaryItemKey::InteractText),
            100 => Ok(MetadataDictionaryItemKey::TradeTier),
            101 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            102 => Ok(MetadataDictionaryItemKey::TradeExperience),
            103 => Ok(MetadataDictionaryItemKey::SkinID),
            104 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            105 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            107 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            110 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            111 => Ok(MetadataDictionaryItemKey::NameRawText),
            112 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            113 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            114 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            117 => Ok(MetadataDictionaryItemKey::Hitbox),
            118 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            119 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemType {
    Byte = 0,
    Short = 1,
    Int = 2,
    Float = 3,
    String = 4,
    Compound = 5,
    Vec3I = 6,
    Long = 7,
    Vec3F = 8,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(MetadataDictionaryItemType::Byte),
            1 => Ok(MetadataDictionaryItemType::Short),
            2 => Ok(MetadataDictionaryItemType::Int),
            3 => Ok(MetadataDictionaryItemType::Float),
            4 => Ok(MetadataDictionaryItemType::String),
            5 => Ok(MetadataDictionaryItemType::Compound),
            6 => Ok(MetadataDictionaryItemType::Vec3I),
            7 => Ok(MetadataDictionaryItemType::Long),
            8 => Ok(MetadataDictionaryItemType::Vec3F),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Byte(i8),
    Compound(Vec<u8>),
    Float(f32),
    Int(crate::bedrock::codec::ZigZag32),
    Long(crate::bedrock::codec::ZigZag64),
    Short(i16),
    String(String),
    Vec3F(Vec3F),
    Vec3I(Vec3I),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: Option<MetadataDictionaryItemValue>,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                MetadataDictionaryItemValue::Byte(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::Compound(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::Float(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::Int(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::Long(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::Short(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::String(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::Vec3F(v) => v.encode(buf)?,
                MetadataDictionaryItemValue::Vec3I(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value = match type_ {
            _ => {
                Some(
                    MetadataDictionaryItemValue::Byte(
                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::Compound(
                        <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::Float(
                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::Int(
                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::Long(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::Short(
                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::String(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::Vec3F(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => {
                Some(
                    MetadataDictionaryItemValue::Vec3I(
                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { key, type_, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PotionContainerChangeRecipesItem {
    pub input_item_id: crate::bedrock::codec::ZigZag32,
    pub ingredient_id: crate::bedrock::codec::ZigZag32,
    pub output_item_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PotionContainerChangeRecipesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.input_item_id.encode(buf)?;
        self.ingredient_id.encode(buf)?;
        self.output_item_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let input_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let ingredient_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let output_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            input_item_id,
            ingredient_id,
            output_item_id,
        })
    }
}
pub type PotionContainerChangeRecipes = Vec<PotionContainerChangeRecipesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PotionTypeRecipesItem {
    pub input_item_id: crate::bedrock::codec::ZigZag32,
    pub input_item_meta: crate::bedrock::codec::ZigZag32,
    pub ingredient_id: crate::bedrock::codec::ZigZag32,
    pub ingredient_meta: crate::bedrock::codec::ZigZag32,
    pub output_item_id: crate::bedrock::codec::ZigZag32,
    pub output_item_meta: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PotionTypeRecipesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.input_item_id.encode(buf)?;
        self.input_item_meta.encode(buf)?;
        self.ingredient_id.encode(buf)?;
        self.ingredient_meta.encode(buf)?;
        self.output_item_id.encode(buf)?;
        self.output_item_meta.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let input_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_item_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let ingredient_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let ingredient_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let output_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let output_item_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            input_item_id,
            input_item_meta,
            ingredient_id,
            ingredient_meta,
            output_item_id,
            output_item_meta,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum RecipesItemType {
    Shapeless = 0,
    Shaped = 1,
    Furnace = 2,
    FurnaceWithMetadata = 3,
    Multi = 4,
    ShulkerBox = 5,
    ShapelessChemistry = 6,
    ShapedChemistry = 7,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(RecipesItemType::Shapeless),
            1 => Ok(RecipesItemType::Shaped),
            2 => Ok(RecipesItemType::Furnace),
            3 => Ok(RecipesItemType::FurnaceWithMetadata),
            4 => Ok(RecipesItemType::Multi),
            5 => Ok(RecipesItemType::ShulkerBox),
            6 => Ok(RecipesItemType::ShapelessChemistry),
            7 => Ok(RecipesItemType::ShapedChemistry),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(RecipesItemType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnace {
    pub input_id: crate::bedrock::codec::ZigZag32,
    pub output: Item,
    pub block: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnace {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.input_id.encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let output = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { input_id, output, block })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnaceWithMetadata {
    pub input_id: crate::bedrock::codec::ZigZag32,
    pub input_meta: crate::bedrock::codec::ZigZag32,
    pub output: Item,
    pub block: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnaceWithMetadata {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.input_id.encode(buf)?;
        self.input_meta.encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let output = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            input_id,
            input_meta,
            output,
            block,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeMulti {
    pub uuid: uuid::Uuid,
    pub network_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeMulti {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { uuid, network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShaped {
    pub recipe_id: LatinString,
    pub width: crate::bedrock::codec::ZigZag32,
    pub height: crate::bedrock::codec::ZigZag32,
    pub input: Vec<Vec<RecipeIngredient>>,
    pub output: Vec<Item>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: crate::bedrock::codec::ZigZag32,
    pub network_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShaped {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        let len = self.input.len() as i32;
        len.encode(buf)?;
        for item in &self.input {
            let len = item.len() as i32;
            len.encode(buf)?;
            for item in &item {
                item.encode(buf)?;
            }
        }
        let len = self.output.len() as i32;
        len.encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        self.priority.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let width = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )? as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                    )?,
                                );
                        }
                        tmp_vec
                    });
            }
            tmp_vec
        };
        let output = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            recipe_id,
            width,
            height,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShapeless {
    pub recipe_id: LatinString,
    pub input: Vec<RecipeIngredient>,
    pub output: Vec<Item>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: crate::bedrock::codec::ZigZag32,
    pub network_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShapeless {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        let len = self.input.len() as i32;
        len.encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.output.len() as i32;
        len.encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        self.priority.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let output = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            recipe_id,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipesItemRecipe {
    Furnace(Box<RecipesItemRecipeFurnace>),
    FurnaceWithMetadata(Box<RecipesItemRecipeFurnaceWithMetadata>),
    Multi(RecipesItemRecipeMulti),
    Shaped(Box<RecipesItemRecipeShaped>),
    ShapedChemistry(Box<RecipesItemRecipeShaped>),
    Shapeless(Box<RecipesItemRecipeShapeless>),
    ShapelessChemistry(Box<RecipesItemRecipeShapeless>),
    ShulkerBox(Box<RecipesItemRecipeShapeless>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItem {
    pub type_: RecipesItemType,
    pub recipe: Option<RecipesItemRecipe>,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.recipe {
            match v {
                RecipesItemRecipe::Furnace(v) => v.encode(buf)?,
                RecipesItemRecipe::FurnaceWithMetadata(v) => v.encode(buf)?,
                RecipesItemRecipe::Multi(v) => v.encode(buf)?,
                RecipesItemRecipe::Shaped(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapedChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::Shapeless(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapelessChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::ShulkerBox(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <RecipesItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let recipe = match type_ {
            _ => {
                Some(
                    RecipesItemRecipe::Furnace(
                        Box::new(
                            <RecipesItemRecipeFurnace as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::FurnaceWithMetadata(
                        Box::new(
                            <RecipesItemRecipeFurnaceWithMetadata as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Multi(
                        <RecipesItemRecipeMulti as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Shaped(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShapedChemistry(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::Shapeless(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShapelessChemistry(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    RecipesItemRecipe::ShulkerBox(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, recipe })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum ScoreEntriesEntriesItemContentSomeEntryType {
    Player = 1,
    Entity = 2,
    FakePlayer = 3,
}
impl crate::bedrock::codec::BedrockCodec
for ScoreEntriesEntriesItemContentSomeEntryType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(ScoreEntriesEntriesItemContentSomeEntryType::Player),
            2 => Ok(ScoreEntriesEntriesItemContentSomeEntryType::Entity),
            3 => Ok(ScoreEntriesEntriesItemContentSomeEntryType::FakePlayer),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ScoreEntriesEntriesItemContentSomeEntryType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreEntriesEntriesItemContentSome {
    pub entry_type: ScoreEntriesEntriesItemContentSomeEntryType,
    pub entity_unique_id: Option<ScoreEntriesEntriesItemContentSomeEntityUniqueID>,
    pub custom_name: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for ScoreEntriesEntriesItemContentSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entry_type.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            match v {
                ScoreEntriesEntriesItemContentSomeEntityUniqueID::Entity(v) => {
                    v.encode(buf)?
                }
                ScoreEntriesEntriesItemContentSomeEntityUniqueID::Player(v) => {
                    v.encode(buf)?
                }
            }
        }
        if let Some(v) = &self.custom_name {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entry_type = <ScoreEntriesEntriesItemContentSomeEntryType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_unique_id = match entry_type {
            _ => {
                Some(
                    ScoreEntriesEntriesItemContentSomeEntityUniqueID::Entity(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ScoreEntriesEntriesItemContentSomeEntityUniqueID::Player(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let custom_name = match entry_type {
            _ => Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        Ok(Self {
            entry_type,
            entity_unique_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreEntriesEntriesItem {
    pub scoreboard_id: crate::bedrock::codec::ZigZag64,
    pub objective_name: String,
    pub score: i32,
    pub content: Option<ScoreEntriesEntriesItemContentSome>,
}
impl crate::bedrock::codec::BedrockCodec for ScoreEntriesEntriesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.scoreboard_id.encode(buf)?;
        self.objective_name.encode(buf)?;
        self.score.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let score = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content = match type_ {
            _ => {
                Some(
                    <ScoreEntriesEntriesItemContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            objective_name,
            score,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyTransactionsItemChangedSlotsItem {
    pub slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionLegacyTransactionsItemChangedSlotsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyTransactionsItem {
    pub container_id: u8,
    pub changed_slots: Vec<TransactionLegacyTransactionsItemChangedSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacyTransactionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        let len = self.changed_slots.len() as i32;
        len.encode(buf)?;
        for item in &self.changed_slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let changed_slots = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionLegacyTransactionsItemChangedSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            container_id,
            changed_slots,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionInventoryActionsItemSourceType {
    Container = 0,
    Global = 1,
    WorldInteraction = 2,
    Creative = 3,
    CraftSlot = 100,
    Craft = 99999,
}
impl crate::bedrock::codec::BedrockCodec for TransactionInventoryActionsItemSourceType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionInventoryActionsItemSourceType::Container),
            1 => Ok(TransactionInventoryActionsItemSourceType::Global),
            2 => Ok(TransactionInventoryActionsItemSourceType::WorldInteraction),
            3 => Ok(TransactionInventoryActionsItemSourceType::Creative),
            100 => Ok(TransactionInventoryActionsItemSourceType::CraftSlot),
            99999 => Ok(TransactionInventoryActionsItemSourceType::Craft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionInventoryActionsItemSourceType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItemContentContainer {
    pub inventory_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionInventoryActionsItemContentContainer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.inventory_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let inventory_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { inventory_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItemContentCraft {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionInventoryActionsItemContentCraft {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { action })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItemContentWorldInteraction {
    pub flags: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionInventoryActionsItemContentWorldInteraction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.flags.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionInventoryActionsItemContent {
    Container(TransactionInventoryActionsItemContentContainer),
    Craft(TransactionInventoryActionsItemContentCraft),
    CraftSlot(TransactionInventoryActionsItemContentCraft),
    Creative(TransactionInventoryActionsItemContentContainer),
    WorldInteraction(TransactionInventoryActionsItemContentWorldInteraction),
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItem {
    pub source_type: TransactionInventoryActionsItemSourceType,
    pub content: Option<TransactionInventoryActionsItemContent>,
    pub slot: i32,
    pub old_item: Item,
    pub new_item: Item,
    pub new_item_stack_id: Option<crate::bedrock::codec::ZigZag32>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionInventoryActionsItem {
    fn encode<B: bytes::BufMut>(&self, _buf: &mut B) -> Result<(), std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to encode",
            ),
        )
    }
    fn decode<B: bytes::Buf>(_buf: &mut B) -> Result<Self, std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to decode",
            ),
        )
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemReleaseActionType {
    Release = 0,
    Consume = 1,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemReleaseActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionTransactionDataItemReleaseActionType::Release),
            1 => Ok(TransactionTransactionDataItemReleaseActionType::Consume),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemReleaseActionType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemRelease {
    pub action_type: TransactionTransactionDataItemReleaseActionType,
    pub hotbar_slot: crate::bedrock::codec::ZigZag32,
    pub held_item: Item,
    pub head_pos: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemRelease {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.held_item.encode(buf)?;
        self.head_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_type = <TransactionTransactionDataItemReleaseActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            action_type,
            hotbar_slot,
            held_item,
            head_pos,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemUseActionType {
    ClickBlock = 0,
    ClickAir = 1,
    BreakBlock = 2,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemUseActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionTransactionDataItemUseActionType::ClickBlock),
            1 => Ok(TransactionTransactionDataItemUseActionType::ClickAir),
            2 => Ok(TransactionTransactionDataItemUseActionType::BreakBlock),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemUseActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemUse {
    pub action_type: TransactionTransactionDataItemUseActionType,
    pub block_position: BlockCoordinates,
    pub face: i32,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
    pub block_runtime_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemUse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.block_position.encode(buf)?;
        self.face.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_type = <TransactionTransactionDataItemUseActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hotbar_slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            action_type,
            block_position,
            face,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
            block_runtime_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum WindowID {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
}
impl crate::bedrock::codec::BedrockCodec for WindowID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            -100 => Ok(WindowID::DropContents),
            -24 => Ok(WindowID::Beacon),
            -23 => Ok(WindowID::TradingOutput),
            -22 => Ok(WindowID::TradingUseInputs),
            -21 => Ok(WindowID::TradingInput2),
            -20 => Ok(WindowID::TradingInput1),
            -17 => Ok(WindowID::EnchantOutput),
            -16 => Ok(WindowID::EnchantMaterial),
            -15 => Ok(WindowID::EnchantInput),
            -13 => Ok(WindowID::AnvilOutput),
            -12 => Ok(WindowID::AnvilResult),
            -11 => Ok(WindowID::AnvilMaterial),
            -10 => Ok(WindowID::ContainerInput),
            -5 => Ok(WindowID::CraftingUseIngredient),
            -4 => Ok(WindowID::CraftingResult),
            -3 => Ok(WindowID::CraftingRemoveIngredient),
            -2 => Ok(WindowID::CraftingAddIngredient),
            -1 => Ok(WindowID::None),
            0 => Ok(WindowID::Inventory),
            1 => Ok(WindowID::First),
            100 => Ok(WindowID::Last),
            119 => Ok(WindowID::Offhand),
            120 => Ok(WindowID::Armor),
            121 => Ok(WindowID::Creative),
            122 => Ok(WindowID::Hotbar),
            123 => Ok(WindowID::FixedInventory),
            124 => Ok(WindowID::Ui),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum WindowIDVarint {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
}
impl crate::bedrock::codec::BedrockCodec for WindowIDVarint {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            -100 => Ok(WindowIDVarint::DropContents),
            -24 => Ok(WindowIDVarint::Beacon),
            -23 => Ok(WindowIDVarint::TradingOutput),
            -22 => Ok(WindowIDVarint::TradingUseInputs),
            -21 => Ok(WindowIDVarint::TradingInput2),
            -20 => Ok(WindowIDVarint::TradingInput1),
            -17 => Ok(WindowIDVarint::EnchantOutput),
            -16 => Ok(WindowIDVarint::EnchantMaterial),
            -15 => Ok(WindowIDVarint::EnchantInput),
            -13 => Ok(WindowIDVarint::AnvilOutput),
            -12 => Ok(WindowIDVarint::AnvilResult),
            -11 => Ok(WindowIDVarint::AnvilMaterial),
            -10 => Ok(WindowIDVarint::ContainerInput),
            -5 => Ok(WindowIDVarint::CraftingUseIngredient),
            -4 => Ok(WindowIDVarint::CraftingResult),
            -3 => Ok(WindowIDVarint::CraftingRemoveIngredient),
            -2 => Ok(WindowIDVarint::CraftingAddIngredient),
            -1 => Ok(WindowIDVarint::None),
            0 => Ok(WindowIDVarint::Inventory),
            1 => Ok(WindowIDVarint::First),
            100 => Ok(WindowIDVarint::Last),
            119 => Ok(WindowIDVarint::Offhand),
            120 => Ok(WindowIDVarint::Armor),
            121 => Ok(WindowIDVarint::Creative),
            122 => Ok(WindowIDVarint::Hotbar),
            123 => Ok(WindowIDVarint::FixedInventory),
            124 => Ok(WindowIDVarint::Ui),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowIDVarint),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum WindowType {
    Container = 0,
    Workbench = 1,
    Furnace = 2,
    Enchantment = 3,
    BrewingStand = 4,
    Anvil = 5,
    Dispenser = 6,
    Dropper = 7,
    Hopper = 8,
    Cauldron = 9,
    MinecartChest = 10,
    MinecartHopper = 11,
    Horse = 12,
    Beacon = 13,
    StructureEditor = 14,
    Trading = 15,
    CommandBlock = 16,
    Jukebox = 17,
    Armor = 18,
    Hand = 19,
    CompoundCreator = 20,
    ElementConstructor = 21,
    MaterialReducer = 22,
    LabTable = 23,
    Loom = 24,
    Lectern = 25,
    Grindstone = 26,
    BlastFurnace = 27,
    Smoker = 28,
    Stonecutter = 29,
    Cartography = 30,
    Hud = 31,
    JigsawEditor = 32,
    SmithingTable = 33,
}
impl crate::bedrock::codec::BedrockCodec for WindowType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(WindowType::Container),
            1 => Ok(WindowType::Workbench),
            2 => Ok(WindowType::Furnace),
            3 => Ok(WindowType::Enchantment),
            4 => Ok(WindowType::BrewingStand),
            5 => Ok(WindowType::Anvil),
            6 => Ok(WindowType::Dispenser),
            7 => Ok(WindowType::Dropper),
            8 => Ok(WindowType::Hopper),
            9 => Ok(WindowType::Cauldron),
            10 => Ok(WindowType::MinecartChest),
            11 => Ok(WindowType::MinecartHopper),
            12 => Ok(WindowType::Horse),
            13 => Ok(WindowType::Beacon),
            14 => Ok(WindowType::StructureEditor),
            15 => Ok(WindowType::Trading),
            16 => Ok(WindowType::CommandBlock),
            17 => Ok(WindowType::Jukebox),
            18 => Ok(WindowType::Armor),
            19 => Ok(WindowType::Hand),
            20 => Ok(WindowType::CompoundCreator),
            21 => Ok(WindowType::ElementConstructor),
            22 => Ok(WindowType::MaterialReducer),
            23 => Ok(WindowType::LabTable),
            24 => Ok(WindowType::Loom),
            25 => Ok(WindowType::Lectern),
            26 => Ok(WindowType::Grindstone),
            27 => Ok(WindowType::BlastFurnace),
            28 => Ok(WindowType::Smoker),
            29 => Ok(WindowType::Stonecutter),
            30 => Ok(WindowType::Cartography),
            31 => Ok(WindowType::Hud),
            32 => Ok(WindowType::JigsawEditor),
            33 => Ok(WindowType::SmithingTable),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketAvailableCommandsEnumsItemValuesItem {
    Byte(u8),
    Int(u32),
    Short(u16),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumsItem {
    pub name: String,
    pub values: Vec<Option<PacketAvailableCommandsEnumsItemValuesItem>>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsEnumsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len() as i32;
        len.encode(buf)?;
        for item in &self.values {
            if let Some(v) = &item {
                match v {
                    PacketAvailableCommandsEnumsItemValuesItem::Byte(v) => v.encode(buf)?,
                    PacketAvailableCommandsEnumsItemValuesItem::Int(v) => v.encode(buf)?,
                    PacketAvailableCommandsEnumsItemValuesItem::Short(v) => {
                        v.encode(buf)?
                    }
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let values = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match enum_type {
                            _ => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Byte(
                                        <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Int(
                                        <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Short(
                                        <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItem {
    pub name: String,
    pub description: String,
    pub flags: u8,
    pub permission_level: u8,
    pub alias: i32,
    pub overloads: Vec<PacketAvailableCommandsCommandDataItemOverloadsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsCommandDataItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.description.encode(buf)?;
        self.flags.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.alias.encode(buf)?;
        let len = self.overloads.len() as i32;
        len.encode(buf)?;
        for item in &self.overloads {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let description = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let permission_level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let alias = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let overloads = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            name,
            description,
            flags,
            permission_level,
            alias,
            overloads,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsDynamicEnumsItem {
    pub name: String,
    pub values: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsDynamicEnumsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len() as i32;
        len.encode(buf)?;
        for item in &self.values {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let values = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    CheatsEnabled = 0,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::CheatsEnabled,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    pub constraint: PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.constraint.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let constraint = <PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { constraint })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItem {
    pub value_index: i32,
    pub enum_index: i32,
    pub constraints: Vec<PacketAvailableCommandsEnumConstraintsItemConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsEnumConstraintsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.value_index.encode(buf)?;
        self.enum_index.encode(buf)?;
        let len = self.constraints.len() as i32;
        len.encode(buf)?;
        for item in &self.constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let value_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enum_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let constraints = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItemConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            value_index,
            enum_index,
            constraints,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketBookEditType {
    ReplacePage = 0,
    AddPage = 1,
    DeletePage = 2,
    SwapPages = 3,
    Sign = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketBookEditType::ReplacePage),
            1 => Ok(PacketBookEditType::AddPage),
            2 => Ok(PacketBookEditType::DeletePage),
            3 => Ok(PacketBookEditType::SwapPages),
            4 => Ok(PacketBookEditType::Sign),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBookEditType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentAddPage {
    pub page_number: u8,
    pub text: String,
    pub photo_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentAddPage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_number.encode(buf)?;
        self.text.encode(buf)?;
        self.photo_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let photo_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            page_number,
            text,
            photo_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentDeletePage {
    pub page_number: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentDeletePage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_number.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { page_number })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentSign {
    pub title: String,
    pub author: String,
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentSign {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.author.encode(buf)?;
        self.xuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let author = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { title, author, xuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentSwapPages {
    pub page1: u8,
    pub page2: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentSwapPages {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page1.encode(buf)?;
        self.page2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let page1 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let page2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { page1, page2 })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketBookEditContent {
    AddPage(PacketBookEditContentAddPage),
    DeletePage(PacketBookEditContentDeletePage),
    ReplacePage(PacketBookEditContentAddPage),
    Sign(PacketBookEditContentSign),
    SwapPages(PacketBookEditContentSwapPages),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEdit {
    pub type_: PacketBookEditType,
    pub slot: u8,
    pub content: Option<PacketBookEditContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEdit {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.slot.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketBookEditContent::AddPage(v) => v.encode(buf)?,
                PacketBookEditContent::DeletePage(v) => v.encode(buf)?,
                PacketBookEditContent::ReplacePage(v) => v.encode(buf)?,
                PacketBookEditContent::Sign(v) => v.encode(buf)?,
                PacketBookEditContent::SwapPages(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <PacketBookEditType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content = match type_ {
            _ => {
                Some(
                    PacketBookEditContent::AddPage(
                        <PacketBookEditContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBookEditContent::DeletePage(
                        <PacketBookEditContentDeletePage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBookEditContent::ReplacePage(
                        <PacketBookEditContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBookEditContent::Sign(
                        <PacketBookEditContentSign as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBookEditContent::SwapPages(
                        <PacketBookEditContentSwapPages as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, slot, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandOutputOutputItem {
    pub success: bool,
    pub message_id: String,
    pub parameters: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandOutputOutputItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.success.encode(buf)?;
        self.message_id.encode(buf)?;
        let len = self.parameters.len() as i32;
        len.encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let success = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let message_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let parameters = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            success,
            message_id,
            parameters,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCompletedUsingItemUseMethod {
    EquipArmor = 0,
    Eat = 1,
    Attack = 2,
    Consume = 3,
    Throw = 4,
    Shoot = 5,
    Place = 6,
    FillBottle = 7,
    FillBucket = 8,
    PourBucket = 9,
    UseTool = 10,
    Interact = 11,
    Retrieved = 12,
    Dyed = 13,
    Traded = 14,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItemUseMethod {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCompletedUsingItemUseMethod::EquipArmor),
            1 => Ok(PacketCompletedUsingItemUseMethod::Eat),
            2 => Ok(PacketCompletedUsingItemUseMethod::Attack),
            3 => Ok(PacketCompletedUsingItemUseMethod::Consume),
            4 => Ok(PacketCompletedUsingItemUseMethod::Throw),
            5 => Ok(PacketCompletedUsingItemUseMethod::Shoot),
            6 => Ok(PacketCompletedUsingItemUseMethod::Place),
            7 => Ok(PacketCompletedUsingItemUseMethod::FillBottle),
            8 => Ok(PacketCompletedUsingItemUseMethod::FillBucket),
            9 => Ok(PacketCompletedUsingItemUseMethod::PourBucket),
            10 => Ok(PacketCompletedUsingItemUseMethod::UseTool),
            11 => Ok(PacketCompletedUsingItemUseMethod::Interact),
            12 => Ok(PacketCompletedUsingItemUseMethod::Retrieved),
            13 => Ok(PacketCompletedUsingItemUseMethod::Dyed),
            14 => Ok(PacketCompletedUsingItemUseMethod::Traded),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCompletedUsingItemUseMethod), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCompletedUsingItem {
    pub used_item_id: i16,
    pub use_method: PacketCompletedUsingItemUseMethod,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.used_item_id.encode(buf)?;
        self.use_method.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let used_item_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let use_method = <PacketCompletedUsingItemUseMethod as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { used_item_id, use_method })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerClose {
    pub window_id: WindowID,
    pub server: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerClose {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let server = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { window_id, server })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerOpen {
    pub window_id: WindowID,
    pub window_type: WindowType,
    pub coordinates: BlockCoordinates,
    pub runtime_entity_id: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerOpen {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.coordinates.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            window_id,
            window_type,
            coordinates,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerSetData {
    pub window_id: WindowID,
    pub property: crate::bedrock::codec::ZigZag32,
    pub value: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerSetData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.property.encode(buf)?;
        self.value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let property = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { window_id, property, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingData {
    pub recipes: Recipes,
    pub potion_type_recipes: PotionTypeRecipes,
    pub potion_container_recipes: PotionContainerChangeRecipes,
    pub is_clean: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipes.encode(buf)?;
        self.potion_type_recipes.encode(buf)?;
        self.potion_container_recipes.encode(buf)?;
        self.is_clean.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipes = <Recipes as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let potion_type_recipes = <PotionTypeRecipes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let potion_container_recipes = <PotionContainerChangeRecipes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let is_clean = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipes,
            potion_type_recipes,
            potion_container_recipes,
            is_clean,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCraftingEventRecipeType {
    Inventory = 0,
    Crafting = 1,
    Workbench = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingEventRecipeType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCraftingEventRecipeType::Inventory),
            1 => Ok(PacketCraftingEventRecipeType::Crafting),
            2 => Ok(PacketCraftingEventRecipeType::Workbench),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCraftingEventRecipeType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingEvent {
    pub window_id: WindowID,
    pub recipe_type: PacketCraftingEventRecipeType,
    pub recipe_id: uuid::Uuid,
    pub input: Vec<Item>,
    pub result: Vec<Item>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.recipe_type.encode(buf)?;
        self.recipe_id.encode(buf)?;
        let len = self.input.len() as i32;
        len.encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.result.len() as i32;
        len.encode(buf)?;
        for item in &self.result {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let recipe_type = <PacketCraftingEventRecipeType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let recipe_id = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let result = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            window_id,
            recipe_type,
            recipe_id,
            input,
            result,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGuiDataPickItem {}
impl crate::bedrock::codec::BedrockCodec for PacketGuiDataPickItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryContent {
    pub inventory_id: WindowIDVarint,
    pub input: ItemStacks,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.inventory_id.encode(buf)?;
        self.input.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let inventory_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = <ItemStacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { inventory_id, input })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventorySlot {
    pub window_id: WindowIDVarint,
    pub slot: i32,
    pub item: ItemStack,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventorySlot {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.slot.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <ItemStack as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { window_id, slot, item })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryTransaction {
    pub transaction: Transaction,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryTransaction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.transaction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let transaction = <Transaction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { transaction })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemComponent {
    pub entries: ItemComponentList,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemComponent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entries.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entries = <ItemComponentList as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemFrameDropItem {
    pub coordinates: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemFrameDropItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { coordinates })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemStackRequest {
    pub requests: ItemStackRequests,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemStackRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.requests.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let requests = <ItemStackRequests as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { requests })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemStackResponse {
    pub responses: ItemStackResponses,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemStackResponse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.responses.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let responses = <ItemStackResponses as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { responses })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateTrade {
    pub window_id: WindowID,
    pub window_type: WindowType,
    pub size: i32,
    pub trade_tier: i32,
    pub villager_unique_id: i64,
    pub entity_unique_id: i64,
    pub display_name: String,
    pub new_trading_ui: bool,
    pub economic_trades: bool,
    pub offers: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateTrade {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.size.encode(buf)?;
        self.trade_tier.encode(buf)?;
        self.villager_unique_id.encode(buf)?;
        self.entity_unique_id.encode(buf)?;
        self.display_name.encode(buf)?;
        self.new_trading_ui.encode(buf)?;
        self.economic_trades.encode(buf)?;
        self.offers.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let size = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let trade_tier = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let villager_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_unique_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let new_trading_ui = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let economic_trades = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let offers = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            window_id,
            window_type,
            size,
            trade_tier,
            villager_unique_id,
            entity_unique_id,
            display_name,
            new_trading_ui,
            economic_trades,
            offers,
        })
    }
}
