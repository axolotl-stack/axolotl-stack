// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOriginPlayerEntityIDDevConsole {
    pub player_entity_id: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginPlayerEntityIDDevConsole {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.player_entity_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let player_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { player_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum CommandOriginPlayerEntityID {
    DevConsole(CommandOriginPlayerEntityIDDevConsole),
    Test(CommandOriginPlayerEntityIDDevConsole),
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct DeltaMoveFlags : u16 {}
}
#[derive(Debug, Clone, PartialEq)]
pub struct EntityAttributesItem {
    pub name: String,
    pub min: f32,
    pub value: f32,
    pub max: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntityAttributesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.min.encode(buf)?;
        self.value.encode(buf)?;
        self.max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let value = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { name, min, value, max })
    }
}
pub type EntityAttributes = Vec<EntityAttributesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum LegacyEntityType {
    Chicken = 10,
    Cow = 11,
    Pig = 12,
    Sheep = 13,
    Wolf = 14,
    Villager = 15,
    Mooshroom = 16,
    Squid = 17,
    Rabbit = 18,
    Bat = 19,
    IronGolem = 20,
    SnowGolem = 21,
    Ocelot = 22,
    Horse = 23,
    Donkey = 24,
    Mule = 25,
    SkeletonHorse = 26,
    ZombieHorse = 27,
    PolarBear = 28,
    Llama = 29,
    Parrot = 30,
    Dolphin = 31,
    Zombie = 32,
    Creeper = 33,
    Skeleton = 34,
    Spider = 35,
    ZombiePigman = 36,
    Slime = 37,
    Enderman = 38,
    Silverfish = 39,
    CaveSpider = 40,
    Ghast = 41,
    MagmaCube = 42,
    Blaze = 43,
    ZombieVillager = 44,
    Witch = 45,
    Stray = 46,
    Husk = 47,
    WitherSkeleton = 48,
    Guardian = 49,
    ElderGuardian = 50,
    Npc = 51,
    Wither = 52,
    EnderDragon = 53,
    Shulker = 54,
    Endermite = 55,
    Agent = 56,
    Vindicator = 57,
    Phantom = 58,
    ArmorStand = 61,
    TripodCamera = 62,
    Player = 63,
    Item = 64,
    Tnt = 65,
    FallingBlock = 66,
    MovingBlock = 67,
    XpBottle = 68,
    XpOrb = 69,
    EyeOfEnderSignal = 70,
    EnderCrystal = 71,
    FireworksRocket = 72,
    ThrownTrident = 73,
    Turtle = 74,
    Cat = 75,
    ShulkerBullet = 76,
    FishingHook = 77,
    Chalkboard = 78,
    DragonFireball = 79,
    Arrow = 80,
    Snowball = 81,
    Egg = 82,
    Painting = 83,
    Minecart = 84,
    Fireball = 85,
    SplashPotion = 86,
    EnderPearl = 87,
    LeashKnot = 88,
    WitherSkull = 89,
    Boat = 90,
    WitherSkullDangerous = 91,
    LightningBolt = 93,
    SmallFireball = 94,
    AreaEffectCloud = 95,
    HopperMinecart = 96,
    TntMinecart = 97,
    ChestMinecart = 98,
    CommandBlockMinecart = 100,
    LingeringPotion = 101,
    LlamaSpit = 102,
    EvocationFang = 103,
    EvocationIllager = 104,
    Vex = 105,
    IceBomb = 106,
    Balloon = 107,
    Pufferfish = 108,
    Salmon = 109,
    Drowned = 110,
    Tropicalfish = 111,
    Cod = 112,
    Panda = 113,
}
impl crate::bedrock::codec::BedrockCodec for LegacyEntityType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            10 => Ok(LegacyEntityType::Chicken),
            11 => Ok(LegacyEntityType::Cow),
            12 => Ok(LegacyEntityType::Pig),
            13 => Ok(LegacyEntityType::Sheep),
            14 => Ok(LegacyEntityType::Wolf),
            15 => Ok(LegacyEntityType::Villager),
            16 => Ok(LegacyEntityType::Mooshroom),
            17 => Ok(LegacyEntityType::Squid),
            18 => Ok(LegacyEntityType::Rabbit),
            19 => Ok(LegacyEntityType::Bat),
            20 => Ok(LegacyEntityType::IronGolem),
            21 => Ok(LegacyEntityType::SnowGolem),
            22 => Ok(LegacyEntityType::Ocelot),
            23 => Ok(LegacyEntityType::Horse),
            24 => Ok(LegacyEntityType::Donkey),
            25 => Ok(LegacyEntityType::Mule),
            26 => Ok(LegacyEntityType::SkeletonHorse),
            27 => Ok(LegacyEntityType::ZombieHorse),
            28 => Ok(LegacyEntityType::PolarBear),
            29 => Ok(LegacyEntityType::Llama),
            30 => Ok(LegacyEntityType::Parrot),
            31 => Ok(LegacyEntityType::Dolphin),
            32 => Ok(LegacyEntityType::Zombie),
            33 => Ok(LegacyEntityType::Creeper),
            34 => Ok(LegacyEntityType::Skeleton),
            35 => Ok(LegacyEntityType::Spider),
            36 => Ok(LegacyEntityType::ZombiePigman),
            37 => Ok(LegacyEntityType::Slime),
            38 => Ok(LegacyEntityType::Enderman),
            39 => Ok(LegacyEntityType::Silverfish),
            40 => Ok(LegacyEntityType::CaveSpider),
            41 => Ok(LegacyEntityType::Ghast),
            42 => Ok(LegacyEntityType::MagmaCube),
            43 => Ok(LegacyEntityType::Blaze),
            44 => Ok(LegacyEntityType::ZombieVillager),
            45 => Ok(LegacyEntityType::Witch),
            46 => Ok(LegacyEntityType::Stray),
            47 => Ok(LegacyEntityType::Husk),
            48 => Ok(LegacyEntityType::WitherSkeleton),
            49 => Ok(LegacyEntityType::Guardian),
            50 => Ok(LegacyEntityType::ElderGuardian),
            51 => Ok(LegacyEntityType::Npc),
            52 => Ok(LegacyEntityType::Wither),
            53 => Ok(LegacyEntityType::EnderDragon),
            54 => Ok(LegacyEntityType::Shulker),
            55 => Ok(LegacyEntityType::Endermite),
            56 => Ok(LegacyEntityType::Agent),
            57 => Ok(LegacyEntityType::Vindicator),
            58 => Ok(LegacyEntityType::Phantom),
            61 => Ok(LegacyEntityType::ArmorStand),
            62 => Ok(LegacyEntityType::TripodCamera),
            63 => Ok(LegacyEntityType::Player),
            64 => Ok(LegacyEntityType::Item),
            65 => Ok(LegacyEntityType::Tnt),
            66 => Ok(LegacyEntityType::FallingBlock),
            67 => Ok(LegacyEntityType::MovingBlock),
            68 => Ok(LegacyEntityType::XpBottle),
            69 => Ok(LegacyEntityType::XpOrb),
            70 => Ok(LegacyEntityType::EyeOfEnderSignal),
            71 => Ok(LegacyEntityType::EnderCrystal),
            72 => Ok(LegacyEntityType::FireworksRocket),
            73 => Ok(LegacyEntityType::ThrownTrident),
            74 => Ok(LegacyEntityType::Turtle),
            75 => Ok(LegacyEntityType::Cat),
            76 => Ok(LegacyEntityType::ShulkerBullet),
            77 => Ok(LegacyEntityType::FishingHook),
            78 => Ok(LegacyEntityType::Chalkboard),
            79 => Ok(LegacyEntityType::DragonFireball),
            80 => Ok(LegacyEntityType::Arrow),
            81 => Ok(LegacyEntityType::Snowball),
            82 => Ok(LegacyEntityType::Egg),
            83 => Ok(LegacyEntityType::Painting),
            84 => Ok(LegacyEntityType::Minecart),
            85 => Ok(LegacyEntityType::Fireball),
            86 => Ok(LegacyEntityType::SplashPotion),
            87 => Ok(LegacyEntityType::EnderPearl),
            88 => Ok(LegacyEntityType::LeashKnot),
            89 => Ok(LegacyEntityType::WitherSkull),
            90 => Ok(LegacyEntityType::Boat),
            91 => Ok(LegacyEntityType::WitherSkullDangerous),
            93 => Ok(LegacyEntityType::LightningBolt),
            94 => Ok(LegacyEntityType::SmallFireball),
            95 => Ok(LegacyEntityType::AreaEffectCloud),
            96 => Ok(LegacyEntityType::HopperMinecart),
            97 => Ok(LegacyEntityType::TntMinecart),
            98 => Ok(LegacyEntityType::ChestMinecart),
            100 => Ok(LegacyEntityType::CommandBlockMinecart),
            101 => Ok(LegacyEntityType::LingeringPotion),
            102 => Ok(LegacyEntityType::LlamaSpit),
            103 => Ok(LegacyEntityType::EvocationFang),
            104 => Ok(LegacyEntityType::EvocationIllager),
            105 => Ok(LegacyEntityType::Vex),
            106 => Ok(LegacyEntityType::IceBomb),
            107 => Ok(LegacyEntityType::Balloon),
            108 => Ok(LegacyEntityType::Pufferfish),
            109 => Ok(LegacyEntityType::Salmon),
            110 => Ok(LegacyEntityType::Drowned),
            111 => Ok(LegacyEntityType::Tropicalfish),
            112 => Ok(LegacyEntityType::Cod),
            113 => Ok(LegacyEntityType::Panda),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(LegacyEntityType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerAttributesItem {
    pub min: f32,
    pub max: f32,
    pub current: f32,
    pub default: f32,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        self.current.encode(buf)?;
        self.default.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let current = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let default = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            min,
            max,
            current,
            default,
            name,
        })
    }
}
pub type PlayerAttributes = Vec<PlayerAttributesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PlayerRecordsType {
    Add = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PlayerRecordsType::Add),
            1 => Ok(PlayerRecordsType::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PlayerRecordsType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemAdd {
    pub uuid: uuid::Uuid,
    pub entity_unique_id: crate::bedrock::codec::ZigZag64,
    pub username: String,
    pub xbox_user_id: String,
    pub platform_chat_id: String,
    pub build_platform: i32,
    pub skin_data: Skin,
    pub is_teacher: bool,
    pub is_host: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemAdd {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.entity_unique_id.encode(buf)?;
        self.username.encode(buf)?;
        self.xbox_user_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.build_platform.encode(buf)?;
        self.skin_data.encode(buf)?;
        self.is_teacher.encode(buf)?;
        self.is_host.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let xbox_user_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let build_platform = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_data = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_teacher = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_host = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            entity_unique_id,
            username,
            xbox_user_id,
            platform_chat_id,
            build_platform,
            skin_data,
            is_teacher,
            is_host,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemRemove {
    pub uuid: uuid::Uuid,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemRemove {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { uuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerRecordsRecordsItem {
    Add(Box<PlayerRecordsRecordsItemAdd>),
    Remove(PlayerRecordsRecordsItemRemove),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Vec<bool>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.records_count.encode(buf)?;
        let len = self.records.len() as i32;
        len.encode(buf)?;
        for item in &self.records {
            if let Some(v) = &item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => v.encode(buf)?,
                    PlayerRecordsRecordsItem::Remove(v) => v.encode(buf)?,
                }
            }
        }
        let len = self.verified.len() as i32;
        len.encode(buf)?;
        for item in &self.verified {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let records_count = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let records = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            _ => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        let verified = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ScoreEntriesEntriesItemContentSomeEntityUniqueID {
    Entity(crate::bedrock::codec::ZigZag64),
    Player(crate::bedrock::codec::ZigZag64),
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum ScoreboardIdentityEntriesType {
    TypeRegisterIdentity = 0,
    TypeClearIdentity = 1,
}
impl crate::bedrock::codec::BedrockCodec for ScoreboardIdentityEntriesType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ScoreboardIdentityEntriesType::TypeRegisterIdentity),
            1 => Ok(ScoreboardIdentityEntriesType::TypeClearIdentity),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ScoreboardIdentityEntriesType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreboardIdentityEntriesEntriesItem {
    pub scoreboard_id: crate::bedrock::codec::ZigZag64,
    pub entity_unique_id: Option<crate::bedrock::codec::ZigZag64>,
}
impl crate::bedrock::codec::BedrockCodec for ScoreboardIdentityEntriesEntriesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.scoreboard_id.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_unique_id = match type_ {
            _ => {
                Some(
                    <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreboardIdentityEntries {
    pub type_: ScoreboardIdentityEntriesType,
    pub entries: Vec<ScoreboardIdentityEntriesEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for ScoreboardIdentityEntries {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        let len = self.entries.len() as i32;
        len.encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <ScoreboardIdentityEntriesType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entries = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ScoreboardIdentityEntriesEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { type_, entries })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemUseOnEntityActionType {
    Interact = 0,
    Attack = 1,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemUseOnEntityActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Interact),
            1 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Attack),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemUseOnEntityActionType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemUseOnEntity {
    pub entity_runtime_id: i64,
    pub action_type: TransactionTransactionDataItemUseOnEntityActionType,
    pub hotbar_slot: crate::bedrock::codec::ZigZag32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemUseOnEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_runtime_id.encode(buf)?;
        self.action_type.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action_type = <TransactionTransactionDataItemUseOnEntityActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_runtime_id,
            action_type,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEcsEntity {
    pub network_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEcsEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i32,
    pub entity_type: String,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.attributes.encode(buf)?;
        self.metadata.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let attributes = <EntityAttributes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            entity_type,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            pitch,
            yaw,
            head_yaw,
            attributes,
            metadata,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddItemEntity {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i32,
    pub item: Item,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub metadata: MetadataDictionary,
    pub is_from_fishing: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddItemEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.item.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.metadata.encode(buf)?;
        self.is_from_fishing.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let is_from_fishing = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            item,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            metadata,
            is_from_fishing,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i32,
    pub platform_chat_id: String,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub metadata: MetadataDictionary,
    pub flags: i32,
    pub command_permission: i32,
    pub action_permissions: i32,
    pub permission_level: i32,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
    pub links: Links,
    pub device_id: String,
    pub device_os: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.held_item.encode(buf)?;
        self.metadata.encode(buf)?;
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.custom_stored_permissions.encode(buf)?;
        self.user_id.encode(buf)?;
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let command_permission = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let permission_level = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let custom_stored_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_os = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            username,
            entity_id_self,
            runtime_entity_id,
            platform_chat_id,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            pitch,
            yaw,
            head_yaw,
            held_item,
            metadata,
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAnimateActionID {
    None = 0,
    SwingArm = 1,
    Unknown = 2,
    WakeUp = 3,
    CriticalHit = 4,
    MagicCriticalHit = 5,
    RowRight = 128,
    RowLeft = 129,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateActionID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketAnimateActionID::None),
            1 => Ok(PacketAnimateActionID::SwingArm),
            2 => Ok(PacketAnimateActionID::Unknown),
            3 => Ok(PacketAnimateActionID::WakeUp),
            4 => Ok(PacketAnimateActionID::CriticalHit),
            5 => Ok(PacketAnimateActionID::MagicCriticalHit),
            128 => Ok(PacketAnimateActionID::RowRight),
            129 => Ok(PacketAnimateActionID::RowLeft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAnimateActionID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimateContentRowLeft {
    pub boat_rowing_time: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateContentRowLeft {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.boat_rowing_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let boat_rowing_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { boat_rowing_time })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketAnimateContent {
    RowLeft(PacketAnimateContentRowLeft),
    RowRight(PacketAnimateContentRowLeft),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimate {
    pub action_id: PacketAnimateActionID,
    pub runtime_entity_id: i64,
    pub content: Option<PacketAnimateContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_id.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketAnimateContent::RowLeft(v) => v.encode(buf)?,
                PacketAnimateContent::RowRight(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_id = <PacketAnimateActionID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match action_id {
            _ => {
                Some(
                    PacketAnimateContent::RowLeft(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketAnimateContent::RowRight(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            action_id,
            runtime_entity_id,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimateEntity {
    pub animation: String,
    pub next_state: String,
    pub stop_condition: String,
    pub controller: String,
    pub blend_out_time: f32,
    pub runtime_entity_ids: Vec<i64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.animation.encode(buf)?;
        self.next_state.encode(buf)?;
        self.stop_condition.encode(buf)?;
        self.controller.encode(buf)?;
        self.blend_out_time.encode(buf)?;
        let len = self.runtime_entity_ids.len() as i32;
        len.encode(buf)?;
        for item in &self.runtime_entity_ids {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let animation = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let next_state = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let stop_condition = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let controller = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let blend_out_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let runtime_entity_ids = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            animation,
            next_state,
            stop_condition,
            controller,
            blend_out_time,
            runtime_entity_ids,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    Int = 1,
    Float = 2,
    Value = 3,
    WildcardInt = 4,
    Operator = 5,
    Target = 6,
    FilePath = 14,
    String = 29,
    Position = 37,
    Message = 41,
    RawText = 43,
    Json = 46,
    Command = 53,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Int,
                )
            }
            2 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Float,
                )
            }
            3 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Value,
                )
            }
            4 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardInt,
                )
            }
            5 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Operator,
                )
            }
            6 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Target,
                )
            }
            14 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::FilePath,
                )
            }
            29 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::String,
                )
            }
            37 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Position,
                )
            }
            41 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Message,
                )
            }
            43 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::RawText,
                )
            }
            46 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Json,
                )
            }
            53 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Command,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType {
    Valid = 16,
    Enum = 48,
    Suffixed = 256,
    SoftEnum = 1040,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            16 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Valid,
                )
            }
            48 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Enum,
                )
            }
            256 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Suffixed,
                )
            }
            1040 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::SoftEnum,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    pub parameter_name: String,
    pub value_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType,
    pub enum_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType,
    pub optional: bool,
    pub options: CommandFlags,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.parameter_name.encode(buf)?;
        self.value_type.encode(buf)?;
        self.enum_type.encode(buf)?;
        self.optional.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameter_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let enum_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let optional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let options = <CommandFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            parameter_name,
            value_type,
            enum_type,
            optional,
            options,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItem {
    pub parameters: Vec<
        PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem,
    >,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.parameters.len() as i32;
        len.encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameters = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { parameters })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableEntityIdentifiers {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableEntityIdentifiers {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentRegisterPlayer {
    pub player_id: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentRegisterPlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.player_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let player_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { player_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCamera {
    pub camera_entity_unique_id: crate::bedrock::codec::ZigZag64,
    pub target_player_unique_id: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCamera {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.camera_entity_unique_id.encode(buf)?;
        self.target_player_unique_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let camera_entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let target_player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            camera_entity_unique_id,
            target_player_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraShake {
    pub intensity: f32,
    pub duration: f32,
    pub type_: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraShake {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.intensity.encode(buf)?;
        self.duration.encode(buf)?;
        self.type_.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let intensity = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { intensity, duration, type_ })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCorrectPlayerMovePrediction {
    pub position: Vec3F,
    pub delta: Vec3F,
    pub on_ground: bool,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCorrectPlayerMovePrediction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.delta.encode(buf)?;
        self.on_ground.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            position,
            delta,
            on_ground,
            tick,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEntityEventEventID {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEventEventID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketEntityEventEventID::Jump),
            2 => Ok(PacketEntityEventEventID::HurtAnimation),
            3 => Ok(PacketEntityEventEventID::DeathAnimation),
            4 => Ok(PacketEntityEventEventID::ArmSwing),
            5 => Ok(PacketEntityEventEventID::StopAttack),
            6 => Ok(PacketEntityEventEventID::TameFail),
            7 => Ok(PacketEntityEventEventID::TameSuccess),
            8 => Ok(PacketEntityEventEventID::ShakeWet),
            9 => Ok(PacketEntityEventEventID::UseItem),
            10 => Ok(PacketEntityEventEventID::EatGrassAnimation),
            11 => Ok(PacketEntityEventEventID::FishHookBubble),
            12 => Ok(PacketEntityEventEventID::FishHookPosition),
            13 => Ok(PacketEntityEventEventID::FishHookHook),
            14 => Ok(PacketEntityEventEventID::FishHookTease),
            15 => Ok(PacketEntityEventEventID::SquidInkCloud),
            16 => Ok(PacketEntityEventEventID::ZombieVillagerCure),
            18 => Ok(PacketEntityEventEventID::Respawn),
            19 => Ok(PacketEntityEventEventID::IronGolemOfferFlower),
            20 => Ok(PacketEntityEventEventID::IronGolemWithdrawFlower),
            21 => Ok(PacketEntityEventEventID::LoveParticles),
            22 => Ok(PacketEntityEventEventID::VillagerAngry),
            23 => Ok(PacketEntityEventEventID::VillagerHappy),
            24 => Ok(PacketEntityEventEventID::WitchSpellParticles),
            25 => Ok(PacketEntityEventEventID::FireworkParticles),
            26 => Ok(PacketEntityEventEventID::InLoveParticles),
            27 => Ok(PacketEntityEventEventID::SilverfishSpawnAnimation),
            28 => Ok(PacketEntityEventEventID::GuardianAttack),
            29 => Ok(PacketEntityEventEventID::WitchDrinkPotion),
            30 => Ok(PacketEntityEventEventID::WitchThrowPotion),
            31 => Ok(PacketEntityEventEventID::MinecartTntPrimeFuse),
            32 => Ok(PacketEntityEventEventID::CreeperPrimeFuse),
            33 => Ok(PacketEntityEventEventID::AirSupplyExpired),
            34 => Ok(PacketEntityEventEventID::PlayerAddXpLevels),
            35 => Ok(PacketEntityEventEventID::ElderGuardianCurse),
            36 => Ok(PacketEntityEventEventID::AgentArmSwing),
            37 => Ok(PacketEntityEventEventID::EnderDragonDeath),
            38 => Ok(PacketEntityEventEventID::DustParticles),
            39 => Ok(PacketEntityEventEventID::ArrowShake),
            57 => Ok(PacketEntityEventEventID::EatingItem),
            60 => Ok(PacketEntityEventEventID::BabyAnimalFeed),
            61 => Ok(PacketEntityEventEventID::DeathSmokeCloud),
            62 => Ok(PacketEntityEventEventID::CompleteTrade),
            63 => Ok(PacketEntityEventEventID::RemoveLeash),
            65 => Ok(PacketEntityEventEventID::ConsumeTotem),
            66 => Ok(PacketEntityEventEventID::PlayerCheckTreasureHunterAchievement),
            67 => Ok(PacketEntityEventEventID::EntitySpawn),
            68 => Ok(PacketEntityEventEventID::DragonPuke),
            69 => Ok(PacketEntityEventEventID::ItemEntityMerge),
            70 => Ok(PacketEntityEventEventID::StartSwim),
            71 => Ok(PacketEntityEventEventID::BalloonPop),
            72 => Ok(PacketEntityEventEventID::TreasureHunt),
            73 => Ok(PacketEntityEventEventID::AgentSummon),
            74 => Ok(PacketEntityEventEventID::ChargedItem),
            75 => Ok(PacketEntityEventEventID::Fall),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEntityEventEventID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i32,
    pub event_id: PacketEntityEventEventID,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketEntityEventEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityPickRequest {
    pub runtime_entity_id: u64,
    pub selected_slot: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityPickRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.selected_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            selected_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobArmorEquipment {
    pub runtime_entity_id: i32,
    pub helmet: Item,
    pub chestplate: Item,
    pub leggings: Item,
    pub boots: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobArmorEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.helmet.encode(buf)?;
        self.chestplate.encode(buf)?;
        self.leggings.encode(buf)?;
        self.boots.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let helmet = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chestplate = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let leggings = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let boots = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            helmet,
            chestplate,
            leggings,
            boots,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketMobEffectEventID {
    Add = 1,
    Update = 2,
    Remove = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffectEventID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketMobEffectEventID::Add),
            2 => Ok(PacketMobEffectEventID::Update),
            3 => Ok(PacketMobEffectEventID::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMobEffectEventID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEffect {
    pub runtime_entity_id: i32,
    pub event_id: PacketMobEffectEventID,
    pub effect_id: crate::bedrock::codec::ZigZag32,
    pub amplifier: crate::bedrock::codec::ZigZag32,
    pub particles: bool,
    pub duration: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.event_id.encode(buf)?;
        self.effect_id.encode(buf)?;
        self.amplifier.encode(buf)?;
        self.particles.encode(buf)?;
        self.duration.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let event_id = <PacketMobEffectEventID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let effect_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let amplifier = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let particles = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            effect_id,
            amplifier,
            particles,
            duration,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEquipment {
    pub runtime_entity_id: i32,
    pub item: Item,
    pub slot: u8,
    pub selected_slot: u8,
    pub windows_id: WindowID,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.item.encode(buf)?;
        self.slot.encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.windows_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let windows_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            item,
            slot,
            selected_slot,
            windows_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMotionPredictionHints {
    pub entity_runtime_id: i64,
    pub velocity: Vec3F,
    pub on_ground: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketMotionPredictionHints {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_runtime_id.encode(buf)?;
        self.velocity.encode(buf)?;
        self.on_ground.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_runtime_id,
            velocity,
            on_ground,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntity {
    pub runtime_entity_id: i32,
    pub flags: u8,
    pub position: Vec3F,
    pub rotation: Rotation,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.flags.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation = <Rotation as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            flags,
            position,
            rotation,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntityDelta {
    pub runtime_entity_id: i64,
    pub flags: DeltaMoveFlags,
    pub x: Option<f32>,
    pub y: Option<f32>,
    pub z: Option<f32>,
    pub rot_x: Option<u8>,
    pub rot_y: Option<u8>,
    pub rot_z: Option<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntityDelta {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.flags.encode(buf)?;
        if let Some(v) = &self.x {
            v.encode(buf)?;
        }
        if let Some(v) = &self.y {
            v.encode(buf)?;
        }
        if let Some(v) = &self.z {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_x {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_y {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_z {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <DeltaMoveFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let x = match flags_has_x {
            true => Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let y = match flags_has_y {
            true => Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let z = match flags_has_z {
            true => Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let rot_x = match flags_has_rot_x {
            true => Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let rot_y = match flags_has_rot_y {
            true => Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let rot_z = match flags_has_rot_z {
            true => Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        Ok(Self {
            runtime_entity_id,
            flags,
            x,
            y,
            z,
            rot_x,
            rot_y,
            rot_z,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketMovePlayerMode {
    Normal = 0,
    Reset = 1,
    Teleport = 2,
    Rotation = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerMode {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketMovePlayerMode::Normal),
            1 => Ok(PacketMovePlayerMode::Reset),
            2 => Ok(PacketMovePlayerMode::Teleport),
            3 => Ok(PacketMovePlayerMode::Rotation),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMovePlayerMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketMovePlayerTeleportSomeCause {
    Unknown = 0,
    Projectile = 1,
    ChorusFruit = 2,
    Command = 3,
    Behavior = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerTeleportSomeCause {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketMovePlayerTeleportSomeCause::Unknown),
            1 => Ok(PacketMovePlayerTeleportSomeCause::Projectile),
            2 => Ok(PacketMovePlayerTeleportSomeCause::ChorusFruit),
            3 => Ok(PacketMovePlayerTeleportSomeCause::Command),
            4 => Ok(PacketMovePlayerTeleportSomeCause::Behavior),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMovePlayerTeleportSomeCause), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovePlayerTeleportSome {
    pub cause: PacketMovePlayerTeleportSomeCause,
    pub source_entity_type: LegacyEntityType,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerTeleportSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cause.encode(buf)?;
        self.source_entity_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let cause = <PacketMovePlayerTeleportSomeCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let source_entity_type = <LegacyEntityType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { cause, source_entity_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovePlayer {
    pub runtime_id: i32,
    pub position: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub mode: PacketMovePlayerMode,
    pub on_ground: bool,
    pub ridden_runtime_id: i32,
    pub teleport: Option<PacketMovePlayerTeleportSome>,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        self.position.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.mode.encode(buf)?;
        self.on_ground.encode(buf)?;
        self.ridden_runtime_id.encode(buf)?;
        if let Some(v) = &self.teleport {
            v.encode(buf)?;
        }
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let mode = <PacketMovePlayerMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ridden_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let teleport = match mode {
            _ => {
                Some(
                    <PacketMovePlayerTeleportSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_id,
            position,
            pitch,
            yaw,
            head_yaw,
            mode,
            on_ground,
            ridden_runtime_id,
            teleport,
            tick,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketMultiplayerSettingsActionType {
    EnableMultiplayer = 0,
    DisableMultiplayer = 1,
    RefreshJoinCode = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketMultiplayerSettingsActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketMultiplayerSettingsActionType::EnableMultiplayer),
            1 => Ok(PacketMultiplayerSettingsActionType::DisableMultiplayer),
            2 => Ok(PacketMultiplayerSettingsActionType::RefreshJoinCode),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMultiplayerSettingsActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMultiplayerSettings {
    pub action_type: PacketMultiplayerSettingsActionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketMultiplayerSettings {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_type = <PacketMultiplayerSettingsActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { action_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcRequest {
    pub runtime_entity_id: i32,
    pub unknown0: u8,
    pub unknown1: String,
    pub unknown2: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.unknown0.encode(buf)?;
        self.unknown1.encode(buf)?;
        self.unknown2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let unknown0 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown1 = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            unknown0,
            unknown1,
            unknown2,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerActionAction {
    StartBreak = 0,
    AbortBreak = 1,
    StopBreak = 2,
    GetUpdatedBlock = 3,
    DropItem = 4,
    StartSleeping = 5,
    StopSleeping = 6,
    Respawn = 7,
    Jump = 8,
    StartSprint = 9,
    StopSprint = 10,
    StartSneak = 11,
    StopSneak = 12,
    CreativePlayerDestroyBlock = 13,
    DimensionChangeAck = 14,
    StartGlide = 15,
    StopGlide = 16,
    BuildDenied = 17,
    ContinueBreak = 18,
    ChangeSkin = 19,
    SetEnchatnmentSeed = 20,
    Swimming = 21,
    StopSwimming = 22,
    StartSpinAttack = 23,
    StopSpinAttack = 24,
    IneractBlock = 25,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerActionAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerActionAction::StartBreak),
            1 => Ok(PacketPlayerActionAction::AbortBreak),
            2 => Ok(PacketPlayerActionAction::StopBreak),
            3 => Ok(PacketPlayerActionAction::GetUpdatedBlock),
            4 => Ok(PacketPlayerActionAction::DropItem),
            5 => Ok(PacketPlayerActionAction::StartSleeping),
            6 => Ok(PacketPlayerActionAction::StopSleeping),
            7 => Ok(PacketPlayerActionAction::Respawn),
            8 => Ok(PacketPlayerActionAction::Jump),
            9 => Ok(PacketPlayerActionAction::StartSprint),
            10 => Ok(PacketPlayerActionAction::StopSprint),
            11 => Ok(PacketPlayerActionAction::StartSneak),
            12 => Ok(PacketPlayerActionAction::StopSneak),
            13 => Ok(PacketPlayerActionAction::CreativePlayerDestroyBlock),
            14 => Ok(PacketPlayerActionAction::DimensionChangeAck),
            15 => Ok(PacketPlayerActionAction::StartGlide),
            16 => Ok(PacketPlayerActionAction::StopGlide),
            17 => Ok(PacketPlayerActionAction::BuildDenied),
            18 => Ok(PacketPlayerActionAction::ContinueBreak),
            19 => Ok(PacketPlayerActionAction::ChangeSkin),
            20 => Ok(PacketPlayerActionAction::SetEnchatnmentSeed),
            21 => Ok(PacketPlayerActionAction::Swimming),
            22 => Ok(PacketPlayerActionAction::StopSwimming),
            23 => Ok(PacketPlayerActionAction::StartSpinAttack),
            24 => Ok(PacketPlayerActionAction::StopSpinAttack),
            25 => Ok(PacketPlayerActionAction::IneractBlock),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerActionAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAction {
    pub runtime_entity_id: i32,
    pub action: PacketPlayerActionAction,
    pub position: BlockCoordinates,
    pub face: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.action.encode(buf)?;
        self.position.encode(buf)?;
        self.face.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action = <PacketPlayerActionAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            action,
            position,
            face,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerArmorDamage {
    pub type_: ArmorDamageType,
    pub helmet_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub chestplate_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub leggings_damage: Option<crate::bedrock::codec::ZigZag32>,
    pub boots_damage: Option<crate::bedrock::codec::ZigZag32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerArmorDamage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.helmet_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.chestplate_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.leggings_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.boots_damage {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <ArmorDamageType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let helmet_damage = match type_head {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let chestplate_damage = match type_chest {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let leggings_damage = match type_legs {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let boots_damage = match types_feet {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            helmet_damage,
            chestplate_damage,
            leggings_damage,
            boots_damage,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputInputMode {
    Mouse = 0,
    Touch = 1,
    GamePad = 2,
    MotionController = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputInputMode {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerAuthInputInputMode::Mouse),
            1 => Ok(PacketPlayerAuthInputInputMode::Touch),
            2 => Ok(PacketPlayerAuthInputInputMode::GamePad),
            3 => Ok(PacketPlayerAuthInputInputMode::MotionController),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputInputMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputPlayMode {
    Normal = 0,
    Teaser = 1,
    Screen = 2,
    Viewer = 3,
    Reality = 4,
    Placement = 5,
    LivingRoom = 6,
    ExitLevel = 7,
    ExitLevelLivingRoom = 8,
    NumModes = 9,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputPlayMode {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerAuthInputPlayMode::Normal),
            1 => Ok(PacketPlayerAuthInputPlayMode::Teaser),
            2 => Ok(PacketPlayerAuthInputPlayMode::Screen),
            3 => Ok(PacketPlayerAuthInputPlayMode::Viewer),
            4 => Ok(PacketPlayerAuthInputPlayMode::Reality),
            5 => Ok(PacketPlayerAuthInputPlayMode::Placement),
            6 => Ok(PacketPlayerAuthInputPlayMode::LivingRoom),
            7 => Ok(PacketPlayerAuthInputPlayMode::ExitLevel),
            8 => Ok(PacketPlayerAuthInputPlayMode::ExitLevelLivingRoom),
            9 => Ok(PacketPlayerAuthInputPlayMode::NumModes),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputPlayMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub gaze_direction: Option<Vec3F>,
    pub tick: i64,
    pub delta: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        if let Some(v) = &self.gaze_direction {
            v.encode(buf)?;
        }
        self.tick.encode(buf)?;
        self.delta.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let gaze_direction = match play_mode {
            _ => Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            gaze_direction,
            tick,
            delta,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerEnchantOptions {
    pub enchant_options: EnchantOptions,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerEnchantOptions {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enchant_options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let enchant_options = <EnchantOptions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { enchant_options })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerFog {
    pub stack: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerFog {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.stack.len() as i32;
        len.encode(buf)?;
        for item in &self.stack {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let stack = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self { stack })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerHotbar {
    pub selected_slot: i32,
    pub window_id: WindowID,
    pub select_slot: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerHotbar {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.selected_slot.encode(buf)?;
        self.window_id.encode(buf)?;
        self.select_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let selected_slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let select_slot = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            selected_slot,
            window_id,
            select_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerInput {
    pub motion_x: f32,
    pub motion_z: f32,
    pub jumping: bool,
    pub sneaking: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerInput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.motion_x.encode(buf)?;
        self.motion_z.encode(buf)?;
        self.jumping.encode(buf)?;
        self.sneaking.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let motion_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let motion_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let jumping = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let sneaking = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            motion_x,
            motion_z,
            jumping,
            sneaking,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerList {
    pub records: PlayerRecords,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerList {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.records.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let records = <PlayerRecords as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { records })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveEcsEntity {
    pub network_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveEcsEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveEntity {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entity_id_self })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveObjective {
    pub objective_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveObjective {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.objective_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { objective_name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityData {
    pub runtime_entity_id: i32,
    pub metadata: MetadataDictionary,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.metadata.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            metadata,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityLink {
    pub link: Link,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityLink {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.link.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let link = <Link as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { link })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityMotion {
    pub runtime_entity_id: i32,
    pub velocity: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityMotion {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.velocity.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            velocity,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetPlayerGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerGameType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentity {
    pub entries: ScoreboardIdentityEntries,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entries.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entries = <ScoreboardIdentityEntries as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnParticleEffect {
    pub dimension_id: u8,
    pub entity_id: crate::bedrock::codec::ZigZag64,
    pub position: Vec3F,
    pub particle_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnParticleEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension_id.encode(buf)?;
        self.entity_id.encode(buf)?;
        self.position.encode(buf)?;
        self.particle_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dimension_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let particle_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            dimension_id,
            entity_id,
            position,
            particle_name,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketStartGameMovementAuthority {
    Client = 0,
    Server = 1,
    ServerV2Rewind = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameMovementAuthority {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketStartGameMovementAuthority::Client),
            1 => Ok(PacketStartGameMovementAuthority::Server),
            2 => Ok(PacketStartGameMovementAuthority::ServerV2Rewind),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameMovementAuthority), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTakeItemEntity {
    pub runtime_entity_id: i32,
    pub target: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketTakeItemEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.target.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let target = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { runtime_entity_id, target })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAttributes {
    pub runtime_entity_id: i64,
    pub attributes: PlayerAttributes,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAttributes {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.attributes.encode(buf)?;
        self.tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let attributes = <PlayerAttributes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            attributes,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdatePlayerGameType {
    pub gamemode: GameMode,
    pub player_unique_id: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdatePlayerGameType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        self.player_unique_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { gamemode, player_unique_id })
    }
}
