// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
use crate::bedrock::codec::BedrockCodec;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct ActionPermissions : u32
    { const ATTACK_MOBS = 65552; const ATTACK_PLAYERS = 65544; const BUILD_AND_MINE =
    65537; const DOORS_AND_SWITCHES = 65538; const OPEN_CONTAINERS = 65540; const
    OPERATOR = 65568; const TELEPORT = 65664; }
}
impl crate::bedrock::codec::BedrockCodec for ActionPermissions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct AdventureFlags : u32 {
    const ALLOW_FLIGHT = 64; const AUTO_JUMP = 32; const FLYING = 512; const MUTED =
    1024; const NO_CLIP = 128; const NO_PVP = 2; const WORLD_BUILDER = 256; const
    WORLD_IMMUTABLE = 1; }
}
impl crate::bedrock::codec::BedrockCodec for AdventureFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct ArmorDamageType : u8 {
    const CHEST = 2; const FEET = 8; const HEAD = 1; const LEGS = 4; }
}
impl crate::bedrock::codec::BedrockCodec for ArmorDamageType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        (val as u8).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw as u8;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BehaviourPackInfosItem {
    pub uuid: String,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
}
impl crate::bedrock::codec::BedrockCodec for BehaviourPackInfosItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.size.encode(buf)?;
        self.content_key.encode(buf)?;
        self.sub_pack_name.encode(buf)?;
        self.content_identity.encode(buf)?;
        self.has_scripts.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content_key = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let sub_pack_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content_identity = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
        })
    }
}
pub type BehaviourPackInfos = Vec<BehaviourPackInfosItem>;
pub type ByteArray = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Blob {
    pub hash: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for Blob {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.hash.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let hash = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { hash, payload })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BlockCoordinates {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for BlockCoordinates {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::VarInt(self.y).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let y = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BlockPaletteItem {
    pub name: String,
    pub state: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for BlockPaletteItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.state.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let state = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, state })
    }
}
pub type BlockPalette = Vec<BlockPaletteItem>;
pub type CommandFlags = u8;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CommandOriginType {
    Player = 0,
    Block = 1,
    MinecartBlock = 2,
    DevConsole = 3,
    Test = 4,
    AutomationPlayer = 5,
    ClientAutomation = 6,
    DedicatedServer = 7,
    Entity = 8,
    Virtual = 9,
    GameArgument = 10,
    EntityServer = 11,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandOriginType::Player),
            1 => Ok(CommandOriginType::Block),
            2 => Ok(CommandOriginType::MinecartBlock),
            3 => Ok(CommandOriginType::DevConsole),
            4 => Ok(CommandOriginType::Test),
            5 => Ok(CommandOriginType::AutomationPlayer),
            6 => Ok(CommandOriginType::ClientAutomation),
            7 => Ok(CommandOriginType::DedicatedServer),
            8 => Ok(CommandOriginType::Entity),
            9 => Ok(CommandOriginType::Virtual),
            10 => Ok(CommandOriginType::GameArgument),
            11 => Ok(CommandOriginType::EntityServer),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CommandOriginType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOriginPlayerEntityIdDevConsole {
    pub player_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginPlayerEntityIdDevConsole {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.player_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { player_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum CommandOriginPlayerEntityId {
    DevConsole(CommandOriginPlayerEntityIdDevConsole),
    Test(CommandOriginPlayerEntityIdDevConsole),
}
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOrigin {
    pub type_: CommandOriginType,
    pub uuid: uuid::Uuid,
    pub request_id: String,
    pub player_entity_id: Option<CommandOriginPlayerEntityId>,
}
impl crate::bedrock::codec::BedrockCodec for CommandOrigin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.uuid.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.player_entity_id {
            match v {
                CommandOriginPlayerEntityId::DevConsole(v) => {
                    v.encode(buf)?;
                }
                CommandOriginPlayerEntityId::Test(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <CommandOriginType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let request_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_entity_id = match type_ {
            CommandOriginType::DevConsole => {
                Some(
                    CommandOriginPlayerEntityId::DevConsole(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            CommandOriginType::Test => {
                Some(
                    CommandOriginPlayerEntityId::Test(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            uuid,
            request_id,
            player_entity_id,
        })
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct DeltaMoveFlags : u16 {
    const FORCE_MOVE = 256; const HAS_ROT_X = 8; const HAS_ROT_Y = 16; const HAS_ROT_Z =
    32; const HAS_X = 1; const HAS_Y = 2; const HAS_Z = 4; const ON_GROUND = 64; const
    TELEPORT = 128; }
}
impl crate::bedrock::codec::BedrockCodec for DeltaMoveFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        (val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw as u16;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Enchant {
    pub id: u8,
    pub level: u8,
}
impl crate::bedrock::codec::BedrockCodec for Enchant {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        self.level.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { id, level })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EnchantOptionsItem {
    pub cost: i32,
    pub slot_flags: i32,
    pub equip_enchants: Vec<Enchant>,
    pub held_enchants: Vec<Enchant>,
    pub self_enchants: Vec<Enchant>,
    pub name: String,
    pub option_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for EnchantOptionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.cost).encode(buf)?;
        self.slot_flags.encode(buf)?;
        let len = self.equip_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.equip_enchants {
            item.encode(buf)?;
        }
        let len = self.held_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.held_enchants {
            item.encode(buf)?;
        }
        let len = self.self_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.self_enchants {
            item.encode(buf)?;
        }
        self.name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.option_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cost = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let slot_flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let equip_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let held_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let self_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let option_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            cost,
            slot_flags,
            equip_enchants,
            held_enchants,
            self_enchants,
            name,
            option_id,
        })
    }
}
pub type EnchantOptions = Vec<EnchantOptionsItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct EntityAttributesItem {
    pub name: String,
    pub min: f32,
    pub value: f32,
    pub max: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntityAttributesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.min.encode(buf)?;
        self.value.encode(buf)?;
        self.max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let value = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, min, value, max })
    }
}
pub type EntityAttributes = Vec<EntityAttributesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct Experiment {
    pub name: String,
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for Experiment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, enabled })
    }
}
pub type Experiments = Vec<Experiment>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameMode {
    Survival = 0,
    Creative = 1,
    Adventure = 2,
    SurvivalSpectator = 3,
    CreativeSpectator = 4,
    Fallback = 5,
}
impl crate::bedrock::codec::BedrockCodec for GameMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(GameMode::Survival),
            1 => Ok(GameMode::Creative),
            2 => Ok(GameMode::Adventure),
            3 => Ok(GameMode::SurvivalSpectator),
            4 => Ok(GameMode::CreativeSpectator),
            5 => Ok(GameMode::Fallback),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(GameMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameRuleType {
    Bool = 1,
    Int = 2,
    Float = 3,
}
impl crate::bedrock::codec::BedrockCodec for GameRuleType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(GameRuleType::Bool),
            2 => Ok(GameRuleType::Int),
            3 => Ok(GameRuleType::Float),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(GameRuleType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum GameRuleValue {
    Bool(bool),
    Float(f32),
    Int(i32),
}
#[derive(Debug, Clone, PartialEq)]
pub struct GameRule {
    pub name: String,
    pub type_: GameRuleType,
    pub value: Option<GameRuleValue>,
}
impl crate::bedrock::codec::BedrockCodec for GameRule {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                GameRuleValue::Bool(v) => {
                    (*v).encode(buf)?;
                }
                GameRuleValue::Float(v) => {
                    (*v).encode(buf)?;
                }
                GameRuleValue::Int(v) => {
                    crate::bedrock::codec::ZigZag32(*v).encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let type_ = <GameRuleType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match type_ {
            GameRuleType::Bool => {
                Some(
                    GameRuleValue::Bool(
                        <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            GameRuleType::Float => {
                Some(
                    GameRuleValue::Float(
                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            GameRuleType::Int => {
                Some(
                    GameRuleValue::Int(
                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { name, type_, value })
    }
}
pub type GameRules = Vec<GameRule>;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct InputFlag : u32 { const
    ASCEND = 1; const ASCEND_SCAFFOLDING = 2097152; const AUTO_JUMPING_IN_WATER = 128;
    const CHANGE_HEIGHT = 32; const DESCEND = 2; const DESCEND_SCAFFOLDING = 4194304;
    const DOWN = 2048; const JUMP_DOWN = 8; const JUMPING = 64; const LEFT = 4096; const
    NORTH_JUMP = 4; const PERSIST_SNEAK = 16777216; const RIGHT = 8192; const SNEAK_DOWN
    = 512; const SNEAK_TOGGLE_DOWN = 8388608; const SNEAKING = 256; const SPRINT_DOWN =
    16; const SPRINTING = 1048576; const UP = 1024; const UP_LEFT = 16384; const UP_RIGHT
    = 32768; const WANT_DOWN = 131072; const WANT_DOWN_SLOW = 262144; const WANT_UP =
    65536; const WANT_UP_SLOW = 524288; }
}
impl crate::bedrock::codec::BedrockCodec for InputFlag {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContentNbt {
    pub version: u8,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemContentNbt {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { version, nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContent {
    pub auxiliary_value: i32,
    pub nbt: Option<ItemContentNbt>,
    pub can_place_on: Vec<String>,
    pub can_destroy: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for ItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.auxiliary_value).encode(buf)?;
        let val = self.nbt.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len();
        crate::bedrock::codec::ZigZag32(len as i32).encode(buf)?;
        for item in &self.can_place_on {
            (*item).encode(buf)?;
        }
        let len = self.can_destroy.len();
        crate::bedrock::codec::ZigZag32(len as i32).encode(buf)?;
        for item in &self.can_destroy {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let auxiliary_value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_nbt = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = if has_nbt {
            Some(
                <ItemContentNbt as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
            )
        } else {
            None
        };
        let can_place_on = {
            let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            auxiliary_value,
            nbt,
            can_place_on,
            can_destroy,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtra {
    pub blocking_tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtra {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.blocking_tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let blocking_tick = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { blocking_tick })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Item {
    pub content: Option<Box<ItemContent>>,
    pub extra: Option<ItemExtra>,
}
impl crate::bedrock::codec::BedrockCodec for Item {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        if let Some(v) = &self.extra {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = if (network_id) != 0 {
            Some(
                Box::new(
                    <ItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                ),
            )
        } else {
            None
        };
        let extra = match network_id {
            355 => {
                Some(
                    <ItemExtra as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                )
            }
            _ => None,
        };
        Ok(Self { content, extra })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemComponentListItem {
    pub name: String,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemComponentListItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, nbt })
    }
}
pub type ItemComponentList = Vec<ItemComponentListItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStack {
    pub runtime_id: i32,
    pub item: Item,
}
impl crate::bedrock::codec::BedrockCodec for ItemStack {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.runtime_id).encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { runtime_id, item })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackRequestsItemActionsItemTypeId {
    Take = 0,
    Place = 1,
    Swap = 2,
    Drop = 3,
    Destroy = 4,
    Consume = 5,
    Create = 6,
    LabTableCombine = 7,
    BeaconPayment = 8,
    CraftRecipe = 9,
    CraftRecipeAuto = 10,
    CraftCreative = 11,
    Optional = 12,
    NonImplemented = 13,
    ResultsDeprecated = 14,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestsItemActionsItemTypeId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackRequestsItemActionsItemTypeId::Take),
            1 => Ok(ItemStackRequestsItemActionsItemTypeId::Place),
            2 => Ok(ItemStackRequestsItemActionsItemTypeId::Swap),
            3 => Ok(ItemStackRequestsItemActionsItemTypeId::Drop),
            4 => Ok(ItemStackRequestsItemActionsItemTypeId::Destroy),
            5 => Ok(ItemStackRequestsItemActionsItemTypeId::Consume),
            6 => Ok(ItemStackRequestsItemActionsItemTypeId::Create),
            7 => Ok(ItemStackRequestsItemActionsItemTypeId::LabTableCombine),
            8 => Ok(ItemStackRequestsItemActionsItemTypeId::BeaconPayment),
            9 => Ok(ItemStackRequestsItemActionsItemTypeId::CraftRecipe),
            10 => Ok(ItemStackRequestsItemActionsItemTypeId::CraftRecipeAuto),
            11 => Ok(ItemStackRequestsItemActionsItemTypeId::CraftCreative),
            12 => Ok(ItemStackRequestsItemActionsItemTypeId::Optional),
            13 => Ok(ItemStackRequestsItemActionsItemTypeId::NonImplemented),
            14 => Ok(ItemStackRequestsItemActionsItemTypeId::ResultsDeprecated),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackRequestsItemActionsItemTypeId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentBeaconPayment {
    pub primary_effect: i32,
    pub secondary_effect: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentBeaconPayment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.primary_effect).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.secondary_effect).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let primary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let secondary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            primary_effect,
            secondary_effect,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct StackRequestSlotInfo {
    pub container_id: u8,
    pub slot_id: u8,
    pub stack_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for StackRequestSlotInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        self.slot_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.stack_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            container_id,
            slot_id,
            stack_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentConsume {
    pub count: u8,
    pub source: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentConsume {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { count, source })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCraftCreative {
    pub creative_item_network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCraftCreative {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.creative_item_network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let creative_item_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { creative_item_network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCraftRecipe {
    pub recipe_network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCraftRecipe {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { recipe_network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCraftRecipeAuto {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCraftRecipeAuto {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentCreate {
    pub result_slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentCreate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.result_slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let result_slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { result_slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentDrop {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub randomly: bool,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentDrop {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.randomly.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let randomly = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { count, source, randomly })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentOptional {
    pub recipe_network_id: i32,
    pub filtered_string_index: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentOptional {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.filtered_string_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_network_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let filtered_string_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            recipe_network_id,
            filtered_string_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentPlace {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentPlace {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { count, source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentResultsDeprecated {
    pub result_items: Vec<Item>,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentResultsDeprecated {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.result_items.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result_items {
            item.encode(buf)?;
        }
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let result_items = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            result_items,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItemContentSwap {
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestsItemActionsItemContentSwap {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestsItemActionsItemContent {
    BeaconPayment(ItemStackRequestsItemActionsItemContentBeaconPayment),
    Consume(ItemStackRequestsItemActionsItemContentConsume),
    CraftCreative(ItemStackRequestsItemActionsItemContentCraftCreative),
    CraftRecipe(ItemStackRequestsItemActionsItemContentCraftRecipe),
    CraftRecipeAuto(ItemStackRequestsItemActionsItemContentCraftRecipeAuto),
    Create(ItemStackRequestsItemActionsItemContentCreate),
    Destroy(ItemStackRequestsItemActionsItemContentConsume),
    Drop(ItemStackRequestsItemActionsItemContentDrop),
    NonImplemented,
    Optional(ItemStackRequestsItemActionsItemContentOptional),
    Place(ItemStackRequestsItemActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestsItemActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestsItemActionsItemContentSwap),
    Take(ItemStackRequestsItemActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItemActionsItem {
    pub type_id: ItemStackRequestsItemActionsItemTypeId,
    pub content: Option<ItemStackRequestsItemActionsItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestsItemActionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestsItemActionsItemContent::BeaconPayment(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::Consume(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::CraftCreative(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::CraftRecipe(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::CraftRecipeAuto(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::Create(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::Destroy(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::Drop(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::NonImplemented => {}
                ItemStackRequestsItemActionsItemContent::Optional(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::Place(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::Swap(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestsItemActionsItemContent::Take(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestsItemActionsItemTypeId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_id {
            ItemStackRequestsItemActionsItemTypeId::BeaconPayment => {
                Some(
                    ItemStackRequestsItemActionsItemContent::BeaconPayment(
                        <ItemStackRequestsItemActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::Consume => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Consume(
                        <ItemStackRequestsItemActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::CraftCreative => {
                Some(
                    ItemStackRequestsItemActionsItemContent::CraftCreative(
                        <ItemStackRequestsItemActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::CraftRecipe => {
                Some(
                    ItemStackRequestsItemActionsItemContent::CraftRecipe(
                        <ItemStackRequestsItemActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::CraftRecipeAuto => {
                Some(
                    ItemStackRequestsItemActionsItemContent::CraftRecipeAuto(
                        <ItemStackRequestsItemActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::Create => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Create(
                        <ItemStackRequestsItemActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::Destroy => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Destroy(
                        <ItemStackRequestsItemActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::Drop => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Drop(
                        <ItemStackRequestsItemActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::NonImplemented => {
                Some(ItemStackRequestsItemActionsItemContent::NonImplemented)
            }
            ItemStackRequestsItemActionsItemTypeId::Optional => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Optional(
                        <ItemStackRequestsItemActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::Place => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Place(
                        <ItemStackRequestsItemActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::ResultsDeprecated => {
                Some(
                    ItemStackRequestsItemActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestsItemActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::Swap => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Swap(
                        <ItemStackRequestsItemActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestsItemActionsItemTypeId::Take => {
                Some(
                    ItemStackRequestsItemActionsItemContent::Take(
                        <ItemStackRequestsItemActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestsItem {
    pub request_id: i32,
    pub actions: Vec<ItemStackRequestsItemActionsItem>,
    pub custom_names: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.request_id).encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.custom_names {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let actions = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestsItemActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            request_id,
            actions,
            custom_names,
        })
    }
}
pub type ItemStackRequests = Vec<ItemStackRequestsItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: i32,
    pub custom_name: String,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContainersItemSlotsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        crate::bedrock::codec::VarInt(self.item_stack_id).encode(buf)?;
        self.custom_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let item_stack_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContainersItem {
    pub container_id: u8,
    pub slots: Vec<ItemStackResponsesItemContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContainersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        let len = self.slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let slots = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { container_id, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub result: u8,
    pub request_id: i32,
    pub containers: Vec<ItemStackResponsesItemContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.result.encode(buf)?;
        crate::bedrock::codec::VarInt(self.request_id).encode(buf)?;
        let len = self.containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let result = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let request_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let containers = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            result,
            request_id,
            containers,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
pub type ItemStacks = Vec<ItemStack>;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemstatesItem {
    pub name: String,
    pub runtime_id: i16,
    pub component_based: bool,
}
impl crate::bedrock::codec::BedrockCodec for ItemstatesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.runtime_id.encode(buf)?;
        self.component_based.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let component_based = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            name,
            runtime_id,
            component_based,
        })
    }
}
pub type Itemstates = Vec<ItemstatesItem>;
pub type LatinString = String;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum LegacyEntityType {
    Chicken = 10,
    Cow = 11,
    Pig = 12,
    Sheep = 13,
    Wolf = 14,
    Villager = 15,
    Mooshroom = 16,
    Squid = 17,
    Rabbit = 18,
    Bat = 19,
    IronGolem = 20,
    SnowGolem = 21,
    Ocelot = 22,
    Horse = 23,
    Donkey = 24,
    Mule = 25,
    SkeletonHorse = 26,
    ZombieHorse = 27,
    PolarBear = 28,
    Llama = 29,
    Parrot = 30,
    Dolphin = 31,
    Zombie = 32,
    Creeper = 33,
    Skeleton = 34,
    Spider = 35,
    ZombiePigman = 36,
    Slime = 37,
    Enderman = 38,
    Silverfish = 39,
    CaveSpider = 40,
    Ghast = 41,
    MagmaCube = 42,
    Blaze = 43,
    ZombieVillager = 44,
    Witch = 45,
    Stray = 46,
    Husk = 47,
    WitherSkeleton = 48,
    Guardian = 49,
    ElderGuardian = 50,
    Npc = 51,
    Wither = 52,
    EnderDragon = 53,
    Shulker = 54,
    Endermite = 55,
    Agent = 56,
    Vindicator = 57,
    Phantom = 58,
    ArmorStand = 61,
    TripodCamera = 62,
    Player = 63,
    Item = 64,
    Tnt = 65,
    FallingBlock = 66,
    MovingBlock = 67,
    XpBottle = 68,
    XpOrb = 69,
    EyeOfEnderSignal = 70,
    EnderCrystal = 71,
    FireworksRocket = 72,
    ThrownTrident = 73,
    Turtle = 74,
    Cat = 75,
    ShulkerBullet = 76,
    FishingHook = 77,
    Chalkboard = 78,
    DragonFireball = 79,
    Arrow = 80,
    Snowball = 81,
    Egg = 82,
    Painting = 83,
    Minecart = 84,
    Fireball = 85,
    SplashPotion = 86,
    EnderPearl = 87,
    LeashKnot = 88,
    WitherSkull = 89,
    Boat = 90,
    WitherSkullDangerous = 91,
    LightningBolt = 93,
    SmallFireball = 94,
    AreaEffectCloud = 95,
    HopperMinecart = 96,
    TntMinecart = 97,
    ChestMinecart = 98,
    CommandBlockMinecart = 100,
    LingeringPotion = 101,
    LlamaSpit = 102,
    EvocationFang = 103,
    EvocationIllager = 104,
    Vex = 105,
    IceBomb = 106,
    Balloon = 107,
    Pufferfish = 108,
    Salmon = 109,
    Drowned = 110,
    Tropicalfish = 111,
    Cod = 112,
    Panda = 113,
}
impl crate::bedrock::codec::BedrockCodec for LegacyEntityType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            10 => Ok(LegacyEntityType::Chicken),
            11 => Ok(LegacyEntityType::Cow),
            12 => Ok(LegacyEntityType::Pig),
            13 => Ok(LegacyEntityType::Sheep),
            14 => Ok(LegacyEntityType::Wolf),
            15 => Ok(LegacyEntityType::Villager),
            16 => Ok(LegacyEntityType::Mooshroom),
            17 => Ok(LegacyEntityType::Squid),
            18 => Ok(LegacyEntityType::Rabbit),
            19 => Ok(LegacyEntityType::Bat),
            20 => Ok(LegacyEntityType::IronGolem),
            21 => Ok(LegacyEntityType::SnowGolem),
            22 => Ok(LegacyEntityType::Ocelot),
            23 => Ok(LegacyEntityType::Horse),
            24 => Ok(LegacyEntityType::Donkey),
            25 => Ok(LegacyEntityType::Mule),
            26 => Ok(LegacyEntityType::SkeletonHorse),
            27 => Ok(LegacyEntityType::ZombieHorse),
            28 => Ok(LegacyEntityType::PolarBear),
            29 => Ok(LegacyEntityType::Llama),
            30 => Ok(LegacyEntityType::Parrot),
            31 => Ok(LegacyEntityType::Dolphin),
            32 => Ok(LegacyEntityType::Zombie),
            33 => Ok(LegacyEntityType::Creeper),
            34 => Ok(LegacyEntityType::Skeleton),
            35 => Ok(LegacyEntityType::Spider),
            36 => Ok(LegacyEntityType::ZombiePigman),
            37 => Ok(LegacyEntityType::Slime),
            38 => Ok(LegacyEntityType::Enderman),
            39 => Ok(LegacyEntityType::Silverfish),
            40 => Ok(LegacyEntityType::CaveSpider),
            41 => Ok(LegacyEntityType::Ghast),
            42 => Ok(LegacyEntityType::MagmaCube),
            43 => Ok(LegacyEntityType::Blaze),
            44 => Ok(LegacyEntityType::ZombieVillager),
            45 => Ok(LegacyEntityType::Witch),
            46 => Ok(LegacyEntityType::Stray),
            47 => Ok(LegacyEntityType::Husk),
            48 => Ok(LegacyEntityType::WitherSkeleton),
            49 => Ok(LegacyEntityType::Guardian),
            50 => Ok(LegacyEntityType::ElderGuardian),
            51 => Ok(LegacyEntityType::Npc),
            52 => Ok(LegacyEntityType::Wither),
            53 => Ok(LegacyEntityType::EnderDragon),
            54 => Ok(LegacyEntityType::Shulker),
            55 => Ok(LegacyEntityType::Endermite),
            56 => Ok(LegacyEntityType::Agent),
            57 => Ok(LegacyEntityType::Vindicator),
            58 => Ok(LegacyEntityType::Phantom),
            61 => Ok(LegacyEntityType::ArmorStand),
            62 => Ok(LegacyEntityType::TripodCamera),
            63 => Ok(LegacyEntityType::Player),
            64 => Ok(LegacyEntityType::Item),
            65 => Ok(LegacyEntityType::Tnt),
            66 => Ok(LegacyEntityType::FallingBlock),
            67 => Ok(LegacyEntityType::MovingBlock),
            68 => Ok(LegacyEntityType::XpBottle),
            69 => Ok(LegacyEntityType::XpOrb),
            70 => Ok(LegacyEntityType::EyeOfEnderSignal),
            71 => Ok(LegacyEntityType::EnderCrystal),
            72 => Ok(LegacyEntityType::FireworksRocket),
            73 => Ok(LegacyEntityType::ThrownTrident),
            74 => Ok(LegacyEntityType::Turtle),
            75 => Ok(LegacyEntityType::Cat),
            76 => Ok(LegacyEntityType::ShulkerBullet),
            77 => Ok(LegacyEntityType::FishingHook),
            78 => Ok(LegacyEntityType::Chalkboard),
            79 => Ok(LegacyEntityType::DragonFireball),
            80 => Ok(LegacyEntityType::Arrow),
            81 => Ok(LegacyEntityType::Snowball),
            82 => Ok(LegacyEntityType::Egg),
            83 => Ok(LegacyEntityType::Painting),
            84 => Ok(LegacyEntityType::Minecart),
            85 => Ok(LegacyEntityType::Fireball),
            86 => Ok(LegacyEntityType::SplashPotion),
            87 => Ok(LegacyEntityType::EnderPearl),
            88 => Ok(LegacyEntityType::LeashKnot),
            89 => Ok(LegacyEntityType::WitherSkull),
            90 => Ok(LegacyEntityType::Boat),
            91 => Ok(LegacyEntityType::WitherSkullDangerous),
            93 => Ok(LegacyEntityType::LightningBolt),
            94 => Ok(LegacyEntityType::SmallFireball),
            95 => Ok(LegacyEntityType::AreaEffectCloud),
            96 => Ok(LegacyEntityType::HopperMinecart),
            97 => Ok(LegacyEntityType::TntMinecart),
            98 => Ok(LegacyEntityType::ChestMinecart),
            100 => Ok(LegacyEntityType::CommandBlockMinecart),
            101 => Ok(LegacyEntityType::LingeringPotion),
            102 => Ok(LegacyEntityType::LlamaSpit),
            103 => Ok(LegacyEntityType::EvocationFang),
            104 => Ok(LegacyEntityType::EvocationIllager),
            105 => Ok(LegacyEntityType::Vex),
            106 => Ok(LegacyEntityType::IceBomb),
            107 => Ok(LegacyEntityType::Balloon),
            108 => Ok(LegacyEntityType::Pufferfish),
            109 => Ok(LegacyEntityType::Salmon),
            110 => Ok(LegacyEntityType::Drowned),
            111 => Ok(LegacyEntityType::Tropicalfish),
            112 => Ok(LegacyEntityType::Cod),
            113 => Ok(LegacyEntityType::Panda),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(LegacyEntityType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Link {
    pub ridden_entity_id: i64,
    pub rider_entity_id: i64,
    pub type_: u8,
    pub immediate: bool,
    pub rider_initiated: bool,
}
impl crate::bedrock::codec::BedrockCodec for Link {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.ridden_entity_id).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.rider_entity_id).encode(buf)?;
        self.type_.encode(buf)?;
        self.immediate.encode(buf)?;
        self.rider_initiated.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let ridden_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let rider_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let immediate = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rider_initiated = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            ridden_entity_id,
            rider_entity_id,
            type_,
            immediate,
            rider_initiated,
        })
    }
}
pub type Links = Vec<Link>;
pub type LittleString = String;
#[derive(Debug, Clone, PartialEq)]
pub struct LoginTokens {
    pub identity: LittleString,
    pub client: LittleString,
}
impl crate::bedrock::codec::BedrockCodec for LoginTokens {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.identity.encode(buf)?;
        self.client.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let identity = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { identity, client })
    }
}
pub type MapInfo = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Index = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    OldSwell = 20,
    SwellDir = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeId = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinId = 40,
    UrlTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    AerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    AreaEffectCloudRadius = 60,
    AreaEffectCloudWaiting = 61,
    AreaEffectCloudParticleId = 62,
    ShulkerPeekId = 63,
    ShulkerAttachFace = 64,
    ShulkerAttached = 65,
    ShulkerAttachPos = 66,
    TradingPlayerEid = 67,
    TradingCareer = 68,
    HasCommandBlock = 69,
    CommandBlockCommand = 70,
    CommandBlockLastOutput = 71,
    CommandBlockTrackOutput = 72,
    ControllingRiderSeatNumber = 73,
    Strength = 74,
    MaxStrength = 75,
    SpellCastingColor = 76,
    LimitedLife = 77,
    ArmorStandPoseIndex = 78,
    EnderCrystalTimeOffset = 79,
    AlwaysShowNametag = 80,
    Color2 = 81,
    NameAuthor = 82,
    ScoreTag = 83,
    BalloonAttachedEntity = 84,
    PufferfishSize = 85,
    BubbleTime = 86,
    Agent = 87,
    SittingAmount = 88,
    SittingAmountPrevious = 89,
    EatingCounter = 90,
    FlagsExtended = 91,
    LayingAmount = 92,
    LayingAmountPrevious = 93,
    Duration = 94,
    SpawnTime = 95,
    ChangeRate = 96,
    ChangeOnPickup = 97,
    PickupCount = 98,
    InteractText = 99,
    TradeTier = 100,
    MaxTradeTier = 101,
    TradeExperience = 102,
    SkinId = 103,
    SpawningFrames = 104,
    CommandBlockTickDelay = 105,
    CommandBlockExecuteOnFirstTick = 106,
    AmbientSoundInterval = 107,
    AmbientSoundIntervalRange = 108,
    AmbientSoundEventName = 109,
    FallDamageMultiplier = 110,
    NameRawText = 111,
    CanRideTarget = 112,
    LowTierCuredDiscount = 113,
    HighTierCuredDiscount = 114,
    NearbyCuredDiscount = 115,
    NearbyCuredDiscountTimestamp = 116,
    Hitbox = 117,
    IsBuoyant = 118,
    BuoyancyData = 119,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Index),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            20 => Ok(MetadataDictionaryItemKey::OldSwell),
            21 => Ok(MetadataDictionaryItemKey::SwellDir),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeId),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinId),
            41 => Ok(MetadataDictionaryItemKey::UrlTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::AerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleId),
            63 => Ok(MetadataDictionaryItemKey::ShulkerPeekId),
            64 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            67 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            68 => Ok(MetadataDictionaryItemKey::TradingCareer),
            69 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            70 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            73 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            74 => Ok(MetadataDictionaryItemKey::Strength),
            75 => Ok(MetadataDictionaryItemKey::MaxStrength),
            76 => Ok(MetadataDictionaryItemKey::SpellCastingColor),
            77 => Ok(MetadataDictionaryItemKey::LimitedLife),
            78 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            79 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            80 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            81 => Ok(MetadataDictionaryItemKey::Color2),
            82 => Ok(MetadataDictionaryItemKey::NameAuthor),
            83 => Ok(MetadataDictionaryItemKey::ScoreTag),
            84 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            85 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            86 => Ok(MetadataDictionaryItemKey::BubbleTime),
            87 => Ok(MetadataDictionaryItemKey::Agent),
            88 => Ok(MetadataDictionaryItemKey::SittingAmount),
            89 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            90 => Ok(MetadataDictionaryItemKey::EatingCounter),
            91 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            92 => Ok(MetadataDictionaryItemKey::LayingAmount),
            93 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            94 => Ok(MetadataDictionaryItemKey::Duration),
            95 => Ok(MetadataDictionaryItemKey::SpawnTime),
            96 => Ok(MetadataDictionaryItemKey::ChangeRate),
            97 => Ok(MetadataDictionaryItemKey::ChangeOnPickup),
            98 => Ok(MetadataDictionaryItemKey::PickupCount),
            99 => Ok(MetadataDictionaryItemKey::InteractText),
            100 => Ok(MetadataDictionaryItemKey::TradeTier),
            101 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            102 => Ok(MetadataDictionaryItemKey::TradeExperience),
            103 => Ok(MetadataDictionaryItemKey::SkinId),
            104 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            105 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            107 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            110 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            111 => Ok(MetadataDictionaryItemKey::NameRawText),
            112 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            113 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            114 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            117 => Ok(MetadataDictionaryItemKey::Hitbox),
            118 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            119 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemType {
    Byte = 0,
    Short = 1,
    Int = 2,
    Float = 3,
    String = 4,
    Compound = 5,
    Vec3I = 6,
    Long = 7,
    Vec3F = 8,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MetadataDictionaryItemType::Byte),
            1 => Ok(MetadataDictionaryItemType::Short),
            2 => Ok(MetadataDictionaryItemType::Int),
            3 => Ok(MetadataDictionaryItemType::Float),
            4 => Ok(MetadataDictionaryItemType::String),
            5 => Ok(MetadataDictionaryItemType::Compound),
            6 => Ok(MetadataDictionaryItemType::Vec3I),
            7 => Ok(MetadataDictionaryItemType::Long),
            8 => Ok(MetadataDictionaryItemType::Vec3F),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3F {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3F {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3I {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3I {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Byte(i8),
    Compound(Vec<u8>),
    Float(f32),
    Int(i32),
    Long(i64),
    Short(i16),
    String(String),
    Vec3F(Vec3F),
    Vec3I(Vec3I),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: Option<MetadataDictionaryItemValue>,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                MetadataDictionaryItemValue::Byte(v) => {
                    (*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Compound(v) => {
                    (*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Float(v) => {
                    (*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Int(v) => {
                    crate::bedrock::codec::ZigZag32(*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Long(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Short(v) => {
                    (*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::String(v) => {
                    (*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Vec3F(v) => {
                    v.encode(buf)?;
                }
                MetadataDictionaryItemValue::Vec3I(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match type_ {
            MetadataDictionaryItemType::Byte => {
                Some(
                    MetadataDictionaryItemValue::Byte(
                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Compound => {
                Some(
                    MetadataDictionaryItemValue::Compound(
                        <Vec<
                            u8,
                        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Float => {
                Some(
                    MetadataDictionaryItemValue::Float(
                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Int => {
                Some(
                    MetadataDictionaryItemValue::Int(
                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            MetadataDictionaryItemType::Long => {
                Some(
                    MetadataDictionaryItemValue::Long(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            MetadataDictionaryItemType::Short => {
                Some(
                    MetadataDictionaryItemValue::Short(
                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::String => {
                Some(
                    MetadataDictionaryItemValue::String(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Vec3F => {
                Some(
                    MetadataDictionaryItemValue::Vec3F(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Vec3I => {
                Some(
                    MetadataDictionaryItemValue::Vec3I(
                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { key, type_, value })
    }
}
pub type MetadataDictionary = Vec<MetadataDictionaryItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerAttributesItem {
    pub min: f32,
    pub max: f32,
    pub current: f32,
    pub default: f32,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        self.current.encode(buf)?;
        self.default.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let current = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let default = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            min,
            max,
            current,
            default,
            name,
        })
    }
}
pub type PlayerAttributes = Vec<PlayerAttributesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PlayerRecordsType {
    Add = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PlayerRecordsType::Add),
            1 => Ok(PlayerRecordsType::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PlayerRecordsType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinImage {
    pub width: i32,
    pub height: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for SkinImage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let height = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { width, height, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinAnimationsItem {
    pub skin_image: SkinImage,
    pub animation_type: i32,
    pub animation_frames: f32,
    pub expression_type: f32,
}
impl crate::bedrock::codec::BedrockCodec for SkinAnimationsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.skin_image.encode(buf)?;
        self.animation_type.encode(buf)?;
        self.animation_frames.encode(buf)?;
        self.expression_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let skin_image = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_type = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_frames = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let expression_type = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            skin_image,
            animation_type,
            animation_frames,
            expression_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPersonalPiecesItem {
    pub piece_id: String,
    pub piece_type: String,
    pub pack_id: String,
    pub is_default_piece: bool,
    pub product_id: String,
}
impl crate::bedrock::codec::BedrockCodec for SkinPersonalPiecesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.piece_id.encode(buf)?;
        self.piece_type.encode(buf)?;
        self.pack_id.encode(buf)?;
        self.is_default_piece.encode(buf)?;
        self.product_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let piece_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_default_piece = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let product_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            piece_id,
            piece_type,
            pack_id,
            is_default_piece,
            product_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPieceTintColorsItem {
    pub piece_type: String,
    pub colors: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for SkinPieceTintColorsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.piece_type.encode(buf)?;
        let len = self.colors.len();
        (len as i32).encode(buf)?;
        for item in &self.colors {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { piece_type, colors })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Skin {
    pub skin_id: String,
    pub skin_resource_pack: String,
    pub skin_data: SkinImage,
    pub animations: Vec<SkinAnimationsItem>,
    pub cape_data: SkinImage,
    pub geometry_data: String,
    pub animation_data: String,
    pub premium: String,
    pub persona: bool,
    pub cape_on_classic: bool,
    pub cape_id: String,
    pub full_skin_id: String,
    pub arm_size: String,
    pub skin_color: String,
    pub personal_pieces: Vec<SkinPersonalPiecesItem>,
    pub piece_tint_colors: Vec<SkinPieceTintColorsItem>,
}
impl crate::bedrock::codec::BedrockCodec for Skin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.skin_id.encode(buf)?;
        self.skin_resource_pack.encode(buf)?;
        self.skin_data.encode(buf)?;
        let len = self.animations.len();
        (len as i32).encode(buf)?;
        for item in &self.animations {
            item.encode(buf)?;
        }
        self.cape_data.encode(buf)?;
        self.geometry_data.encode(buf)?;
        self.animation_data.encode(buf)?;
        self.premium.encode(buf)?;
        self.persona.encode(buf)?;
        self.cape_on_classic.encode(buf)?;
        self.cape_id.encode(buf)?;
        self.full_skin_id.encode(buf)?;
        self.arm_size.encode(buf)?;
        self.skin_color.encode(buf)?;
        let len = self.personal_pieces.len();
        (len as i32).encode(buf)?;
        for item in &self.personal_pieces {
            item.encode(buf)?;
        }
        let len = self.piece_tint_colors.len();
        (len as i32).encode(buf)?;
        for item in &self.piece_tint_colors {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin_resource_pack = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let skin_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinAnimationsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let cape_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let geometry_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let premium = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let persona = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let cape_on_classic = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let cape_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let full_skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let arm_size = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin_color = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let personal_pieces = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPersonalPiecesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let piece_tint_colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPieceTintColorsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            skin_id,
            skin_resource_pack,
            skin_data,
            animations,
            cape_data,
            geometry_data,
            animation_data,
            premium,
            persona,
            cape_on_classic,
            cape_id,
            full_skin_id,
            arm_size,
            skin_color,
            personal_pieces,
            piece_tint_colors,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemAdd {
    pub uuid: uuid::Uuid,
    pub entity_unique_id: i64,
    pub username: String,
    pub xbox_user_id: String,
    pub platform_chat_id: String,
    pub build_platform: i32,
    pub skin_data: Skin,
    pub is_teacher: bool,
    pub is_host: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemAdd {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id).encode(buf)?;
        self.username.encode(buf)?;
        self.xbox_user_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.build_platform.encode(buf)?;
        self.skin_data.encode(buf)?;
        self.is_teacher.encode(buf)?;
        self.is_host.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let xbox_user_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let build_platform = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let skin_data = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_teacher = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_host = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            uuid,
            entity_unique_id,
            username,
            xbox_user_id,
            platform_chat_id,
            build_platform,
            skin_data,
            is_teacher,
            is_host,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemRemove {
    pub uuid: uuid::Uuid,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemRemove {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { uuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerRecordsRecordsItem {
    Add(Box<PlayerRecordsRecordsItemAdd>),
    Remove(PlayerRecordsRecordsItemRemove),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Vec<bool>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        crate::bedrock::codec::VarInt(self.records_count).encode(buf)?;
        let len = self.records.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.records {
            if let Some(v) = item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => {
                        v.encode(buf)?;
                    }
                    PlayerRecordsRecordsItem::Remove(v) => {
                        v.encode(buf)?;
                    }
                }
            }
        }
        let len = self.verified.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.verified {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let records_count = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let records = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            PlayerRecordsType::Add => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            PlayerRecordsType::Remove => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        let verified = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PotionContainerChangeRecipesItem {
    pub input_item_id: i32,
    pub ingredient_id: i32,
    pub output_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PotionContainerChangeRecipesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_item_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let ingredient_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            input_item_id,
            ingredient_id,
            output_item_id,
        })
    }
}
pub type PotionContainerChangeRecipes = Vec<PotionContainerChangeRecipesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PotionTypeRecipesItem {
    pub input_item_id: i32,
    pub input_item_meta: i32,
    pub ingredient_id: i32,
    pub ingredient_meta: i32,
    pub output_item_id: i32,
    pub output_item_meta: i32,
}
impl crate::bedrock::codec::BedrockCodec for PotionTypeRecipesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_item_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.input_item_meta).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_meta).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_meta).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let input_item_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let ingredient_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let ingredient_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output_item_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            input_item_id,
            input_item_meta,
            ingredient_id,
            ingredient_meta,
            output_item_id,
            output_item_meta,
        })
    }
}
pub type PotionTypeRecipes = Vec<PotionTypeRecipesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredientContent {
    pub network_data: i32,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.network_data).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.count).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { network_data, count })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredient {
    pub content: Option<RecipeIngredientContent>,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredient {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = if (network_id) != 0 {
            Some(
                <RecipeIngredientContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        Ok(Self { content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum RecipesItemType {
    Shapeless = 0,
    Shaped = 1,
    Furnace = 2,
    FurnaceWithMetadata = 3,
    Multi = 4,
    ShulkerBox = 5,
    ShapelessChemistry = 6,
    ShapedChemistry = 7,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(RecipesItemType::Shapeless),
            1 => Ok(RecipesItemType::Shaped),
            2 => Ok(RecipesItemType::Furnace),
            3 => Ok(RecipesItemType::FurnaceWithMetadata),
            4 => Ok(RecipesItemType::Multi),
            5 => Ok(RecipesItemType::ShulkerBox),
            6 => Ok(RecipesItemType::ShapelessChemistry),
            7 => Ok(RecipesItemType::ShapedChemistry),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(RecipesItemType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnace {
    pub input_id: i32,
    pub output: Item,
    pub block: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnace {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_id).encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { input_id, output, block })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnaceWithMetadata {
    pub input_id: i32,
    pub input_meta: i32,
    pub output: Item,
    pub block: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnaceWithMetadata {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.input_meta).encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let input_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            input_id,
            input_meta,
            output,
            block,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeMulti {
    pub uuid: uuid::Uuid,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeMulti {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { uuid, network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShaped {
    pub recipe_id: LatinString,
    pub width: i32,
    pub height: i32,
    pub input: Vec<Vec<RecipeIngredient>>,
    pub output: Vec<Item>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: i32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShaped {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.width).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.height).encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            let len = item.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            for item in item {
                item.encode(buf)?;
            }
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.priority).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let width = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let input = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?,
                                );
                        }
                        tmp_vec
                    });
            }
            tmp_vec
        };
        let output = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_id,
            width,
            height,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShapeless {
    pub recipe_id: LatinString,
    pub input: Vec<RecipeIngredient>,
    pub output: Vec<Item>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: i32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShapeless {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.priority).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let output = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_id,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipesItemRecipe {
    Furnace(Box<RecipesItemRecipeFurnace>),
    FurnaceWithMetadata(Box<RecipesItemRecipeFurnaceWithMetadata>),
    Multi(RecipesItemRecipeMulti),
    Shaped(Box<RecipesItemRecipeShaped>),
    ShapedChemistry(Box<RecipesItemRecipeShaped>),
    Shapeless(Box<RecipesItemRecipeShapeless>),
    ShapelessChemistry(Box<RecipesItemRecipeShapeless>),
    ShulkerBox(Box<RecipesItemRecipeShapeless>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItem {
    pub type_: RecipesItemType,
    pub recipe: Option<RecipesItemRecipe>,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.recipe {
            match v {
                RecipesItemRecipe::Furnace(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::FurnaceWithMetadata(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::Multi(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::Shaped(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::ShapedChemistry(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::Shapeless(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::ShapelessChemistry(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::ShulkerBox(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <RecipesItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe = match type_ {
            RecipesItemType::Furnace => {
                Some(
                    RecipesItemRecipe::Furnace(
                        Box::new(
                            <RecipesItemRecipeFurnace as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::FurnaceWithMetadata => {
                Some(
                    RecipesItemRecipe::FurnaceWithMetadata(
                        Box::new(
                            <RecipesItemRecipeFurnaceWithMetadata as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Multi => {
                Some(
                    RecipesItemRecipe::Multi(
                        <RecipesItemRecipeMulti as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipesItemType::Shaped => {
                Some(
                    RecipesItemRecipe::Shaped(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapedChemistry => {
                Some(
                    RecipesItemRecipe::ShapedChemistry(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Shapeless => {
                Some(
                    RecipesItemRecipe::Shapeless(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapelessChemistry => {
                Some(
                    RecipesItemRecipe::ShapelessChemistry(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShulkerBox => {
                Some(
                    RecipesItemRecipe::ShulkerBox(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, recipe })
    }
}
pub type Recipes = Vec<RecipesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct ResourcePackIdVersionsItem {
    pub uuid: String,
    pub version: String,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackIdVersionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { uuid, version, name })
    }
}
pub type ResourcePackIdVersions = Vec<ResourcePackIdVersionsItem>;
pub type ResourcePackIds = Vec<String>;
pub type Byterot = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Rotation {
    pub yaw: Byterot,
    pub pitch: Byterot,
    pub head_yaw: Byterot,
}
impl crate::bedrock::codec::BedrockCodec for Rotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.yaw.encode(buf)?;
        self.pitch.encode(buf)?;
        self.head_yaw.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { yaw, pitch, head_yaw })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ScoreEntriesType {
    Change = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for ScoreEntriesType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ScoreEntriesType::Change),
            1 => Ok(ScoreEntriesType::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ScoreEntriesType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum ScoreEntriesEntriesItemContentEntryType {
    Player = 1,
    Entity = 2,
    FakePlayer = 3,
}
impl crate::bedrock::codec::BedrockCodec for ScoreEntriesEntriesItemContentEntryType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(ScoreEntriesEntriesItemContentEntryType::Player),
            2 => Ok(ScoreEntriesEntriesItemContentEntryType::Entity),
            3 => Ok(ScoreEntriesEntriesItemContentEntryType::FakePlayer),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ScoreEntriesEntriesItemContentEntryType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ScoreEntriesEntriesItemContentEntityUniqueId {
    Entity(i64),
    Player(i64),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreEntriesEntriesItemContent {
    pub entry_type: ScoreEntriesEntriesItemContentEntryType,
    pub entity_unique_id: Option<ScoreEntriesEntriesItemContentEntityUniqueId>,
    pub custom_name: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for ScoreEntriesEntriesItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entry_type.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            match v {
                ScoreEntriesEntriesItemContentEntityUniqueId::Entity(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
                ScoreEntriesEntriesItemContentEntityUniqueId::Player(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
            }
        }
        if let Some(v) = &self.custom_name {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entry_type = <ScoreEntriesEntriesItemContentEntryType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_unique_id = match entry_type {
            ScoreEntriesEntriesItemContentEntryType::Entity => {
                Some(
                    ScoreEntriesEntriesItemContentEntityUniqueId::Entity(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            ScoreEntriesEntriesItemContentEntryType::Player => {
                Some(
                    ScoreEntriesEntriesItemContentEntityUniqueId::Player(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            _ => None,
        };
        let custom_name = match entry_type {
            ScoreEntriesEntriesItemContentEntryType::FakePlayer => {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        Ok(Self {
            entry_type,
            entity_unique_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreEntriesEntriesItem {
    pub scoreboard_id: i64,
    pub objective_name: String,
    pub score: i32,
    pub content: Option<Box<ScoreEntriesEntriesItemContent>>,
}
#[derive(Debug, Clone)]
pub struct ScoreEntriesEntriesItemArgs {
    pub type_: i32,
}
impl crate::bedrock::codec::BedrockCodec for ScoreEntriesEntriesItem {
    type Args = ScoreEntriesEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.scoreboard_id).encode(buf)?;
        self.objective_name.encode(buf)?;
        self.score.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let score = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match args.type_ {
            Remove => {
                Some(
                    Box::new(
                        <ScoreEntriesEntriesItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            objective_name,
            score,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreEntries {
    pub type_: ScoreEntriesType,
    pub entries: Vec<ScoreEntriesEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for ScoreEntries {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <ScoreEntriesType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ScoreEntriesEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ScoreEntriesEntriesItemArgs {
                                type_: type_ as i32,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { type_, entries })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum ScoreboardIdentityEntriesType {
    TypeRegisterIdentity = 0,
    TypeClearIdentity = 1,
}
impl crate::bedrock::codec::BedrockCodec for ScoreboardIdentityEntriesType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ScoreboardIdentityEntriesType::TypeRegisterIdentity),
            1 => Ok(ScoreboardIdentityEntriesType::TypeClearIdentity),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ScoreboardIdentityEntriesType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreboardIdentityEntriesEntriesItem {
    pub scoreboard_id: i64,
    pub entity_unique_id: Option<i64>,
}
#[derive(Debug, Clone)]
pub struct ScoreboardIdentityEntriesEntriesItemArgs {
    pub type_: i32,
}
impl crate::bedrock::codec::BedrockCodec for ScoreboardIdentityEntriesEntriesItem {
    type Args = ScoreboardIdentityEntriesEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.scoreboard_id).encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let scoreboard_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_unique_id = match args.type_ {
            TypeRegisterIdentity => {
                Some(
                    <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            }
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreboardIdentityEntries {
    pub type_: ScoreboardIdentityEntriesType,
    pub entries: Vec<ScoreboardIdentityEntriesEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for ScoreboardIdentityEntries {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <ScoreboardIdentityEntriesType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ScoreboardIdentityEntriesEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ScoreboardIdentityEntriesEntriesItemArgs {
                                type_: type_ as i32,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { type_, entries })
    }
}
pub type SignedByteArray = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct TexturePackInfosItem {
    pub uuid: String,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
    pub rtx_enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for TexturePackInfosItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.size.encode(buf)?;
        self.content_key.encode(buf)?;
        self.sub_pack_name.encode(buf)?;
        self.content_identity.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.rtx_enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content_key = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let sub_pack_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content_identity = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rtx_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
            rtx_enabled,
        })
    }
}
pub type TexturePackInfos = Vec<TexturePackInfosItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyTransactionsItemChangedSlotsItem {
    pub slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionLegacyTransactionsItemChangedSlotsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyTransactionsItem {
    pub container_id: u8,
    pub changed_slots: Vec<TransactionLegacyTransactionsItemChangedSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacyTransactionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        let len = self.changed_slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.changed_slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let changed_slots = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionLegacyTransactionsItemChangedSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            container_id,
            changed_slots,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionType {
    Normal = 0,
    InventoryMismatch = 1,
    ItemUse = 2,
    ItemUseOnEntity = 3,
    ItemRelease = 4,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionTransactionType::Normal),
            1 => Ok(TransactionTransactionType::InventoryMismatch),
            2 => Ok(TransactionTransactionType::ItemUse),
            3 => Ok(TransactionTransactionType::ItemUseOnEntity),
            4 => Ok(TransactionTransactionType::ItemRelease),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionInventoryActionsItemSourceType {
    Container = 0,
    Global = 1,
    WorldInteraction = 2,
    Creative = 3,
    CraftSlot = 100,
    Craft = 99999,
}
impl crate::bedrock::codec::BedrockCodec for TransactionInventoryActionsItemSourceType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionInventoryActionsItemSourceType::Container),
            1 => Ok(TransactionInventoryActionsItemSourceType::Global),
            2 => Ok(TransactionInventoryActionsItemSourceType::WorldInteraction),
            3 => Ok(TransactionInventoryActionsItemSourceType::Creative),
            100 => Ok(TransactionInventoryActionsItemSourceType::CraftSlot),
            99999 => Ok(TransactionInventoryActionsItemSourceType::Craft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionInventoryActionsItemSourceType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItemContentContainer {
    pub inventory_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionInventoryActionsItemContentContainer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.inventory_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let inventory_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { inventory_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItemContentCraft {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionInventoryActionsItemContentCraft {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.action).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { action })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItemContentWorldInteraction {
    pub flags: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionInventoryActionsItemContentWorldInteraction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.flags).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let flags = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionInventoryActionsItemContent {
    Container(TransactionInventoryActionsItemContentContainer),
    Craft(TransactionInventoryActionsItemContentCraft),
    CraftSlot(TransactionInventoryActionsItemContentCraft),
    Creative(TransactionInventoryActionsItemContentContainer),
    WorldInteraction(TransactionInventoryActionsItemContentWorldInteraction),
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionInventoryActionsItem {
    pub source_type: TransactionInventoryActionsItemSourceType,
    pub content: Option<TransactionInventoryActionsItemContent>,
    pub slot: i32,
    pub old_item: Item,
    pub new_item: Item,
    pub new_item_stack_id: Option<i32>,
}
#[derive(Debug, Clone)]
pub struct TransactionInventoryActionsItemArgs {
    pub network_ids: bool,
}
impl crate::bedrock::codec::BedrockCodec for TransactionInventoryActionsItem {
    type Args = TransactionInventoryActionsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source_type.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                TransactionInventoryActionsItemContent::Container(v) => {
                    v.encode(buf)?;
                }
                TransactionInventoryActionsItemContent::Craft(v) => {
                    v.encode(buf)?;
                }
                TransactionInventoryActionsItemContent::CraftSlot(v) => {
                    v.encode(buf)?;
                }
                TransactionInventoryActionsItemContent::Creative(v) => {
                    v.encode(buf)?;
                }
                TransactionInventoryActionsItemContent::WorldInteraction(v) => {
                    v.encode(buf)?;
                }
            }
        }
        crate::bedrock::codec::VarInt(self.slot).encode(buf)?;
        self.old_item.encode(buf)?;
        self.new_item.encode(buf)?;
        if let Some(v) = &self.new_item_stack_id {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let source_type = <TransactionInventoryActionsItemSourceType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match source_type {
            TransactionInventoryActionsItemSourceType::Container => {
                Some(
                    TransactionInventoryActionsItemContent::Container(
                        <TransactionInventoryActionsItemContentContainer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionInventoryActionsItemSourceType::Craft => {
                Some(
                    TransactionInventoryActionsItemContent::Craft(
                        <TransactionInventoryActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionInventoryActionsItemSourceType::CraftSlot => {
                Some(
                    TransactionInventoryActionsItemContent::CraftSlot(
                        <TransactionInventoryActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionInventoryActionsItemSourceType::Creative => {
                Some(
                    TransactionInventoryActionsItemContent::Creative(
                        <TransactionInventoryActionsItemContentContainer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionInventoryActionsItemSourceType::WorldInteraction => {
                Some(
                    TransactionInventoryActionsItemContent::WorldInteraction(
                        <TransactionInventoryActionsItemContentWorldInteraction as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let slot = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let old_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let new_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let new_item_stack_id = if args.network_ids {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        Ok(Self {
            source_type,
            content,
            slot,
            old_item,
            new_item,
            new_item_stack_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemReleaseActionType {
    Release = 0,
    Consume = 1,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemReleaseActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionTransactionDataItemReleaseActionType::Release),
            1 => Ok(TransactionTransactionDataItemReleaseActionType::Consume),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemReleaseActionType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemRelease {
    pub action_type: TransactionTransactionDataItemReleaseActionType,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub head_pos: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemRelease {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot).encode(buf)?;
        self.held_item.encode(buf)?;
        self.head_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <TransactionTransactionDataItemReleaseActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            action_type,
            hotbar_slot,
            held_item,
            head_pos,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemUseActionType {
    ClickBlock = 0,
    ClickAir = 1,
    BreakBlock = 2,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemUseActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionTransactionDataItemUseActionType::ClickBlock),
            1 => Ok(TransactionTransactionDataItemUseActionType::ClickAir),
            2 => Ok(TransactionTransactionDataItemUseActionType::BreakBlock),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemUseActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemUse {
    pub action_type: TransactionTransactionDataItemUseActionType,
    pub block_position: BlockCoordinates,
    pub face: i32,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
    pub block_runtime_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemUse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.block_position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.face).encode(buf)?;
        crate::bedrock::codec::VarInt(self.hotbar_slot).encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <TransactionTransactionDataItemUseActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let face = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let hotbar_slot = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            action_type,
            block_position,
            face,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
            block_runtime_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemUseOnEntityActionType {
    Interact = 0,
    Attack = 1,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemUseOnEntityActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Interact),
            1 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Attack),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemUseOnEntityActionType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemUseOnEntity {
    pub entity_runtime_id: i64,
    pub action_type: TransactionTransactionDataItemUseOnEntityActionType,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemUseOnEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.entity_runtime_id).encode(buf)?;
        self.action_type.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot).encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let action_type = <TransactionTransactionDataItemUseOnEntityActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_runtime_id,
            action_type,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionTransactionData {
    InventoryMismatch,
    ItemRelease(Box<TransactionTransactionDataItemRelease>),
    ItemUse(Box<TransactionTransactionDataItemUse>),
    ItemUseOnEntity(Box<TransactionTransactionDataItemUseOnEntity>),
    Normal,
}
#[derive(Debug, Clone, PartialEq)]
pub struct Transaction {
    pub legacy_transactions: Option<Vec<TransactionLegacyTransactionsItem>>,
    pub transaction_type: TransactionTransactionType,
    pub network_ids: bool,
    pub inventory_actions: Vec<TransactionInventoryActionsItem>,
    pub transaction_data: Option<TransactionTransactionData>,
}
impl crate::bedrock::codec::BedrockCodec for Transaction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.legacy_transactions.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.legacy_transactions {
            v.encode(buf)?;
        }
        self.transaction_type.encode(buf)?;
        self.network_ids.encode(buf)?;
        let len = self.inventory_actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.inventory_actions {
            item.encode(buf)?;
        }
        if let Some(v) = &self.transaction_data {
            match v {
                TransactionTransactionData::InventoryMismatch => {}
                TransactionTransactionData::ItemRelease(v) => {
                    v.encode(buf)?;
                }
                TransactionTransactionData::ItemUse(v) => {
                    v.encode(buf)?;
                }
                TransactionTransactionData::ItemUseOnEntity(v) => {
                    v.encode(buf)?;
                }
                TransactionTransactionData::Normal => {}
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let legacy_request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let legacy_transactions = if (legacy_request_id) != 0 {
            Some({
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TransactionLegacyTransactionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            })
        } else {
            None
        };
        let transaction_type = <TransactionTransactionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let network_ids = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let inventory_actions = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionInventoryActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            TransactionInventoryActionsItemArgs {
                                network_ids: network_ids,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let transaction_data = match transaction_type {
            TransactionTransactionType::InventoryMismatch => {
                Some(TransactionTransactionData::InventoryMismatch)
            }
            TransactionTransactionType::ItemRelease => {
                Some(
                    TransactionTransactionData::ItemRelease(
                        Box::new(
                            <TransactionTransactionDataItemRelease as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUse => {
                Some(
                    TransactionTransactionData::ItemUse(
                        Box::new(
                            <TransactionTransactionDataItemUse as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUseOnEntity => {
                Some(
                    TransactionTransactionData::ItemUseOnEntity(
                        Box::new(
                            <TransactionTransactionDataItemUseOnEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::Normal => {
                Some(TransactionTransactionData::Normal)
            }
            _ => None,
        };
        Ok(Self {
            legacy_transactions,
            transaction_type,
            network_ids,
            inventory_actions,
            transaction_data,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum WindowId {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
}
impl crate::bedrock::codec::BedrockCodec for WindowId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            -100 => Ok(WindowId::DropContents),
            -24 => Ok(WindowId::Beacon),
            -23 => Ok(WindowId::TradingOutput),
            -22 => Ok(WindowId::TradingUseInputs),
            -21 => Ok(WindowId::TradingInput2),
            -20 => Ok(WindowId::TradingInput1),
            -17 => Ok(WindowId::EnchantOutput),
            -16 => Ok(WindowId::EnchantMaterial),
            -15 => Ok(WindowId::EnchantInput),
            -13 => Ok(WindowId::AnvilOutput),
            -12 => Ok(WindowId::AnvilResult),
            -11 => Ok(WindowId::AnvilMaterial),
            -10 => Ok(WindowId::ContainerInput),
            -5 => Ok(WindowId::CraftingUseIngredient),
            -4 => Ok(WindowId::CraftingResult),
            -3 => Ok(WindowId::CraftingRemoveIngredient),
            -2 => Ok(WindowId::CraftingAddIngredient),
            -1 => Ok(WindowId::None),
            0 => Ok(WindowId::Inventory),
            1 => Ok(WindowId::First),
            100 => Ok(WindowId::Last),
            119 => Ok(WindowId::Offhand),
            120 => Ok(WindowId::Armor),
            121 => Ok(WindowId::Creative),
            122 => Ok(WindowId::Hotbar),
            123 => Ok(WindowId::FixedInventory),
            124 => Ok(WindowId::Ui),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum WindowIdVarint {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
}
impl crate::bedrock::codec::BedrockCodec for WindowIdVarint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            -100 => Ok(WindowIdVarint::DropContents),
            -24 => Ok(WindowIdVarint::Beacon),
            -23 => Ok(WindowIdVarint::TradingOutput),
            -22 => Ok(WindowIdVarint::TradingUseInputs),
            -21 => Ok(WindowIdVarint::TradingInput2),
            -20 => Ok(WindowIdVarint::TradingInput1),
            -17 => Ok(WindowIdVarint::EnchantOutput),
            -16 => Ok(WindowIdVarint::EnchantMaterial),
            -15 => Ok(WindowIdVarint::EnchantInput),
            -13 => Ok(WindowIdVarint::AnvilOutput),
            -12 => Ok(WindowIdVarint::AnvilResult),
            -11 => Ok(WindowIdVarint::AnvilMaterial),
            -10 => Ok(WindowIdVarint::ContainerInput),
            -5 => Ok(WindowIdVarint::CraftingUseIngredient),
            -4 => Ok(WindowIdVarint::CraftingResult),
            -3 => Ok(WindowIdVarint::CraftingRemoveIngredient),
            -2 => Ok(WindowIdVarint::CraftingAddIngredient),
            -1 => Ok(WindowIdVarint::None),
            0 => Ok(WindowIdVarint::Inventory),
            1 => Ok(WindowIdVarint::First),
            100 => Ok(WindowIdVarint::Last),
            119 => Ok(WindowIdVarint::Offhand),
            120 => Ok(WindowIdVarint::Armor),
            121 => Ok(WindowIdVarint::Creative),
            122 => Ok(WindowIdVarint::Hotbar),
            123 => Ok(WindowIdVarint::FixedInventory),
            124 => Ok(WindowIdVarint::Ui),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowIdVarint),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum WindowType {
    Container = 0,
    Workbench = 1,
    Furnace = 2,
    Enchantment = 3,
    BrewingStand = 4,
    Anvil = 5,
    Dispenser = 6,
    Dropper = 7,
    Hopper = 8,
    Cauldron = 9,
    MinecartChest = 10,
    MinecartHopper = 11,
    Horse = 12,
    Beacon = 13,
    StructureEditor = 14,
    Trading = 15,
    CommandBlock = 16,
    Jukebox = 17,
    Armor = 18,
    Hand = 19,
    CompoundCreator = 20,
    ElementConstructor = 21,
    MaterialReducer = 22,
    LabTable = 23,
    Loom = 24,
    Lectern = 25,
    Grindstone = 26,
    BlastFurnace = 27,
    Smoker = 28,
    Stonecutter = 29,
    Cartography = 30,
    Hud = 31,
    JigsawEditor = 32,
    SmithingTable = 33,
}
impl crate::bedrock::codec::BedrockCodec for WindowType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(WindowType::Container),
            1 => Ok(WindowType::Workbench),
            2 => Ok(WindowType::Furnace),
            3 => Ok(WindowType::Enchantment),
            4 => Ok(WindowType::BrewingStand),
            5 => Ok(WindowType::Anvil),
            6 => Ok(WindowType::Dispenser),
            7 => Ok(WindowType::Dropper),
            8 => Ok(WindowType::Hopper),
            9 => Ok(WindowType::Cauldron),
            10 => Ok(WindowType::MinecartChest),
            11 => Ok(WindowType::MinecartHopper),
            12 => Ok(WindowType::Horse),
            13 => Ok(WindowType::Beacon),
            14 => Ok(WindowType::StructureEditor),
            15 => Ok(WindowType::Trading),
            16 => Ok(WindowType::CommandBlock),
            17 => Ok(WindowType::Jukebox),
            18 => Ok(WindowType::Armor),
            19 => Ok(WindowType::Hand),
            20 => Ok(WindowType::CompoundCreator),
            21 => Ok(WindowType::ElementConstructor),
            22 => Ok(WindowType::MaterialReducer),
            23 => Ok(WindowType::LabTable),
            24 => Ok(WindowType::Loom),
            25 => Ok(WindowType::Lectern),
            26 => Ok(WindowType::Grindstone),
            27 => Ok(WindowType::BlastFurnace),
            28 => Ok(WindowType::Smoker),
            29 => Ok(WindowType::Stonecutter),
            30 => Ok(WindowType::Cartography),
            31 => Ok(WindowType::Hud),
            32 => Ok(WindowType::JigsawEditor),
            33 => Ok(WindowType::SmithingTable),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowType), val
                        ),
                    ),
                )
            }
        }
    }
}
pub type Bitflags = Vec<u8>;
pub type Encapsulated = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum EnumSizeBasedOnValuesLen {
    Byte = 0,
    Short = 1,
    Int = 2,
}
impl crate::bedrock::codec::BedrockCodec for EnumSizeBasedOnValuesLen {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(EnumSizeBasedOnValuesLen::Byte),
            1 => Ok(EnumSizeBasedOnValuesLen::Short),
            2 => Ok(EnumSizeBasedOnValuesLen::Int),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(EnumSizeBasedOnValuesLen), val
                        ),
                    ),
                )
            }
        }
    }
}
pub type Lnbt = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum McpePacketName {
    Login = 1,
    PlayStatus = 2,
    ServerToClientHandshake = 3,
    ClientToServerHandshake = 4,
    Disconnect = 5,
    ResourcePacksInfo = 6,
    ResourcePackStack = 7,
    ResourcePackClientResponse = 8,
    Text = 9,
    SetTime = 10,
    StartGame = 11,
    AddPlayer = 12,
    AddEntity = 13,
    RemoveEntity = 14,
    AddItemEntity = 15,
    TakeItemEntity = 17,
    MoveEntity = 18,
    MovePlayer = 19,
    RiderJump = 20,
    UpdateBlock = 21,
    AddPainting = 22,
    TickSync = 23,
    LevelSoundEventOld = 24,
    LevelEvent = 25,
    BlockEvent = 26,
    EntityEvent = 27,
    MobEffect = 28,
    UpdateAttributes = 29,
    InventoryTransaction = 30,
    MobEquipment = 31,
    MobArmorEquipment = 32,
    Interact = 33,
    BlockPickRequest = 34,
    EntityPickRequest = 35,
    PlayerAction = 36,
    HurtArmor = 38,
    SetEntityData = 39,
    SetEntityMotion = 40,
    SetEntityLink = 41,
    SetHealth = 42,
    SetSpawnPosition = 43,
    Animate = 44,
    Respawn = 45,
    ContainerOpen = 46,
    ContainerClose = 47,
    PlayerHotbar = 48,
    InventoryContent = 49,
    InventorySlot = 50,
    ContainerSetData = 51,
    CraftingData = 52,
    CraftingEvent = 53,
    GuiDataPickItem = 54,
    AdventureSettings = 55,
    BlockEntityData = 56,
    PlayerInput = 57,
    LevelChunk = 58,
    SetCommandsEnabled = 59,
    SetDifficulty = 60,
    ChangeDimension = 61,
    SetPlayerGameType = 62,
    PlayerList = 63,
    SimpleEvent = 64,
    Event = 65,
    SpawnExperienceOrb = 66,
    ClientboundMapItemData = 67,
    MapInfoRequest = 68,
    RequestChunkRadius = 69,
    ChunkRadiusUpdate = 70,
    ItemFrameDropItem = 71,
    GameRulesChanged = 72,
    Camera = 73,
    BossEvent = 74,
    ShowCredits = 75,
    AvailableCommands = 76,
    CommandRequest = 77,
    CommandBlockUpdate = 78,
    CommandOutput = 79,
    UpdateTrade = 80,
    UpdateEquipment = 81,
    ResourcePackDataInfo = 82,
    ResourcePackChunkData = 83,
    ResourcePackChunkRequest = 84,
    Transfer = 85,
    PlaySound = 86,
    StopSound = 87,
    SetTitle = 88,
    AddBehaviorTree = 89,
    StructureBlockUpdate = 90,
    ShowStoreOffer = 91,
    PurchaseReceipt = 92,
    PlayerSkin = 93,
    SubClientLogin = 94,
    InitiateWebSocketConnection = 95,
    SetLastHurtBy = 96,
    BookEdit = 97,
    NpcRequest = 98,
    PhotoTransfer = 99,
    ModalFormRequest = 100,
    ModalFormResponse = 101,
    ServerSettingsRequest = 102,
    ServerSettingsResponse = 103,
    ShowProfile = 104,
    SetDefaultGameType = 105,
    RemoveObjective = 106,
    SetDisplayObjective = 107,
    SetScore = 108,
    LabTable = 109,
    UpdateBlockSynced = 110,
    MoveEntityDelta = 111,
    SetScoreboardIdentity = 112,
    SetLocalPlayerAsInitialized = 113,
    UpdateSoftEnum = 114,
    NetworkStackLatency = 115,
    ScriptCustomEvent = 117,
    SpawnParticleEffect = 118,
    AvailableEntityIdentifiers = 119,
    LevelSoundEventV2 = 120,
    NetworkChunkPublisherUpdate = 121,
    BiomeDefinitionList = 122,
    LevelSoundEvent = 123,
    LevelEventGeneric = 124,
    LecternUpdate = 125,
    VideoStreamConnect = 126,
    AddEcsEntity = 127,
    RemoveEcsEntity = 128,
    ClientCacheStatus = 129,
    OnScreenTextureAnimation = 130,
    MapCreateLockedCopy = 131,
    StructureTemplateDataExportRequest = 132,
    StructureTemplateDataExportResponse = 133,
    UpdateBlockProperties = 134,
    ClientCacheBlobStatus = 135,
    ClientCacheMissResponse = 136,
    EducationSettings = 137,
    Emote = 138,
    MultiplayerSettings = 139,
    SettingsCommand = 140,
    AnvilDamage = 141,
    CompletedUsingItem = 142,
    NetworkSettings = 143,
    PlayerAuthInput = 144,
    CreativeContent = 145,
    PlayerEnchantOptions = 146,
    ItemStackRequest = 147,
    ItemStackResponse = 148,
    PlayerArmorDamage = 149,
    CodeBuilder = 150,
    UpdatePlayerGameType = 151,
    EmoteList = 152,
    PositionTrackingDbBroadcast = 153,
    PositionTrackingDbRequest = 154,
    DebugInfo = 155,
    PacketViolationWarning = 156,
    MotionPredictionHints = 157,
    AnimateEntity = 158,
    CameraShake = 159,
    PlayerFog = 160,
    CorrectPlayerMovePrediction = 161,
    ItemComponent = 162,
    FilterTextPacket = 163,
}
impl crate::bedrock::codec::BedrockCodec for McpePacketName {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(McpePacketName::Login),
            2 => Ok(McpePacketName::PlayStatus),
            3 => Ok(McpePacketName::ServerToClientHandshake),
            4 => Ok(McpePacketName::ClientToServerHandshake),
            5 => Ok(McpePacketName::Disconnect),
            6 => Ok(McpePacketName::ResourcePacksInfo),
            7 => Ok(McpePacketName::ResourcePackStack),
            8 => Ok(McpePacketName::ResourcePackClientResponse),
            9 => Ok(McpePacketName::Text),
            10 => Ok(McpePacketName::SetTime),
            11 => Ok(McpePacketName::StartGame),
            12 => Ok(McpePacketName::AddPlayer),
            13 => Ok(McpePacketName::AddEntity),
            14 => Ok(McpePacketName::RemoveEntity),
            15 => Ok(McpePacketName::AddItemEntity),
            17 => Ok(McpePacketName::TakeItemEntity),
            18 => Ok(McpePacketName::MoveEntity),
            19 => Ok(McpePacketName::MovePlayer),
            20 => Ok(McpePacketName::RiderJump),
            21 => Ok(McpePacketName::UpdateBlock),
            22 => Ok(McpePacketName::AddPainting),
            23 => Ok(McpePacketName::TickSync),
            24 => Ok(McpePacketName::LevelSoundEventOld),
            25 => Ok(McpePacketName::LevelEvent),
            26 => Ok(McpePacketName::BlockEvent),
            27 => Ok(McpePacketName::EntityEvent),
            28 => Ok(McpePacketName::MobEffect),
            29 => Ok(McpePacketName::UpdateAttributes),
            30 => Ok(McpePacketName::InventoryTransaction),
            31 => Ok(McpePacketName::MobEquipment),
            32 => Ok(McpePacketName::MobArmorEquipment),
            33 => Ok(McpePacketName::Interact),
            34 => Ok(McpePacketName::BlockPickRequest),
            35 => Ok(McpePacketName::EntityPickRequest),
            36 => Ok(McpePacketName::PlayerAction),
            38 => Ok(McpePacketName::HurtArmor),
            39 => Ok(McpePacketName::SetEntityData),
            40 => Ok(McpePacketName::SetEntityMotion),
            41 => Ok(McpePacketName::SetEntityLink),
            42 => Ok(McpePacketName::SetHealth),
            43 => Ok(McpePacketName::SetSpawnPosition),
            44 => Ok(McpePacketName::Animate),
            45 => Ok(McpePacketName::Respawn),
            46 => Ok(McpePacketName::ContainerOpen),
            47 => Ok(McpePacketName::ContainerClose),
            48 => Ok(McpePacketName::PlayerHotbar),
            49 => Ok(McpePacketName::InventoryContent),
            50 => Ok(McpePacketName::InventorySlot),
            51 => Ok(McpePacketName::ContainerSetData),
            52 => Ok(McpePacketName::CraftingData),
            53 => Ok(McpePacketName::CraftingEvent),
            54 => Ok(McpePacketName::GuiDataPickItem),
            55 => Ok(McpePacketName::AdventureSettings),
            56 => Ok(McpePacketName::BlockEntityData),
            57 => Ok(McpePacketName::PlayerInput),
            58 => Ok(McpePacketName::LevelChunk),
            59 => Ok(McpePacketName::SetCommandsEnabled),
            60 => Ok(McpePacketName::SetDifficulty),
            61 => Ok(McpePacketName::ChangeDimension),
            62 => Ok(McpePacketName::SetPlayerGameType),
            63 => Ok(McpePacketName::PlayerList),
            64 => Ok(McpePacketName::SimpleEvent),
            65 => Ok(McpePacketName::Event),
            66 => Ok(McpePacketName::SpawnExperienceOrb),
            67 => Ok(McpePacketName::ClientboundMapItemData),
            68 => Ok(McpePacketName::MapInfoRequest),
            69 => Ok(McpePacketName::RequestChunkRadius),
            70 => Ok(McpePacketName::ChunkRadiusUpdate),
            71 => Ok(McpePacketName::ItemFrameDropItem),
            72 => Ok(McpePacketName::GameRulesChanged),
            73 => Ok(McpePacketName::Camera),
            74 => Ok(McpePacketName::BossEvent),
            75 => Ok(McpePacketName::ShowCredits),
            76 => Ok(McpePacketName::AvailableCommands),
            77 => Ok(McpePacketName::CommandRequest),
            78 => Ok(McpePacketName::CommandBlockUpdate),
            79 => Ok(McpePacketName::CommandOutput),
            80 => Ok(McpePacketName::UpdateTrade),
            81 => Ok(McpePacketName::UpdateEquipment),
            82 => Ok(McpePacketName::ResourcePackDataInfo),
            83 => Ok(McpePacketName::ResourcePackChunkData),
            84 => Ok(McpePacketName::ResourcePackChunkRequest),
            85 => Ok(McpePacketName::Transfer),
            86 => Ok(McpePacketName::PlaySound),
            87 => Ok(McpePacketName::StopSound),
            88 => Ok(McpePacketName::SetTitle),
            89 => Ok(McpePacketName::AddBehaviorTree),
            90 => Ok(McpePacketName::StructureBlockUpdate),
            91 => Ok(McpePacketName::ShowStoreOffer),
            92 => Ok(McpePacketName::PurchaseReceipt),
            93 => Ok(McpePacketName::PlayerSkin),
            94 => Ok(McpePacketName::SubClientLogin),
            95 => Ok(McpePacketName::InitiateWebSocketConnection),
            96 => Ok(McpePacketName::SetLastHurtBy),
            97 => Ok(McpePacketName::BookEdit),
            98 => Ok(McpePacketName::NpcRequest),
            99 => Ok(McpePacketName::PhotoTransfer),
            100 => Ok(McpePacketName::ModalFormRequest),
            101 => Ok(McpePacketName::ModalFormResponse),
            102 => Ok(McpePacketName::ServerSettingsRequest),
            103 => Ok(McpePacketName::ServerSettingsResponse),
            104 => Ok(McpePacketName::ShowProfile),
            105 => Ok(McpePacketName::SetDefaultGameType),
            106 => Ok(McpePacketName::RemoveObjective),
            107 => Ok(McpePacketName::SetDisplayObjective),
            108 => Ok(McpePacketName::SetScore),
            109 => Ok(McpePacketName::LabTable),
            110 => Ok(McpePacketName::UpdateBlockSynced),
            111 => Ok(McpePacketName::MoveEntityDelta),
            112 => Ok(McpePacketName::SetScoreboardIdentity),
            113 => Ok(McpePacketName::SetLocalPlayerAsInitialized),
            114 => Ok(McpePacketName::UpdateSoftEnum),
            115 => Ok(McpePacketName::NetworkStackLatency),
            117 => Ok(McpePacketName::ScriptCustomEvent),
            118 => Ok(McpePacketName::SpawnParticleEffect),
            119 => Ok(McpePacketName::AvailableEntityIdentifiers),
            120 => Ok(McpePacketName::LevelSoundEventV2),
            121 => Ok(McpePacketName::NetworkChunkPublisherUpdate),
            122 => Ok(McpePacketName::BiomeDefinitionList),
            123 => Ok(McpePacketName::LevelSoundEvent),
            124 => Ok(McpePacketName::LevelEventGeneric),
            125 => Ok(McpePacketName::LecternUpdate),
            126 => Ok(McpePacketName::VideoStreamConnect),
            127 => Ok(McpePacketName::AddEcsEntity),
            128 => Ok(McpePacketName::RemoveEcsEntity),
            129 => Ok(McpePacketName::ClientCacheStatus),
            130 => Ok(McpePacketName::OnScreenTextureAnimation),
            131 => Ok(McpePacketName::MapCreateLockedCopy),
            132 => Ok(McpePacketName::StructureTemplateDataExportRequest),
            133 => Ok(McpePacketName::StructureTemplateDataExportResponse),
            134 => Ok(McpePacketName::UpdateBlockProperties),
            135 => Ok(McpePacketName::ClientCacheBlobStatus),
            136 => Ok(McpePacketName::ClientCacheMissResponse),
            137 => Ok(McpePacketName::EducationSettings),
            138 => Ok(McpePacketName::Emote),
            139 => Ok(McpePacketName::MultiplayerSettings),
            140 => Ok(McpePacketName::SettingsCommand),
            141 => Ok(McpePacketName::AnvilDamage),
            142 => Ok(McpePacketName::CompletedUsingItem),
            143 => Ok(McpePacketName::NetworkSettings),
            144 => Ok(McpePacketName::PlayerAuthInput),
            145 => Ok(McpePacketName::CreativeContent),
            146 => Ok(McpePacketName::PlayerEnchantOptions),
            147 => Ok(McpePacketName::ItemStackRequest),
            148 => Ok(McpePacketName::ItemStackResponse),
            149 => Ok(McpePacketName::PlayerArmorDamage),
            150 => Ok(McpePacketName::CodeBuilder),
            151 => Ok(McpePacketName::UpdatePlayerGameType),
            152 => Ok(McpePacketName::EmoteList),
            153 => Ok(McpePacketName::PositionTrackingDbBroadcast),
            154 => Ok(McpePacketName::PositionTrackingDbRequest),
            155 => Ok(McpePacketName::DebugInfo),
            156 => Ok(McpePacketName::PacketViolationWarning),
            157 => Ok(McpePacketName::MotionPredictionHints),
            158 => Ok(McpePacketName::AnimateEntity),
            159 => Ok(McpePacketName::CameraShake),
            160 => Ok(McpePacketName::PlayerFog),
            161 => Ok(McpePacketName::CorrectPlayerMovePrediction),
            162 => Ok(McpePacketName::ItemComponent),
            163 => Ok(McpePacketName::FilterTextPacket),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(McpePacketName),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
pub type NbtLoop = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Vec2F {
    pub x: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec2F {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { x, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum McpePacketParams {
    AddBehaviorTree(PacketAddBehaviorTree),
    AddEcsEntity(PacketAddEcsEntity),
    AddEntity(Box<PacketAddEntity>),
    AddItemEntity(Box<PacketAddItemEntity>),
    AddPainting(Box<PacketAddPainting>),
    AddPlayer(Box<PacketAddPlayer>),
    AdventureSettings(Box<PacketAdventureSettings>),
    Animate(Box<PacketAnimate>),
    AnimateEntity(Box<PacketAnimateEntity>),
    AnvilDamage(PacketAnvilDamage),
    AvailableCommands(Box<PacketAvailableCommands>),
    AvailableEntityIdentifiers(PacketAvailableEntityIdentifiers),
    BiomeDefinitionList(PacketBiomeDefinitionList),
    BlockEntityData(PacketBlockEntityData),
    BlockEvent(PacketBlockEvent),
    BlockPickRequest(Box<PacketBlockPickRequest>),
    BookEdit(Box<PacketBookEdit>),
    BossEvent(Box<PacketBossEvent>),
    Camera(PacketCamera),
    CameraShake(PacketCameraShake),
    ChangeDimension(PacketChangeDimension),
    ChunkRadiusUpdate(PacketChunkRadiusUpdate),
    ClientCacheBlobStatus(Box<PacketClientCacheBlobStatus>),
    ClientCacheMissResponse(PacketClientCacheMissResponse),
    ClientCacheStatus(PacketClientCacheStatus),
    ClientToServerHandshake(PacketClientToServerHandshake),
    ClientboundMapItemData(PacketClientboundMapItemData),
    CodeBuilder(PacketCodeBuilder),
    CommandBlockUpdate(Box<PacketCommandBlockUpdate>),
    CommandOutput(Box<PacketCommandOutput>),
    CommandRequest(Box<PacketCommandRequest>),
    CompletedUsingItem(PacketCompletedUsingItem),
    ContainerClose(PacketContainerClose),
    ContainerOpen(Box<PacketContainerOpen>),
    ContainerSetData(PacketContainerSetData),
    CorrectPlayerMovePrediction(Box<PacketCorrectPlayerMovePrediction>),
    CraftingData(Box<PacketCraftingData>),
    CraftingEvent(Box<PacketCraftingEvent>),
    CreativeContent(PacketCreativeContent),
    DebugInfo(PacketDebugInfo),
    Disconnect(PacketDisconnect),
    EducationSettings(Box<PacketEducationSettings>),
    Emote(PacketEmote),
    EmoteList(PacketEmoteList),
    EntityEvent(PacketEntityEvent),
    EntityPickRequest(PacketEntityPickRequest),
    Event(Box<PacketEvent>),
    FilterTextPacket(PacketFilterTextPacket),
    GameRulesChanged(PacketGameRulesChanged),
    GuiDataPickItem(PacketGuiDataPickItem),
    HurtArmor(PacketHurtArmor),
    InitiateWebSocketConnection(PacketInitiateWebSocketConnection),
    Interact(Box<PacketInteract>),
    InventoryContent(PacketInventoryContent),
    InventorySlot(Box<PacketInventorySlot>),
    InventoryTransaction(Box<PacketInventoryTransaction>),
    ItemComponent(PacketItemComponent),
    ItemFrameDropItem(PacketItemFrameDropItem),
    ItemStackRequest(PacketItemStackRequest),
    ItemStackResponse(PacketItemStackResponse),
    LabTable(PacketLabTable),
    LecternUpdate(Box<PacketLecternUpdate>),
    LevelChunk(Box<PacketLevelChunk>),
    LevelEvent(PacketLevelEvent),
    LevelEventGeneric(PacketLevelEventGeneric),
    LevelSoundEvent(Box<PacketLevelSoundEvent>),
    LevelSoundEventOld(Box<PacketLevelSoundEventOld>),
    LevelSoundEventV2(Box<PacketLevelSoundEventV2>),
    Login(PacketLogin),
    MapCreateLockedCopy(PacketMapCreateLockedCopy),
    MapInfoRequest(PacketMapInfoRequest),
    MobArmorEquipment(Box<PacketMobArmorEquipment>),
    MobEffect(Box<PacketMobEffect>),
    MobEquipment(Box<PacketMobEquipment>),
    ModalFormRequest(PacketModalFormRequest),
    ModalFormResponse(PacketModalFormResponse),
    MotionPredictionHints(PacketMotionPredictionHints),
    MoveEntity(Box<PacketMoveEntity>),
    MoveEntityDelta(Box<PacketMoveEntityDelta>),
    MovePlayer(Box<PacketMovePlayer>),
    MultiplayerSettings(PacketMultiplayerSettings),
    NetworkChunkPublisherUpdate(PacketNetworkChunkPublisherUpdate),
    NetworkSettings(PacketNetworkSettings),
    NetworkStackLatency(PacketNetworkStackLatency),
    NpcRequest(Box<PacketNpcRequest>),
    OnScreenTextureAnimation(PacketOnScreenTextureAnimation),
    PacketViolationWarning(Box<PacketPacketViolationWarning>),
    PhotoTransfer(PacketPhotoTransfer),
    PlaySound(Box<PacketPlaySound>),
    PlayStatus(PacketPlayStatus),
    PlayerAction(Box<PacketPlayerAction>),
    PlayerArmorDamage(Box<PacketPlayerArmorDamage>),
    PlayerAuthInput(Box<PacketPlayerAuthInput>),
    PlayerEnchantOptions(PacketPlayerEnchantOptions),
    PlayerFog(PacketPlayerFog),
    PlayerHotbar(PacketPlayerHotbar),
    PlayerInput(Box<PacketPlayerInput>),
    PlayerList(Box<PacketPlayerList>),
    PlayerSkin(Box<PacketPlayerSkin>),
    PositionTrackingDbBroadcast(PacketPositionTrackingDbBroadcast),
    PositionTrackingDbRequest(PacketPositionTrackingDbRequest),
    PurchaseReceipt(PacketPurchaseReceipt),
    RemoveEcsEntity(PacketRemoveEcsEntity),
    RemoveEntity(PacketRemoveEntity),
    RemoveObjective(PacketRemoveObjective),
    RequestChunkRadius(PacketRequestChunkRadius),
    ResourcePackChunkData(Box<PacketResourcePackChunkData>),
    ResourcePackChunkRequest(PacketResourcePackChunkRequest),
    ResourcePackClientResponse(PacketResourcePackClientResponse),
    ResourcePackDataInfo(Box<PacketResourcePackDataInfo>),
    ResourcePackStack(Box<PacketResourcePackStack>),
    ResourcePacksInfo(Box<PacketResourcePacksInfo>),
    Respawn(Box<PacketRespawn>),
    RiderJump(PacketRiderJump),
    ScriptCustomEvent(PacketScriptCustomEvent),
    ServerSettingsRequest(PacketServerSettingsRequest),
    ServerSettingsResponse(PacketServerSettingsResponse),
    ServerToClientHandshake(PacketServerToClientHandshake),
    SetCommandsEnabled(PacketSetCommandsEnabled),
    SetDefaultGameType(PacketSetDefaultGameType),
    SetDifficulty(PacketSetDifficulty),
    SetDisplayObjective(Box<PacketSetDisplayObjective>),
    SetEntityData(PacketSetEntityData),
    SetEntityLink(Box<PacketSetEntityLink>),
    SetEntityMotion(PacketSetEntityMotion),
    SetHealth(PacketSetHealth),
    SetLastHurtBy(PacketSetLastHurtBy),
    SetLocalPlayerAsInitialized(PacketSetLocalPlayerAsInitialized),
    SetPlayerGameType(PacketSetPlayerGameType),
    SetScore(PacketSetScore),
    SetScoreboardIdentity(PacketSetScoreboardIdentity),
    SetSpawnPosition(Box<PacketSetSpawnPosition>),
    SetTime(PacketSetTime),
    SetTitle(Box<PacketSetTitle>),
    SettingsCommand(PacketSettingsCommand),
    ShowCredits(PacketShowCredits),
    ShowProfile(PacketShowProfile),
    ShowStoreOffer(PacketShowStoreOffer),
    SimpleEvent(PacketSimpleEvent),
    SpawnExperienceOrb(PacketSpawnExperienceOrb),
    SpawnParticleEffect(Box<PacketSpawnParticleEffect>),
    StartGame(Box<PacketStartGame>),
    StopSound(PacketStopSound),
    StructureBlockUpdate(PacketStructureBlockUpdate),
    StructureTemplateDataExportRequest(PacketStructureTemplateDataExportRequest),
    StructureTemplateDataExportResponse(PacketStructureTemplateDataExportResponse),
    SubClientLogin(PacketSubClientLogin),
    TakeItemEntity(PacketTakeItemEntity),
    Text(Box<PacketText>),
    TickSync(PacketTickSync),
    Transfer(PacketTransfer),
    UpdateAttributes(PacketUpdateAttributes),
    UpdateBlock(Box<PacketUpdateBlock>),
    UpdateBlockProperties(PacketUpdateBlockProperties),
    UpdateBlockSynced(Box<PacketUpdateBlockSynced>),
    UpdateEquipment(Box<PacketUpdateEquipment>),
    UpdatePlayerGameType(PacketUpdatePlayerGameType),
    UpdateSoftEnum(PacketUpdateSoftEnum),
    UpdateTrade(Box<PacketUpdateTrade>),
    VideoStreamConnect(Box<PacketVideoStreamConnect>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct McpePacket {
    pub name: McpePacketName,
    pub params: Option<McpePacketParams>,
}
impl crate::bedrock::codec::BedrockCodec for McpePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        if let Some(v) = &self.params {
            match v {
                McpePacketParams::AddBehaviorTree(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AddEcsEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AddEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AddItemEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AddPainting(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AddPlayer(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AdventureSettings(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Animate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AnimateEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AnvilDamage(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AvailableCommands(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AvailableEntityIdentifiers(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BiomeDefinitionList(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BlockEntityData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BlockEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BlockPickRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BookEdit(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BossEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Camera(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CameraShake(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ChangeDimension(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ChunkRadiusUpdate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientCacheBlobStatus(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientCacheMissResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientCacheStatus(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientToServerHandshake(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientboundMapItemData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CodeBuilder(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CommandBlockUpdate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CommandOutput(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CommandRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CompletedUsingItem(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ContainerClose(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ContainerOpen(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ContainerSetData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CorrectPlayerMovePrediction(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CraftingData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CraftingEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CreativeContent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::DebugInfo(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Disconnect(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EducationSettings(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Emote(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EmoteList(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EntityEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EntityPickRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Event(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::FilterTextPacket(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::GameRulesChanged(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::GuiDataPickItem(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::HurtArmor(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::InitiateWebSocketConnection(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Interact(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::InventoryContent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::InventorySlot(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::InventoryTransaction(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ItemComponent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ItemFrameDropItem(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ItemStackRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ItemStackResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LabTable(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LecternUpdate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelChunk(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelEventGeneric(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelSoundEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelSoundEventOld(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelSoundEventV2(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Login(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MapCreateLockedCopy(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MapInfoRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MobArmorEquipment(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MobEffect(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MobEquipment(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ModalFormRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ModalFormResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MotionPredictionHints(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MoveEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MoveEntityDelta(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MovePlayer(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MultiplayerSettings(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::NetworkChunkPublisherUpdate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::NetworkSettings(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::NetworkStackLatency(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::NpcRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::OnScreenTextureAnimation(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PacketViolationWarning(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PhotoTransfer(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlaySound(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayStatus(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerAction(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerArmorDamage(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerAuthInput(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerEnchantOptions(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerFog(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerHotbar(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerInput(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerList(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerSkin(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PositionTrackingDbBroadcast(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PositionTrackingDbRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PurchaseReceipt(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RemoveEcsEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RemoveEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RemoveObjective(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RequestChunkRadius(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackChunkData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackChunkRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackClientResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackDataInfo(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackStack(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePacksInfo(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Respawn(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RiderJump(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ScriptCustomEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ServerSettingsRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ServerSettingsResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ServerToClientHandshake(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetCommandsEnabled(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetDefaultGameType(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetDifficulty(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetDisplayObjective(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetEntityData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetEntityLink(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetEntityMotion(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetHealth(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetLastHurtBy(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetLocalPlayerAsInitialized(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetPlayerGameType(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetScore(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetScoreboardIdentity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetSpawnPosition(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetTime(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetTitle(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SettingsCommand(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ShowCredits(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ShowProfile(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ShowStoreOffer(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SimpleEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SpawnExperienceOrb(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SpawnParticleEffect(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::StartGame(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::StopSound(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::StructureBlockUpdate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::StructureTemplateDataExportRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::StructureTemplateDataExportResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SubClientLogin(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::TakeItemEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Text(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::TickSync(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Transfer(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateAttributes(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateBlock(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateBlockProperties(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateBlockSynced(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateEquipment(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdatePlayerGameType(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateSoftEnum(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateTrade(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::VideoStreamConnect(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <McpePacketName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let params = match name {
            McpePacketName::AddBehaviorTree => {
                Some(
                    McpePacketParams::AddBehaviorTree(
                        <PacketAddBehaviorTree as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::AddEcsEntity => {
                Some(
                    McpePacketParams::AddEcsEntity(
                        <PacketAddEcsEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::AddEntity => {
                Some(
                    McpePacketParams::AddEntity(
                        Box::new(
                            <PacketAddEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AddItemEntity => {
                Some(
                    McpePacketParams::AddItemEntity(
                        Box::new(
                            <PacketAddItemEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AddPainting => {
                Some(
                    McpePacketParams::AddPainting(
                        Box::new(
                            <PacketAddPainting as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AddPlayer => {
                Some(
                    McpePacketParams::AddPlayer(
                        Box::new(
                            <PacketAddPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AdventureSettings => {
                Some(
                    McpePacketParams::AdventureSettings(
                        Box::new(
                            <PacketAdventureSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Animate => {
                Some(
                    McpePacketParams::Animate(
                        Box::new(
                            <PacketAnimate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AnimateEntity => {
                Some(
                    McpePacketParams::AnimateEntity(
                        Box::new(
                            <PacketAnimateEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AnvilDamage => {
                Some(
                    McpePacketParams::AnvilDamage(
                        <PacketAnvilDamage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::AvailableCommands => {
                Some(
                    McpePacketParams::AvailableCommands(
                        Box::new(
                            <PacketAvailableCommands as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AvailableEntityIdentifiers => {
                Some(
                    McpePacketParams::AvailableEntityIdentifiers(
                        <PacketAvailableEntityIdentifiers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BiomeDefinitionList => {
                Some(
                    McpePacketParams::BiomeDefinitionList(
                        <PacketBiomeDefinitionList as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BlockEntityData => {
                Some(
                    McpePacketParams::BlockEntityData(
                        <PacketBlockEntityData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BlockEvent => {
                Some(
                    McpePacketParams::BlockEvent(
                        <PacketBlockEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BlockPickRequest => {
                Some(
                    McpePacketParams::BlockPickRequest(
                        Box::new(
                            <PacketBlockPickRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::BookEdit => {
                Some(
                    McpePacketParams::BookEdit(
                        Box::new(
                            <PacketBookEdit as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::BossEvent => {
                Some(
                    McpePacketParams::BossEvent(
                        Box::new(
                            <PacketBossEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Camera => {
                Some(
                    McpePacketParams::Camera(
                        <PacketCamera as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CameraShake => {
                Some(
                    McpePacketParams::CameraShake(
                        <PacketCameraShake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ChangeDimension => {
                Some(
                    McpePacketParams::ChangeDimension(
                        <PacketChangeDimension as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ChunkRadiusUpdate => {
                Some(
                    McpePacketParams::ChunkRadiusUpdate(
                        <PacketChunkRadiusUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientCacheBlobStatus => {
                Some(
                    McpePacketParams::ClientCacheBlobStatus(
                        Box::new(
                            <PacketClientCacheBlobStatus as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ClientCacheMissResponse => {
                Some(
                    McpePacketParams::ClientCacheMissResponse(
                        <PacketClientCacheMissResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientCacheStatus => {
                Some(
                    McpePacketParams::ClientCacheStatus(
                        <PacketClientCacheStatus as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientToServerHandshake => {
                Some(
                    McpePacketParams::ClientToServerHandshake(
                        <PacketClientToServerHandshake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientboundMapItemData => {
                Some(
                    McpePacketParams::ClientboundMapItemData(
                        <PacketClientboundMapItemData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CodeBuilder => {
                Some(
                    McpePacketParams::CodeBuilder(
                        <PacketCodeBuilder as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CommandBlockUpdate => {
                Some(
                    McpePacketParams::CommandBlockUpdate(
                        Box::new(
                            <PacketCommandBlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CommandOutput => {
                Some(
                    McpePacketParams::CommandOutput(
                        Box::new(
                            <PacketCommandOutput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CommandRequest => {
                Some(
                    McpePacketParams::CommandRequest(
                        Box::new(
                            <PacketCommandRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CompletedUsingItem => {
                Some(
                    McpePacketParams::CompletedUsingItem(
                        <PacketCompletedUsingItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ContainerClose => {
                Some(
                    McpePacketParams::ContainerClose(
                        <PacketContainerClose as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ContainerOpen => {
                Some(
                    McpePacketParams::ContainerOpen(
                        Box::new(
                            <PacketContainerOpen as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ContainerSetData => {
                Some(
                    McpePacketParams::ContainerSetData(
                        <PacketContainerSetData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CorrectPlayerMovePrediction => {
                Some(
                    McpePacketParams::CorrectPlayerMovePrediction(
                        Box::new(
                            <PacketCorrectPlayerMovePrediction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CraftingData => {
                Some(
                    McpePacketParams::CraftingData(
                        Box::new(
                            <PacketCraftingData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CraftingEvent => {
                Some(
                    McpePacketParams::CraftingEvent(
                        Box::new(
                            <PacketCraftingEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CreativeContent => {
                Some(
                    McpePacketParams::CreativeContent(
                        <PacketCreativeContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::DebugInfo => {
                Some(
                    McpePacketParams::DebugInfo(
                        <PacketDebugInfo as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Disconnect => {
                Some(
                    McpePacketParams::Disconnect(
                        <PacketDisconnect as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EducationSettings => {
                Some(
                    McpePacketParams::EducationSettings(
                        Box::new(
                            <PacketEducationSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Emote => {
                Some(
                    McpePacketParams::Emote(
                        <PacketEmote as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EmoteList => {
                Some(
                    McpePacketParams::EmoteList(
                        <PacketEmoteList as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EntityEvent => {
                Some(
                    McpePacketParams::EntityEvent(
                        <PacketEntityEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EntityPickRequest => {
                Some(
                    McpePacketParams::EntityPickRequest(
                        <PacketEntityPickRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Event => {
                Some(
                    McpePacketParams::Event(
                        Box::new(
                            <PacketEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::FilterTextPacket => {
                Some(
                    McpePacketParams::FilterTextPacket(
                        <PacketFilterTextPacket as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::GameRulesChanged => {
                Some(
                    McpePacketParams::GameRulesChanged(
                        <PacketGameRulesChanged as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::GuiDataPickItem => {
                Some(
                    McpePacketParams::GuiDataPickItem(
                        <PacketGuiDataPickItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::HurtArmor => {
                Some(
                    McpePacketParams::HurtArmor(
                        <PacketHurtArmor as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::InitiateWebSocketConnection => {
                Some(
                    McpePacketParams::InitiateWebSocketConnection(
                        <PacketInitiateWebSocketConnection as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Interact => {
                Some(
                    McpePacketParams::Interact(
                        Box::new(
                            <PacketInteract as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::InventoryContent => {
                Some(
                    McpePacketParams::InventoryContent(
                        <PacketInventoryContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::InventorySlot => {
                Some(
                    McpePacketParams::InventorySlot(
                        Box::new(
                            <PacketInventorySlot as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::InventoryTransaction => {
                Some(
                    McpePacketParams::InventoryTransaction(
                        Box::new(
                            <PacketInventoryTransaction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ItemComponent => {
                Some(
                    McpePacketParams::ItemComponent(
                        <PacketItemComponent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ItemFrameDropItem => {
                Some(
                    McpePacketParams::ItemFrameDropItem(
                        <PacketItemFrameDropItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ItemStackRequest => {
                Some(
                    McpePacketParams::ItemStackRequest(
                        <PacketItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ItemStackResponse => {
                Some(
                    McpePacketParams::ItemStackResponse(
                        <PacketItemStackResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LabTable => {
                Some(
                    McpePacketParams::LabTable(
                        <PacketLabTable as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LecternUpdate => {
                Some(
                    McpePacketParams::LecternUpdate(
                        Box::new(
                            <PacketLecternUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LevelChunk => {
                Some(
                    McpePacketParams::LevelChunk(
                        Box::new(
                            <PacketLevelChunk as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LevelEvent => {
                Some(
                    McpePacketParams::LevelEvent(
                        <PacketLevelEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LevelEventGeneric => {
                Some(
                    McpePacketParams::LevelEventGeneric(
                        <PacketLevelEventGeneric as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LevelSoundEvent => {
                Some(
                    McpePacketParams::LevelSoundEvent(
                        Box::new(
                            <PacketLevelSoundEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LevelSoundEventOld => {
                Some(
                    McpePacketParams::LevelSoundEventOld(
                        Box::new(
                            <PacketLevelSoundEventOld as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LevelSoundEventV2 => {
                Some(
                    McpePacketParams::LevelSoundEventV2(
                        Box::new(
                            <PacketLevelSoundEventV2 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Login => {
                Some(
                    McpePacketParams::Login(
                        <PacketLogin as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MapCreateLockedCopy => {
                Some(
                    McpePacketParams::MapCreateLockedCopy(
                        <PacketMapCreateLockedCopy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MapInfoRequest => {
                Some(
                    McpePacketParams::MapInfoRequest(
                        <PacketMapInfoRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MobArmorEquipment => {
                Some(
                    McpePacketParams::MobArmorEquipment(
                        Box::new(
                            <PacketMobArmorEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MobEffect => {
                Some(
                    McpePacketParams::MobEffect(
                        Box::new(
                            <PacketMobEffect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MobEquipment => {
                Some(
                    McpePacketParams::MobEquipment(
                        Box::new(
                            <PacketMobEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ModalFormRequest => {
                Some(
                    McpePacketParams::ModalFormRequest(
                        <PacketModalFormRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ModalFormResponse => {
                Some(
                    McpePacketParams::ModalFormResponse(
                        <PacketModalFormResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MotionPredictionHints => {
                Some(
                    McpePacketParams::MotionPredictionHints(
                        <PacketMotionPredictionHints as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MoveEntity => {
                Some(
                    McpePacketParams::MoveEntity(
                        Box::new(
                            <PacketMoveEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MoveEntityDelta => {
                Some(
                    McpePacketParams::MoveEntityDelta(
                        Box::new(
                            <PacketMoveEntityDelta as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MovePlayer => {
                Some(
                    McpePacketParams::MovePlayer(
                        Box::new(
                            <PacketMovePlayer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MultiplayerSettings => {
                Some(
                    McpePacketParams::MultiplayerSettings(
                        <PacketMultiplayerSettings as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::NetworkChunkPublisherUpdate => {
                Some(
                    McpePacketParams::NetworkChunkPublisherUpdate(
                        <PacketNetworkChunkPublisherUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::NetworkSettings => {
                Some(
                    McpePacketParams::NetworkSettings(
                        <PacketNetworkSettings as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::NetworkStackLatency => {
                Some(
                    McpePacketParams::NetworkStackLatency(
                        <PacketNetworkStackLatency as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::NpcRequest => {
                Some(
                    McpePacketParams::NpcRequest(
                        Box::new(
                            <PacketNpcRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::OnScreenTextureAnimation => {
                Some(
                    McpePacketParams::OnScreenTextureAnimation(
                        <PacketOnScreenTextureAnimation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PacketViolationWarning => {
                Some(
                    McpePacketParams::PacketViolationWarning(
                        Box::new(
                            <PacketPacketViolationWarning as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PhotoTransfer => {
                Some(
                    McpePacketParams::PhotoTransfer(
                        <PacketPhotoTransfer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlaySound => {
                Some(
                    McpePacketParams::PlaySound(
                        Box::new(
                            <PacketPlaySound as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayStatus => {
                Some(
                    McpePacketParams::PlayStatus(
                        <PacketPlayStatus as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerAction => {
                Some(
                    McpePacketParams::PlayerAction(
                        Box::new(
                            <PacketPlayerAction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerArmorDamage => {
                Some(
                    McpePacketParams::PlayerArmorDamage(
                        Box::new(
                            <PacketPlayerArmorDamage as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerAuthInput => {
                Some(
                    McpePacketParams::PlayerAuthInput(
                        Box::new(
                            <PacketPlayerAuthInput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerEnchantOptions => {
                Some(
                    McpePacketParams::PlayerEnchantOptions(
                        <PacketPlayerEnchantOptions as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerFog => {
                Some(
                    McpePacketParams::PlayerFog(
                        <PacketPlayerFog as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerHotbar => {
                Some(
                    McpePacketParams::PlayerHotbar(
                        <PacketPlayerHotbar as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerInput => {
                Some(
                    McpePacketParams::PlayerInput(
                        Box::new(
                            <PacketPlayerInput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerList => {
                Some(
                    McpePacketParams::PlayerList(
                        Box::new(
                            <PacketPlayerList as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerSkin => {
                Some(
                    McpePacketParams::PlayerSkin(
                        Box::new(
                            <PacketPlayerSkin as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PositionTrackingDbBroadcast => {
                Some(
                    McpePacketParams::PositionTrackingDbBroadcast(
                        <PacketPositionTrackingDbBroadcast as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PositionTrackingDbRequest => {
                Some(
                    McpePacketParams::PositionTrackingDbRequest(
                        <PacketPositionTrackingDbRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PurchaseReceipt => {
                Some(
                    McpePacketParams::PurchaseReceipt(
                        <PacketPurchaseReceipt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RemoveEcsEntity => {
                Some(
                    McpePacketParams::RemoveEcsEntity(
                        <PacketRemoveEcsEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RemoveEntity => {
                Some(
                    McpePacketParams::RemoveEntity(
                        <PacketRemoveEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RemoveObjective => {
                Some(
                    McpePacketParams::RemoveObjective(
                        <PacketRemoveObjective as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RequestChunkRadius => {
                Some(
                    McpePacketParams::RequestChunkRadius(
                        <PacketRequestChunkRadius as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ResourcePackChunkData => {
                Some(
                    McpePacketParams::ResourcePackChunkData(
                        Box::new(
                            <PacketResourcePackChunkData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ResourcePackChunkRequest => {
                Some(
                    McpePacketParams::ResourcePackChunkRequest(
                        <PacketResourcePackChunkRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ResourcePackClientResponse => {
                Some(
                    McpePacketParams::ResourcePackClientResponse(
                        <PacketResourcePackClientResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ResourcePackDataInfo => {
                Some(
                    McpePacketParams::ResourcePackDataInfo(
                        Box::new(
                            <PacketResourcePackDataInfo as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ResourcePackStack => {
                Some(
                    McpePacketParams::ResourcePackStack(
                        Box::new(
                            <PacketResourcePackStack as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ResourcePacksInfo => {
                Some(
                    McpePacketParams::ResourcePacksInfo(
                        Box::new(
                            <PacketResourcePacksInfo as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Respawn => {
                Some(
                    McpePacketParams::Respawn(
                        Box::new(
                            <PacketRespawn as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::RiderJump => {
                Some(
                    McpePacketParams::RiderJump(
                        <PacketRiderJump as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ScriptCustomEvent => {
                Some(
                    McpePacketParams::ScriptCustomEvent(
                        <PacketScriptCustomEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ServerSettingsRequest => {
                Some(
                    McpePacketParams::ServerSettingsRequest(
                        <PacketServerSettingsRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ServerSettingsResponse => {
                Some(
                    McpePacketParams::ServerSettingsResponse(
                        <PacketServerSettingsResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ServerToClientHandshake => {
                Some(
                    McpePacketParams::ServerToClientHandshake(
                        <PacketServerToClientHandshake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetCommandsEnabled => {
                Some(
                    McpePacketParams::SetCommandsEnabled(
                        <PacketSetCommandsEnabled as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetDefaultGameType => {
                Some(
                    McpePacketParams::SetDefaultGameType(
                        <PacketSetDefaultGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetDifficulty => {
                Some(
                    McpePacketParams::SetDifficulty(
                        <PacketSetDifficulty as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetDisplayObjective => {
                Some(
                    McpePacketParams::SetDisplayObjective(
                        Box::new(
                            <PacketSetDisplayObjective as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SetEntityData => {
                Some(
                    McpePacketParams::SetEntityData(
                        <PacketSetEntityData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetEntityLink => {
                Some(
                    McpePacketParams::SetEntityLink(
                        Box::new(
                            <PacketSetEntityLink as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SetEntityMotion => {
                Some(
                    McpePacketParams::SetEntityMotion(
                        <PacketSetEntityMotion as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetHealth => {
                Some(
                    McpePacketParams::SetHealth(
                        <PacketSetHealth as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetLastHurtBy => {
                Some(
                    McpePacketParams::SetLastHurtBy(
                        <PacketSetLastHurtBy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetLocalPlayerAsInitialized => {
                Some(
                    McpePacketParams::SetLocalPlayerAsInitialized(
                        <PacketSetLocalPlayerAsInitialized as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetPlayerGameType => {
                Some(
                    McpePacketParams::SetPlayerGameType(
                        <PacketSetPlayerGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetScore => {
                Some(
                    McpePacketParams::SetScore(
                        <PacketSetScore as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetScoreboardIdentity => {
                Some(
                    McpePacketParams::SetScoreboardIdentity(
                        <PacketSetScoreboardIdentity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetSpawnPosition => {
                Some(
                    McpePacketParams::SetSpawnPosition(
                        Box::new(
                            <PacketSetSpawnPosition as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SetTime => {
                Some(
                    McpePacketParams::SetTime(
                        <PacketSetTime as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetTitle => {
                Some(
                    McpePacketParams::SetTitle(
                        Box::new(
                            <PacketSetTitle as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SettingsCommand => {
                Some(
                    McpePacketParams::SettingsCommand(
                        <PacketSettingsCommand as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ShowCredits => {
                Some(
                    McpePacketParams::ShowCredits(
                        <PacketShowCredits as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ShowProfile => {
                Some(
                    McpePacketParams::ShowProfile(
                        <PacketShowProfile as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ShowStoreOffer => {
                Some(
                    McpePacketParams::ShowStoreOffer(
                        <PacketShowStoreOffer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SimpleEvent => {
                Some(
                    McpePacketParams::SimpleEvent(
                        <PacketSimpleEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SpawnExperienceOrb => {
                Some(
                    McpePacketParams::SpawnExperienceOrb(
                        <PacketSpawnExperienceOrb as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SpawnParticleEffect => {
                Some(
                    McpePacketParams::SpawnParticleEffect(
                        Box::new(
                            <PacketSpawnParticleEffect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::StartGame => {
                Some(
                    McpePacketParams::StartGame(
                        Box::new(
                            <PacketStartGame as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::StopSound => {
                Some(
                    McpePacketParams::StopSound(
                        <PacketStopSound as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::StructureBlockUpdate => {
                Some(
                    McpePacketParams::StructureBlockUpdate(
                        <PacketStructureBlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::StructureTemplateDataExportRequest => {
                Some(
                    McpePacketParams::StructureTemplateDataExportRequest(
                        <PacketStructureTemplateDataExportRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::StructureTemplateDataExportResponse => {
                Some(
                    McpePacketParams::StructureTemplateDataExportResponse(
                        <PacketStructureTemplateDataExportResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SubClientLogin => {
                Some(
                    McpePacketParams::SubClientLogin(
                        <PacketSubClientLogin as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::TakeItemEntity => {
                Some(
                    McpePacketParams::TakeItemEntity(
                        <PacketTakeItemEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Text => {
                Some(
                    McpePacketParams::Text(
                        Box::new(
                            <PacketText as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::TickSync => {
                Some(
                    McpePacketParams::TickSync(
                        <PacketTickSync as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Transfer => {
                Some(
                    McpePacketParams::Transfer(
                        <PacketTransfer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateAttributes => {
                Some(
                    McpePacketParams::UpdateAttributes(
                        <PacketUpdateAttributes as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateBlock => {
                Some(
                    McpePacketParams::UpdateBlock(
                        Box::new(
                            <PacketUpdateBlock as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdateBlockProperties => {
                Some(
                    McpePacketParams::UpdateBlockProperties(
                        <PacketUpdateBlockProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateBlockSynced => {
                Some(
                    McpePacketParams::UpdateBlockSynced(
                        Box::new(
                            <PacketUpdateBlockSynced as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdateEquipment => {
                Some(
                    McpePacketParams::UpdateEquipment(
                        Box::new(
                            <PacketUpdateEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdatePlayerGameType => {
                Some(
                    McpePacketParams::UpdatePlayerGameType(
                        <PacketUpdatePlayerGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateSoftEnum => {
                Some(
                    McpePacketParams::UpdateSoftEnum(
                        <PacketUpdateSoftEnum as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateTrade => {
                Some(
                    McpePacketParams::UpdateTrade(
                        Box::new(
                            <PacketUpdateTrade as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::VideoStreamConnect => {
                Some(
                    McpePacketParams::VideoStreamConnect(
                        Box::new(
                            <PacketVideoStreamConnect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { name, params })
    }
}
pub type Nbt = Vec<u8>;
pub type RestBuffer = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3U {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3U {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.x).encode(buf)?;
        crate::bedrock::codec::VarInt(self.y).encode(buf)?;
        crate::bedrock::codec::VarInt(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let y = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { x, y, z })
    }
}
