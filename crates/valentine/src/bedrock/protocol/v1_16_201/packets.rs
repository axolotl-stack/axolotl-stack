// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddBehaviorTree {
    pub behaviortree: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddBehaviorTree {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.behaviortree.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let behaviortree = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { behaviortree })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEcsEntity {
    pub network_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEcsEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub entity_id_self: i64,
    pub runtime_entity_id: i32,
    pub entity_type: String,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.entity_type.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.attributes.encode(buf)?;
        self.metadata.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let attributes = {
            let res: EntityAttributes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <EntityAttributesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let links = {
            let res: Links = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            entity_type,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            pitch,
            yaw,
            head_yaw,
            attributes,
            metadata,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddItemEntity {
    pub entity_id_self: i64,
    pub runtime_entity_id: i32,
    pub item: Item,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub metadata: MetadataDictionary,
    pub is_from_fishing: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddItemEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.item.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.metadata.encode(buf)?;
        self.is_from_fishing.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let is_from_fishing = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            item,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            metadata,
            is_from_fishing,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPainting {
    pub entity_id_self: i64,
    pub runtime_entity_id: i32,
    pub coordinates: BlockCoordinates,
    pub direction: i32,
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPainting {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.direction).encode(buf)?;
        self.title.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let direction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            coordinates,
            direction,
            title,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub entity_id_self: i64,
    pub runtime_entity_id: i32,
    pub platform_chat_id: String,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub speed_x: f32,
    pub speed_y: f32,
    pub speed_z: f32,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub metadata: MetadataDictionary,
    pub flags: i32,
    pub command_permission: i32,
    pub action_permissions: i32,
    pub permission_level: i32,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
    pub links: Links,
    pub device_id: String,
    pub device_os: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.speed_x.encode(buf)?;
        self.speed_y.encode(buf)?;
        self.speed_z.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.held_item.encode(buf)?;
        self.metadata.encode(buf)?;
        crate::bedrock::codec::VarInt(self.flags).encode(buf)?;
        crate::bedrock::codec::VarInt(self.command_permission).encode(buf)?;
        crate::bedrock::codec::VarInt(self.action_permissions).encode(buf)?;
        crate::bedrock::codec::VarInt(self.permission_level).encode(buf)?;
        crate::bedrock::codec::VarInt(self.custom_stored_permissions).encode(buf)?;
        self.user_id.encode(buf)?;
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let speed_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let flags = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let command_permission = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let action_permissions = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let permission_level = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let custom_stored_permissions = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let links = {
            let res: Links = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let device_os = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            uuid,
            username,
            entity_id_self,
            runtime_entity_id,
            platform_chat_id,
            x,
            y,
            z,
            speed_x,
            speed_y,
            speed_z,
            pitch,
            yaw,
            head_yaw,
            held_item,
            metadata,
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAdventureSettingsCommandPermission {
    Normal = 0,
    Operator = 1,
    Host = 2,
    Automation = 3,
    Admin = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketAdventureSettingsCommandPermission {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketAdventureSettingsCommandPermission::Normal),
            1 => Ok(PacketAdventureSettingsCommandPermission::Operator),
            2 => Ok(PacketAdventureSettingsCommandPermission::Host),
            3 => Ok(PacketAdventureSettingsCommandPermission::Automation),
            4 => Ok(PacketAdventureSettingsCommandPermission::Admin),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAdventureSettingsCommandPermission), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAdventureSettingsPermissionLevel {
    Visitor = 0,
    Member = 1,
    Operator = 2,
    Custom = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketAdventureSettingsPermissionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketAdventureSettingsPermissionLevel::Visitor),
            1 => Ok(PacketAdventureSettingsPermissionLevel::Member),
            2 => Ok(PacketAdventureSettingsPermissionLevel::Operator),
            3 => Ok(PacketAdventureSettingsPermissionLevel::Custom),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAdventureSettingsPermissionLevel), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAdventureSettings {
    pub flags: AdventureFlags,
    pub command_permission: PacketAdventureSettingsCommandPermission,
    pub action_permissions: ActionPermissions,
    pub permission_level: PacketAdventureSettingsPermissionLevel,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAdventureSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        crate::bedrock::codec::VarInt(self.custom_stored_permissions).encode(buf)?;
        self.user_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let flags = <AdventureFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <PacketAdventureSettingsCommandPermission as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let action_permissions = <ActionPermissions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PacketAdventureSettingsPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let custom_stored_permissions = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAnimateActionId {
    None = 0,
    SwingArm = 1,
    Unknown = 2,
    WakeUp = 3,
    CriticalHit = 4,
    MagicCriticalHit = 5,
    RowRight = 128,
    RowLeft = 129,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateActionId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketAnimateActionId::None),
            1 => Ok(PacketAnimateActionId::SwingArm),
            2 => Ok(PacketAnimateActionId::Unknown),
            3 => Ok(PacketAnimateActionId::WakeUp),
            4 => Ok(PacketAnimateActionId::CriticalHit),
            5 => Ok(PacketAnimateActionId::MagicCriticalHit),
            128 => Ok(PacketAnimateActionId::RowRight),
            129 => Ok(PacketAnimateActionId::RowLeft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAnimateActionId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimateContentRowLeft {
    pub boat_rowing_time: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateContentRowLeft {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.boat_rowing_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let boat_rowing_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { boat_rowing_time })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketAnimateContent {
    RowLeft(PacketAnimateContentRowLeft),
    RowRight(PacketAnimateContentRowLeft),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimate {
    pub action_id: PacketAnimateActionId,
    pub runtime_entity_id: i64,
    pub content: Option<PacketAnimateContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_id.encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketAnimateContent::RowLeft(v) => {
                    v.encode(buf)?;
                }
                PacketAnimateContent::RowRight(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_id = <PacketAnimateActionId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = match action_id {
            PacketAnimateActionId::RowLeft => {
                Some(
                    PacketAnimateContent::RowLeft(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketAnimateActionId::RowRight => {
                Some(
                    PacketAnimateContent::RowRight(
                        <PacketAnimateContentRowLeft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            action_id,
            runtime_entity_id,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnimateEntity {
    pub animation: String,
    pub next_state: String,
    pub stop_condition: String,
    pub controller: String,
    pub blend_out_time: f32,
    pub runtime_entity_ids: Vec<i64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnimateEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.animation.encode(buf)?;
        self.next_state.encode(buf)?;
        self.stop_condition.encode(buf)?;
        self.controller.encode(buf)?;
        self.blend_out_time.encode(buf)?;
        let len = self.runtime_entity_ids.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.runtime_entity_ids {
            crate::bedrock::codec::VarLong(*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let animation = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let next_state = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let stop_condition = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let controller = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let blend_out_time = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_ids = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            animation,
            next_state,
            stop_condition,
            controller,
            blend_out_time,
            runtime_entity_ids,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnvilDamage {
    pub damage: u8,
    pub position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnvilDamage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.damage.encode(buf)?;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let damage = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { damage, position })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketAvailableCommandsEnumsItemValuesItem {
    Byte(u8),
    Int(u32),
    Short(u16),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumsItem {
    pub name: String,
    pub values: Vec<Option<PacketAvailableCommandsEnumsItemValuesItem>>,
}
#[derive(Debug, Clone)]
pub struct PacketAvailableCommandsEnumsItemArgs {
    pub _enum_type: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsEnumsItem {
    type Args = PacketAvailableCommandsEnumsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            if let Some(v) = item {
                match v {
                    PacketAvailableCommandsEnumsItemValuesItem::Byte(v) => {
                        (*v).encode(buf)?;
                    }
                    PacketAvailableCommandsEnumsItemValuesItem::Int(v) => {
                        (*v).encode(buf)?;
                    }
                    PacketAvailableCommandsEnumsItemValuesItem::Short(v) => {
                        (*v).encode(buf)?;
                    }
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match args._enum_type {
                            Byte => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Byte(
                                        <u8 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            Int => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Int(
                                        <u32 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            Short => {
                                Some(
                                    PacketAvailableCommandsEnumsItemValuesItem::Short(
                                        <u16 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    Int = 1,
    Float = 2,
    Value = 3,
    WildcardInt = 4,
    Operator = 5,
    Target = 6,
    FilePath = 14,
    String = 29,
    Position = 37,
    Message = 41,
    RawText = 43,
    Json = 46,
    Command = 53,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Int,
                )
            }
            2 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Float,
                )
            }
            3 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Value,
                )
            }
            4 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardInt,
                )
            }
            5 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Operator,
                )
            }
            6 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Target,
                )
            }
            14 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::FilePath,
                )
            }
            29 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::String,
                )
            }
            37 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Position,
                )
            }
            41 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Message,
                )
            }
            43 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::RawText,
                )
            }
            46 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Json,
                )
            }
            53 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Command,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType {
    Valid = 16,
    Enum = 48,
    Suffixed = 256,
    SoftEnum = 1040,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            16 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Valid,
                )
            }
            48 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Enum,
                )
            }
            256 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::Suffixed,
                )
            }
            1040 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType::SoftEnum,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    pub parameter_name: String,
    pub value_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType,
    pub enum_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType,
    pub optional: bool,
    pub options: CommandFlags,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.parameter_name.encode(buf)?;
        self.value_type.encode(buf)?;
        self.enum_type.encode(buf)?;
        self.optional.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let parameter_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let enum_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let optional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let options = <CommandFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            parameter_name,
            value_type,
            enum_type,
            optional,
            options,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItem {
    pub parameters: Vec<
        PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem,
    >,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let parameters = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { parameters })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItem {
    pub name: String,
    pub description: String,
    pub flags: u8,
    pub permission_level: u8,
    pub alias: i32,
    pub overloads: Vec<PacketAvailableCommandsCommandDataItemOverloadsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsCommandDataItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.description.encode(buf)?;
        self.flags.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.alias.encode(buf)?;
        let len = self.overloads.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.overloads {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let description = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let permission_level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let alias = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let overloads = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            name,
            description,
            flags,
            permission_level,
            alias,
            overloads,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsDynamicEnumsItem {
    pub name: String,
    pub values: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsDynamicEnumsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    CheatsEnabled = 0,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::CheatsEnabled,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    pub constraint: PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.constraint.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let constraint = <PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { constraint })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItem {
    pub value_index: i32,
    pub enum_index: i32,
    pub constraints: Vec<PacketAvailableCommandsEnumConstraintsItemConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsEnumConstraintsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.value_index.encode(buf)?;
        self.enum_index.encode(buf)?;
        let len = self.constraints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let value_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let enum_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let constraints = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItemConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            value_index,
            enum_index,
            constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommands {
    pub values_len: i32,
    pub _enum_type: EnumSizeBasedOnValuesLen,
    pub enum_values: Vec<String>,
    pub suffixes: Vec<String>,
    pub enums: Vec<PacketAvailableCommandsEnumsItem>,
    pub command_data: Vec<PacketAvailableCommandsCommandDataItem>,
    pub dynamic_enums: Vec<PacketAvailableCommandsDynamicEnumsItem>,
    pub enum_constraints: Vec<PacketAvailableCommandsEnumConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommands {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.values_len).encode(buf)?;
        {
            let len = self.values_len as usize;
            let val_i32 = self._enum_type as i32;
            if len <= 0xff {
                (val_i32 as u8).encode(buf)?;
            } else if len <= 0xffff {
                (val_i32 as u16).encode(buf)?;
            } else {
                (val_i32 as u32).encode(buf)?;
            }
        }
        let len = self.enum_values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enum_values {
            (*item).encode(buf)?;
        }
        let len = self.suffixes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.suffixes {
            (*item).encode(buf)?;
        }
        let len = self.enums.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enums {
            item.encode(buf)?;
        }
        let len = self.command_data.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.command_data {
            item.encode(buf)?;
        }
        let len = self.dynamic_enums.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.dynamic_enums {
            item.encode(buf)?;
        }
        let len = self.enum_constraints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enum_constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let values_len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let _enum_type = {
            let len = values_len as usize;
            let raw_val = if len <= 0xff {
                <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())? as i32
            } else if len <= 0xffff {
                <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())? as i32
            } else {
                <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
            };
            match raw_val {
                0 => EnumSizeBasedOnValuesLen::Byte,
                1 => EnumSizeBasedOnValuesLen::Short,
                _ => EnumSizeBasedOnValuesLen::Int,
            }
        };
        let enum_values = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let suffixes = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let enums = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketAvailableCommandsEnumsItemArgs {
                                _enum_type: _enum_type as i32,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let command_data = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let dynamic_enums = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsDynamicEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let enum_constraints = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            values_len,
            _enum_type,
            enum_values,
            suffixes,
            enums,
            command_data,
            dynamic_enums,
            enum_constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableEntityIdentifiers {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableEntityIdentifiers {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBiomeDefinitionList {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBiomeDefinitionList {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockEntityData {
    pub position: BlockCoordinates,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEntityData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { position, nbt })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketBlockEventType {
    Sound = 0,
    ChangeState = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketBlockEventType::Sound),
            1 => Ok(PacketBlockEventType::ChangeState),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBlockEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockEvent {
    pub position: BlockCoordinates,
    pub type_: PacketBlockEventType,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.type_.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let type_ = <PacketBlockEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { position, type_, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBlockPickRequest {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub add_user_data: bool,
    pub selected_slot: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBlockPickRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        self.add_user_data.encode(buf)?;
        self.selected_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let add_user_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            x,
            y,
            z,
            add_user_data,
            selected_slot,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketBookEditType {
    ReplacePage = 0,
    AddPage = 1,
    DeletePage = 2,
    SwapPages = 3,
    Sign = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketBookEditType::ReplacePage),
            1 => Ok(PacketBookEditType::AddPage),
            2 => Ok(PacketBookEditType::DeletePage),
            3 => Ok(PacketBookEditType::SwapPages),
            4 => Ok(PacketBookEditType::Sign),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBookEditType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentAddPage {
    pub page_number: u8,
    pub text: String,
    pub photo_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentAddPage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_number.encode(buf)?;
        self.text.encode(buf)?;
        self.photo_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let photo_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            page_number,
            text,
            photo_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentDeletePage {
    pub page_number: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentDeletePage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_number.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { page_number })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentSign {
    pub title: String,
    pub author: String,
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentSign {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.author.encode(buf)?;
        self.xuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let author = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { title, author, xuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEditContentSwapPages {
    pub page_1: u8,
    pub page_2: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEditContentSwapPages {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page_1.encode(buf)?;
        self.page_2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page_1 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let page_2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { page_1, page_2 })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketBookEditContent {
    AddPage(PacketBookEditContentAddPage),
    DeletePage(PacketBookEditContentDeletePage),
    ReplacePage(PacketBookEditContentAddPage),
    Sign(PacketBookEditContentSign),
    SwapPages(PacketBookEditContentSwapPages),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBookEdit {
    pub type_: PacketBookEditType,
    pub slot: u8,
    pub content: Option<PacketBookEditContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBookEdit {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.slot.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketBookEditContent::AddPage(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::DeletePage(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::ReplacePage(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::Sign(v) => {
                    v.encode(buf)?;
                }
                PacketBookEditContent::SwapPages(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketBookEditType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match type_ {
            PacketBookEditType::AddPage => {
                Some(
                    PacketBookEditContent::AddPage(
                        <PacketBookEditContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::DeletePage => {
                Some(
                    PacketBookEditContent::DeletePage(
                        <PacketBookEditContentDeletePage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::ReplacePage => {
                Some(
                    PacketBookEditContent::ReplacePage(
                        <PacketBookEditContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::Sign => {
                Some(
                    PacketBookEditContent::Sign(
                        <PacketBookEditContentSign as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBookEditType::SwapPages => {
                Some(
                    PacketBookEditContent::SwapPages(
                        <PacketBookEditContentSwapPages as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, slot, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketBossEventType {
    ShowBar = 0,
    RegisterPlayer = 1,
    HideBar = 2,
    UnregisterPlayer = 3,
    SetBarProgress = 4,
    SetBarTitle = 5,
    UpdateProperties = 6,
    Texture = 7,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketBossEventType::ShowBar),
            1 => Ok(PacketBossEventType::RegisterPlayer),
            2 => Ok(PacketBossEventType::HideBar),
            3 => Ok(PacketBossEventType::UnregisterPlayer),
            4 => Ok(PacketBossEventType::SetBarProgress),
            5 => Ok(PacketBossEventType::SetBarTitle),
            6 => Ok(PacketBossEventType::UpdateProperties),
            7 => Ok(PacketBossEventType::Texture),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBossEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentRegisterPlayer {
    pub player_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentRegisterPlayer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.player_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { player_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentSetBarProgress {
    pub bar_progress: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentSetBarProgress {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.bar_progress.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let bar_progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { bar_progress })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentSetBarTitle {
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentSetBarTitle {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { title })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentShowBar {
    pub title: String,
    pub bar_progress: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentShowBar {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.bar_progress.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bar_progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { title, bar_progress })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentTexture {
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentTexture {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.color).encode(buf)?;
        crate::bedrock::codec::VarInt(self.overlay).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let color = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let overlay = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { color, overlay })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentUpdateProperties {
    pub darkness_factor: i16,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentUpdateProperties {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.darkness_factor.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let darkness_factor = <i16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { darkness_factor })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketBossEventContent {
    RegisterPlayer(PacketBossEventContentRegisterPlayer),
    SetBarProgress(PacketBossEventContentSetBarProgress),
    SetBarTitle(PacketBossEventContentSetBarTitle),
    ShowBar(PacketBossEventContentShowBar),
    Texture(PacketBossEventContentTexture),
    UnregisterPlayer(PacketBossEventContentRegisterPlayer),
    UpdateProperties(PacketBossEventContentUpdateProperties),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEvent {
    pub boss_entity_id: i64,
    pub type_: PacketBossEventType,
    pub content: Option<PacketBossEventContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.boss_entity_id).encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketBossEventContent::RegisterPlayer(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::SetBarProgress(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::SetBarTitle(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::ShowBar(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::Texture(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::UnregisterPlayer(v) => {
                    v.encode(buf)?;
                }
                PacketBossEventContent::UpdateProperties(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let boss_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let type_ = <PacketBossEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            PacketBossEventType::RegisterPlayer => {
                Some(
                    PacketBossEventContent::RegisterPlayer(
                        <PacketBossEventContentRegisterPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::SetBarProgress => {
                Some(
                    PacketBossEventContent::SetBarProgress(
                        <PacketBossEventContentSetBarProgress as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::SetBarTitle => {
                Some(
                    PacketBossEventContent::SetBarTitle(
                        <PacketBossEventContentSetBarTitle as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::ShowBar => {
                Some(
                    PacketBossEventContent::ShowBar(
                        <PacketBossEventContentShowBar as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::Texture => {
                Some(
                    PacketBossEventContent::Texture(
                        <PacketBossEventContentTexture as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::UnregisterPlayer => {
                Some(
                    PacketBossEventContent::UnregisterPlayer(
                        <PacketBossEventContentRegisterPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketBossEventType::UpdateProperties => {
                Some(
                    PacketBossEventContent::UpdateProperties(
                        <PacketBossEventContentUpdateProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            boss_entity_id,
            type_,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCamera {
    pub camera_entity_unique_id: i64,
    pub target_player_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCamera {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.camera_entity_unique_id).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.target_player_unique_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let camera_entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let target_player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            camera_entity_unique_id,
            target_player_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCameraShake {
    pub intensity: f32,
    pub duration: f32,
    pub type_: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketCameraShake {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.intensity.encode(buf)?;
        self.duration.encode(buf)?;
        self.type_.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let intensity = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { intensity, duration, type_ })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChangeDimension {
    pub dimension: i32,
    pub position: Vec3F,
    pub respawn: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketChangeDimension {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.position.encode(buf)?;
        self.respawn.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let respawn = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            dimension,
            position,
            respawn,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketChunkRadiusUpdate {
    pub chunk_radius: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketChunkRadiusUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.chunk_radius).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { chunk_radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheBlobStatus {
    pub misses: i32,
    pub haves: i32,
    pub missing: Vec<u64>,
    pub have: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheBlobStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.misses).encode(buf)?;
        crate::bedrock::codec::VarInt(self.haves).encode(buf)?;
        let len = self.missing.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.missing {
            (*item).encode(buf)?;
        }
        let len = self.have.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.have {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let misses = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let haves = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let missing = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let have = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            misses,
            haves,
            missing,
            have,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheMissResponse {
    pub blobs: Vec<Blob>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheMissResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.blobs.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.blobs {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let blobs = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Blob as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { blobs })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheStatus {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientToServerHandshake {}
impl crate::bedrock::codec::BedrockCodec for PacketClientToServerHandshake {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemData {
    pub mapinfo: MapInfo,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.mapinfo.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let mapinfo = <MapInfo as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { mapinfo })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCodeBuilder {
    pub url: String,
    pub should_open_code_builder: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCodeBuilder {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.url.encode(buf)?;
        self.should_open_code_builder.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let url = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let should_open_code_builder = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            url,
            should_open_code_builder,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdateContentFalse {
    pub minecart_entity_runtime_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentFalse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.minecart_entity_runtime_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let minecart_entity_runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { minecart_entity_runtime_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCommandBlockUpdateContentTrueMode {
    Impulse = 0,
    Repeat = 1,
    Chain = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentTrueMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCommandBlockUpdateContentTrueMode::Impulse),
            1 => Ok(PacketCommandBlockUpdateContentTrueMode::Repeat),
            2 => Ok(PacketCommandBlockUpdateContentTrueMode::Chain),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCommandBlockUpdateContentTrueMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdateContentTrue {
    pub position: BlockCoordinates,
    pub mode: PacketCommandBlockUpdateContentTrueMode,
    pub needs_redstone: bool,
    pub conditional: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdateContentTrue {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.mode.encode(buf)?;
        self.needs_redstone.encode(buf)?;
        self.conditional.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let mode = <PacketCommandBlockUpdateContentTrueMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let needs_redstone = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let conditional = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            position,
            mode,
            needs_redstone,
            conditional,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketCommandBlockUpdateContent {
    False(PacketCommandBlockUpdateContentFalse),
    True(Box<PacketCommandBlockUpdateContentTrue>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandBlockUpdate {
    pub content: Option<PacketCommandBlockUpdateContent>,
    pub command: String,
    pub last_output: String,
    pub name: String,
    pub should_track_output: bool,
    pub tick_delay: i32,
    pub execute_on_first_tick: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandBlockUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketCommandBlockUpdateContent::False(v) => {
                    v.encode(buf)?;
                }
                PacketCommandBlockUpdateContent::True(v) => {
                    v.encode(buf)?;
                }
            }
        }
        self.command.encode(buf)?;
        self.last_output.encode(buf)?;
        self.name.encode(buf)?;
        self.should_track_output.encode(buf)?;
        self.tick_delay.encode(buf)?;
        self.execute_on_first_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let is_block = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = if is_block {
            Some(
                PacketCommandBlockUpdateContent::True(
                    Box::new(
                        <PacketCommandBlockUpdateContentTrue as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                ),
            )
        } else {
            Some(
                PacketCommandBlockUpdateContent::False(
                    <PacketCommandBlockUpdateContentFalse as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                ),
            )
        };
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let last_output = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let should_track_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tick_delay = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let execute_on_first_tick = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            content,
            command,
            last_output,
            name,
            should_track_output,
            tick_delay,
            execute_on_first_tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandOutputOutputItem {
    pub success: bool,
    pub message_id: String,
    pub parameters: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandOutputOutputItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.success.encode(buf)?;
        self.message_id.encode(buf)?;
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let success = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let message_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let parameters = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            success,
            message_id,
            parameters,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandOutput {
    pub origin: CommandOrigin,
    pub output_type: i8,
    pub success_count: i32,
    pub output: Vec<PacketCommandOutputOutputItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandOutput {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.origin.encode(buf)?;
        self.output_type.encode(buf)?;
        crate::bedrock::codec::VarInt(self.success_count).encode(buf)?;
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let output_type = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let success_count = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCommandOutputOutputItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            origin,
            output_type,
            success_count,
            output,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandRequest {
    pub command: String,
    pub origin: CommandOrigin,
    pub internal: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.command.encode(buf)?;
        self.origin.encode(buf)?;
        self.internal.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let internal = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { command, origin, internal })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCompletedUsingItemUseMethod {
    EquipArmor = 0,
    Eat = 1,
    Attack = 2,
    Consume = 3,
    Throw = 4,
    Shoot = 5,
    Place = 6,
    FillBottle = 7,
    FillBucket = 8,
    PourBucket = 9,
    UseTool = 10,
    Interact = 11,
    Retrieved = 12,
    Dyed = 13,
    Traded = 14,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItemUseMethod {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCompletedUsingItemUseMethod::EquipArmor),
            1 => Ok(PacketCompletedUsingItemUseMethod::Eat),
            2 => Ok(PacketCompletedUsingItemUseMethod::Attack),
            3 => Ok(PacketCompletedUsingItemUseMethod::Consume),
            4 => Ok(PacketCompletedUsingItemUseMethod::Throw),
            5 => Ok(PacketCompletedUsingItemUseMethod::Shoot),
            6 => Ok(PacketCompletedUsingItemUseMethod::Place),
            7 => Ok(PacketCompletedUsingItemUseMethod::FillBottle),
            8 => Ok(PacketCompletedUsingItemUseMethod::FillBucket),
            9 => Ok(PacketCompletedUsingItemUseMethod::PourBucket),
            10 => Ok(PacketCompletedUsingItemUseMethod::UseTool),
            11 => Ok(PacketCompletedUsingItemUseMethod::Interact),
            12 => Ok(PacketCompletedUsingItemUseMethod::Retrieved),
            13 => Ok(PacketCompletedUsingItemUseMethod::Dyed),
            14 => Ok(PacketCompletedUsingItemUseMethod::Traded),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCompletedUsingItemUseMethod), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCompletedUsingItem {
    pub used_item_id: i16,
    pub use_method: PacketCompletedUsingItemUseMethod,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.used_item_id.encode(buf)?;
        self.use_method.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let used_item_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let use_method = <PacketCompletedUsingItemUseMethod as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { used_item_id, use_method })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerClose {
    pub window_id: WindowId,
    pub server: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerClose {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { window_id, server })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerOpen {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub coordinates: BlockCoordinates,
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerOpen {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.runtime_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            window_id,
            window_type,
            coordinates,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketContainerSetData {
    pub window_id: WindowId,
    pub property: i32,
    pub value: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketContainerSetData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.property).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.value).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let property = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { window_id, property, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCorrectPlayerMovePrediction {
    pub position: Vec3F,
    pub delta: Vec3F,
    pub on_ground: bool,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketCorrectPlayerMovePrediction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.delta.encode(buf)?;
        self.on_ground.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            position,
            delta,
            on_ground,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingData {
    pub recipes: Recipes,
    pub potion_type_recipes: PotionTypeRecipes,
    pub potion_container_recipes: PotionContainerChangeRecipes,
    pub is_clean: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipes.encode(buf)?;
        self.potion_type_recipes.encode(buf)?;
        self.potion_container_recipes.encode(buf)?;
        self.is_clean.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipes = {
            let res: Recipes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <RecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let potion_type_recipes = {
            let res: PotionTypeRecipes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PotionTypeRecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let potion_container_recipes = {
            let res: PotionContainerChangeRecipes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PotionContainerChangeRecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let is_clean = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            recipes,
            potion_type_recipes,
            potion_container_recipes,
            is_clean,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCraftingEventRecipeType {
    Inventory = 0,
    Crafting = 1,
    Workbench = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingEventRecipeType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketCraftingEventRecipeType::Inventory),
            1 => Ok(PacketCraftingEventRecipeType::Crafting),
            2 => Ok(PacketCraftingEventRecipeType::Workbench),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCraftingEventRecipeType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCraftingEvent {
    pub window_id: WindowId,
    pub recipe_type: PacketCraftingEventRecipeType,
    pub recipe_id: uuid::Uuid,
    pub input: Vec<Item>,
    pub result: Vec<Item>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCraftingEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.recipe_type.encode(buf)?;
        self.recipe_id.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.result.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe_type = <PacketCraftingEventRecipeType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe_id = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let result = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            window_id,
            recipe_type,
            recipe_id,
            input,
            result,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContent {
    pub items: ItemStacks,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.items.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let items = {
            let res: ItemStacks = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemStack as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { items })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDebugInfo {
    pub player_unique_id: i64,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketDebugInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.player_unique_id).encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { player_unique_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDisconnect {
    pub hide_disconnect_reason: bool,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketDisconnect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.hide_disconnect_reason.encode(buf)?;
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let hide_disconnect_reason = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            hide_disconnect_reason,
            message,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEducationSettings {
    pub code_builder_default_uri: String,
    pub code_builder_title: String,
    pub can_resize_code_builder: bool,
    pub has_override_uri: bool,
    pub override_uri: Option<String>,
    pub has_quiz: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketEducationSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.code_builder_default_uri.encode(buf)?;
        self.code_builder_title.encode(buf)?;
        self.can_resize_code_builder.encode(buf)?;
        self.has_override_uri.encode(buf)?;
        if let Some(v) = &self.override_uri {
            v.encode(buf)?;
        }
        self.has_quiz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let code_builder_default_uri = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let code_builder_title = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let can_resize_code_builder = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_override_uri = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let override_uri = if has_override_uri {
            Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let has_quiz = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            code_builder_default_uri,
            code_builder_title,
            can_resize_code_builder,
            has_override_uri,
            override_uri,
            has_quiz,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEmote {
    pub entity_id: i64,
    pub emote_id: String,
    pub flags: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketEmote {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.entity_id).encode(buf)?;
        self.emote_id.encode(buf)?;
        self.flags.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let emote_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { entity_id, emote_id, flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEmoteList {
    pub player_id: i64,
    pub emote_pieces: Vec<uuid::Uuid>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEmoteList {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.player_id).encode(buf)?;
        let len = self.emote_pieces.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.emote_pieces {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let emote_pieces = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { player_id, emote_pieces })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEntityEventEventId {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEventEventId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketEntityEventEventId::Jump),
            2 => Ok(PacketEntityEventEventId::HurtAnimation),
            3 => Ok(PacketEntityEventEventId::DeathAnimation),
            4 => Ok(PacketEntityEventEventId::ArmSwing),
            5 => Ok(PacketEntityEventEventId::StopAttack),
            6 => Ok(PacketEntityEventEventId::TameFail),
            7 => Ok(PacketEntityEventEventId::TameSuccess),
            8 => Ok(PacketEntityEventEventId::ShakeWet),
            9 => Ok(PacketEntityEventEventId::UseItem),
            10 => Ok(PacketEntityEventEventId::EatGrassAnimation),
            11 => Ok(PacketEntityEventEventId::FishHookBubble),
            12 => Ok(PacketEntityEventEventId::FishHookPosition),
            13 => Ok(PacketEntityEventEventId::FishHookHook),
            14 => Ok(PacketEntityEventEventId::FishHookTease),
            15 => Ok(PacketEntityEventEventId::SquidInkCloud),
            16 => Ok(PacketEntityEventEventId::ZombieVillagerCure),
            18 => Ok(PacketEntityEventEventId::Respawn),
            19 => Ok(PacketEntityEventEventId::IronGolemOfferFlower),
            20 => Ok(PacketEntityEventEventId::IronGolemWithdrawFlower),
            21 => Ok(PacketEntityEventEventId::LoveParticles),
            22 => Ok(PacketEntityEventEventId::VillagerAngry),
            23 => Ok(PacketEntityEventEventId::VillagerHappy),
            24 => Ok(PacketEntityEventEventId::WitchSpellParticles),
            25 => Ok(PacketEntityEventEventId::FireworkParticles),
            26 => Ok(PacketEntityEventEventId::InLoveParticles),
            27 => Ok(PacketEntityEventEventId::SilverfishSpawnAnimation),
            28 => Ok(PacketEntityEventEventId::GuardianAttack),
            29 => Ok(PacketEntityEventEventId::WitchDrinkPotion),
            30 => Ok(PacketEntityEventEventId::WitchThrowPotion),
            31 => Ok(PacketEntityEventEventId::MinecartTntPrimeFuse),
            32 => Ok(PacketEntityEventEventId::CreeperPrimeFuse),
            33 => Ok(PacketEntityEventEventId::AirSupplyExpired),
            34 => Ok(PacketEntityEventEventId::PlayerAddXpLevels),
            35 => Ok(PacketEntityEventEventId::ElderGuardianCurse),
            36 => Ok(PacketEntityEventEventId::AgentArmSwing),
            37 => Ok(PacketEntityEventEventId::EnderDragonDeath),
            38 => Ok(PacketEntityEventEventId::DustParticles),
            39 => Ok(PacketEntityEventEventId::ArrowShake),
            57 => Ok(PacketEntityEventEventId::EatingItem),
            60 => Ok(PacketEntityEventEventId::BabyAnimalFeed),
            61 => Ok(PacketEntityEventEventId::DeathSmokeCloud),
            62 => Ok(PacketEntityEventEventId::CompleteTrade),
            63 => Ok(PacketEntityEventEventId::RemoveLeash),
            65 => Ok(PacketEntityEventEventId::ConsumeTotem),
            66 => Ok(PacketEntityEventEventId::PlayerCheckTreasureHunterAchievement),
            67 => Ok(PacketEntityEventEventId::EntitySpawn),
            68 => Ok(PacketEntityEventEventId::DragonPuke),
            69 => Ok(PacketEntityEventEventId::ItemEntityMerge),
            70 => Ok(PacketEntityEventEventId::StartSwim),
            71 => Ok(PacketEntityEventEventId::BalloonPop),
            72 => Ok(PacketEntityEventEventId::TreasureHunt),
            73 => Ok(PacketEntityEventEventId::AgentSummon),
            74 => Ok(PacketEntityEventEventId::ChargedItem),
            75 => Ok(PacketEntityEventEventId::Fall),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEntityEventEventId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i32,
    pub event_id: PacketEntityEventEventId,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.event_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let event_id = <PacketEntityEventEventId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEntityPickRequest {
    pub runtime_entity_id: u64,
    pub selected_slot: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityPickRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.selected_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            selected_slot,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketEventEventType {
    AchievementAwarded = 0,
    EntityInteract = 1,
    PortalBuilt = 2,
    PortalUsed = 3,
    MobKilled = 4,
    CauldronUsed = 5,
    PlayerDeath = 6,
    BossKilled = 7,
    AgentCommand = 8,
    AgentCreated = 9,
    BannerPatternRemoved = 10,
    CommandExecuted = 11,
    FishBucketed = 12,
    MobBorn = 13,
    PetDied = 14,
    CauldronBlockUsed = 15,
    ComposterBlockUsed = 16,
    BellBlockUsed = 17,
}
impl crate::bedrock::codec::BedrockCodec for PacketEventEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketEventEventType::AchievementAwarded),
            1 => Ok(PacketEventEventType::EntityInteract),
            2 => Ok(PacketEventEventType::PortalBuilt),
            3 => Ok(PacketEventEventType::PortalUsed),
            4 => Ok(PacketEventEventType::MobKilled),
            5 => Ok(PacketEventEventType::CauldronUsed),
            6 => Ok(PacketEventEventType::PlayerDeath),
            7 => Ok(PacketEventEventType::BossKilled),
            8 => Ok(PacketEventEventType::AgentCommand),
            9 => Ok(PacketEventEventType::AgentCreated),
            10 => Ok(PacketEventEventType::BannerPatternRemoved),
            11 => Ok(PacketEventEventType::CommandExecuted),
            12 => Ok(PacketEventEventType::FishBucketed),
            13 => Ok(PacketEventEventType::MobBorn),
            14 => Ok(PacketEventEventType::PetDied),
            15 => Ok(PacketEventEventType::CauldronBlockUsed),
            16 => Ok(PacketEventEventType::ComposterBlockUsed),
            17 => Ok(PacketEventEventType::BellBlockUsed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEventEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEvent {
    pub runtime_id: i64,
    pub event_type: PacketEventEventType,
    pub use_player_id: u8,
    pub event_data: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        self.event_type.encode(buf)?;
        self.use_player_id.encode(buf)?;
        self.event_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let event_type = <PacketEventEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let use_player_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let event_data = <Vec<
            u8,
        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_id,
            event_type,
            use_player_id,
            event_data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketFilterTextPacket {
    pub text: String,
    pub from_server: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketFilterTextPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.text.encode(buf)?;
        self.from_server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let from_server = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { text, from_server })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameRulesChanged {
    pub rules: GameRules,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameRulesChanged {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.rules.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let rules = {
            let res: GameRules = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <GameRule as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { rules })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGuiDataPickItem {}
impl crate::bedrock::codec::BedrockCodec for PacketGuiDataPickItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketHurtArmor {
    pub health: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketHurtArmor {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.health).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let health = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { health })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInitiateWebSocketConnection {
    pub server: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketInitiateWebSocketConnection {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let server = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { server })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketInteractActionId {
    LeaveVehicle = 3,
    MouseOverEntity = 4,
    NpcOpen = 5,
    OpenInventory = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketInteractActionId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            3 => Ok(PacketInteractActionId::LeaveVehicle),
            4 => Ok(PacketInteractActionId::MouseOverEntity),
            5 => Ok(PacketInteractActionId::NpcOpen),
            6 => Ok(PacketInteractActionId::OpenInventory),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketInteractActionId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketInteractPosition {
    LeaveVehicle(Vec3F),
    MouseOverEntity(Vec3F),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInteract {
    pub action_id: PacketInteractActionId,
    pub target_runtime_entity_id: i32,
    pub position: Option<PacketInteractPosition>,
}
impl crate::bedrock::codec::BedrockCodec for PacketInteract {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_id.encode(buf)?;
        crate::bedrock::codec::VarInt(self.target_runtime_entity_id).encode(buf)?;
        if let Some(v) = &self.position {
            match v {
                PacketInteractPosition::LeaveVehicle(v) => {
                    v.encode(buf)?;
                }
                PacketInteractPosition::MouseOverEntity(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_id = <PacketInteractActionId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let target_runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = match action_id {
            PacketInteractActionId::LeaveVehicle => {
                Some(
                    PacketInteractPosition::LeaveVehicle(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            PacketInteractActionId::MouseOverEntity => {
                Some(
                    PacketInteractPosition::MouseOverEntity(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            action_id,
            target_runtime_entity_id,
            position,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryContent {
    pub inventory_id: WindowIdVarint,
    pub input: ItemStacks,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.inventory_id.encode(buf)?;
        self.input.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let inventory_id = <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let res: ItemStacks = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemStack as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { inventory_id, input })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventorySlot {
    pub window_id: WindowIdVarint,
    pub slot: i32,
    pub item: ItemStack,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventorySlot {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        crate::bedrock::codec::VarInt(self.slot).encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slot = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <ItemStack as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { window_id, slot, item })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryTransaction {
    pub transaction: Transaction,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryTransaction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.transaction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let transaction = <Transaction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { transaction })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemComponent {
    pub entries: ItemComponentList,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemComponent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entries.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entries = {
            let res: ItemComponentList = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemComponentListItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemFrameDropItem {
    pub coordinates: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemFrameDropItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { coordinates })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemStackRequest {
    pub requests: ItemStackRequests,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemStackRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.requests.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let requests = {
            let res: ItemStackRequests = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemStackRequestsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { requests })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketItemStackResponse {
    pub responses: ItemStackResponses,
}
impl crate::bedrock::codec::BedrockCodec for PacketItemStackResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.responses.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let responses = {
            let res: ItemStackResponses = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemStackResponsesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { responses })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketLabTableActionType {
    Combine = 0,
    React = 1,
    Reset = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketLabTableActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketLabTableActionType::Combine),
            1 => Ok(PacketLabTableActionType::React),
            2 => Ok(PacketLabTableActionType::Reset),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLabTableActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLabTable {
    pub action_type: PacketLabTableActionType,
    pub position: Vec3I,
    pub reaction_type: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketLabTable {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.position.encode(buf)?;
        self.reaction_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <PacketLabTableActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let reaction_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            action_type,
            position,
            reaction_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLecternUpdate {
    pub page: u8,
    pub page_count: u8,
    pub position: Vec3I,
    pub drop_book: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLecternUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page.encode(buf)?;
        self.page_count.encode(buf)?;
        self.position.encode(buf)?;
        self.drop_book.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let page = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let page_count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let drop_book = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            page,
            page_count,
            position,
            drop_book,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunkBlobs {
    pub hashes: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunkBlobs {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.hashes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.hashes {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let hashes = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { hashes })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunk {
    pub x: i32,
    pub z: i32,
    pub sub_chunk_count: i32,
    pub blobs: Option<PacketLevelChunkBlobs>,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunk {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        crate::bedrock::codec::VarInt(self.sub_chunk_count).encode(buf)?;
        let val = self.blobs.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.blobs {
            v.encode(buf)?;
        }
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let sub_chunk_count = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let blobs = if cache_enabled {
            Some(
                <PacketLevelChunkBlobs as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            x,
            z,
            sub_chunk_count,
            blobs,
            payload,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketLevelEventEvent {
    SoundClick = 1000,
    SoundClickFail = 1001,
    SoundShoot = 1002,
    SoundDoor = 1003,
    SoundFizz = 1004,
    SoundIgnite = 1005,
    SoundGhast = 1007,
    SoundGhastShoot = 1008,
    SoundBlazeShoot = 1009,
    SoundDoorBump = 1010,
    SoundDoorCrash = 1012,
    SoundEndermanTeleport = 1018,
    SoundAnvilBreak = 1020,
    SoundAnvilUse = 1021,
    SoundAnvilFall = 1022,
    SoundPop = 1030,
    SoundPortal = 1032,
    SoundItemframeAddItem = 1040,
    SoundItemframeRemove = 1041,
    SoundItemframePlace = 1042,
    SoundItemframeRemoveItem = 1043,
    SoundItemframeRotateItem = 1044,
    SoundCamera = 1050,
    SoundOrb = 1051,
    SoundTotem = 1052,
    SoundArmorStandBreak = 1060,
    SoundArmorStandHit = 1061,
    SoundArmorStandFall = 1062,
    SoundArmorStandPlace = 1063,
    ParticleShoot = 2000,
    ParticleDestroy = 2001,
    ParticleSplash = 2002,
    ParticleEyeDespawn = 2003,
    ParticleSpawn = 2004,
    GuardianCurse = 2006,
    ParticleBlockForceField = 2008,
    ParticleProjectileHit = 2009,
    ParticleEndermanTeleport = 2013,
    ParticlePunchBlock = 2014,
    StartRain = 3001,
    StartThunder = 3002,
    StopRain = 3003,
    StopThunder = 3004,
    PauseGame = 3005,
    PauseGameNoScreen = 3006,
    SetGameSpeed = 3007,
    RedstoneTrigger = 3500,
    CauldronExplode = 3501,
    CauldronDyeArmor = 3502,
    CauldronCleanArmor = 3503,
    CauldronFillPotion = 3504,
    CauldronTakePotion = 3505,
    CauldronFillWater = 3506,
    CauldronTakeWater = 3507,
    CauldronAddDye = 3508,
    CauldronCleanBanner = 3509,
    BlockStartBreak = 3600,
    BlockStopBreak = 3601,
    SetData = 4000,
    PlayersSleeping = 9800,
    AddParticleMask = 16384,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1000 => Ok(PacketLevelEventEvent::SoundClick),
            1001 => Ok(PacketLevelEventEvent::SoundClickFail),
            1002 => Ok(PacketLevelEventEvent::SoundShoot),
            1003 => Ok(PacketLevelEventEvent::SoundDoor),
            1004 => Ok(PacketLevelEventEvent::SoundFizz),
            1005 => Ok(PacketLevelEventEvent::SoundIgnite),
            1007 => Ok(PacketLevelEventEvent::SoundGhast),
            1008 => Ok(PacketLevelEventEvent::SoundGhastShoot),
            1009 => Ok(PacketLevelEventEvent::SoundBlazeShoot),
            1010 => Ok(PacketLevelEventEvent::SoundDoorBump),
            1012 => Ok(PacketLevelEventEvent::SoundDoorCrash),
            1018 => Ok(PacketLevelEventEvent::SoundEndermanTeleport),
            1020 => Ok(PacketLevelEventEvent::SoundAnvilBreak),
            1021 => Ok(PacketLevelEventEvent::SoundAnvilUse),
            1022 => Ok(PacketLevelEventEvent::SoundAnvilFall),
            1030 => Ok(PacketLevelEventEvent::SoundPop),
            1032 => Ok(PacketLevelEventEvent::SoundPortal),
            1040 => Ok(PacketLevelEventEvent::SoundItemframeAddItem),
            1041 => Ok(PacketLevelEventEvent::SoundItemframeRemove),
            1042 => Ok(PacketLevelEventEvent::SoundItemframePlace),
            1043 => Ok(PacketLevelEventEvent::SoundItemframeRemoveItem),
            1044 => Ok(PacketLevelEventEvent::SoundItemframeRotateItem),
            1050 => Ok(PacketLevelEventEvent::SoundCamera),
            1051 => Ok(PacketLevelEventEvent::SoundOrb),
            1052 => Ok(PacketLevelEventEvent::SoundTotem),
            1060 => Ok(PacketLevelEventEvent::SoundArmorStandBreak),
            1061 => Ok(PacketLevelEventEvent::SoundArmorStandHit),
            1062 => Ok(PacketLevelEventEvent::SoundArmorStandFall),
            1063 => Ok(PacketLevelEventEvent::SoundArmorStandPlace),
            2000 => Ok(PacketLevelEventEvent::ParticleShoot),
            2001 => Ok(PacketLevelEventEvent::ParticleDestroy),
            2002 => Ok(PacketLevelEventEvent::ParticleSplash),
            2003 => Ok(PacketLevelEventEvent::ParticleEyeDespawn),
            2004 => Ok(PacketLevelEventEvent::ParticleSpawn),
            2006 => Ok(PacketLevelEventEvent::GuardianCurse),
            2008 => Ok(PacketLevelEventEvent::ParticleBlockForceField),
            2009 => Ok(PacketLevelEventEvent::ParticleProjectileHit),
            2013 => Ok(PacketLevelEventEvent::ParticleEndermanTeleport),
            2014 => Ok(PacketLevelEventEvent::ParticlePunchBlock),
            3001 => Ok(PacketLevelEventEvent::StartRain),
            3002 => Ok(PacketLevelEventEvent::StartThunder),
            3003 => Ok(PacketLevelEventEvent::StopRain),
            3004 => Ok(PacketLevelEventEvent::StopThunder),
            3005 => Ok(PacketLevelEventEvent::PauseGame),
            3006 => Ok(PacketLevelEventEvent::PauseGameNoScreen),
            3007 => Ok(PacketLevelEventEvent::SetGameSpeed),
            3500 => Ok(PacketLevelEventEvent::RedstoneTrigger),
            3501 => Ok(PacketLevelEventEvent::CauldronExplode),
            3502 => Ok(PacketLevelEventEvent::CauldronDyeArmor),
            3503 => Ok(PacketLevelEventEvent::CauldronCleanArmor),
            3504 => Ok(PacketLevelEventEvent::CauldronFillPotion),
            3505 => Ok(PacketLevelEventEvent::CauldronTakePotion),
            3506 => Ok(PacketLevelEventEvent::CauldronFillWater),
            3507 => Ok(PacketLevelEventEvent::CauldronTakeWater),
            3508 => Ok(PacketLevelEventEvent::CauldronAddDye),
            3509 => Ok(PacketLevelEventEvent::CauldronCleanBanner),
            3600 => Ok(PacketLevelEventEvent::BlockStartBreak),
            3601 => Ok(PacketLevelEventEvent::BlockStopBreak),
            4000 => Ok(PacketLevelEventEvent::SetData),
            9800 => Ok(PacketLevelEventEvent::PlayersSleeping),
            16384 => Ok(PacketLevelEventEvent::AddParticleMask),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLevelEventEvent), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEvent {
    pub event: PacketLevelEventEvent,
    pub position: Vec3F,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event = <PacketLevelEventEvent as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { event, position, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEventGeneric {
    pub event_id: i32,
    pub nbt: NbtLoop,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventGeneric {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.event_id).encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let nbt = <NbtLoop as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { event_id, nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEvent {
    pub sound_id: i32,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.sound_id).encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id).encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let sound_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventOld {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: i32,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventOld {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.entity_type).encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEventV2 {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEventV2 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id).encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLogin {
    pub protocol_version: i32,
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for PacketLogin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.protocol_version.encode(buf)?;
        self.tokens.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let protocol_version = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tokens = <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { protocol_version, tokens })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapCreateLockedCopy {}
impl crate::bedrock::codec::BedrockCodec for PacketMapCreateLockedCopy {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapInfoRequest {
    pub map_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapInfoRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.map_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { map_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobArmorEquipment {
    pub runtime_entity_id: i32,
    pub helmet: Item,
    pub chestplate: Item,
    pub leggings: Item,
    pub boots: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobArmorEquipment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.helmet.encode(buf)?;
        self.chestplate.encode(buf)?;
        self.leggings.encode(buf)?;
        self.boots.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let helmet = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let chestplate = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let leggings = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let boots = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            helmet,
            chestplate,
            leggings,
            boots,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketMobEffectEventId {
    Add = 1,
    Update = 2,
    Remove = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffectEventId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketMobEffectEventId::Add),
            2 => Ok(PacketMobEffectEventId::Update),
            3 => Ok(PacketMobEffectEventId::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMobEffectEventId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEffect {
    pub runtime_entity_id: i32,
    pub event_id: PacketMobEffectEventId,
    pub effect_id: i32,
    pub amplifier: i32,
    pub particles: bool,
    pub duration: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEffect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.event_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.effect_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.amplifier).encode(buf)?;
        self.particles.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.duration).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let event_id = <PacketMobEffectEventId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let effect_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let amplifier = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let particles = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            event_id,
            effect_id,
            amplifier,
            particles,
            duration,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMobEquipment {
    pub runtime_entity_id: i32,
    pub item: Item,
    pub slot: u8,
    pub selected_slot: u8,
    pub windows_id: WindowId,
}
impl crate::bedrock::codec::BedrockCodec for PacketMobEquipment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.item.encode(buf)?;
        self.slot.encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.windows_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let windows_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            item,
            slot,
            selected_slot,
            windows_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketModalFormRequest {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.form_id).encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let form_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketModalFormResponse {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.form_id).encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let form_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMotionPredictionHints {
    pub entity_runtime_id: i64,
    pub velocity: Vec3F,
    pub on_ground: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketMotionPredictionHints {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.entity_runtime_id).encode(buf)?;
        self.velocity.encode(buf)?;
        self.on_ground.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_runtime_id,
            velocity,
            on_ground,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntity {
    pub runtime_entity_id: i32,
    pub flags: u8,
    pub position: Vec3F,
    pub rotation: Rotation,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.flags.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation = <Rotation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            flags,
            position,
            rotation,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMoveEntityDelta {
    pub runtime_entity_id: i64,
    pub flags: DeltaMoveFlags,
    pub x: Option<f32>,
    pub y: Option<f32>,
    pub z: Option<f32>,
    pub rot_x: Option<u8>,
    pub rot_y: Option<u8>,
    pub rot_z: Option<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketMoveEntityDelta {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.flags.encode(buf)?;
        if let Some(v) = &self.x {
            v.encode(buf)?;
        }
        if let Some(v) = &self.y {
            v.encode(buf)?;
        }
        if let Some(v) = &self.z {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_x {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_y {
            v.encode(buf)?;
        }
        if let Some(v) = &self.rot_z {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let flags = <DeltaMoveFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let x = if flags.contains(DeltaMoveFlags::HAS_X) {
            Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let y = if flags.contains(DeltaMoveFlags::HAS_Y) {
            Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let z = if flags.contains(DeltaMoveFlags::HAS_Z) {
            Some(<f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_x = if flags.contains(DeltaMoveFlags::HAS_ROT_X) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_y = if flags.contains(DeltaMoveFlags::HAS_ROT_Y) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_z = if flags.contains(DeltaMoveFlags::HAS_ROT_Z) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        Ok(Self {
            runtime_entity_id,
            flags,
            x,
            y,
            z,
            rot_x,
            rot_y,
            rot_z,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketMovePlayerMode {
    Normal = 0,
    Reset = 1,
    Teleport = 2,
    Rotation = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketMovePlayerMode::Normal),
            1 => Ok(PacketMovePlayerMode::Reset),
            2 => Ok(PacketMovePlayerMode::Teleport),
            3 => Ok(PacketMovePlayerMode::Rotation),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMovePlayerMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketMovePlayerTeleportCause {
    Unknown = 0,
    Projectile = 1,
    ChorusFruit = 2,
    Command = 3,
    Behavior = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerTeleportCause {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketMovePlayerTeleportCause::Unknown),
            1 => Ok(PacketMovePlayerTeleportCause::Projectile),
            2 => Ok(PacketMovePlayerTeleportCause::ChorusFruit),
            3 => Ok(PacketMovePlayerTeleportCause::Command),
            4 => Ok(PacketMovePlayerTeleportCause::Behavior),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMovePlayerTeleportCause), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovePlayerTeleport {
    pub cause: PacketMovePlayerTeleportCause,
    pub source_entity_type: LegacyEntityType,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayerTeleport {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cause.encode(buf)?;
        self.source_entity_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cause = <PacketMovePlayerTeleportCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let source_entity_type = <LegacyEntityType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { cause, source_entity_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMovePlayer {
    pub runtime_id: i32,
    pub position: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub mode: PacketMovePlayerMode,
    pub on_ground: bool,
    pub ridden_runtime_id: i32,
    pub teleport: Option<PacketMovePlayerTeleport>,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMovePlayer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_id).encode(buf)?;
        self.position.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.mode.encode(buf)?;
        self.on_ground.encode(buf)?;
        crate::bedrock::codec::VarInt(self.ridden_runtime_id).encode(buf)?;
        if let Some(v) = &self.teleport {
            v.encode(buf)?;
        }
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let mode = <PacketMovePlayerMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let ridden_runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let teleport = match mode {
            PacketMovePlayerMode::Teleport => {
                Some(
                    <PacketMovePlayerTeleport as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => None,
        };
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_id,
            position,
            pitch,
            yaw,
            head_yaw,
            mode,
            on_ground,
            ridden_runtime_id,
            teleport,
            tick,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketMultiplayerSettingsActionType {
    EnableMultiplayer = 0,
    DisableMultiplayer = 1,
    RefreshJoinCode = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketMultiplayerSettingsActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketMultiplayerSettingsActionType::EnableMultiplayer),
            1 => Ok(PacketMultiplayerSettingsActionType::DisableMultiplayer),
            2 => Ok(PacketMultiplayerSettingsActionType::RefreshJoinCode),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketMultiplayerSettingsActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMultiplayerSettings {
    pub action_type: PacketMultiplayerSettingsActionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketMultiplayerSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <PacketMultiplayerSettingsActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { action_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkChunkPublisherUpdate {
    pub coordinates: BlockCoordinates,
    pub radius: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkChunkPublisherUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::VarInt(self.radius).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let radius = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { coordinates, radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkSettings {
    pub compression_threshold: u16,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.compression_threshold.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let compression_threshold = <u16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { compression_threshold })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkStackLatency {
    pub timestamp: u64,
    pub unknown_flag: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkStackLatency {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.timestamp.encode(buf)?;
        self.unknown_flag.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let timestamp = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let unknown_flag = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { timestamp, unknown_flag })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcRequest {
    pub runtime_entity_id: i32,
    pub unknown_0: u8,
    pub unknown_1: String,
    pub unknown_2: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.unknown_0.encode(buf)?;
        self.unknown_1.encode(buf)?;
        self.unknown_2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let unknown_0 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let unknown_1 = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let unknown_2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            unknown_0,
            unknown_1,
            unknown_2,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketOnScreenTextureAnimation {}
impl crate::bedrock::codec::BedrockCodec for PacketOnScreenTextureAnimation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPacketViolationWarningViolationType {
    Malformed = 0,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarningViolationType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPacketViolationWarningViolationType::Malformed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPacketViolationWarningViolationType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPacketViolationWarningSeverity {
    Warning = 0,
    FinalWarning = 1,
    Terminating = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarningSeverity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPacketViolationWarningSeverity::Warning),
            1 => Ok(PacketPacketViolationWarningSeverity::FinalWarning),
            2 => Ok(PacketPacketViolationWarningSeverity::Terminating),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPacketViolationWarningSeverity), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPacketViolationWarning {
    pub violation_type: PacketPacketViolationWarningViolationType,
    pub severity: PacketPacketViolationWarningSeverity,
    pub packet_id: i32,
    pub reason: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarning {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.violation_type.encode(buf)?;
        self.severity.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.packet_id).encode(buf)?;
        self.reason.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let violation_type = <PacketPacketViolationWarningViolationType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let severity = <PacketPacketViolationWarningSeverity as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let packet_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let reason = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            violation_type,
            severity,
            packet_id,
            reason,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPhotoTransfer {
    pub file_name: String,
    pub image_data: String,
    pub unknown_2: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPhotoTransfer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.file_name.encode(buf)?;
        self.image_data.encode(buf)?;
        self.unknown_2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let file_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let image_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let unknown_2 = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            file_name,
            image_data,
            unknown_2,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlaySound {
    pub name: String,
    pub coordinates: BlockCoordinates,
    pub volume: f32,
    pub pitch: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlaySound {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.coordinates.encode(buf)?;
        self.volume.encode(buf)?;
        self.pitch.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let volume = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            name,
            coordinates,
            volume,
            pitch,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayStatusStatus {
    LoginSuccess = 0,
    FailedClient = 1,
    FailedSpawn = 2,
    PlayerSpawn = 3,
    FailedInvalidTenant = 4,
    FailedVanillaEdu = 5,
    FailedEduVanilla = 6,
    FailedServerFull = 7,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayStatusStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayStatusStatus::LoginSuccess),
            1 => Ok(PacketPlayStatusStatus::FailedClient),
            2 => Ok(PacketPlayStatusStatus::FailedSpawn),
            3 => Ok(PacketPlayStatusStatus::PlayerSpawn),
            4 => Ok(PacketPlayStatusStatus::FailedInvalidTenant),
            5 => Ok(PacketPlayStatusStatus::FailedVanillaEdu),
            6 => Ok(PacketPlayStatusStatus::FailedEduVanilla),
            7 => Ok(PacketPlayStatusStatus::FailedServerFull),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayStatusStatus), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayStatus {
    pub status: PacketPlayStatusStatus,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let status = <PacketPlayStatusStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { status })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerActionAction {
    StartBreak = 0,
    AbortBreak = 1,
    StopBreak = 2,
    GetUpdatedBlock = 3,
    DropItem = 4,
    StartSleeping = 5,
    StopSleeping = 6,
    Respawn = 7,
    Jump = 8,
    StartSprint = 9,
    StopSprint = 10,
    StartSneak = 11,
    StopSneak = 12,
    CreativePlayerDestroyBlock = 13,
    DimensionChangeAck = 14,
    StartGlide = 15,
    StopGlide = 16,
    BuildDenied = 17,
    ContinueBreak = 18,
    ChangeSkin = 19,
    SetEnchatnmentSeed = 20,
    Swimming = 21,
    StopSwimming = 22,
    StartSpinAttack = 23,
    StopSpinAttack = 24,
    IneractBlock = 25,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerActionAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayerActionAction::StartBreak),
            1 => Ok(PacketPlayerActionAction::AbortBreak),
            2 => Ok(PacketPlayerActionAction::StopBreak),
            3 => Ok(PacketPlayerActionAction::GetUpdatedBlock),
            4 => Ok(PacketPlayerActionAction::DropItem),
            5 => Ok(PacketPlayerActionAction::StartSleeping),
            6 => Ok(PacketPlayerActionAction::StopSleeping),
            7 => Ok(PacketPlayerActionAction::Respawn),
            8 => Ok(PacketPlayerActionAction::Jump),
            9 => Ok(PacketPlayerActionAction::StartSprint),
            10 => Ok(PacketPlayerActionAction::StopSprint),
            11 => Ok(PacketPlayerActionAction::StartSneak),
            12 => Ok(PacketPlayerActionAction::StopSneak),
            13 => Ok(PacketPlayerActionAction::CreativePlayerDestroyBlock),
            14 => Ok(PacketPlayerActionAction::DimensionChangeAck),
            15 => Ok(PacketPlayerActionAction::StartGlide),
            16 => Ok(PacketPlayerActionAction::StopGlide),
            17 => Ok(PacketPlayerActionAction::BuildDenied),
            18 => Ok(PacketPlayerActionAction::ContinueBreak),
            19 => Ok(PacketPlayerActionAction::ChangeSkin),
            20 => Ok(PacketPlayerActionAction::SetEnchatnmentSeed),
            21 => Ok(PacketPlayerActionAction::Swimming),
            22 => Ok(PacketPlayerActionAction::StopSwimming),
            23 => Ok(PacketPlayerActionAction::StartSpinAttack),
            24 => Ok(PacketPlayerActionAction::StopSpinAttack),
            25 => Ok(PacketPlayerActionAction::IneractBlock),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerActionAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAction {
    pub runtime_entity_id: i32,
    pub action: PacketPlayerActionAction,
    pub position: BlockCoordinates,
    pub face: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.action.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.face).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let action = <PacketPlayerActionAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            action,
            position,
            face,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerArmorDamage {
    pub type_: ArmorDamageType,
    pub helmet_damage: Option<i32>,
    pub chestplate_damage: Option<i32>,
    pub leggings_damage: Option<i32>,
    pub boots_damage: Option<i32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerArmorDamage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.helmet_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.chestplate_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.leggings_damage {
            v.encode(buf)?;
        }
        if let Some(v) = &self.boots_damage {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <ArmorDamageType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let helmet_damage = if type_.contains(ArmorDamageType::HEAD) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        let chestplate_damage = if type_.contains(ArmorDamageType::CHEST) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        let leggings_damage = if type_.contains(ArmorDamageType::LEGS) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        let boots_damage = if type_.contains(ArmorDamageType::FEET) {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        Ok(Self {
            type_,
            helmet_damage,
            chestplate_damage,
            leggings_damage,
            boots_damage,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputInputMode {
    Mouse = 0,
    Touch = 1,
    GamePad = 2,
    MotionController = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputInputMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayerAuthInputInputMode::Mouse),
            1 => Ok(PacketPlayerAuthInputInputMode::Touch),
            2 => Ok(PacketPlayerAuthInputInputMode::GamePad),
            3 => Ok(PacketPlayerAuthInputInputMode::MotionController),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputInputMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputPlayMode {
    Normal = 0,
    Teaser = 1,
    Screen = 2,
    Viewer = 3,
    Reality = 4,
    Placement = 5,
    LivingRoom = 6,
    ExitLevel = 7,
    ExitLevelLivingRoom = 8,
    NumModes = 9,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputPlayMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPlayerAuthInputPlayMode::Normal),
            1 => Ok(PacketPlayerAuthInputPlayMode::Teaser),
            2 => Ok(PacketPlayerAuthInputPlayMode::Screen),
            3 => Ok(PacketPlayerAuthInputPlayMode::Viewer),
            4 => Ok(PacketPlayerAuthInputPlayMode::Reality),
            5 => Ok(PacketPlayerAuthInputPlayMode::Placement),
            6 => Ok(PacketPlayerAuthInputPlayMode::LivingRoom),
            7 => Ok(PacketPlayerAuthInputPlayMode::ExitLevel),
            8 => Ok(PacketPlayerAuthInputPlayMode::ExitLevelLivingRoom),
            9 => Ok(PacketPlayerAuthInputPlayMode::NumModes),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputPlayMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub gaze_direction: Option<Vec3F>,
    pub tick: i64,
    pub delta: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        if let Some(v) = &self.gaze_direction {
            v.encode(buf)?;
        }
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        self.delta.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let gaze_direction = match play_mode {
            PacketPlayerAuthInputPlayMode::Reality => {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            gaze_direction,
            tick,
            delta,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerEnchantOptions {
    pub enchant_options: EnchantOptions,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerEnchantOptions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enchant_options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let enchant_options = {
            let res: EnchantOptions = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <EnchantOptionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { enchant_options })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerFog {
    pub stack: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerFog {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.stack.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.stack {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let stack = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { stack })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerHotbar {
    pub selected_slot: i32,
    pub window_id: WindowId,
    pub select_slot: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerHotbar {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.selected_slot).encode(buf)?;
        self.window_id.encode(buf)?;
        self.select_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let selected_slot = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let select_slot = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            selected_slot,
            window_id,
            select_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerInput {
    pub motion_x: f32,
    pub motion_z: f32,
    pub jumping: bool,
    pub sneaking: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerInput {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.motion_x.encode(buf)?;
        self.motion_z.encode(buf)?;
        self.jumping.encode(buf)?;
        self.sneaking.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let motion_x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let motion_z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let jumping = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let sneaking = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            motion_x,
            motion_z,
            jumping,
            sneaking,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerList {
    pub records: PlayerRecords,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerList {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.records.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let records = <PlayerRecords as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { records })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerSkin {
    pub uuid: uuid::Uuid,
    pub skin: Skin,
    pub skin_name: String,
    pub old_skin_name: String,
    pub is_verified: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerSkin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.skin.encode(buf)?;
        self.skin_name.encode(buf)?;
        self.old_skin_name.encode(buf)?;
        self.is_verified.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let old_skin_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_verified = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            skin,
            skin_name,
            old_skin_name,
            is_verified,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPositionTrackingDbBroadcastBroadcastAction {
    Update = 0,
    Destory = 1,
    NotFound = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketPositionTrackingDbBroadcastBroadcastAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::Update),
            1 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::Destory),
            2 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::NotFound),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPositionTrackingDbBroadcastBroadcastAction),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPositionTrackingDbBroadcast {
    pub broadcast_action: PacketPositionTrackingDbBroadcastBroadcastAction,
    pub tracking_id: i32,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbBroadcast {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.broadcast_action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.tracking_id).encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let broadcast_action = <PacketPositionTrackingDbBroadcastBroadcastAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            broadcast_action,
            tracking_id,
            nbt,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPositionTrackingDbRequestAction {
    Query = 0,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbRequestAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketPositionTrackingDbRequestAction::Query),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPositionTrackingDbRequestAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPositionTrackingDbRequest {
    pub action: PacketPositionTrackingDbRequestAction,
    pub tracking_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.tracking_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <PacketPositionTrackingDbRequestAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { action, tracking_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPurchaseReceipt {
    pub receipts: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPurchaseReceipt {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.receipts.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.receipts {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let receipts = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { receipts })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveEcsEntity {
    pub network_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveEcsEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveEntity {
    pub entity_id_self: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { entity_id_self })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRemoveObjective {
    pub objective_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketRemoveObjective {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.objective_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { objective_name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRequestChunkRadius {
    pub chunk_radius: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRequestChunkRadius {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.chunk_radius).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { chunk_radius })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkData {
    pub package_id: String,
    pub chunk_index: u32,
    pub progress: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.package_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        self.progress.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let package_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let progress = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            package_id,
            chunk_index,
            progress,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkRequest {
    pub package_id: String,
    pub chunk_index: u32,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.package_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let package_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { package_id, chunk_index })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketResourcePackClientResponseResponseStatus {
    None = 0,
    Refused = 1,
    SendPacks = 2,
    HaveAllPacks = 3,
    Completed = 4,
}
impl crate::bedrock::codec::BedrockCodec
for PacketResourcePackClientResponseResponseStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketResourcePackClientResponseResponseStatus::None),
            1 => Ok(PacketResourcePackClientResponseResponseStatus::Refused),
            2 => Ok(PacketResourcePackClientResponseResponseStatus::SendPacks),
            3 => Ok(PacketResourcePackClientResponseResponseStatus::HaveAllPacks),
            4 => Ok(PacketResourcePackClientResponseResponseStatus::Completed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketResourcePackClientResponseResponseStatus),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackClientResponse {
    pub response_status: PacketResourcePackClientResponseResponseStatus,
    pub resourcepackids: ResourcePackIds,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackClientResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.response_status.encode(buf)?;
        self.resourcepackids.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let response_status = <PacketResourcePackClientResponseResponseStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resourcepackids = {
            let res: ResourcePackIds = {
                let len = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <String as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            response_status,
            resourcepackids,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackDataInfo {
    pub package_id: String,
    pub max_chunk_size: u32,
    pub chunk_count: u32,
    pub compressed_package_size: u64,
    pub hash: ByteArray,
    pub is_premium: bool,
    pub pack_type: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackDataInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.package_id.encode(buf)?;
        self.max_chunk_size.encode(buf)?;
        self.chunk_count.encode(buf)?;
        self.compressed_package_size.encode(buf)?;
        self.hash.encode(buf)?;
        self.is_premium.encode(buf)?;
        self.pack_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let package_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let max_chunk_size = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let chunk_count = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let compressed_package_size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hash = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pack_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            package_id,
            max_chunk_size,
            chunk_count,
            compressed_package_size,
            hash,
            is_premium,
            pack_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackStack {
    pub must_accept: bool,
    pub behavior_packs: ResourcePackIdVersions,
    pub resource_packs: ResourcePackIdVersions,
    pub game_version: String,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackStack {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.must_accept.encode(buf)?;
        self.behavior_packs.encode(buf)?;
        self.resource_packs.encode(buf)?;
        self.game_version.encode(buf)?;
        self.experiments.encode(buf)?;
        self.experiments_previously_used.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let behavior_packs = {
            let res: ResourcePackIdVersions = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ResourcePackIdVersionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let resource_packs = {
            let res: ResourcePackIdVersions = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ResourcePackIdVersionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let game_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let experiments = {
            let res: Experiments = {
                let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Experiment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments_previously_used = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            must_accept,
            behavior_packs,
            resource_packs,
            game_version,
            experiments,
            experiments_previously_used,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePacksInfo {
    pub must_accept: bool,
    pub has_scripts: bool,
    pub behaviour_packs: BehaviourPackInfos,
    pub texture_packs: TexturePackInfos,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePacksInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.must_accept.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.behaviour_packs.encode(buf)?;
        self.texture_packs.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let behaviour_packs = {
            let res: BehaviourPackInfos = {
                let len = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <BehaviourPackInfosItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let texture_packs = {
            let res: TexturePackInfos = {
                let len = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TexturePackInfosItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            must_accept,
            has_scripts,
            behaviour_packs,
            texture_packs,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRespawn {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub state: u8,
    pub runtime_entity_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRespawn {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.state.encode(buf)?;
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let state = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            x,
            y,
            z,
            state,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRiderJump {
    pub jump_strength: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRiderJump {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.jump_strength).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let jump_strength = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { jump_strength })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketScriptCustomEvent {
    pub event_name: String,
    pub event_data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketScriptCustomEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event_name.encode(buf)?;
        self.event_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let event_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { event_name, event_data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerSettingsRequest {}
impl crate::bedrock::codec::BedrockCodec for PacketServerSettingsRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerSettingsResponse {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerSettingsResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.form_id).encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let form_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerToClientHandshake {
    pub token: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerToClientHandshake {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.token.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let token = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { token })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetCommandsEnabled {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetCommandsEnabled {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDefaultGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDefaultGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDifficulty {
    pub difficulty: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDifficulty {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.difficulty).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let difficulty = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { difficulty })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDisplayObjective {
    pub display_slot: String,
    pub objective_name: String,
    pub display_name: String,
    pub criteria_name: String,
    pub sort_order: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDisplayObjective {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.display_slot.encode(buf)?;
        self.objective_name.encode(buf)?;
        self.display_name.encode(buf)?;
        self.criteria_name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.sort_order).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let display_slot = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let objective_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let criteria_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let sort_order = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            display_slot,
            objective_name,
            display_name,
            criteria_name,
            sort_order,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityData {
    pub runtime_entity_id: i32,
    pub metadata: MetadataDictionary,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.metadata.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let metadata = {
            let res: MetadataDictionary = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            metadata,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityLink {
    pub link: Link,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityLink {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.link.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let link = <Link as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { link })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetEntityMotion {
    pub runtime_entity_id: i32,
    pub velocity: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetEntityMotion {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        self.velocity.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            velocity,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetHealth {
    pub health: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetHealth {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.health).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let health = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { health })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLastHurtBy {
    pub unknown: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLastHurtBy {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.unknown).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let unknown = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { unknown })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLocalPlayerAsInitialized {
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLocalPlayerAsInitialized {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { runtime_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetPlayerGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetPlayerGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScore {
    pub entries: ScoreEntries,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScore {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entries.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entries = <ScoreEntries as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentity {
    pub entries: ScoreboardIdentityEntries,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entries.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entries = <ScoreboardIdentityEntries as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetSpawnPositionSpawnType {
    Player = 0,
    World = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPositionSpawnType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSetSpawnPositionSpawnType::Player),
            1 => Ok(PacketSetSpawnPositionSpawnType::World),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetSpawnPositionSpawnType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetSpawnPosition {
    pub spawn_type: PacketSetSpawnPositionSpawnType,
    pub player_position: BlockCoordinates,
    pub dimension: i32,
    pub world_position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPosition {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.spawn_type.encode(buf)?;
        self.player_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.world_position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let spawn_type = <PacketSetSpawnPositionSpawnType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let world_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            spawn_type,
            player_position,
            dimension,
            world_position,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetTime {
    pub time: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTime {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.time).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { time })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetTitle {
    pub type_: i32,
    pub text: String,
    pub fade_in_time: i32,
    pub stay_time: i32,
    pub fade_out_time: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTitle {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.type_).encode(buf)?;
        self.text.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.fade_in_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.stay_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.fade_out_time).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let text = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let fade_in_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let stay_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let fade_out_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            type_,
            text,
            fade_in_time,
            stay_time,
            fade_out_time,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSettingsCommand {
    pub command_line: String,
    pub suppress_output: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketSettingsCommand {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.command_line.encode(buf)?;
        self.suppress_output.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let command_line = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let suppress_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            command_line,
            suppress_output,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowCredits {
    pub runtime_entity_id: i32,
    pub status: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowCredits {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.status).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let status = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { runtime_entity_id, status })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowProfile {
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowProfile {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.xuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { xuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowStoreOffer {
    pub unknown_0: String,
    pub unknown_1: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowStoreOffer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.unknown_0.encode(buf)?;
        self.unknown_1.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let unknown_0 = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let unknown_1 = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { unknown_0, unknown_1 })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketSimpleEventEventType {
    UninitializedSubtype = 0,
    EnableCommands = 1,
    DisableCommands = 2,
    UnlockWorldTemplateSettings = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimpleEventEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketSimpleEventEventType::UninitializedSubtype),
            1 => Ok(PacketSimpleEventEventType::EnableCommands),
            2 => Ok(PacketSimpleEventEventType::DisableCommands),
            3 => Ok(PacketSimpleEventEventType::UnlockWorldTemplateSettings),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSimpleEventEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSimpleEvent {
    pub event_type: PacketSimpleEventEventType,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimpleEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let event_type = <PacketSimpleEventEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { event_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnExperienceOrb {
    pub position: Vec3F,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnExperienceOrb {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.count).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { position, count })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnParticleEffect {
    pub dimension_id: u8,
    pub entity_id: i64,
    pub position: Vec3F,
    pub particle_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnParticleEffect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension_id.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_id).encode(buf)?;
        self.position.encode(buf)?;
        self.particle_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dimension_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let particle_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            dimension_id,
            entity_id,
            position,
            particle_name,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketStartGameMovementAuthority {
    Client = 0,
    Server = 1,
    ServerV2Rewind = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGameMovementAuthority {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketStartGameMovementAuthority::Client),
            1 => Ok(PacketStartGameMovementAuthority::Server),
            2 => Ok(PacketStartGameMovementAuthority::ServerV2Rewind),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStartGameMovementAuthority), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStartGame {
    pub entity_id: i64,
    pub runtime_entity_id: i64,
    pub player_gamemode: GameMode,
    pub spawn: Vec3F,
    pub rotation: Vec2F,
    pub seed: i32,
    pub biome_type: i16,
    pub biome_name: String,
    pub dimension: i32,
    pub generator: i32,
    pub world_gamemode: GameMode,
    pub difficulty: i32,
    pub spawn_position: BlockCoordinates,
    pub achievements_disabled: bool,
    pub day_cycle_stop_time: i32,
    pub edu_offer: i32,
    pub edu_features_enabled: bool,
    pub edu_product_uuid: String,
    pub rain_level: f32,
    pub lightning_level: f32,
    pub has_confirmed_platform_locked_content: bool,
    pub is_multiplayer: bool,
    pub broadcast_to_lan: bool,
    pub xbox_live_broadcast_mode: i32,
    pub platform_broadcast_mode: i32,
    pub enable_commands: bool,
    pub is_texturepacks_required: bool,
    pub gamerules: GameRules,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
    pub bonus_chest: bool,
    pub map_enabled: bool,
    pub permission_level: i32,
    pub server_chunk_tick_range: i32,
    pub has_locked_behavior_pack: bool,
    pub has_locked_resource_pack: bool,
    pub is_from_locked_world_template: bool,
    pub msa_gamertags_only: bool,
    pub is_from_world_template: bool,
    pub is_world_template_option_locked: bool,
    pub only_spawn_v_1_villagers: bool,
    pub game_version: String,
    pub limited_world_width: i32,
    pub limited_world_length: i32,
    pub is_new_nether: bool,
    pub experimental_gameplay_override: bool,
    pub level_id: String,
    pub world_name: String,
    pub premium_world_template_id: String,
    pub is_trial: bool,
    pub movement_authority: PacketStartGameMovementAuthority,
    pub current_tick: i64,
    pub enchantment_seed: i32,
    pub block_palette: BlockPalette,
    pub itemstates: Itemstates,
    pub multiplayer_correlation_id: String,
    pub server_authoritative_inventory: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGame {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.entity_id).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.player_gamemode.encode(buf)?;
        self.spawn.encode(buf)?;
        self.rotation.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.seed).encode(buf)?;
        self.biome_type.encode(buf)?;
        self.biome_name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.generator).encode(buf)?;
        self.world_gamemode.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.difficulty).encode(buf)?;
        self.spawn_position.encode(buf)?;
        self.achievements_disabled.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.day_cycle_stop_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.edu_offer).encode(buf)?;
        self.edu_features_enabled.encode(buf)?;
        self.edu_product_uuid.encode(buf)?;
        self.rain_level.encode(buf)?;
        self.lightning_level.encode(buf)?;
        self.has_confirmed_platform_locked_content.encode(buf)?;
        self.is_multiplayer.encode(buf)?;
        self.broadcast_to_lan.encode(buf)?;
        crate::bedrock::codec::VarInt(self.xbox_live_broadcast_mode).encode(buf)?;
        crate::bedrock::codec::VarInt(self.platform_broadcast_mode).encode(buf)?;
        self.enable_commands.encode(buf)?;
        self.is_texturepacks_required.encode(buf)?;
        self.gamerules.encode(buf)?;
        self.experiments.encode(buf)?;
        self.experiments_previously_used.encode(buf)?;
        self.bonus_chest.encode(buf)?;
        self.map_enabled.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.permission_level).encode(buf)?;
        self.server_chunk_tick_range.encode(buf)?;
        self.has_locked_behavior_pack.encode(buf)?;
        self.has_locked_resource_pack.encode(buf)?;
        self.is_from_locked_world_template.encode(buf)?;
        self.msa_gamertags_only.encode(buf)?;
        self.is_from_world_template.encode(buf)?;
        self.is_world_template_option_locked.encode(buf)?;
        self.only_spawn_v_1_villagers.encode(buf)?;
        self.game_version.encode(buf)?;
        self.limited_world_width.encode(buf)?;
        self.limited_world_length.encode(buf)?;
        self.is_new_nether.encode(buf)?;
        self.experimental_gameplay_override.encode(buf)?;
        self.level_id.encode(buf)?;
        self.world_name.encode(buf)?;
        self.premium_world_template_id.encode(buf)?;
        self.is_trial.encode(buf)?;
        self.movement_authority.encode(buf)?;
        self.current_tick.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.enchantment_seed).encode(buf)?;
        self.block_palette.encode(buf)?;
        self.itemstates.encode(buf)?;
        self.multiplayer_correlation_id.encode(buf)?;
        self.server_authoritative_inventory.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let player_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let spawn = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let seed = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let biome_type = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let biome_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let generator = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let world_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let difficulty = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let spawn_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let achievements_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let day_cycle_stop_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let edu_offer = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let edu_features_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let edu_product_uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rain_level = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let lightning_level = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_confirmed_platform_locked_content = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_multiplayer = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let broadcast_to_lan = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let xbox_live_broadcast_mode = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let platform_broadcast_mode = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let enable_commands = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_texturepacks_required = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let gamerules = {
            let res: GameRules = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <GameRule as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments = {
            let res: Experiments = {
                let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                    as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Experiment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments_previously_used = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bonus_chest = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let map_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let server_chunk_tick_range = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_locked_behavior_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_locked_resource_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_from_locked_world_template = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let msa_gamertags_only = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_from_world_template = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_world_template_option_locked = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let only_spawn_v_1_villagers = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let game_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let limited_world_width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let limited_world_length = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_new_nether = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let experimental_gameplay_override = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let level_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let world_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let premium_world_template_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_trial = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let movement_authority = <PacketStartGameMovementAuthority as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let current_tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let enchantment_seed = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let block_palette = {
            let res: BlockPalette = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <BlockPaletteItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let itemstates = {
            let res: Itemstates = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemstatesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let multiplayer_correlation_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server_authoritative_inventory = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id,
            runtime_entity_id,
            player_gamemode,
            spawn,
            rotation,
            seed,
            biome_type,
            biome_name,
            dimension,
            generator,
            world_gamemode,
            difficulty,
            spawn_position,
            achievements_disabled,
            day_cycle_stop_time,
            edu_offer,
            edu_features_enabled,
            edu_product_uuid,
            rain_level,
            lightning_level,
            has_confirmed_platform_locked_content,
            is_multiplayer,
            broadcast_to_lan,
            xbox_live_broadcast_mode,
            platform_broadcast_mode,
            enable_commands,
            is_texturepacks_required,
            gamerules,
            experiments,
            experiments_previously_used,
            bonus_chest,
            map_enabled,
            permission_level,
            server_chunk_tick_range,
            has_locked_behavior_pack,
            has_locked_resource_pack,
            is_from_locked_world_template,
            msa_gamertags_only,
            is_from_world_template,
            is_world_template_option_locked,
            only_spawn_v_1_villagers,
            game_version,
            limited_world_width,
            limited_world_length,
            is_new_nether,
            experimental_gameplay_override,
            level_id,
            world_name,
            premium_world_template_id,
            is_trial,
            movement_authority,
            current_tick,
            enchantment_seed,
            block_palette,
            itemstates,
            multiplayer_correlation_id,
            server_authoritative_inventory,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStopSound {
    pub name: String,
    pub stop_all: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStopSound {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.stop_all.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stop_all = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, stop_all })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureBlockUpdate {}
impl crate::bedrock::codec::BedrockCodec for PacketStructureBlockUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportRequest {}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportResponse {}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportResponse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubClientLogin {
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubClientLogin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.tokens.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let tokens = <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { tokens })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTakeItemEntity {
    pub runtime_entity_id: i32,
    pub target: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketTakeItemEntity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.runtime_entity_id).encode(buf)?;
        crate::bedrock::codec::VarInt(self.target).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let target = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { runtime_entity_id, target })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketTextType {
    Raw = 0,
    Chat = 1,
    Translation = 2,
    Popup = 3,
    JukeboxPopup = 4,
    Tip = 5,
    System = 6,
    Whisper = 7,
    Announcement = 8,
    JsonWhisper = 9,
    Json = 10,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketTextType::Raw),
            1 => Ok(PacketTextType::Chat),
            2 => Ok(PacketTextType::Translation),
            3 => Ok(PacketTextType::Popup),
            4 => Ok(PacketTextType::JukeboxPopup),
            5 => Ok(PacketTextType::Tip),
            6 => Ok(PacketTextType::System),
            7 => Ok(PacketTextType::Whisper),
            8 => Ok(PacketTextType::Announcement),
            9 => Ok(PacketTextType::JsonWhisper),
            10 => Ok(PacketTextType::Json),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(PacketTextType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTextContentAnnouncement {
    pub source_name: String,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextContentAnnouncement {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source_name.encode(buf)?;
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let source_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { source_name, message })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTextContentJson {
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextContentJson {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { message })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTextContentJukeboxPopup {
    pub message: String,
    pub parameters: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketTextContentJukeboxPopup {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.message.encode(buf)?;
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let parameters = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { message, parameters })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketTextContent {
    Announcement(PacketTextContentAnnouncement),
    Chat(PacketTextContentAnnouncement),
    Json(PacketTextContentJson),
    JsonWhisper(PacketTextContentJson),
    JukeboxPopup(PacketTextContentJukeboxPopup),
    Popup(PacketTextContentJukeboxPopup),
    Raw(PacketTextContentJson),
    System(PacketTextContentJson),
    Tip(PacketTextContentJson),
    Translation(PacketTextContentJukeboxPopup),
    Whisper(PacketTextContentAnnouncement),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketText {
    pub type_: PacketTextType,
    pub needs_translation: bool,
    pub content: Option<PacketTextContent>,
    pub xuid: String,
    pub platform_chat_id: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketText {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.needs_translation.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketTextContent::Announcement(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Chat(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Json(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::JsonWhisper(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::JukeboxPopup(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Popup(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Raw(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::System(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Tip(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Translation(v) => {
                    v.encode(buf)?;
                }
                PacketTextContent::Whisper(v) => {
                    v.encode(buf)?;
                }
            }
        }
        self.xuid.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PacketTextType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let needs_translation = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            PacketTextType::Announcement => {
                Some(
                    PacketTextContent::Announcement(
                        <PacketTextContentAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Chat => {
                Some(
                    PacketTextContent::Chat(
                        <PacketTextContentAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Json => {
                Some(
                    PacketTextContent::Json(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::JsonWhisper => {
                Some(
                    PacketTextContent::JsonWhisper(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::JukeboxPopup => {
                Some(
                    PacketTextContent::JukeboxPopup(
                        <PacketTextContentJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Popup => {
                Some(
                    PacketTextContent::Popup(
                        <PacketTextContentJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Raw => {
                Some(
                    PacketTextContent::Raw(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::System => {
                Some(
                    PacketTextContent::System(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Tip => {
                Some(
                    PacketTextContent::Tip(
                        <PacketTextContentJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Translation => {
                Some(
                    PacketTextContent::Translation(
                        <PacketTextContentJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            PacketTextType::Whisper => {
                Some(
                    PacketTextContent::Whisper(
                        <PacketTextContentAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            type_,
            needs_translation,
            content,
            xuid,
            platform_chat_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTickSync {
    pub request_time: i64,
    pub response_time: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketTickSync {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_time.encode(buf)?;
        self.response_time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let request_time = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let response_time = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            request_time,
            response_time,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTransfer {
    pub server_address: String,
    pub port: u16,
}
impl crate::bedrock::codec::BedrockCodec for PacketTransfer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server_address.encode(buf)?;
        self.port.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let server_address = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let port = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { server_address, port })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateAttributes {
    pub runtime_entity_id: i64,
    pub attributes: PlayerAttributes,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateAttributes {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.attributes.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let attributes = {
            let res: PlayerAttributes = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PlayerAttributesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            attributes,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlock {
    pub coordinates: BlockCoordinates,
    pub block_runtime_id: i32,
    pub block_priority: i32,
    pub storage: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlock {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id).encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_priority).encode(buf)?;
        crate::bedrock::codec::VarInt(self.storage).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let block_priority = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let storage = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            coordinates,
            block_runtime_id,
            block_priority,
            storage,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlockProperties {
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockProperties {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateBlockSynced {
    pub coordinates: BlockCoordinates,
    pub block_runtime_id: i32,
    pub block_priority: i32,
    pub data_layer_id: i32,
    pub unknown_0: i32,
    pub unknown_1: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateBlockSynced {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id).encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_priority).encode(buf)?;
        crate::bedrock::codec::VarInt(self.data_layer_id).encode(buf)?;
        crate::bedrock::codec::VarInt(self.unknown_0).encode(buf)?;
        crate::bedrock::codec::VarInt(self.unknown_1).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let block_priority = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data_layer_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let unknown_0 = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let unknown_1 = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            coordinates,
            block_runtime_id,
            block_priority,
            data_layer_id,
            unknown_0,
            unknown_1,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateEquipment {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub size: u8,
    pub entity_id: i64,
    pub inventory: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateEquipment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.size.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_id).encode(buf)?;
        self.inventory.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let size = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let inventory = <Vec<
            u8,
        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            window_id,
            window_type,
            size,
            entity_id,
            inventory,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdatePlayerGameType {
    pub gamemode: GameMode,
    pub player_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdatePlayerGameType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.player_unique_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { gamemode, player_unique_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketUpdateSoftEnumActionType {
    Add = 0,
    Remove = 1,
    Update = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateSoftEnumActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PacketUpdateSoftEnumActionType::Add),
            1 => Ok(PacketUpdateSoftEnumActionType::Remove),
            2 => Ok(PacketUpdateSoftEnumActionType::Update),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketUpdateSoftEnumActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateSoftEnum {
    pub enum_type: String,
    pub options: Vec<String>,
    pub action_type: PacketUpdateSoftEnumActionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateSoftEnum {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enum_type.encode(buf)?;
        let len = self.options.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.options {
            (*item).encode(buf)?;
        }
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let enum_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let options = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let action_type = <PacketUpdateSoftEnumActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            enum_type,
            options,
            action_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateTrade {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub size: i32,
    pub trade_tier: i32,
    pub villager_unique_id: i64,
    pub entity_unique_id: i64,
    pub display_name: String,
    pub new_trading_ui: bool,
    pub economic_trades: bool,
    pub offers: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateTrade {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        crate::bedrock::codec::VarInt(self.size).encode(buf)?;
        crate::bedrock::codec::VarInt(self.trade_tier).encode(buf)?;
        crate::bedrock::codec::VarLong(self.villager_unique_id).encode(buf)?;
        crate::bedrock::codec::VarLong(self.entity_unique_id).encode(buf)?;
        self.display_name.encode(buf)?;
        self.new_trading_ui.encode(buf)?;
        self.economic_trades.encode(buf)?;
        self.offers.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let size = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let trade_tier = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let villager_unique_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_unique_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let new_trading_ui = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let economic_trades = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let offers = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            window_id,
            window_type,
            size,
            trade_tier,
            villager_unique_id,
            entity_unique_id,
            display_name,
            new_trading_ui,
            economic_trades,
            offers,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketVideoStreamConnectAction {
    None = 1,
    Close = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketVideoStreamConnectAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketVideoStreamConnectAction::None),
            2 => Ok(PacketVideoStreamConnectAction::Close),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketVideoStreamConnectAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketVideoStreamConnect {
    pub server_uri: String,
    pub frame_send_frequency: f32,
    pub action: PacketVideoStreamConnectAction,
    pub resolution_x: i32,
    pub resolution_y: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketVideoStreamConnect {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server_uri.encode(buf)?;
        self.frame_send_frequency.encode(buf)?;
        self.action.encode(buf)?;
        self.resolution_x.encode(buf)?;
        self.resolution_y.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let server_uri = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let frame_send_frequency = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let action = <PacketVideoStreamConnectAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resolution_x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resolution_y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            server_uri,
            frame_send_frequency,
            action,
            resolution_x,
            resolution_y,
        })
    }
}
