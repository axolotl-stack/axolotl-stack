// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use super::*;
use super::super::packets::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Index = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    OldSwell = 20,
    SwellDir = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeId = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinId = 40,
    UrlTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    AerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    AreaEffectCloudRadius = 60,
    AreaEffectCloudWaiting = 61,
    AreaEffectCloudParticleId = 62,
    ShulkerPeekId = 63,
    ShulkerAttachFace = 64,
    ShulkerAttached = 65,
    ShulkerAttachPos = 66,
    TradingPlayerEid = 67,
    TradingCareer = 68,
    HasCommandBlock = 69,
    CommandBlockCommand = 70,
    CommandBlockLastOutput = 71,
    CommandBlockTrackOutput = 72,
    ControllingRiderSeatNumber = 73,
    Strength = 74,
    MaxStrength = 75,
    SpellCastingColor = 76,
    LimitedLife = 77,
    ArmorStandPoseIndex = 78,
    EnderCrystalTimeOffset = 79,
    AlwaysShowNametag = 80,
    Color2 = 81,
    NameAuthor = 82,
    ScoreTag = 83,
    BalloonAttachedEntity = 84,
    PufferfishSize = 85,
    BubbleTime = 86,
    Agent = 87,
    SittingAmount = 88,
    SittingAmountPrevious = 89,
    EatingCounter = 90,
    FlagsExtended = 91,
    LayingAmount = 92,
    LayingAmountPrevious = 93,
    Duration = 94,
    SpawnTime = 95,
    ChangeRate = 96,
    ChangeOnPickup = 97,
    PickupCount = 98,
    InteractText = 99,
    TradeTier = 100,
    MaxTradeTier = 101,
    TradeExperience = 102,
    SkinId = 103,
    SpawningFrames = 104,
    CommandBlockTickDelay = 105,
    CommandBlockExecuteOnFirstTick = 106,
    AmbientSoundInterval = 107,
    AmbientSoundIntervalRange = 108,
    AmbientSoundEventName = 109,
    FallDamageMultiplier = 110,
    NameRawText = 111,
    CanRideTarget = 112,
    LowTierCuredDiscount = 113,
    HighTierCuredDiscount = 114,
    NearbyCuredDiscount = 115,
    NearbyCuredDiscountTimestamp = 116,
    Hitbox = 117,
    IsBuoyant = 118,
    BuoyancyData = 119,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Index),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            20 => Ok(MetadataDictionaryItemKey::OldSwell),
            21 => Ok(MetadataDictionaryItemKey::SwellDir),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeId),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinId),
            41 => Ok(MetadataDictionaryItemKey::UrlTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::AerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleId),
            63 => Ok(MetadataDictionaryItemKey::ShulkerPeekId),
            64 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            67 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            68 => Ok(MetadataDictionaryItemKey::TradingCareer),
            69 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            70 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            73 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            74 => Ok(MetadataDictionaryItemKey::Strength),
            75 => Ok(MetadataDictionaryItemKey::MaxStrength),
            76 => Ok(MetadataDictionaryItemKey::SpellCastingColor),
            77 => Ok(MetadataDictionaryItemKey::LimitedLife),
            78 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            79 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            80 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            81 => Ok(MetadataDictionaryItemKey::Color2),
            82 => Ok(MetadataDictionaryItemKey::NameAuthor),
            83 => Ok(MetadataDictionaryItemKey::ScoreTag),
            84 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            85 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            86 => Ok(MetadataDictionaryItemKey::BubbleTime),
            87 => Ok(MetadataDictionaryItemKey::Agent),
            88 => Ok(MetadataDictionaryItemKey::SittingAmount),
            89 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            90 => Ok(MetadataDictionaryItemKey::EatingCounter),
            91 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            92 => Ok(MetadataDictionaryItemKey::LayingAmount),
            93 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            94 => Ok(MetadataDictionaryItemKey::Duration),
            95 => Ok(MetadataDictionaryItemKey::SpawnTime),
            96 => Ok(MetadataDictionaryItemKey::ChangeRate),
            97 => Ok(MetadataDictionaryItemKey::ChangeOnPickup),
            98 => Ok(MetadataDictionaryItemKey::PickupCount),
            99 => Ok(MetadataDictionaryItemKey::InteractText),
            100 => Ok(MetadataDictionaryItemKey::TradeTier),
            101 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            102 => Ok(MetadataDictionaryItemKey::TradeExperience),
            103 => Ok(MetadataDictionaryItemKey::SkinId),
            104 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            105 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            107 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            110 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            111 => Ok(MetadataDictionaryItemKey::NameRawText),
            112 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            113 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            114 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            117 => Ok(MetadataDictionaryItemKey::Hitbox),
            118 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            119 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemType {
    Byte = 0,
    Short = 1,
    Int = 2,
    Float = 3,
    String = 4,
    Compound = 5,
    Vec3I = 6,
    Long = 7,
    Vec3F = 8,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MetadataDictionaryItemType::Byte),
            1 => Ok(MetadataDictionaryItemType::Short),
            2 => Ok(MetadataDictionaryItemType::Int),
            3 => Ok(MetadataDictionaryItemType::Float),
            4 => Ok(MetadataDictionaryItemType::String),
            5 => Ok(MetadataDictionaryItemType::Compound),
            6 => Ok(MetadataDictionaryItemType::Vec3I),
            7 => Ok(MetadataDictionaryItemType::Long),
            8 => Ok(MetadataDictionaryItemType::Vec3F),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Byte(i8),
    Compound(Vec<u8>),
    Float(f32),
    Int(i32),
    Long(i64),
    Short(i16),
    String(String),
    Vec3F(Vec3F),
    Vec3I(Vec3I),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: Option<MetadataDictionaryItemValue>,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                MetadataDictionaryItemValue::Byte(v) => {
                    (*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Compound(v) => {
                    (*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Float(v) => {
                    crate::bedrock::codec::F32LE(*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Int(v) => {
                    crate::bedrock::codec::ZigZag32(*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Long(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::Short(v) => {
                    crate::bedrock::codec::I16LE(*v).encode(buf)?;
                }
                MetadataDictionaryItemValue::String(v) => {
                    let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                        (v)
                            .chars()
                            .map(|ch| {
                                let code = ch as u32;
                                if code <= 0xFF { code as u8 } else { b'?' }
                            })
                            .collect()
                    } else {
                        (v).as_bytes().to_vec()
                    };
                    let len = bytes.len();
                    crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                    buf.put_slice(&bytes);
                }
                MetadataDictionaryItemValue::Vec3F(v) => {
                    v.encode(buf)?;
                }
                MetadataDictionaryItemValue::Vec3I(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match type_ {
            MetadataDictionaryItemType::Byte => {
                Some(
                    MetadataDictionaryItemValue::Byte(
                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Compound => {
                Some(
                    MetadataDictionaryItemValue::Compound(
                        <Vec<
                            u8,
                        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Float => {
                Some(
                    MetadataDictionaryItemValue::Float(
                        <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            MetadataDictionaryItemType::Int => {
                Some(
                    MetadataDictionaryItemValue::Int(
                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            MetadataDictionaryItemType::Long => {
                Some(
                    MetadataDictionaryItemValue::Long(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            MetadataDictionaryItemType::Short => {
                Some(
                    MetadataDictionaryItemValue::Short(
                        <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            MetadataDictionaryItemType::String => {
                Some(
                    MetadataDictionaryItemValue::String({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(
                                std::io::Error::new(
                                    std::io::ErrorKind::InvalidData,
                                    "string length cannot be negative",
                                ),
                            );
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(
                                std::io::Error::new(
                                    std::io::ErrorKind::UnexpectedEof,
                                    format!(
                                        "string declared length {} exceeds remaining {}", len, buf
                                        .remaining()
                                    ),
                                ),
                            );
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    }),
                )
            }
            MetadataDictionaryItemType::Vec3F => {
                Some(
                    MetadataDictionaryItemValue::Vec3F(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            MetadataDictionaryItemType::Vec3I => {
                Some(
                    MetadataDictionaryItemValue::Vec3I(
                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
pub type MetadataDictionary = Vec<MetadataDictionaryItem>;
