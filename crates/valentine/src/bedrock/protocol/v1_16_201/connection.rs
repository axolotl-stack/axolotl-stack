// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct LoginTokens {
    pub identity: LittleString,
    pub client: LittleString,
}
impl crate::bedrock::codec::BedrockCodec for LoginTokens {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.identity.encode(buf)?;
        self.client.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let identity = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let client = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { identity, client })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDisconnect {
    pub hide_disconnect_reason: bool,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketDisconnect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.hide_disconnect_reason.encode(buf)?;
        self.message.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let hide_disconnect_reason = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let message = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            hide_disconnect_reason,
            message,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLogin {
    pub protocol_version: i32,
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for PacketLogin {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.protocol_version.encode(buf)?;
        self.tokens.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let protocol_version = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tokens = <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { protocol_version, tokens })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayStatusStatus {
    LoginSuccess = 0,
    FailedClient = 1,
    FailedSpawn = 2,
    PlayerSpawn = 3,
    FailedInvalidTenant = 4,
    FailedVanillaEdu = 5,
    FailedEduVanilla = 6,
    FailedServerFull = 7,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayStatusStatus {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayStatusStatus::LoginSuccess),
            1 => Ok(PacketPlayStatusStatus::FailedClient),
            2 => Ok(PacketPlayStatusStatus::FailedSpawn),
            3 => Ok(PacketPlayStatusStatus::PlayerSpawn),
            4 => Ok(PacketPlayStatusStatus::FailedInvalidTenant),
            5 => Ok(PacketPlayStatusStatus::FailedVanillaEdu),
            6 => Ok(PacketPlayStatusStatus::FailedEduVanilla),
            7 => Ok(PacketPlayStatusStatus::FailedServerFull),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayStatusStatus), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayStatus {
    pub status: PacketPlayStatusStatus,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayStatus {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let status = <PacketPlayStatusStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { status })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerToClientHandshake {
    pub token: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerToClientHandshake {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.token.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let token = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { token })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLocalPlayerAsInitialized {
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLocalPlayerAsInitialized {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { runtime_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubClientLogin {
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubClientLogin {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.tokens.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let tokens = <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { tokens })
    }
}
