// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct ActionPermissions : u32
    { const ATTACK_MOBS = 65552; const ATTACK_PLAYERS = 65544; const BUILD_AND_MINE =
    65537; const DOORS_AND_SWITCHES = 65538; const OPEN_CONTAINERS = 65540; const
    OPERATOR = 65568; const TELEPORT = 65664; }
}
impl crate::bedrock::codec::BedrockCodec for ActionPermissions {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct AdventureFlags : u32 {
    const ALLOW_FLIGHT = 64; const AUTO_JUMP = 32; const FLYING = 512; const MUTED =
    1024; const NO_CLIP = 128; const NO_PVP = 2; const WORLD_BUILDER = 256; const
    WORLD_IMMUTABLE = 1; }
}
impl crate::bedrock::codec::BedrockCodec for AdventureFlags {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct ArmorDamageType : u8 {
    const CHEST = 2; const FEET = 8; const HEAD = 1; const LEGS = 4; }
}
impl crate::bedrock::codec::BedrockCodec for ArmorDamageType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        (val as u8).encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let raw = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let bits = raw as u8;
        Ok(Self::from_bits_retain(bits))
    }
}
pub type BehaviourPackInfos = Vec<BehaviourPackInfosItem>;
pub type ByteArray = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Blob {
    pub hash: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for Blob {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.hash.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let hash = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { hash, payload })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Experiment {
    pub name: String,
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for Experiment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { name, enabled })
    }
}
pub type Experiments = Vec<Experiment>;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct InputFlag : u32 { const
    ASCEND = 1; const ASCEND_SCAFFOLDING = 2097152; const AUTO_JUMPING_IN_WATER = 128;
    const CHANGE_HEIGHT = 32; const DESCEND = 2; const DESCEND_SCAFFOLDING = 4194304;
    const DOWN = 2048; const JUMP_DOWN = 8; const JUMPING = 64; const LEFT = 4096; const
    NORTH_JUMP = 4; const PERSIST_SNEAK = 16777216; const RIGHT = 8192; const SNEAK_DOWN
    = 512; const SNEAK_TOGGLE_DOWN = 8388608; const SNEAKING = 256; const SPRINT_DOWN =
    16; const SPRINTING = 1048576; const UP = 1024; const UP_LEFT = 16384; const UP_RIGHT
    = 32768; const WANT_DOWN = 131072; const WANT_DOWN_SLOW = 262144; const WANT_UP =
    65536; const WANT_UP_SLOW = 524288; }
}
impl crate::bedrock::codec::BedrockCodec for InputFlag {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct StackRequestSlotInfo {
    pub container_id: u8,
    pub slot_id: u8,
    pub stack_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for StackRequestSlotInfo {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        self.slot_id.encode(buf)?;
        self.stack_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            container_id,
            slot_id,
            stack_id,
        })
    }
}
pub type LatinString = String;
#[derive(Debug, Clone, PartialEq)]
pub struct Link {
    pub ridden_entity_id: crate::bedrock::codec::ZigZag64,
    pub rider_entity_id: crate::bedrock::codec::ZigZag64,
    pub type_: u8,
    pub immediate: bool,
    pub rider_initiated: bool,
}
impl crate::bedrock::codec::BedrockCodec for Link {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.ridden_entity_id.encode(buf)?;
        self.rider_entity_id.encode(buf)?;
        self.type_.encode(buf)?;
        self.immediate.encode(buf)?;
        self.rider_initiated.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let ridden_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let rider_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let immediate = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rider_initiated = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            ridden_entity_id,
            rider_entity_id,
            type_,
            immediate,
            rider_initiated,
        })
    }
}
pub type Links = Vec<Link>;
pub type LittleString = String;
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3F {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3F {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3I {
    pub x: crate::bedrock::codec::ZigZag32,
    pub y: crate::bedrock::codec::ZigZag32,
    pub z: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3I {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { x, y, z })
    }
}
pub type MetadataDictionary = Vec<MetadataDictionaryItem>;
pub type PotionTypeRecipes = Vec<PotionTypeRecipesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredientContent {
    pub network_data: crate::bedrock::codec::ZigZag32,
    pub count: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.network_data.encode(buf)?;
        self.count.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { network_data, count })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredient {
    pub content: Option<RecipeIngredientContent>,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredient {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match network_id {
            crate::bedrock::codec::ZigZag32(0) => None,
            _ => {
                Some(
                    <RecipeIngredientContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
        };
        Ok(Self { content })
    }
}
pub type Recipes = Vec<RecipesItem>;
pub type Byterot = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Rotation {
    pub yaw: Byterot,
    pub pitch: Byterot,
    pub head_yaw: Byterot,
}
impl crate::bedrock::codec::BedrockCodec for Rotation {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.yaw.encode(buf)?;
        self.pitch.encode(buf)?;
        self.head_yaw.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { yaw, pitch, head_yaw })
    }
}
pub type SignedByteArray = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionType {
    Normal = 0,
    InventoryMismatch = 1,
    ItemUse = 2,
    ItemUseOnEntity = 3,
    ItemRelease = 4,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionTransactionType::Normal),
            1 => Ok(TransactionTransactionType::InventoryMismatch),
            2 => Ok(TransactionTransactionType::ItemUse),
            3 => Ok(TransactionTransactionType::ItemUseOnEntity),
            4 => Ok(TransactionTransactionType::ItemRelease),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionTransactionData {
    InventoryMismatch,
    ItemRelease(Box<TransactionTransactionDataItemRelease>),
    ItemUse(Box<TransactionTransactionDataItemUse>),
    ItemUseOnEntity(Box<TransactionTransactionDataItemUseOnEntity>),
    Normal,
}
#[derive(Debug, Clone, PartialEq)]
pub struct Transaction {
    pub legacy_transactions: Option<Vec<TransactionLegacyTransactionsItem>>,
    pub transaction_type: TransactionTransactionType,
    pub network_ids: bool,
    pub inventory_actions: Vec<TransactionInventoryActionsItem>,
    pub transaction_data: Option<TransactionTransactionData>,
}
impl crate::bedrock::codec::BedrockCodec for Transaction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.legacy_transactions.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.legacy_transactions {
            v.encode(buf)?;
        }
        self.transaction_type.encode(buf)?;
        self.network_ids.encode(buf)?;
        let len = self.inventory_actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.inventory_actions {
            item.encode(buf)?;
        }
        if let Some(v) = &self.transaction_data {
            match v {
                TransactionTransactionData::InventoryMismatch => {}
                TransactionTransactionData::ItemRelease(v) => v.encode(buf)?,
                TransactionTransactionData::ItemUse(v) => v.encode(buf)?,
                TransactionTransactionData::ItemUseOnEntity(v) => v.encode(buf)?,
                TransactionTransactionData::Normal => {}
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let legacy_request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let legacy_transactions = match legacy_request_id {
            crate::bedrock::codec::ZigZag32(0) => None,
            _ => {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        .0 as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <TransactionLegacyTransactionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
        };
        let transaction_type = <TransactionTransactionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_ids = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let inventory_actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionInventoryActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let transaction_data = match transaction_type {
            TransactionTransactionType::InventoryMismatch => {
                Some(TransactionTransactionData::InventoryMismatch)
            }
            TransactionTransactionType::ItemRelease => {
                Some(
                    TransactionTransactionData::ItemRelease(
                        Box::new(
                            <TransactionTransactionDataItemRelease as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUse => {
                Some(
                    TransactionTransactionData::ItemUse(
                        Box::new(
                            <TransactionTransactionDataItemUse as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUseOnEntity => {
                Some(
                    TransactionTransactionData::ItemUseOnEntity(
                        Box::new(
                            <TransactionTransactionDataItemUseOnEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::Normal => {
                Some(TransactionTransactionData::Normal)
            }
            _ => None,
        };
        Ok(Self {
            legacy_transactions,
            transaction_type,
            network_ids,
            inventory_actions,
            transaction_data,
        })
    }
}
pub type Bitflags = Vec<u8>;
pub type Encapsulated = Vec<u8>;
pub type EnumSizeBasedOnValuesLen = Vec<u8>;
pub type Lnbt = Vec<u8>;
pub type NBTLoop = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Vec2F {
    pub x: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec2F {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { x, z })
    }
}
pub type NBT = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3U {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3U {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { x, y, z })
    }
}
