// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum McpePacketName {
    Login = 1,
    PlayStatus = 2,
    ServerToClientHandshake = 3,
    ClientToServerHandshake = 4,
    Disconnect = 5,
    ResourcePacksInfo = 6,
    ResourcePackStack = 7,
    ResourcePackClientResponse = 8,
    Text = 9,
    SetTime = 10,
    StartGame = 11,
    AddPlayer = 12,
    AddEntity = 13,
    RemoveEntity = 14,
    AddItemEntity = 15,
    TakeItemEntity = 17,
    MoveEntity = 18,
    MovePlayer = 19,
    RiderJump = 20,
    UpdateBlock = 21,
    AddPainting = 22,
    TickSync = 23,
    LevelSoundEventOld = 24,
    LevelEvent = 25,
    BlockEvent = 26,
    EntityEvent = 27,
    MobEffect = 28,
    UpdateAttributes = 29,
    InventoryTransaction = 30,
    MobEquipment = 31,
    MobArmorEquipment = 32,
    Interact = 33,
    BlockPickRequest = 34,
    EntityPickRequest = 35,
    PlayerAction = 36,
    HurtArmor = 38,
    SetEntityData = 39,
    SetEntityMotion = 40,
    SetEntityLink = 41,
    SetHealth = 42,
    SetSpawnPosition = 43,
    Animate = 44,
    Respawn = 45,
    ContainerOpen = 46,
    ContainerClose = 47,
    PlayerHotbar = 48,
    InventoryContent = 49,
    InventorySlot = 50,
    ContainerSetData = 51,
    CraftingData = 52,
    CraftingEvent = 53,
    GuiDataPickItem = 54,
    AdventureSettings = 55,
    BlockEntityData = 56,
    PlayerInput = 57,
    LevelChunk = 58,
    SetCommandsEnabled = 59,
    SetDifficulty = 60,
    ChangeDimension = 61,
    SetPlayerGameType = 62,
    PlayerList = 63,
    SimpleEvent = 64,
    Event = 65,
    SpawnExperienceOrb = 66,
    ClientboundMapItemData = 67,
    MapInfoRequest = 68,
    RequestChunkRadius = 69,
    ChunkRadiusUpdate = 70,
    ItemFrameDropItem = 71,
    GameRulesChanged = 72,
    Camera = 73,
    BossEvent = 74,
    ShowCredits = 75,
    AvailableCommands = 76,
    CommandRequest = 77,
    CommandBlockUpdate = 78,
    CommandOutput = 79,
    UpdateTrade = 80,
    UpdateEquipment = 81,
    ResourcePackDataInfo = 82,
    ResourcePackChunkData = 83,
    ResourcePackChunkRequest = 84,
    Transfer = 85,
    PlaySound = 86,
    StopSound = 87,
    SetTitle = 88,
    AddBehaviorTree = 89,
    StructureBlockUpdate = 90,
    ShowStoreOffer = 91,
    PurchaseReceipt = 92,
    PlayerSkin = 93,
    SubClientLogin = 94,
    InitiateWebSocketConnection = 95,
    SetLastHurtBy = 96,
    BookEdit = 97,
    NpcRequest = 98,
    PhotoTransfer = 99,
    ModalFormRequest = 100,
    ModalFormResponse = 101,
    ServerSettingsRequest = 102,
    ServerSettingsResponse = 103,
    ShowProfile = 104,
    SetDefaultGameType = 105,
    RemoveObjective = 106,
    SetDisplayObjective = 107,
    SetScore = 108,
    LabTable = 109,
    UpdateBlockSynced = 110,
    MoveEntityDelta = 111,
    SetScoreboardIdentity = 112,
    SetLocalPlayerAsInitialized = 113,
    UpdateSoftEnum = 114,
    NetworkStackLatency = 115,
    ScriptCustomEvent = 117,
    SpawnParticleEffect = 118,
    AvailableEntityIdentifiers = 119,
    LevelSoundEventV2 = 120,
    NetworkChunkPublisherUpdate = 121,
    BiomeDefinitionList = 122,
    LevelSoundEvent = 123,
    LevelEventGeneric = 124,
    LecternUpdate = 125,
    VideoStreamConnect = 126,
    AddEcsEntity = 127,
    RemoveEcsEntity = 128,
    ClientCacheStatus = 129,
    OnScreenTextureAnimation = 130,
    MapCreateLockedCopy = 131,
    StructureTemplateDataExportRequest = 132,
    StructureTemplateDataExportResponse = 133,
    UpdateBlockProperties = 134,
    ClientCacheBlobStatus = 135,
    ClientCacheMissResponse = 136,
    EducationSettings = 137,
    Emote = 138,
    MultiplayerSettings = 139,
    SettingsCommand = 140,
    AnvilDamage = 141,
    CompletedUsingItem = 142,
    NetworkSettings = 143,
    PlayerAuthInput = 144,
    CreativeContent = 145,
    PlayerEnchantOptions = 146,
    ItemStackRequest = 147,
    ItemStackResponse = 148,
    PlayerArmorDamage = 149,
    CodeBuilder = 150,
    UpdatePlayerGameType = 151,
    EmoteList = 152,
    PositionTrackingDbBroadcast = 153,
    PositionTrackingDbRequest = 154,
    DebugInfo = 155,
    PacketViolationWarning = 156,
    MotionPredictionHints = 157,
    AnimateEntity = 158,
    CameraShake = 159,
    PlayerFog = 160,
    CorrectPlayerMovePrediction = 161,
    ItemComponent = 162,
    FilterTextPacket = 163,
}
impl crate::bedrock::codec::BedrockCodec for McpePacketName {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(McpePacketName::Login),
            2 => Ok(McpePacketName::PlayStatus),
            3 => Ok(McpePacketName::ServerToClientHandshake),
            4 => Ok(McpePacketName::ClientToServerHandshake),
            5 => Ok(McpePacketName::Disconnect),
            6 => Ok(McpePacketName::ResourcePacksInfo),
            7 => Ok(McpePacketName::ResourcePackStack),
            8 => Ok(McpePacketName::ResourcePackClientResponse),
            9 => Ok(McpePacketName::Text),
            10 => Ok(McpePacketName::SetTime),
            11 => Ok(McpePacketName::StartGame),
            12 => Ok(McpePacketName::AddPlayer),
            13 => Ok(McpePacketName::AddEntity),
            14 => Ok(McpePacketName::RemoveEntity),
            15 => Ok(McpePacketName::AddItemEntity),
            17 => Ok(McpePacketName::TakeItemEntity),
            18 => Ok(McpePacketName::MoveEntity),
            19 => Ok(McpePacketName::MovePlayer),
            20 => Ok(McpePacketName::RiderJump),
            21 => Ok(McpePacketName::UpdateBlock),
            22 => Ok(McpePacketName::AddPainting),
            23 => Ok(McpePacketName::TickSync),
            24 => Ok(McpePacketName::LevelSoundEventOld),
            25 => Ok(McpePacketName::LevelEvent),
            26 => Ok(McpePacketName::BlockEvent),
            27 => Ok(McpePacketName::EntityEvent),
            28 => Ok(McpePacketName::MobEffect),
            29 => Ok(McpePacketName::UpdateAttributes),
            30 => Ok(McpePacketName::InventoryTransaction),
            31 => Ok(McpePacketName::MobEquipment),
            32 => Ok(McpePacketName::MobArmorEquipment),
            33 => Ok(McpePacketName::Interact),
            34 => Ok(McpePacketName::BlockPickRequest),
            35 => Ok(McpePacketName::EntityPickRequest),
            36 => Ok(McpePacketName::PlayerAction),
            38 => Ok(McpePacketName::HurtArmor),
            39 => Ok(McpePacketName::SetEntityData),
            40 => Ok(McpePacketName::SetEntityMotion),
            41 => Ok(McpePacketName::SetEntityLink),
            42 => Ok(McpePacketName::SetHealth),
            43 => Ok(McpePacketName::SetSpawnPosition),
            44 => Ok(McpePacketName::Animate),
            45 => Ok(McpePacketName::Respawn),
            46 => Ok(McpePacketName::ContainerOpen),
            47 => Ok(McpePacketName::ContainerClose),
            48 => Ok(McpePacketName::PlayerHotbar),
            49 => Ok(McpePacketName::InventoryContent),
            50 => Ok(McpePacketName::InventorySlot),
            51 => Ok(McpePacketName::ContainerSetData),
            52 => Ok(McpePacketName::CraftingData),
            53 => Ok(McpePacketName::CraftingEvent),
            54 => Ok(McpePacketName::GuiDataPickItem),
            55 => Ok(McpePacketName::AdventureSettings),
            56 => Ok(McpePacketName::BlockEntityData),
            57 => Ok(McpePacketName::PlayerInput),
            58 => Ok(McpePacketName::LevelChunk),
            59 => Ok(McpePacketName::SetCommandsEnabled),
            60 => Ok(McpePacketName::SetDifficulty),
            61 => Ok(McpePacketName::ChangeDimension),
            62 => Ok(McpePacketName::SetPlayerGameType),
            63 => Ok(McpePacketName::PlayerList),
            64 => Ok(McpePacketName::SimpleEvent),
            65 => Ok(McpePacketName::Event),
            66 => Ok(McpePacketName::SpawnExperienceOrb),
            67 => Ok(McpePacketName::ClientboundMapItemData),
            68 => Ok(McpePacketName::MapInfoRequest),
            69 => Ok(McpePacketName::RequestChunkRadius),
            70 => Ok(McpePacketName::ChunkRadiusUpdate),
            71 => Ok(McpePacketName::ItemFrameDropItem),
            72 => Ok(McpePacketName::GameRulesChanged),
            73 => Ok(McpePacketName::Camera),
            74 => Ok(McpePacketName::BossEvent),
            75 => Ok(McpePacketName::ShowCredits),
            76 => Ok(McpePacketName::AvailableCommands),
            77 => Ok(McpePacketName::CommandRequest),
            78 => Ok(McpePacketName::CommandBlockUpdate),
            79 => Ok(McpePacketName::CommandOutput),
            80 => Ok(McpePacketName::UpdateTrade),
            81 => Ok(McpePacketName::UpdateEquipment),
            82 => Ok(McpePacketName::ResourcePackDataInfo),
            83 => Ok(McpePacketName::ResourcePackChunkData),
            84 => Ok(McpePacketName::ResourcePackChunkRequest),
            85 => Ok(McpePacketName::Transfer),
            86 => Ok(McpePacketName::PlaySound),
            87 => Ok(McpePacketName::StopSound),
            88 => Ok(McpePacketName::SetTitle),
            89 => Ok(McpePacketName::AddBehaviorTree),
            90 => Ok(McpePacketName::StructureBlockUpdate),
            91 => Ok(McpePacketName::ShowStoreOffer),
            92 => Ok(McpePacketName::PurchaseReceipt),
            93 => Ok(McpePacketName::PlayerSkin),
            94 => Ok(McpePacketName::SubClientLogin),
            95 => Ok(McpePacketName::InitiateWebSocketConnection),
            96 => Ok(McpePacketName::SetLastHurtBy),
            97 => Ok(McpePacketName::BookEdit),
            98 => Ok(McpePacketName::NpcRequest),
            99 => Ok(McpePacketName::PhotoTransfer),
            100 => Ok(McpePacketName::ModalFormRequest),
            101 => Ok(McpePacketName::ModalFormResponse),
            102 => Ok(McpePacketName::ServerSettingsRequest),
            103 => Ok(McpePacketName::ServerSettingsResponse),
            104 => Ok(McpePacketName::ShowProfile),
            105 => Ok(McpePacketName::SetDefaultGameType),
            106 => Ok(McpePacketName::RemoveObjective),
            107 => Ok(McpePacketName::SetDisplayObjective),
            108 => Ok(McpePacketName::SetScore),
            109 => Ok(McpePacketName::LabTable),
            110 => Ok(McpePacketName::UpdateBlockSynced),
            111 => Ok(McpePacketName::MoveEntityDelta),
            112 => Ok(McpePacketName::SetScoreboardIdentity),
            113 => Ok(McpePacketName::SetLocalPlayerAsInitialized),
            114 => Ok(McpePacketName::UpdateSoftEnum),
            115 => Ok(McpePacketName::NetworkStackLatency),
            117 => Ok(McpePacketName::ScriptCustomEvent),
            118 => Ok(McpePacketName::SpawnParticleEffect),
            119 => Ok(McpePacketName::AvailableEntityIdentifiers),
            120 => Ok(McpePacketName::LevelSoundEventV2),
            121 => Ok(McpePacketName::NetworkChunkPublisherUpdate),
            122 => Ok(McpePacketName::BiomeDefinitionList),
            123 => Ok(McpePacketName::LevelSoundEvent),
            124 => Ok(McpePacketName::LevelEventGeneric),
            125 => Ok(McpePacketName::LecternUpdate),
            126 => Ok(McpePacketName::VideoStreamConnect),
            127 => Ok(McpePacketName::AddEcsEntity),
            128 => Ok(McpePacketName::RemoveEcsEntity),
            129 => Ok(McpePacketName::ClientCacheStatus),
            130 => Ok(McpePacketName::OnScreenTextureAnimation),
            131 => Ok(McpePacketName::MapCreateLockedCopy),
            132 => Ok(McpePacketName::StructureTemplateDataExportRequest),
            133 => Ok(McpePacketName::StructureTemplateDataExportResponse),
            134 => Ok(McpePacketName::UpdateBlockProperties),
            135 => Ok(McpePacketName::ClientCacheBlobStatus),
            136 => Ok(McpePacketName::ClientCacheMissResponse),
            137 => Ok(McpePacketName::EducationSettings),
            138 => Ok(McpePacketName::Emote),
            139 => Ok(McpePacketName::MultiplayerSettings),
            140 => Ok(McpePacketName::SettingsCommand),
            141 => Ok(McpePacketName::AnvilDamage),
            142 => Ok(McpePacketName::CompletedUsingItem),
            143 => Ok(McpePacketName::NetworkSettings),
            144 => Ok(McpePacketName::PlayerAuthInput),
            145 => Ok(McpePacketName::CreativeContent),
            146 => Ok(McpePacketName::PlayerEnchantOptions),
            147 => Ok(McpePacketName::ItemStackRequest),
            148 => Ok(McpePacketName::ItemStackResponse),
            149 => Ok(McpePacketName::PlayerArmorDamage),
            150 => Ok(McpePacketName::CodeBuilder),
            151 => Ok(McpePacketName::UpdatePlayerGameType),
            152 => Ok(McpePacketName::EmoteList),
            153 => Ok(McpePacketName::PositionTrackingDbBroadcast),
            154 => Ok(McpePacketName::PositionTrackingDbRequest),
            155 => Ok(McpePacketName::DebugInfo),
            156 => Ok(McpePacketName::PacketViolationWarning),
            157 => Ok(McpePacketName::MotionPredictionHints),
            158 => Ok(McpePacketName::AnimateEntity),
            159 => Ok(McpePacketName::CameraShake),
            160 => Ok(McpePacketName::PlayerFog),
            161 => Ok(McpePacketName::CorrectPlayerMovePrediction),
            162 => Ok(McpePacketName::ItemComponent),
            163 => Ok(McpePacketName::FilterTextPacket),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(McpePacketName),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddBehaviorTree {
    pub behaviortree: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddBehaviorTree {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.behaviortree.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let behaviortree = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { behaviortree })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPainting {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i32,
    pub coordinates: BlockCoordinates,
    pub direction: crate::bedrock::codec::ZigZag32,
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPainting {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.coordinates.encode(buf)?;
        self.direction.encode(buf)?;
        self.title.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let direction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            coordinates,
            direction,
            title,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAnvilDamage {
    pub damage: u8,
    pub position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketAnvilDamage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.damage.encode(buf)?;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let damage = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { damage, position })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketBossEventType {
    ShowBar = 0,
    RegisterPlayer = 1,
    HideBar = 2,
    UnregisterPlayer = 3,
    SetBarProgress = 4,
    SetBarTitle = 5,
    UpdateProperties = 6,
    Texture = 7,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketBossEventType::ShowBar),
            1 => Ok(PacketBossEventType::RegisterPlayer),
            2 => Ok(PacketBossEventType::HideBar),
            3 => Ok(PacketBossEventType::UnregisterPlayer),
            4 => Ok(PacketBossEventType::SetBarProgress),
            5 => Ok(PacketBossEventType::SetBarTitle),
            6 => Ok(PacketBossEventType::UpdateProperties),
            7 => Ok(PacketBossEventType::Texture),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketBossEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentSetBarProgress {
    pub bar_progress: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentSetBarProgress {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.bar_progress.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let bar_progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { bar_progress })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentShow {
    pub title: String,
    pub bar_progress: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentShow {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.bar_progress.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let bar_progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { title, bar_progress })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentUpdateProperties {
    pub darkness_factor: i16,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentUpdateProperties {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.darkness_factor.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let darkness_factor = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { darkness_factor })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketBossEventContent {
    RegisterPlayer(PacketBossEventContentRegisterPlayer),
    SetBarProgress(PacketBossEventContentSetBarProgress),
    SetBarTitle(PacketBossEventContentSetBarTitle),
    Show(PacketBossEventContentShow),
    Texture(PacketBossEventContentTexture),
    UnregisterPlayer(PacketBossEventContentRegisterPlayer),
    UpdateProperties(PacketBossEventContentUpdateProperties),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEvent {
    pub boss_entity_id: crate::bedrock::codec::ZigZag64,
    pub type_: PacketBossEventType,
    pub content: Option<PacketBossEventContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.boss_entity_id.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketBossEventContent::RegisterPlayer(v) => v.encode(buf)?,
                PacketBossEventContent::SetBarProgress(v) => v.encode(buf)?,
                PacketBossEventContent::SetBarTitle(v) => v.encode(buf)?,
                PacketBossEventContent::Show(v) => v.encode(buf)?,
                PacketBossEventContent::Texture(v) => v.encode(buf)?,
                PacketBossEventContent::UnregisterPlayer(v) => v.encode(buf)?,
                PacketBossEventContent::UpdateProperties(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let boss_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <PacketBossEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_ {
            _ => {
                Some(
                    PacketBossEventContent::RegisterPlayer(
                        <PacketBossEventContentRegisterPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::SetBarProgress(
                        <PacketBossEventContentSetBarProgress as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::SetBarTitle(
                        <PacketBossEventContentSetBarTitle as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::Show(
                        <PacketBossEventContentShow as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::Texture(
                        <PacketBossEventContentTexture as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::UnregisterPlayer(
                        <PacketBossEventContentRegisterPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::UpdateProperties(
                        <PacketBossEventContentUpdateProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            boss_entity_id,
            type_,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheBlobStatus {
    pub misses: i32,
    pub haves: i32,
    pub missing: Vec<u64>,
    pub have: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheBlobStatus {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.misses.encode(buf)?;
        self.haves.encode(buf)?;
        let len = self.missing.len() as i32;
        len.encode(buf)?;
        for item in &self.missing {
            item.encode(buf)?;
        }
        let len = self.have.len() as i32;
        len.encode(buf)?;
        for item in &self.have {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let misses = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let haves = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let missing = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let have = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            misses,
            haves,
            missing,
            have,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheMissResponse {
    pub blobs: Vec<Blob>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheMissResponse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.blobs.len() as i32;
        len.encode(buf)?;
        for item in &self.blobs {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let blobs = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<Blob as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self { blobs })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientCacheStatus {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientCacheStatus {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCodeBuilder {
    pub url: String,
    pub should_open_code_builder: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCodeBuilder {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.url.encode(buf)?;
        self.should_open_code_builder.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let url = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let should_open_code_builder = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            url,
            should_open_code_builder,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContent {
    pub items: ItemStacks,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.items.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let items = <ItemStacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { items })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketDebugInfo {
    pub player_unique_id: crate::bedrock::codec::ZigZag64,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketDebugInfo {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.player_unique_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { player_unique_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEmote {
    pub entity_id: i64,
    pub emote_id: String,
    pub flags: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketEmote {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id.encode(buf)?;
        self.emote_id.encode(buf)?;
        self.flags.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let emote_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { entity_id, emote_id, flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEmoteList {
    pub player_id: i64,
    pub emote_pieces: Vec<uuid::Uuid>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEmoteList {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.player_id.encode(buf)?;
        let len = self.emote_pieces.len() as i32;
        len.encode(buf)?;
        for item in &self.emote_pieces {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let player_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let emote_pieces = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        Ok(Self { player_id, emote_pieces })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketEventEventType {
    AchievementAwarded = 0,
    EntityInteract = 1,
    PortalBuilt = 2,
    PortalUsed = 3,
    MobKilled = 4,
    CauldronUsed = 5,
    PlayerDeath = 6,
    BossKilled = 7,
    AgentCommand = 8,
    AgentCreated = 9,
    BannerPatternRemoved = 10,
    CommandExecuted = 11,
    FishBucketed = 12,
    MobBorn = 13,
    PetDied = 14,
    CauldronBlockUsed = 15,
    ComposterBlockUsed = 16,
    BellBlockUsed = 17,
}
impl crate::bedrock::codec::BedrockCodec for PacketEventEventType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketEventEventType::AchievementAwarded),
            1 => Ok(PacketEventEventType::EntityInteract),
            2 => Ok(PacketEventEventType::PortalBuilt),
            3 => Ok(PacketEventEventType::PortalUsed),
            4 => Ok(PacketEventEventType::MobKilled),
            5 => Ok(PacketEventEventType::CauldronUsed),
            6 => Ok(PacketEventEventType::PlayerDeath),
            7 => Ok(PacketEventEventType::BossKilled),
            8 => Ok(PacketEventEventType::AgentCommand),
            9 => Ok(PacketEventEventType::AgentCreated),
            10 => Ok(PacketEventEventType::BannerPatternRemoved),
            11 => Ok(PacketEventEventType::CommandExecuted),
            12 => Ok(PacketEventEventType::FishBucketed),
            13 => Ok(PacketEventEventType::MobBorn),
            14 => Ok(PacketEventEventType::PetDied),
            15 => Ok(PacketEventEventType::CauldronBlockUsed),
            16 => Ok(PacketEventEventType::ComposterBlockUsed),
            17 => Ok(PacketEventEventType::BellBlockUsed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEventEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEvent {
    pub runtime_id: i64,
    pub event_type: PacketEventEventType,
    pub use_player_id: u8,
    pub event_data: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_id.encode(buf)?;
        self.event_type.encode(buf)?;
        self.use_player_id.encode(buf)?;
        self.event_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let event_type = <PacketEventEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let use_player_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let event_data = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_id,
            event_type,
            use_player_id,
            event_data,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketHurtArmor {
    pub health: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketHurtArmor {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.health.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let health = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { health })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInitiateWebSocketConnection {
    pub server: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketInitiateWebSocketConnection {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let server = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { server })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketInteractActionID {
    LeaveVehicle = 3,
    MouseOverEntity = 4,
    NpcOpen = 5,
    OpenInventory = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketInteractActionID {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            3 => Ok(PacketInteractActionID::LeaveVehicle),
            4 => Ok(PacketInteractActionID::MouseOverEntity),
            5 => Ok(PacketInteractActionID::NpcOpen),
            6 => Ok(PacketInteractActionID::OpenInventory),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketInteractActionID), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketInteractPosition {
    LeaveVehicle(Vec3F),
    MouseOverEntity(Vec3F),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInteract {
    pub action_id: PacketInteractActionID,
    pub target_runtime_entity_id: i32,
    pub position: Option<PacketInteractPosition>,
}
impl crate::bedrock::codec::BedrockCodec for PacketInteract {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_id.encode(buf)?;
        self.target_runtime_entity_id.encode(buf)?;
        if let Some(v) = &self.position {
            match v {
                PacketInteractPosition::LeaveVehicle(v) => v.encode(buf)?,
                PacketInteractPosition::MouseOverEntity(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_id = <PacketInteractActionID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let target_runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = match action_id {
            _ => {
                Some(
                    PacketInteractPosition::LeaveVehicle(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketInteractPosition::MouseOverEntity(
                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            action_id,
            target_runtime_entity_id,
            position,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketLabTableActionType {
    Combine = 0,
    React = 1,
    Reset = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketLabTableActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketLabTableActionType::Combine),
            1 => Ok(PacketLabTableActionType::React),
            2 => Ok(PacketLabTableActionType::Reset),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLabTableActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLabTable {
    pub action_type: PacketLabTableActionType,
    pub position: Vec3I,
    pub reaction_type: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketLabTable {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.position.encode(buf)?;
        self.reaction_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_type = <PacketLabTableActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let reaction_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            action_type,
            position,
            reaction_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLecternUpdate {
    pub page: u8,
    pub page_count: u8,
    pub position: Vec3I,
    pub drop_book: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLecternUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.page.encode(buf)?;
        self.page_count.encode(buf)?;
        self.position.encode(buf)?;
        self.drop_book.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let page = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let page_count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let drop_book = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            page,
            page_count,
            position,
            drop_book,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketModalFormRequest {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.form_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let form_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketModalFormResponse {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketModalFormResponse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.form_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let form_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkStackLatency {
    pub timestamp: u64,
    pub unknown_flag: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkStackLatency {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.timestamp.encode(buf)?;
        self.unknown_flag.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let timestamp = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown_flag = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { timestamp, unknown_flag })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPacketViolationWarningViolationType {
    Malformed = 0,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarningViolationType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPacketViolationWarningViolationType::Malformed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPacketViolationWarningViolationType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPacketViolationWarningSeverity {
    Warning = 0,
    FinalWarning = 1,
    Terminating = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarningSeverity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPacketViolationWarningSeverity::Warning),
            1 => Ok(PacketPacketViolationWarningSeverity::FinalWarning),
            2 => Ok(PacketPacketViolationWarningSeverity::Terminating),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPacketViolationWarningSeverity), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPacketViolationWarning {
    pub violation_type: PacketPacketViolationWarningViolationType,
    pub severity: PacketPacketViolationWarningSeverity,
    pub packet_id: crate::bedrock::codec::ZigZag32,
    pub reason: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPacketViolationWarning {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.violation_type.encode(buf)?;
        self.severity.encode(buf)?;
        self.packet_id.encode(buf)?;
        self.reason.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let violation_type = <PacketPacketViolationWarningViolationType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let severity = <PacketPacketViolationWarningSeverity as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let packet_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let reason = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            violation_type,
            severity,
            packet_id,
            reason,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPhotoTransfer {
    pub file_name: String,
    pub image_data: String,
    pub unknown2: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPhotoTransfer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.file_name.encode(buf)?;
        self.image_data.encode(buf)?;
        self.unknown2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let file_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let image_data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown2 = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            file_name,
            image_data,
            unknown2,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlaySound {
    pub name: String,
    pub coordinates: BlockCoordinates,
    pub volume: f32,
    pub pitch: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlaySound {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.coordinates.encode(buf)?;
        self.volume.encode(buf)?;
        self.pitch.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let volume = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            name,
            coordinates,
            volume,
            pitch,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPositionTrackingDbBroadcastBroadcastAction {
    Update = 0,
    Destory = 1,
    NotFound = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketPositionTrackingDbBroadcastBroadcastAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::Update),
            1 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::Destory),
            2 => Ok(PacketPositionTrackingDbBroadcastBroadcastAction::NotFound),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPositionTrackingDbBroadcastBroadcastAction),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPositionTrackingDbBroadcast {
    pub broadcast_action: PacketPositionTrackingDbBroadcastBroadcastAction,
    pub tracking_id: crate::bedrock::codec::ZigZag32,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbBroadcast {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.broadcast_action.encode(buf)?;
        self.tracking_id.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let broadcast_action = <PacketPositionTrackingDbBroadcastBroadcastAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            broadcast_action,
            tracking_id,
            nbt,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketPositionTrackingDbRequestAction {
    Query = 0,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbRequestAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPositionTrackingDbRequestAction::Query),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPositionTrackingDbRequestAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPositionTrackingDbRequest {
    pub action: PacketPositionTrackingDbRequestAction,
    pub tracking_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPositionTrackingDbRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        self.tracking_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action = <PacketPositionTrackingDbRequestAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { action, tracking_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPurchaseReceipt {
    pub receipts: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPurchaseReceipt {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.receipts.len() as i32;
        len.encode(buf)?;
        for item in &self.receipts {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let receipts = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self { receipts })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRespawn {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub state: u8,
    pub runtime_entity_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRespawn {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        self.state.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let state = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            x,
            y,
            z,
            state,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRiderJump {
    pub jump_strength: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketRiderJump {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.jump_strength.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let jump_strength = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { jump_strength })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketScriptCustomEvent {
    pub event_name: String,
    pub event_data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketScriptCustomEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event_name.encode(buf)?;
        self.event_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let event_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let event_data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { event_name, event_data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDifficulty {
    pub difficulty: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDifficulty {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.difficulty.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let difficulty = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { difficulty })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetHealth {
    pub health: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetHealth {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.health.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let health = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { health })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLastHurtBy {
    pub unknown: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLastHurtBy {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.unknown.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let unknown = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { unknown })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketSetSpawnPositionSpawnType {
    Player = 0,
    World = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPositionSpawnType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketSetSpawnPositionSpawnType::Player),
            1 => Ok(PacketSetSpawnPositionSpawnType::World),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetSpawnPositionSpawnType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetSpawnPosition {
    pub spawn_type: PacketSetSpawnPositionSpawnType,
    pub player_position: BlockCoordinates,
    pub dimension: crate::bedrock::codec::ZigZag32,
    pub world_position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetSpawnPosition {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.spawn_type.encode(buf)?;
        self.player_position.encode(buf)?;
        self.dimension.encode(buf)?;
        self.world_position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let spawn_type = <PacketSetSpawnPositionSpawnType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let player_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let world_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            spawn_type,
            player_position,
            dimension,
            world_position,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetTime {
    pub time: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetTime {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.time.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { time })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowCredits {
    pub runtime_entity_id: i32,
    pub status: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowCredits {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.status.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let status = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { runtime_entity_id, status })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowProfile {
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowProfile {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.xuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let xuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { xuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowStoreOffer {
    pub unknown0: String,
    pub unknown1: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowStoreOffer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.unknown0.encode(buf)?;
        self.unknown1.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let unknown0 = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let unknown1 = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { unknown0, unknown1 })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketSimpleEventEventType {
    UninitializedSubtype = 0,
    EnableCommands = 1,
    DisableCommands = 2,
    UnlockWorldTemplateSettings = 3,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimpleEventEventType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketSimpleEventEventType::UninitializedSubtype),
            1 => Ok(PacketSimpleEventEventType::EnableCommands),
            2 => Ok(PacketSimpleEventEventType::DisableCommands),
            3 => Ok(PacketSimpleEventEventType::UnlockWorldTemplateSettings),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSimpleEventEventType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSimpleEvent {
    pub event_type: PacketSimpleEventEventType,
}
impl crate::bedrock::codec::BedrockCodec for PacketSimpleEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let event_type = <PacketSimpleEventEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { event_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnExperienceOrb {
    pub position: Vec3F,
    pub count: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnExperienceOrb {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.count.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { position, count })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStopSound {
    pub name: String,
    pub stop_all: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStopSound {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.stop_all.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let stop_all = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { name, stop_all })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketTransfer {
    pub server_address: String,
    pub port: u16,
}
impl crate::bedrock::codec::BedrockCodec for PacketTransfer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server_address.encode(buf)?;
        self.port.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let server_address = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let port = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { server_address, port })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateEquipment {
    pub window_id: WindowID,
    pub window_type: WindowType,
    pub size: u8,
    pub entity_id: crate::bedrock::codec::ZigZag64,
    pub inventory: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateEquipment {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.size.encode(buf)?;
        self.entity_id.encode(buf)?;
        self.inventory.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowID as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let size = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let inventory = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            window_id,
            window_type,
            size,
            entity_id,
            inventory,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketUpdateSoftEnumActionType {
    Add = 0,
    Remove = 1,
    Update = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateSoftEnumActionType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketUpdateSoftEnumActionType::Add),
            1 => Ok(PacketUpdateSoftEnumActionType::Remove),
            2 => Ok(PacketUpdateSoftEnumActionType::Update),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketUpdateSoftEnumActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketUpdateSoftEnum {
    pub enum_type: String,
    pub options: Vec<String>,
    pub action_type: PacketUpdateSoftEnumActionType,
}
impl crate::bedrock::codec::BedrockCodec for PacketUpdateSoftEnum {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enum_type.encode(buf)?;
        let len = self.options.len() as i32;
        len.encode(buf)?;
        for item in &self.options {
            item.encode(buf)?;
        }
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let enum_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let options = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let action_type = <PacketUpdateSoftEnumActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            enum_type,
            options,
            action_type,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketVideoStreamConnectAction {
    None = 1,
    Close = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketVideoStreamConnectAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketVideoStreamConnectAction::None),
            2 => Ok(PacketVideoStreamConnectAction::Close),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketVideoStreamConnectAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketVideoStreamConnect {
    pub server_uri: String,
    pub frame_send_frequency: f32,
    pub action: PacketVideoStreamConnectAction,
    pub resolution_x: i32,
    pub resolution_y: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketVideoStreamConnect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.server_uri.encode(buf)?;
        self.frame_send_frequency.encode(buf)?;
        self.action.encode(buf)?;
        self.resolution_x.encode(buf)?;
        self.resolution_y.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let server_uri = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let frame_send_frequency = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action = <PacketVideoStreamConnectAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let resolution_x = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let resolution_y = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            server_uri,
            frame_send_frequency,
            action,
            resolution_x,
            resolution_y,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum McpePacketParams {
    AddBehaviorTree(PacketAddBehaviorTree),
    AddEcsEntity(PacketAddEcsEntity),
    AddEntity(Box<PacketAddEntity>),
    AddItemEntity(Box<PacketAddItemEntity>),
    AddPainting(Box<PacketAddPainting>),
    AddPlayer(Box<PacketAddPlayer>),
    AdventureSettings(Box<PacketAdventureSettings>),
    Animate(Box<PacketAnimate>),
    AnimateEntity(Box<PacketAnimateEntity>),
    AnvilDamage(PacketAnvilDamage),
    AvailableCommands(Box<PacketAvailableCommands>),
    AvailableEntityIdentifiers(PacketAvailableEntityIdentifiers),
    BiomeDefinitionList(PacketBiomeDefinitionList),
    BlockEntityData(PacketBlockEntityData),
    BlockEvent(PacketBlockEvent),
    BlockPickRequest(Box<PacketBlockPickRequest>),
    BookEdit(Box<PacketBookEdit>),
    BossEvent(Box<PacketBossEvent>),
    Camera(PacketCamera),
    CameraShake(PacketCameraShake),
    ChangeDimension(PacketChangeDimension),
    ChunkRadiusUpdate(PacketChunkRadiusUpdate),
    ClientCacheBlobStatus(Box<PacketClientCacheBlobStatus>),
    ClientCacheMissResponse(PacketClientCacheMissResponse),
    ClientCacheStatus(PacketClientCacheStatus),
    ClientToServerHandshake(PacketClientToServerHandshake),
    ClientboundMapItemData(PacketClientboundMapItemData),
    CodeBuilder(PacketCodeBuilder),
    CommandBlockUpdate(Box<PacketCommandBlockUpdate>),
    CommandOutput(Box<PacketCommandOutput>),
    CommandRequest(Box<PacketCommandRequest>),
    CompletedUsingItem(PacketCompletedUsingItem),
    ContainerClose(PacketContainerClose),
    ContainerOpen(Box<PacketContainerOpen>),
    ContainerSetData(PacketContainerSetData),
    CorrectPlayerMovePrediction(Box<PacketCorrectPlayerMovePrediction>),
    CraftingData(Box<PacketCraftingData>),
    CraftingEvent(Box<PacketCraftingEvent>),
    CreativeContent(PacketCreativeContent),
    DebugInfo(PacketDebugInfo),
    Disconnect(PacketDisconnect),
    EducationSettings(Box<PacketEducationSettings>),
    Emote(PacketEmote),
    EmoteList(PacketEmoteList),
    EntityEvent(PacketEntityEvent),
    EntityPickRequest(PacketEntityPickRequest),
    Event(Box<PacketEvent>),
    FilterTextPacket(PacketFilterTextPacket),
    GameRulesChanged(PacketGameRulesChanged),
    GuiDataPickItem(PacketGuiDataPickItem),
    HurtArmor(PacketHurtArmor),
    InitiateWebSocketConnection(PacketInitiateWebSocketConnection),
    Interact(Box<PacketInteract>),
    InventoryContent(PacketInventoryContent),
    InventorySlot(Box<PacketInventorySlot>),
    InventoryTransaction(Box<PacketInventoryTransaction>),
    ItemComponent(PacketItemComponent),
    ItemFrameDropItem(PacketItemFrameDropItem),
    ItemStackRequest(PacketItemStackRequest),
    ItemStackResponse(PacketItemStackResponse),
    LabTable(PacketLabTable),
    LecternUpdate(Box<PacketLecternUpdate>),
    LevelChunk(Box<PacketLevelChunk>),
    LevelEvent(PacketLevelEvent),
    LevelEventGeneric(PacketLevelEventGeneric),
    LevelSoundEvent(Box<PacketLevelSoundEvent>),
    LevelSoundEventOld(Box<PacketLevelSoundEventOld>),
    LevelSoundEventV2(Box<PacketLevelSoundEventV2>),
    Login(PacketLogin),
    MapCreateLockedCopy(PacketMapCreateLockedCopy),
    MapInfoRequest(PacketMapInfoRequest),
    MobArmorEquipment(Box<PacketMobArmorEquipment>),
    MobEffect(Box<PacketMobEffect>),
    MobEquipment(Box<PacketMobEquipment>),
    ModalFormRequest(PacketModalFormRequest),
    ModalFormResponse(PacketModalFormResponse),
    MotionPredictionHints(PacketMotionPredictionHints),
    MoveEntity(Box<PacketMoveEntity>),
    MoveEntityDelta(Box<PacketMoveEntityDelta>),
    MovePlayer(Box<PacketMovePlayer>),
    MultiplayerSettings(PacketMultiplayerSettings),
    NetworkChunkPublisherUpdate(PacketNetworkChunkPublisherUpdate),
    NetworkSettings(PacketNetworkSettings),
    NetworkStackLatency(PacketNetworkStackLatency),
    NpcRequest(Box<PacketNpcRequest>),
    OnScreenTextureAnimation(PacketOnScreenTextureAnimation),
    PacketViolationWarning(Box<PacketPacketViolationWarning>),
    PhotoTransfer(PacketPhotoTransfer),
    PlaySound(Box<PacketPlaySound>),
    PlayStatus(PacketPlayStatus),
    PlayerAction(Box<PacketPlayerAction>),
    PlayerArmorDamage(Box<PacketPlayerArmorDamage>),
    PlayerAuthInput(Box<PacketPlayerAuthInput>),
    PlayerEnchantOptions(PacketPlayerEnchantOptions),
    PlayerFog(PacketPlayerFog),
    PlayerHotbar(PacketPlayerHotbar),
    PlayerInput(Box<PacketPlayerInput>),
    PlayerList(Box<PacketPlayerList>),
    PlayerSkin(Box<PacketPlayerSkin>),
    PositionTrackingDbBroadcast(PacketPositionTrackingDbBroadcast),
    PositionTrackingDbRequest(PacketPositionTrackingDbRequest),
    PurchaseReceipt(PacketPurchaseReceipt),
    RemoveEcsEntity(PacketRemoveEcsEntity),
    RemoveEntity(PacketRemoveEntity),
    RemoveObjective(PacketRemoveObjective),
    RequestChunkRadius(PacketRequestChunkRadius),
    ResourcePackChunkData(Box<PacketResourcePackChunkData>),
    ResourcePackChunkRequest(PacketResourcePackChunkRequest),
    ResourcePackClientResponse(PacketResourcePackClientResponse),
    ResourcePackDataInfo(Box<PacketResourcePackDataInfo>),
    ResourcePackStack(Box<PacketResourcePackStack>),
    ResourcePacksInfo(Box<PacketResourcePacksInfo>),
    Respawn(Box<PacketRespawn>),
    RiderJump(PacketRiderJump),
    ScriptCustomEvent(PacketScriptCustomEvent),
    ServerSettingsRequest(PacketServerSettingsRequest),
    ServerSettingsResponse(PacketServerSettingsResponse),
    ServerToClientHandshake(PacketServerToClientHandshake),
    SetCommandsEnabled(PacketSetCommandsEnabled),
    SetDefaultGameType(PacketSetDefaultGameType),
    SetDifficulty(PacketSetDifficulty),
    SetDisplayObjective(Box<PacketSetDisplayObjective>),
    SetEntityData(PacketSetEntityData),
    SetEntityLink(Box<PacketSetEntityLink>),
    SetEntityMotion(PacketSetEntityMotion),
    SetHealth(PacketSetHealth),
    SetLastHurtBy(PacketSetLastHurtBy),
    SetLocalPlayerAsInitialized(PacketSetLocalPlayerAsInitialized),
    SetPlayerGameType(PacketSetPlayerGameType),
    SetScore(PacketSetScore),
    SetScoreboardIdentity(PacketSetScoreboardIdentity),
    SetSpawnPosition(Box<PacketSetSpawnPosition>),
    SetTime(PacketSetTime),
    SetTitle(Box<PacketSetTitle>),
    SettingsCommand(PacketSettingsCommand),
    ShowCredits(PacketShowCredits),
    ShowProfile(PacketShowProfile),
    ShowStoreOffer(PacketShowStoreOffer),
    SimpleEvent(PacketSimpleEvent),
    SpawnExperienceOrb(PacketSpawnExperienceOrb),
    SpawnParticleEffect(Box<PacketSpawnParticleEffect>),
    StartGame(Box<PacketStartGame>),
    StopSound(PacketStopSound),
    StructureBlockUpdate(PacketStructureBlockUpdate),
    StructureTemplateDataExportRequest(PacketStructureTemplateDataExportRequest),
    StructureTemplateDataExportResponse(PacketStructureTemplateDataExportResponse),
    SubClientLogin(PacketSubClientLogin),
    TakeItemEntity(PacketTakeItemEntity),
    Text(Box<PacketText>),
    TickSync(PacketTickSync),
    Transfer(PacketTransfer),
    UpdateAttributes(PacketUpdateAttributes),
    UpdateBlock(Box<PacketUpdateBlock>),
    UpdateBlockProperties(PacketUpdateBlockProperties),
    UpdateBlockSynced(Box<PacketUpdateBlockSynced>),
    UpdateEquipment(Box<PacketUpdateEquipment>),
    UpdatePlayerGameType(PacketUpdatePlayerGameType),
    UpdateSoftEnum(PacketUpdateSoftEnum),
    UpdateTrade(Box<PacketUpdateTrade>),
    VideoStreamConnect(Box<PacketVideoStreamConnect>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct McpePacket {
    pub name: McpePacketName,
    pub params: Option<McpePacketParams>,
}
impl crate::bedrock::codec::BedrockCodec for McpePacket {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        if let Some(v) = &self.params {
            match v {
                McpePacketParams::AddBehaviorTree(v) => v.encode(buf)?,
                McpePacketParams::AddEcsEntity(v) => v.encode(buf)?,
                McpePacketParams::AddEntity(v) => v.encode(buf)?,
                McpePacketParams::AddItemEntity(v) => v.encode(buf)?,
                McpePacketParams::AddPainting(v) => v.encode(buf)?,
                McpePacketParams::AddPlayer(v) => v.encode(buf)?,
                McpePacketParams::AdventureSettings(v) => v.encode(buf)?,
                McpePacketParams::Animate(v) => v.encode(buf)?,
                McpePacketParams::AnimateEntity(v) => v.encode(buf)?,
                McpePacketParams::AnvilDamage(v) => v.encode(buf)?,
                McpePacketParams::AvailableCommands(v) => v.encode(buf)?,
                McpePacketParams::AvailableEntityIdentifiers(v) => v.encode(buf)?,
                McpePacketParams::BiomeDefinitionList(v) => v.encode(buf)?,
                McpePacketParams::BlockEntityData(v) => v.encode(buf)?,
                McpePacketParams::BlockEvent(v) => v.encode(buf)?,
                McpePacketParams::BlockPickRequest(v) => v.encode(buf)?,
                McpePacketParams::BookEdit(v) => v.encode(buf)?,
                McpePacketParams::BossEvent(v) => v.encode(buf)?,
                McpePacketParams::Camera(v) => v.encode(buf)?,
                McpePacketParams::CameraShake(v) => v.encode(buf)?,
                McpePacketParams::ChangeDimension(v) => v.encode(buf)?,
                McpePacketParams::ChunkRadiusUpdate(v) => v.encode(buf)?,
                McpePacketParams::ClientCacheBlobStatus(v) => v.encode(buf)?,
                McpePacketParams::ClientCacheMissResponse(v) => v.encode(buf)?,
                McpePacketParams::ClientCacheStatus(v) => v.encode(buf)?,
                McpePacketParams::ClientToServerHandshake(v) => v.encode(buf)?,
                McpePacketParams::ClientboundMapItemData(v) => v.encode(buf)?,
                McpePacketParams::CodeBuilder(v) => v.encode(buf)?,
                McpePacketParams::CommandBlockUpdate(v) => v.encode(buf)?,
                McpePacketParams::CommandOutput(v) => v.encode(buf)?,
                McpePacketParams::CommandRequest(v) => v.encode(buf)?,
                McpePacketParams::CompletedUsingItem(v) => v.encode(buf)?,
                McpePacketParams::ContainerClose(v) => v.encode(buf)?,
                McpePacketParams::ContainerOpen(v) => v.encode(buf)?,
                McpePacketParams::ContainerSetData(v) => v.encode(buf)?,
                McpePacketParams::CorrectPlayerMovePrediction(v) => v.encode(buf)?,
                McpePacketParams::CraftingData(v) => v.encode(buf)?,
                McpePacketParams::CraftingEvent(v) => v.encode(buf)?,
                McpePacketParams::CreativeContent(v) => v.encode(buf)?,
                McpePacketParams::DebugInfo(v) => v.encode(buf)?,
                McpePacketParams::Disconnect(v) => v.encode(buf)?,
                McpePacketParams::EducationSettings(v) => v.encode(buf)?,
                McpePacketParams::Emote(v) => v.encode(buf)?,
                McpePacketParams::EmoteList(v) => v.encode(buf)?,
                McpePacketParams::EntityEvent(v) => v.encode(buf)?,
                McpePacketParams::EntityPickRequest(v) => v.encode(buf)?,
                McpePacketParams::Event(v) => v.encode(buf)?,
                McpePacketParams::FilterTextPacket(v) => v.encode(buf)?,
                McpePacketParams::GameRulesChanged(v) => v.encode(buf)?,
                McpePacketParams::GuiDataPickItem(v) => v.encode(buf)?,
                McpePacketParams::HurtArmor(v) => v.encode(buf)?,
                McpePacketParams::InitiateWebSocketConnection(v) => v.encode(buf)?,
                McpePacketParams::Interact(v) => v.encode(buf)?,
                McpePacketParams::InventoryContent(v) => v.encode(buf)?,
                McpePacketParams::InventorySlot(v) => v.encode(buf)?,
                McpePacketParams::InventoryTransaction(v) => v.encode(buf)?,
                McpePacketParams::ItemComponent(v) => v.encode(buf)?,
                McpePacketParams::ItemFrameDropItem(v) => v.encode(buf)?,
                McpePacketParams::ItemStackRequest(v) => v.encode(buf)?,
                McpePacketParams::ItemStackResponse(v) => v.encode(buf)?,
                McpePacketParams::LabTable(v) => v.encode(buf)?,
                McpePacketParams::LecternUpdate(v) => v.encode(buf)?,
                McpePacketParams::LevelChunk(v) => v.encode(buf)?,
                McpePacketParams::LevelEvent(v) => v.encode(buf)?,
                McpePacketParams::LevelEventGeneric(v) => v.encode(buf)?,
                McpePacketParams::LevelSoundEvent(v) => v.encode(buf)?,
                McpePacketParams::LevelSoundEventOld(v) => v.encode(buf)?,
                McpePacketParams::LevelSoundEventV2(v) => v.encode(buf)?,
                McpePacketParams::Login(v) => v.encode(buf)?,
                McpePacketParams::MapCreateLockedCopy(v) => v.encode(buf)?,
                McpePacketParams::MapInfoRequest(v) => v.encode(buf)?,
                McpePacketParams::MobArmorEquipment(v) => v.encode(buf)?,
                McpePacketParams::MobEffect(v) => v.encode(buf)?,
                McpePacketParams::MobEquipment(v) => v.encode(buf)?,
                McpePacketParams::ModalFormRequest(v) => v.encode(buf)?,
                McpePacketParams::ModalFormResponse(v) => v.encode(buf)?,
                McpePacketParams::MotionPredictionHints(v) => v.encode(buf)?,
                McpePacketParams::MoveEntity(v) => v.encode(buf)?,
                McpePacketParams::MoveEntityDelta(v) => v.encode(buf)?,
                McpePacketParams::MovePlayer(v) => v.encode(buf)?,
                McpePacketParams::MultiplayerSettings(v) => v.encode(buf)?,
                McpePacketParams::NetworkChunkPublisherUpdate(v) => v.encode(buf)?,
                McpePacketParams::NetworkSettings(v) => v.encode(buf)?,
                McpePacketParams::NetworkStackLatency(v) => v.encode(buf)?,
                McpePacketParams::NpcRequest(v) => v.encode(buf)?,
                McpePacketParams::OnScreenTextureAnimation(v) => v.encode(buf)?,
                McpePacketParams::PacketViolationWarning(v) => v.encode(buf)?,
                McpePacketParams::PhotoTransfer(v) => v.encode(buf)?,
                McpePacketParams::PlaySound(v) => v.encode(buf)?,
                McpePacketParams::PlayStatus(v) => v.encode(buf)?,
                McpePacketParams::PlayerAction(v) => v.encode(buf)?,
                McpePacketParams::PlayerArmorDamage(v) => v.encode(buf)?,
                McpePacketParams::PlayerAuthInput(v) => v.encode(buf)?,
                McpePacketParams::PlayerEnchantOptions(v) => v.encode(buf)?,
                McpePacketParams::PlayerFog(v) => v.encode(buf)?,
                McpePacketParams::PlayerHotbar(v) => v.encode(buf)?,
                McpePacketParams::PlayerInput(v) => v.encode(buf)?,
                McpePacketParams::PlayerList(v) => v.encode(buf)?,
                McpePacketParams::PlayerSkin(v) => v.encode(buf)?,
                McpePacketParams::PositionTrackingDbBroadcast(v) => v.encode(buf)?,
                McpePacketParams::PositionTrackingDbRequest(v) => v.encode(buf)?,
                McpePacketParams::PurchaseReceipt(v) => v.encode(buf)?,
                McpePacketParams::RemoveEcsEntity(v) => v.encode(buf)?,
                McpePacketParams::RemoveEntity(v) => v.encode(buf)?,
                McpePacketParams::RemoveObjective(v) => v.encode(buf)?,
                McpePacketParams::RequestChunkRadius(v) => v.encode(buf)?,
                McpePacketParams::ResourcePackChunkData(v) => v.encode(buf)?,
                McpePacketParams::ResourcePackChunkRequest(v) => v.encode(buf)?,
                McpePacketParams::ResourcePackClientResponse(v) => v.encode(buf)?,
                McpePacketParams::ResourcePackDataInfo(v) => v.encode(buf)?,
                McpePacketParams::ResourcePackStack(v) => v.encode(buf)?,
                McpePacketParams::ResourcePacksInfo(v) => v.encode(buf)?,
                McpePacketParams::Respawn(v) => v.encode(buf)?,
                McpePacketParams::RiderJump(v) => v.encode(buf)?,
                McpePacketParams::ScriptCustomEvent(v) => v.encode(buf)?,
                McpePacketParams::ServerSettingsRequest(v) => v.encode(buf)?,
                McpePacketParams::ServerSettingsResponse(v) => v.encode(buf)?,
                McpePacketParams::ServerToClientHandshake(v) => v.encode(buf)?,
                McpePacketParams::SetCommandsEnabled(v) => v.encode(buf)?,
                McpePacketParams::SetDefaultGameType(v) => v.encode(buf)?,
                McpePacketParams::SetDifficulty(v) => v.encode(buf)?,
                McpePacketParams::SetDisplayObjective(v) => v.encode(buf)?,
                McpePacketParams::SetEntityData(v) => v.encode(buf)?,
                McpePacketParams::SetEntityLink(v) => v.encode(buf)?,
                McpePacketParams::SetEntityMotion(v) => v.encode(buf)?,
                McpePacketParams::SetHealth(v) => v.encode(buf)?,
                McpePacketParams::SetLastHurtBy(v) => v.encode(buf)?,
                McpePacketParams::SetLocalPlayerAsInitialized(v) => v.encode(buf)?,
                McpePacketParams::SetPlayerGameType(v) => v.encode(buf)?,
                McpePacketParams::SetScore(v) => v.encode(buf)?,
                McpePacketParams::SetScoreboardIdentity(v) => v.encode(buf)?,
                McpePacketParams::SetSpawnPosition(v) => v.encode(buf)?,
                McpePacketParams::SetTime(v) => v.encode(buf)?,
                McpePacketParams::SetTitle(v) => v.encode(buf)?,
                McpePacketParams::SettingsCommand(v) => v.encode(buf)?,
                McpePacketParams::ShowCredits(v) => v.encode(buf)?,
                McpePacketParams::ShowProfile(v) => v.encode(buf)?,
                McpePacketParams::ShowStoreOffer(v) => v.encode(buf)?,
                McpePacketParams::SimpleEvent(v) => v.encode(buf)?,
                McpePacketParams::SpawnExperienceOrb(v) => v.encode(buf)?,
                McpePacketParams::SpawnParticleEffect(v) => v.encode(buf)?,
                McpePacketParams::StartGame(v) => v.encode(buf)?,
                McpePacketParams::StopSound(v) => v.encode(buf)?,
                McpePacketParams::StructureBlockUpdate(v) => v.encode(buf)?,
                McpePacketParams::StructureTemplateDataExportRequest(v) => v.encode(buf)?,
                McpePacketParams::StructureTemplateDataExportResponse(v) => {
                    v.encode(buf)?
                }
                McpePacketParams::SubClientLogin(v) => v.encode(buf)?,
                McpePacketParams::TakeItemEntity(v) => v.encode(buf)?,
                McpePacketParams::Text(v) => v.encode(buf)?,
                McpePacketParams::TickSync(v) => v.encode(buf)?,
                McpePacketParams::Transfer(v) => v.encode(buf)?,
                McpePacketParams::UpdateAttributes(v) => v.encode(buf)?,
                McpePacketParams::UpdateBlock(v) => v.encode(buf)?,
                McpePacketParams::UpdateBlockProperties(v) => v.encode(buf)?,
                McpePacketParams::UpdateBlockSynced(v) => v.encode(buf)?,
                McpePacketParams::UpdateEquipment(v) => v.encode(buf)?,
                McpePacketParams::UpdatePlayerGameType(v) => v.encode(buf)?,
                McpePacketParams::UpdateSoftEnum(v) => v.encode(buf)?,
                McpePacketParams::UpdateTrade(v) => v.encode(buf)?,
                McpePacketParams::VideoStreamConnect(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <McpePacketName as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let params = match name {
            _ => {
                Some(
                    McpePacketParams::AddBehaviorTree(
                        <PacketAddBehaviorTree as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AddEcsEntity(
                        <PacketAddEcsEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AddEntity(
                        Box::new(
                            <PacketAddEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AddItemEntity(
                        Box::new(
                            <PacketAddItemEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AddPainting(
                        Box::new(
                            <PacketAddPainting as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AddPlayer(
                        Box::new(
                            <PacketAddPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AdventureSettings(
                        Box::new(
                            <PacketAdventureSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Animate(
                        Box::new(
                            <PacketAnimate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AnimateEntity(
                        Box::new(
                            <PacketAnimateEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AnvilDamage(
                        <PacketAnvilDamage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AvailableCommands(
                        Box::new(
                            <PacketAvailableCommands as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::AvailableEntityIdentifiers(
                        <PacketAvailableEntityIdentifiers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::BiomeDefinitionList(
                        <PacketBiomeDefinitionList as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::BlockEntityData(
                        <PacketBlockEntityData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::BlockEvent(
                        <PacketBlockEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::BlockPickRequest(
                        Box::new(
                            <PacketBlockPickRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::BookEdit(
                        Box::new(
                            <PacketBookEdit as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::BossEvent(
                        Box::new(
                            <PacketBossEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Camera(
                        <PacketCamera as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CameraShake(
                        <PacketCameraShake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ChangeDimension(
                        <PacketChangeDimension as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ChunkRadiusUpdate(
                        <PacketChunkRadiusUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ClientCacheBlobStatus(
                        Box::new(
                            <PacketClientCacheBlobStatus as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ClientCacheMissResponse(
                        <PacketClientCacheMissResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ClientCacheStatus(
                        <PacketClientCacheStatus as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ClientToServerHandshake(
                        <PacketClientToServerHandshake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ClientboundMapItemData(
                        <PacketClientboundMapItemData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CodeBuilder(
                        <PacketCodeBuilder as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CommandBlockUpdate(
                        Box::new(
                            <PacketCommandBlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CommandOutput(
                        Box::new(
                            <PacketCommandOutput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CommandRequest(
                        Box::new(
                            <PacketCommandRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CompletedUsingItem(
                        <PacketCompletedUsingItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ContainerClose(
                        <PacketContainerClose as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ContainerOpen(
                        Box::new(
                            <PacketContainerOpen as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ContainerSetData(
                        <PacketContainerSetData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CorrectPlayerMovePrediction(
                        Box::new(
                            <PacketCorrectPlayerMovePrediction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CraftingData(
                        Box::new(
                            <PacketCraftingData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CraftingEvent(
                        Box::new(
                            <PacketCraftingEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::CreativeContent(
                        <PacketCreativeContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::DebugInfo(
                        <PacketDebugInfo as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Disconnect(
                        <PacketDisconnect as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::EducationSettings(
                        Box::new(
                            <PacketEducationSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Emote(
                        <PacketEmote as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::EmoteList(
                        <PacketEmoteList as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::EntityEvent(
                        <PacketEntityEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::EntityPickRequest(
                        <PacketEntityPickRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Event(
                        Box::new(
                            <PacketEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::FilterTextPacket(
                        <PacketFilterTextPacket as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::GameRulesChanged(
                        <PacketGameRulesChanged as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::GuiDataPickItem(
                        <PacketGuiDataPickItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::HurtArmor(
                        <PacketHurtArmor as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::InitiateWebSocketConnection(
                        <PacketInitiateWebSocketConnection as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Interact(
                        Box::new(
                            <PacketInteract as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::InventoryContent(
                        <PacketInventoryContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::InventorySlot(
                        Box::new(
                            <PacketInventorySlot as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::InventoryTransaction(
                        Box::new(
                            <PacketInventoryTransaction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ItemComponent(
                        <PacketItemComponent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ItemFrameDropItem(
                        <PacketItemFrameDropItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ItemStackRequest(
                        <PacketItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ItemStackResponse(
                        <PacketItemStackResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LabTable(
                        <PacketLabTable as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LecternUpdate(
                        Box::new(
                            <PacketLecternUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LevelChunk(
                        Box::new(
                            <PacketLevelChunk as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LevelEvent(
                        <PacketLevelEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LevelEventGeneric(
                        <PacketLevelEventGeneric as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LevelSoundEvent(
                        Box::new(
                            <PacketLevelSoundEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LevelSoundEventOld(
                        Box::new(
                            <PacketLevelSoundEventOld as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::LevelSoundEventV2(
                        Box::new(
                            <PacketLevelSoundEventV2 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Login(
                        <PacketLogin as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MapCreateLockedCopy(
                        <PacketMapCreateLockedCopy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MapInfoRequest(
                        <PacketMapInfoRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MobArmorEquipment(
                        Box::new(
                            <PacketMobArmorEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MobEffect(
                        Box::new(
                            <PacketMobEffect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MobEquipment(
                        Box::new(
                            <PacketMobEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ModalFormRequest(
                        <PacketModalFormRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ModalFormResponse(
                        <PacketModalFormResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MotionPredictionHints(
                        <PacketMotionPredictionHints as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MoveEntity(
                        Box::new(
                            <PacketMoveEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MoveEntityDelta(
                        Box::new(
                            <PacketMoveEntityDelta as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MovePlayer(
                        Box::new(
                            <PacketMovePlayer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::MultiplayerSettings(
                        <PacketMultiplayerSettings as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::NetworkChunkPublisherUpdate(
                        <PacketNetworkChunkPublisherUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::NetworkSettings(
                        <PacketNetworkSettings as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::NetworkStackLatency(
                        <PacketNetworkStackLatency as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::NpcRequest(
                        Box::new(
                            <PacketNpcRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::OnScreenTextureAnimation(
                        <PacketOnScreenTextureAnimation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PacketViolationWarning(
                        Box::new(
                            <PacketPacketViolationWarning as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PhotoTransfer(
                        <PacketPhotoTransfer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlaySound(
                        Box::new(
                            <PacketPlaySound as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayStatus(
                        <PacketPlayStatus as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerAction(
                        Box::new(
                            <PacketPlayerAction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerArmorDamage(
                        Box::new(
                            <PacketPlayerArmorDamage as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerAuthInput(
                        Box::new(
                            <PacketPlayerAuthInput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerEnchantOptions(
                        <PacketPlayerEnchantOptions as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerFog(
                        <PacketPlayerFog as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerHotbar(
                        <PacketPlayerHotbar as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerInput(
                        Box::new(
                            <PacketPlayerInput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerList(
                        Box::new(
                            <PacketPlayerList as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PlayerSkin(
                        Box::new(
                            <PacketPlayerSkin as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PositionTrackingDbBroadcast(
                        <PacketPositionTrackingDbBroadcast as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PositionTrackingDbRequest(
                        <PacketPositionTrackingDbRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::PurchaseReceipt(
                        <PacketPurchaseReceipt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::RemoveEcsEntity(
                        <PacketRemoveEcsEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::RemoveEntity(
                        <PacketRemoveEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::RemoveObjective(
                        <PacketRemoveObjective as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::RequestChunkRadius(
                        <PacketRequestChunkRadius as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ResourcePackChunkData(
                        Box::new(
                            <PacketResourcePackChunkData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ResourcePackChunkRequest(
                        <PacketResourcePackChunkRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ResourcePackClientResponse(
                        <PacketResourcePackClientResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ResourcePackDataInfo(
                        Box::new(
                            <PacketResourcePackDataInfo as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ResourcePackStack(
                        Box::new(
                            <PacketResourcePackStack as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ResourcePacksInfo(
                        Box::new(
                            <PacketResourcePacksInfo as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Respawn(
                        Box::new(
                            <PacketRespawn as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::RiderJump(
                        <PacketRiderJump as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ScriptCustomEvent(
                        <PacketScriptCustomEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ServerSettingsRequest(
                        <PacketServerSettingsRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ServerSettingsResponse(
                        <PacketServerSettingsResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ServerToClientHandshake(
                        <PacketServerToClientHandshake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetCommandsEnabled(
                        <PacketSetCommandsEnabled as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetDefaultGameType(
                        <PacketSetDefaultGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetDifficulty(
                        <PacketSetDifficulty as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetDisplayObjective(
                        Box::new(
                            <PacketSetDisplayObjective as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetEntityData(
                        <PacketSetEntityData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetEntityLink(
                        Box::new(
                            <PacketSetEntityLink as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetEntityMotion(
                        <PacketSetEntityMotion as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetHealth(
                        <PacketSetHealth as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetLastHurtBy(
                        <PacketSetLastHurtBy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetLocalPlayerAsInitialized(
                        <PacketSetLocalPlayerAsInitialized as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetPlayerGameType(
                        <PacketSetPlayerGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetScore(
                        <PacketSetScore as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetScoreboardIdentity(
                        <PacketSetScoreboardIdentity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetSpawnPosition(
                        Box::new(
                            <PacketSetSpawnPosition as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetTime(
                        <PacketSetTime as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SetTitle(
                        Box::new(
                            <PacketSetTitle as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SettingsCommand(
                        <PacketSettingsCommand as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ShowCredits(
                        <PacketShowCredits as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ShowProfile(
                        <PacketShowProfile as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::ShowStoreOffer(
                        <PacketShowStoreOffer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SimpleEvent(
                        <PacketSimpleEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SpawnExperienceOrb(
                        <PacketSpawnExperienceOrb as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SpawnParticleEffect(
                        Box::new(
                            <PacketSpawnParticleEffect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::StartGame(
                        Box::new(
                            <PacketStartGame as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::StopSound(
                        <PacketStopSound as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::StructureBlockUpdate(
                        <PacketStructureBlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::StructureTemplateDataExportRequest(
                        <PacketStructureTemplateDataExportRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::StructureTemplateDataExportResponse(
                        <PacketStructureTemplateDataExportResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::SubClientLogin(
                        <PacketSubClientLogin as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::TakeItemEntity(
                        <PacketTakeItemEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Text(
                        Box::new(
                            <PacketText as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::TickSync(
                        <PacketTickSync as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::Transfer(
                        <PacketTransfer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdateAttributes(
                        <PacketUpdateAttributes as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdateBlock(
                        Box::new(
                            <PacketUpdateBlock as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdateBlockProperties(
                        <PacketUpdateBlockProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdateBlockSynced(
                        Box::new(
                            <PacketUpdateBlockSynced as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdateEquipment(
                        Box::new(
                            <PacketUpdateEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdatePlayerGameType(
                        <PacketUpdatePlayerGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdateSoftEnum(
                        <PacketUpdateSoftEnum as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::UpdateTrade(
                        Box::new(
                            <PacketUpdateTrade as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    McpePacketParams::VideoStreamConnect(
                        Box::new(
                            <PacketVideoStreamConnect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { name, params })
    }
}
