// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use super::*;
use bitflags::bitflags;
pub type CommandFlags = u8;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CommandOriginType {
    Player = 0,
    Block = 1,
    MinecartBlock = 2,
    DevConsole = 3,
    Test = 4,
    AutomationPlayer = 5,
    ClientAutomation = 6,
    DedicatedServer = 7,
    Entity = 8,
    Virtual = 9,
    GameArgument = 10,
    EntityServer = 11,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(CommandOriginType::Player),
            1 => Ok(CommandOriginType::Block),
            2 => Ok(CommandOriginType::MinecartBlock),
            3 => Ok(CommandOriginType::DevConsole),
            4 => Ok(CommandOriginType::Test),
            5 => Ok(CommandOriginType::AutomationPlayer),
            6 => Ok(CommandOriginType::ClientAutomation),
            7 => Ok(CommandOriginType::DedicatedServer),
            8 => Ok(CommandOriginType::Entity),
            9 => Ok(CommandOriginType::Virtual),
            10 => Ok(CommandOriginType::GameArgument),
            11 => Ok(CommandOriginType::EntityServer),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "Invalid enum value for {}: {}",
                    stringify!(CommandOriginType),
                    val
                ),
            )),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOrigin {
    pub type_: CommandOriginType,
    pub uuid: uuid::Uuid,
    pub request_id: String,
    pub player_entity_id: Option<CommandOriginPlayerEntityID>,
}
impl crate::bedrock::codec::BedrockCodec for CommandOrigin {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.uuid.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.player_entity_id {
            match v {
                CommandOriginPlayerEntityID::DevConsole(v) => v.encode(buf)?,
                CommandOriginPlayerEntityID::Test(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <CommandOriginType as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let request_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_entity_id = match type_ {
            _ => {
                Some(
                    CommandOriginPlayerEntityID::DevConsole(
                        <CommandOriginPlayerEntityIDDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    CommandOriginPlayerEntityID::Test(
                        <CommandOriginPlayerEntityIDDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            uuid,
            request_id,
            player_entity_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameMode {
    Survival = 0,
    Creative = 1,
    Adventure = 2,
    SurvivalSpectator = 3,
    CreativeSpectator = 4,
    Fallback = 5,
}
impl crate::bedrock::codec::BedrockCodec for GameMode {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(GameMode::Survival),
            1 => Ok(GameMode::Creative),
            2 => Ok(GameMode::Adventure),
            3 => Ok(GameMode::SurvivalSpectator),
            4 => Ok(GameMode::CreativeSpectator),
            5 => Ok(GameMode::Fallback),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("Invalid enum value for {}: {}", stringify!(GameMode), val),
            )),
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameRuleType {
    Bool = 1,
    Int = 2,
    Float = 3,
}
impl crate::bedrock::codec::BedrockCodec for GameRuleType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(GameRuleType::Bool),
            2 => Ok(GameRuleType::Int),
            3 => Ok(GameRuleType::Float),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "Invalid enum value for {}: {}",
                    stringify!(GameRuleType),
                    val
                ),
            )),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum GameRuleValue {
    Bool(bool),
    Float(f32),
    Int(crate::bedrock::codec::ZigZag32),
}
#[derive(Debug, Clone, PartialEq)]
pub struct GameRule {
    pub name: String,
    pub type_: GameRuleType,
    pub value: Option<GameRuleValue>,
}
impl crate::bedrock::codec::BedrockCodec for GameRule {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                GameRuleValue::Bool(v) => v.encode(buf)?,
                GameRuleValue::Float(v) => v.encode(buf)?,
                GameRuleValue::Int(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let type_ = <GameRuleType as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let value = match type_ {
            _ => Some(GameRuleValue::Bool(
                <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
            )),
            _ => Some(GameRuleValue::Float(
                <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
            )),
            _ => Some(GameRuleValue::Int(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                )?,
            )),
            _ => None,
        };
        Ok(Self { name, type_, value })
    }
}
pub type GameRules = Vec<GameRule>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketAdventureSettingsCommandPermission {
    Normal = 0,
    Operator = 1,
    Host = 2,
    Automation = 3,
    Admin = 4,
}
impl crate::bedrock::codec::BedrockCodec for PacketAdventureSettingsCommandPermission {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketAdventureSettingsCommandPermission::Normal),
            1 => Ok(PacketAdventureSettingsCommandPermission::Operator),
            2 => Ok(PacketAdventureSettingsCommandPermission::Host),
            3 => Ok(PacketAdventureSettingsCommandPermission::Automation),
            4 => Ok(PacketAdventureSettingsCommandPermission::Admin),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "Invalid enum value for {}: {}",
                    stringify!(PacketAdventureSettingsCommandPermission),
                    val
                ),
            )),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAdventureSettings {
    pub flags: AdventureFlags,
    pub command_permission: PacketAdventureSettingsCommandPermission,
    pub action_permissions: ActionPermissions,
    pub permission_level: PacketAdventureSettingsPermissionLevel,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketAdventureSettings {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.custom_stored_permissions.encode(buf)?;
        self.user_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let flags = <AdventureFlags as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let command_permission = <PacketAdventureSettingsCommandPermission as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action_permissions =
            <ActionPermissions as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let permission_level = <PacketAdventureSettingsPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let custom_stored_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommands {
    pub values_len: i32,
    pub enum_type: i32,
    pub enum_values: Vec<String>,
    pub suffixes: Vec<String>,
    pub enums: Vec<PacketAvailableCommandsEnumsItem>,
    pub command_data: Vec<PacketAvailableCommandsCommandDataItem>,
    pub dynamic_enums: Vec<PacketAvailableCommandsDynamicEnumsItem>,
    pub enum_constraints: Vec<PacketAvailableCommandsEnumConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommands {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.values_len.encode(buf)?;
        self.enum_type.encode(buf)?;
        let len = self.enum_values.len() as i32;
        len.encode(buf)?;
        for item in &self.enum_values {
            item.encode(buf)?;
        }
        let len = self.suffixes.len() as i32;
        len.encode(buf)?;
        for item in &self.suffixes {
            item.encode(buf)?;
        }
        let len = self.enums.len() as i32;
        len.encode(buf)?;
        for item in &self.enums {
            item.encode(buf)?;
        }
        let len = self.command_data.len() as i32;
        len.encode(buf)?;
        for item in &self.command_data {
            item.encode(buf)?;
        }
        let len = self.dynamic_enums.len() as i32;
        len.encode(buf)?;
        for item in &self.dynamic_enums {
            item.encode(buf)?;
        }
        let len = self.enum_constraints.len() as i32;
        len.encode(buf)?;
        for item in &self.enum_constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let values_len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enum_type = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enum_values = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<String as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                )?);
            }
            tmp_vec
        };
        let suffixes = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<String as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                )?);
            }
            tmp_vec
        };
        let enums = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let command_data = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let dynamic_enums = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsDynamicEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let enum_constraints = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            values_len,
            enum_type,
            enum_values,
            suffixes,
            enums,
            command_data,
            dynamic_enums,
            enum_constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandOutput {
    pub origin: CommandOrigin,
    pub output_type: i8,
    pub success_count: i32,
    pub output: Vec<PacketCommandOutputOutputItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandOutput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.origin.encode(buf)?;
        self.output_type.encode(buf)?;
        self.success_count.encode(buf)?;
        let len = self.output.len() as i32;
        len.encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let output_type = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let success_count = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let output = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)? as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <PacketCommandOutputOutputItem as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                );
            }
            tmp_vec
        };
        Ok(Self {
            origin,
            output_type,
            success_count,
            output,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCommandRequest {
    pub command: String,
    pub origin: CommandOrigin,
    pub internal: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketCommandRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.command.encode(buf)?;
        self.origin.encode(buf)?;
        self.internal.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let internal = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            command,
            origin,
            internal,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketEducationSettings {
    pub codebuilderdefaulturi: String,
    pub codebuildertitle: String,
    pub canresizecodebuilder: bool,
    pub hasoverrideuri: bool,
    pub overrideuri: Option<String>,
    pub hasquiz: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketEducationSettings {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.codebuilderdefaulturi.encode(buf)?;
        self.codebuildertitle.encode(buf)?;
        self.canresizecodebuilder.encode(buf)?;
        self.hasoverrideuri.encode(buf)?;
        if let Some(v) = &self.overrideuri {
            v.encode(buf)?;
        }
        self.hasquiz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let codebuilderdefaulturi = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let codebuildertitle = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let canresizecodebuilder = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hasoverrideuri = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let overrideuri = match hasoverrideuri {
            true => Some(<String as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
            )?),
            _ => None,
        };
        let hasquiz = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            codebuilderdefaulturi,
            codebuildertitle,
            canresizecodebuilder,
            hasoverrideuri,
            overrideuri,
            hasquiz,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketGameRulesChanged {
    pub rules: GameRules,
}
impl crate::bedrock::codec::BedrockCodec for PacketGameRulesChanged {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.rules.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let rules = <GameRules as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { rules })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkSettings {
    pub compression_threshold: u16,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkSettings {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.compression_threshold.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let compression_threshold = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            compression_threshold,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerSettingsRequest {}
impl crate::bedrock::codec::BedrockCodec for PacketServerSettingsRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketServerSettingsResponse {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketServerSettingsResponse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.form_id.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let form_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetCommandsEnabled {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetCommandsEnabled {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetDefaultGameType {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetDefaultGameType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSettingsCommand {
    pub command_line: String,
    pub suppress_output: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketSettingsCommand {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.command_line.encode(buf)?;
        self.suppress_output.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let command_line = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let suppress_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            command_line,
            suppress_output,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStartGame {
    pub entity_id: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub player_gamemode: GameMode,
    pub spawn: Vec3F,
    pub rotation: Vec2F,
    pub seed: crate::bedrock::codec::ZigZag32,
    pub biome_type: i16,
    pub biome_name: String,
    pub dimension: crate::bedrock::codec::ZigZag32,
    pub generator: crate::bedrock::codec::ZigZag32,
    pub world_gamemode: GameMode,
    pub difficulty: crate::bedrock::codec::ZigZag32,
    pub spawn_position: BlockCoordinates,
    pub achievements_disabled: bool,
    pub day_cycle_stop_time: crate::bedrock::codec::ZigZag32,
    pub edu_offer: crate::bedrock::codec::ZigZag32,
    pub edu_features_enabled: bool,
    pub edu_product_uuid: String,
    pub rain_level: f32,
    pub lightning_level: f32,
    pub has_confirmed_platform_locked_content: bool,
    pub is_multiplayer: bool,
    pub broadcast_to_lan: bool,
    pub xbox_live_broadcast_mode: i32,
    pub platform_broadcast_mode: i32,
    pub enable_commands: bool,
    pub is_texturepacks_required: bool,
    pub gamerules: GameRules,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
    pub bonus_chest: bool,
    pub map_enabled: bool,
    pub permission_level: crate::bedrock::codec::ZigZag32,
    pub server_chunk_tick_range: i32,
    pub has_locked_behavior_pack: bool,
    pub has_locked_resource_pack: bool,
    pub is_from_locked_world_template: bool,
    pub msa_gamertags_only: bool,
    pub is_from_world_template: bool,
    pub is_world_template_option_locked: bool,
    pub only_spawn_v1_villagers: bool,
    pub game_version: String,
    pub limited_world_width: i32,
    pub limited_world_length: i32,
    pub is_new_nether: bool,
    pub experimental_gameplay_override: bool,
    pub level_id: String,
    pub world_name: String,
    pub premium_world_template_id: String,
    pub is_trial: bool,
    pub movement_authority: PacketStartGameMovementAuthority,
    pub current_tick: i64,
    pub enchantment_seed: crate::bedrock::codec::ZigZag32,
    pub block_palette: BlockPalette,
    pub itemstates: Itemstates,
    pub multiplayer_correlation_id: String,
    pub server_authoritative_inventory: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStartGame {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.player_gamemode.encode(buf)?;
        self.spawn.encode(buf)?;
        self.rotation.encode(buf)?;
        self.seed.encode(buf)?;
        self.biome_type.encode(buf)?;
        self.biome_name.encode(buf)?;
        self.dimension.encode(buf)?;
        self.generator.encode(buf)?;
        self.world_gamemode.encode(buf)?;
        self.difficulty.encode(buf)?;
        self.spawn_position.encode(buf)?;
        self.achievements_disabled.encode(buf)?;
        self.day_cycle_stop_time.encode(buf)?;
        self.edu_offer.encode(buf)?;
        self.edu_features_enabled.encode(buf)?;
        self.edu_product_uuid.encode(buf)?;
        self.rain_level.encode(buf)?;
        self.lightning_level.encode(buf)?;
        self.has_confirmed_platform_locked_content.encode(buf)?;
        self.is_multiplayer.encode(buf)?;
        self.broadcast_to_lan.encode(buf)?;
        self.xbox_live_broadcast_mode.encode(buf)?;
        self.platform_broadcast_mode.encode(buf)?;
        self.enable_commands.encode(buf)?;
        self.is_texturepacks_required.encode(buf)?;
        self.gamerules.encode(buf)?;
        self.experiments.encode(buf)?;
        self.experiments_previously_used.encode(buf)?;
        self.bonus_chest.encode(buf)?;
        self.map_enabled.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.server_chunk_tick_range.encode(buf)?;
        self.has_locked_behavior_pack.encode(buf)?;
        self.has_locked_resource_pack.encode(buf)?;
        self.is_from_locked_world_template.encode(buf)?;
        self.msa_gamertags_only.encode(buf)?;
        self.is_from_world_template.encode(buf)?;
        self.is_world_template_option_locked.encode(buf)?;
        self.only_spawn_v1_villagers.encode(buf)?;
        self.game_version.encode(buf)?;
        self.limited_world_width.encode(buf)?;
        self.limited_world_length.encode(buf)?;
        self.is_new_nether.encode(buf)?;
        self.experimental_gameplay_override.encode(buf)?;
        self.level_id.encode(buf)?;
        self.world_name.encode(buf)?;
        self.premium_world_template_id.encode(buf)?;
        self.is_trial.encode(buf)?;
        self.movement_authority.encode(buf)?;
        self.current_tick.encode(buf)?;
        self.enchantment_seed.encode(buf)?;
        self.block_palette.encode(buf)?;
        self.itemstates.encode(buf)?;
        self.multiplayer_correlation_id.encode(buf)?;
        self.server_authoritative_inventory.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let spawn = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let seed =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let biome_type = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let biome_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dimension =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let generator =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let world_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let difficulty =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let spawn_position =
            <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let achievements_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let day_cycle_stop_time =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let edu_offer =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let edu_features_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let edu_product_uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rain_level = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let lightning_level = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let has_confirmed_platform_locked_content =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_multiplayer = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let broadcast_to_lan = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let xbox_live_broadcast_mode = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let platform_broadcast_mode = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enable_commands = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_texturepacks_required = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let gamerules = <GameRules as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let experiments = <Experiments as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let experiments_previously_used =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let bonus_chest = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let map_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let permission_level =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let server_chunk_tick_range = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let has_locked_behavior_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let has_locked_resource_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_from_locked_world_template =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let msa_gamertags_only = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_from_world_template = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_world_template_option_locked =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let only_spawn_v1_villagers = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let game_version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let limited_world_width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let limited_world_length = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_new_nether = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let experimental_gameplay_override =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let level_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let world_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let premium_world_template_id =
            <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_trial = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let movement_authority =
            <PacketStartGameMovementAuthority as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let current_tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enchantment_seed =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_palette = <BlockPalette as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let itemstates = <Itemstates as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let multiplayer_correlation_id =
            <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let server_authoritative_inventory =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_id,
            runtime_entity_id,
            player_gamemode,
            spawn,
            rotation,
            seed,
            biome_type,
            biome_name,
            dimension,
            generator,
            world_gamemode,
            difficulty,
            spawn_position,
            achievements_disabled,
            day_cycle_stop_time,
            edu_offer,
            edu_features_enabled,
            edu_product_uuid,
            rain_level,
            lightning_level,
            has_confirmed_platform_locked_content,
            is_multiplayer,
            broadcast_to_lan,
            xbox_live_broadcast_mode,
            platform_broadcast_mode,
            enable_commands,
            is_texturepacks_required,
            gamerules,
            experiments,
            experiments_previously_used,
            bonus_chest,
            map_enabled,
            permission_level,
            server_chunk_tick_range,
            has_locked_behavior_pack,
            has_locked_resource_pack,
            is_from_locked_world_template,
            msa_gamertags_only,
            is_from_world_template,
            is_world_template_option_locked,
            only_spawn_v1_villagers,
            game_version,
            limited_world_width,
            limited_world_length,
            is_new_nether,
            experimental_gameplay_override,
            level_id,
            world_name,
            premium_world_template_id,
            is_trial,
            movement_authority,
            current_tick,
            enchantment_seed,
            block_palette,
            itemstates,
            multiplayer_correlation_id,
            server_authoritative_inventory,
        })
    }
}
