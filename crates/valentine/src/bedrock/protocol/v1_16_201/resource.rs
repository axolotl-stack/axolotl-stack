// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct SkinImage {
    pub width: i32,
    pub height: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for SkinImage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let height = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { width, height, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinAnimationsItem {
    pub skin_image: SkinImage,
    pub animation_type: i32,
    pub animation_frames: f32,
    pub expression_type: f32,
}
impl crate::bedrock::codec::BedrockCodec for SkinAnimationsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.skin_image.encode(buf)?;
        self.animation_type.encode(buf)?;
        self.animation_frames.encode(buf)?;
        self.expression_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let skin_image = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let animation_type = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let animation_frames = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let expression_type = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            skin_image,
            animation_type,
            animation_frames,
            expression_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPersonalPiecesItem {
    pub piece_id: String,
    pub piece_type: String,
    pub pack_id: String,
    pub is_default_piece: bool,
    pub product_id: String,
}
impl crate::bedrock::codec::BedrockCodec for SkinPersonalPiecesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.piece_id.encode(buf)?;
        self.piece_type.encode(buf)?;
        self.pack_id.encode(buf)?;
        self.is_default_piece.encode(buf)?;
        self.product_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let piece_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_default_piece = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let product_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            piece_id,
            piece_type,
            pack_id,
            is_default_piece,
            product_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPieceTintColorsItem {
    pub piece_type: String,
    pub colors: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for SkinPieceTintColorsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.piece_type.encode(buf)?;
        let len = self.colors.len() as i32;
        len.encode(buf)?;
        for item in &self.colors {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self { piece_type, colors })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Skin {
    pub skin_id: String,
    pub skin_resource_pack: String,
    pub skin_data: SkinImage,
    pub animations: Vec<SkinAnimationsItem>,
    pub cape_data: SkinImage,
    pub geometry_data: String,
    pub animation_data: String,
    pub premium: String,
    pub persona: bool,
    pub cape_on_classic: bool,
    pub cape_id: String,
    pub full_skin_id: String,
    pub arm_size: String,
    pub skin_color: String,
    pub personal_pieces: Vec<SkinPersonalPiecesItem>,
    pub piece_tint_colors: Vec<SkinPieceTintColorsItem>,
}
impl crate::bedrock::codec::BedrockCodec for Skin {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.skin_id.encode(buf)?;
        self.skin_resource_pack.encode(buf)?;
        self.skin_data.encode(buf)?;
        let len = self.animations.len() as i32;
        len.encode(buf)?;
        for item in &self.animations {
            item.encode(buf)?;
        }
        self.cape_data.encode(buf)?;
        self.geometry_data.encode(buf)?;
        self.animation_data.encode(buf)?;
        self.premium.encode(buf)?;
        self.persona.encode(buf)?;
        self.cape_on_classic.encode(buf)?;
        self.cape_id.encode(buf)?;
        self.full_skin_id.encode(buf)?;
        self.arm_size.encode(buf)?;
        self.skin_color.encode(buf)?;
        let len = self.personal_pieces.len() as i32;
        len.encode(buf)?;
        for item in &self.personal_pieces {
            item.encode(buf)?;
        }
        let len = self.piece_tint_colors.len() as i32;
        len.encode(buf)?;
        for item in &self.piece_tint_colors {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_resource_pack = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let skin_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let animations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinAnimationsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let cape_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let geometry_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let animation_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let premium = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let persona = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let cape_on_classic = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let cape_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let full_skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let arm_size = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_color = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let personal_pieces = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPersonalPiecesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let piece_tint_colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPieceTintColorsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            skin_id,
            skin_resource_pack,
            skin_data,
            animations,
            cape_data,
            geometry_data,
            animation_data,
            premium,
            persona,
            cape_on_classic,
            cape_id,
            full_skin_id,
            arm_size,
            skin_color,
            personal_pieces,
            piece_tint_colors,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ResourcePackIDVersionsItem {
    pub uuid: String,
    pub version: String,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackIDVersionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { uuid, version, name })
    }
}
pub type ResourcePackIDVersions = Vec<ResourcePackIDVersionsItem>;
pub type ResourcePackIds = Vec<String>;
#[derive(Debug, Clone, PartialEq)]
pub struct TexturePackInfosItem {
    pub uuid: String,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
    pub rtx_enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for TexturePackInfosItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.size.encode(buf)?;
        self.content_key.encode(buf)?;
        self.sub_pack_name.encode(buf)?;
        self.content_identity.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.rtx_enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content_key = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let sub_pack_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content_identity = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let rtx_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
            rtx_enabled,
        })
    }
}
pub type TexturePackInfos = Vec<TexturePackInfosItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentTexture {
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentTexture {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.color.encode(buf)?;
        self.overlay.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let color = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let overlay = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { color, overlay })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketOnScreenTextureAnimation {}
impl crate::bedrock::codec::BedrockCodec for PacketOnScreenTextureAnimation {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerSkin {
    pub uuid: uuid::Uuid,
    pub skin: Skin,
    pub skin_name: String,
    pub old_skin_name: String,
    pub is_verified: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerSkin {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.skin.encode(buf)?;
        self.skin_name.encode(buf)?;
        self.old_skin_name.encode(buf)?;
        self.is_verified.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let old_skin_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let is_verified = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            skin,
            skin_name,
            old_skin_name,
            is_verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkData {
    pub package_id: String,
    pub chunk_index: u32,
    pub progress: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.package_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        self.progress.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let package_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let progress = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            package_id,
            chunk_index,
            progress,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkRequest {
    pub package_id: String,
    pub chunk_index: u32,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.package_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let package_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { package_id, chunk_index })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketResourcePackClientResponseResponseStatus {
    None = 0,
    Refused = 1,
    SendPacks = 2,
    HaveAllPacks = 3,
    Completed = 4,
}
impl crate::bedrock::codec::BedrockCodec
for PacketResourcePackClientResponseResponseStatus {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketResourcePackClientResponseResponseStatus::None),
            1 => Ok(PacketResourcePackClientResponseResponseStatus::Refused),
            2 => Ok(PacketResourcePackClientResponseResponseStatus::SendPacks),
            3 => Ok(PacketResourcePackClientResponseResponseStatus::HaveAllPacks),
            4 => Ok(PacketResourcePackClientResponseResponseStatus::Completed),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketResourcePackClientResponseResponseStatus),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackClientResponse {
    pub response_status: PacketResourcePackClientResponseResponseStatus,
    pub resourcepackids: ResourcePackIds,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackClientResponse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.response_status.encode(buf)?;
        self.resourcepackids.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let response_status = <PacketResourcePackClientResponseResponseStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let resourcepackids = <ResourcePackIds as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            response_status,
            resourcepackids,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackDataInfo {
    pub package_id: String,
    pub max_chunk_size: u32,
    pub chunk_count: u32,
    pub compressed_package_size: u64,
    pub hash: ByteArray,
    pub is_premium: bool,
    pub pack_type: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackDataInfo {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.package_id.encode(buf)?;
        self.max_chunk_size.encode(buf)?;
        self.chunk_count.encode(buf)?;
        self.compressed_package_size.encode(buf)?;
        self.hash.encode(buf)?;
        self.is_premium.encode(buf)?;
        self.pack_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let package_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let max_chunk_size = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chunk_count = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let compressed_package_size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let hash = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pack_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            package_id,
            max_chunk_size,
            chunk_count,
            compressed_package_size,
            hash,
            is_premium,
            pack_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackStack {
    pub must_accept: bool,
    pub behavior_packs: ResourcePackIDVersions,
    pub resource_packs: ResourcePackIDVersions,
    pub game_version: String,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackStack {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.must_accept.encode(buf)?;
        self.behavior_packs.encode(buf)?;
        self.resource_packs.encode(buf)?;
        self.game_version.encode(buf)?;
        self.experiments.encode(buf)?;
        self.experiments_previously_used.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let behavior_packs = <ResourcePackIDVersions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let resource_packs = <ResourcePackIDVersions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let game_version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let experiments = <Experiments as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let experiments_previously_used = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            must_accept,
            behavior_packs,
            resource_packs,
            game_version,
            experiments,
            experiments_previously_used,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePacksInfo {
    pub must_accept: bool,
    pub has_scripts: bool,
    pub behaviour_packs: BehaviourPackInfos,
    pub texture_packs: TexturePackInfos,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePacksInfo {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.must_accept.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.behaviour_packs.encode(buf)?;
        self.texture_packs.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let behaviour_packs = <BehaviourPackInfos as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let texture_packs = <TexturePackInfos as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            must_accept,
            has_scripts,
            behaviour_packs,
            texture_packs,
        })
    }
}
