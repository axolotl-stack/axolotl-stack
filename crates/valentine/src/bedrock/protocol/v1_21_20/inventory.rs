// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct BehaviourPackInfosItem {
    pub uuid: String,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
    pub addon_pack: bool,
}
impl crate::bedrock::codec::BedrockCodec for BehaviourPackInfosItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.size.encode(buf)?;
        self.content_key.encode(buf)?;
        self.sub_pack_name.encode(buf)?;
        self.content_identity.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.addon_pack.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let content_key = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let sub_pack_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content_identity = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let addon_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
            addon_pack,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ContainerSlotType {
    AnvilInput = 0,
    AnvilMaterial = 1,
    AnvilResult = 2,
    SmithingTableInput = 3,
    SmithingTableMaterial = 4,
    SmithingTableResult = 5,
    Armor = 6,
    Container = 7,
    BeaconPayment = 8,
    BrewingInput = 9,
    BrewingResult = 10,
    BrewingFuel = 11,
    HotbarAndInventory = 12,
    CraftingInput = 13,
    CraftingOutput = 14,
    RecipeConstruction = 15,
    RecipeNature = 16,
    RecipeItems = 17,
    RecipeSearch = 18,
    RecipeSearchBar = 19,
    RecipeEquipment = 20,
    RecipeBook = 21,
    EnchantingInput = 22,
    EnchantingLapis = 23,
    FurnaceFuel = 24,
    FurnaceIngredient = 25,
    FurnaceOutput = 26,
    HorseEquip = 27,
    Hotbar = 28,
    Inventory = 29,
    Shulker = 30,
    TradeIngredient1 = 31,
    TradeIngredient2 = 32,
    TradeResult = 33,
    Offhand = 34,
    CompcreateInput = 35,
    CompcreateOutput = 36,
    ElemconstructOutput = 37,
    MatreduceInput = 38,
    MatreduceOutput = 39,
    LabtableInput = 40,
    LoomInput = 41,
    LoomDye = 42,
    LoomMaterial = 43,
    LoomResult = 44,
    BlastFurnaceIngredient = 45,
    SmokerIngredient = 46,
    Trade2Ingredient1 = 47,
    Trade2Ingredient2 = 48,
    Trade2Result = 49,
    GrindstoneInput = 50,
    GrindstoneAdditional = 51,
    GrindstoneResult = 52,
    StonecutterInput = 53,
    StonecutterResult = 54,
    CartographyInput = 55,
    CartographyAdditional = 56,
    CartographyResult = 57,
    Barrel = 58,
    Cursor = 59,
    CreativeOutput = 60,
    SmithingTableTemplate = 61,
    Crafter = 62,
    Dynamic = 63,
}
impl crate::bedrock::codec::BedrockCodec for ContainerSlotType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ContainerSlotType::AnvilInput),
            1 => Ok(ContainerSlotType::AnvilMaterial),
            2 => Ok(ContainerSlotType::AnvilResult),
            3 => Ok(ContainerSlotType::SmithingTableInput),
            4 => Ok(ContainerSlotType::SmithingTableMaterial),
            5 => Ok(ContainerSlotType::SmithingTableResult),
            6 => Ok(ContainerSlotType::Armor),
            7 => Ok(ContainerSlotType::Container),
            8 => Ok(ContainerSlotType::BeaconPayment),
            9 => Ok(ContainerSlotType::BrewingInput),
            10 => Ok(ContainerSlotType::BrewingResult),
            11 => Ok(ContainerSlotType::BrewingFuel),
            12 => Ok(ContainerSlotType::HotbarAndInventory),
            13 => Ok(ContainerSlotType::CraftingInput),
            14 => Ok(ContainerSlotType::CraftingOutput),
            15 => Ok(ContainerSlotType::RecipeConstruction),
            16 => Ok(ContainerSlotType::RecipeNature),
            17 => Ok(ContainerSlotType::RecipeItems),
            18 => Ok(ContainerSlotType::RecipeSearch),
            19 => Ok(ContainerSlotType::RecipeSearchBar),
            20 => Ok(ContainerSlotType::RecipeEquipment),
            21 => Ok(ContainerSlotType::RecipeBook),
            22 => Ok(ContainerSlotType::EnchantingInput),
            23 => Ok(ContainerSlotType::EnchantingLapis),
            24 => Ok(ContainerSlotType::FurnaceFuel),
            25 => Ok(ContainerSlotType::FurnaceIngredient),
            26 => Ok(ContainerSlotType::FurnaceOutput),
            27 => Ok(ContainerSlotType::HorseEquip),
            28 => Ok(ContainerSlotType::Hotbar),
            29 => Ok(ContainerSlotType::Inventory),
            30 => Ok(ContainerSlotType::Shulker),
            31 => Ok(ContainerSlotType::TradeIngredient1),
            32 => Ok(ContainerSlotType::TradeIngredient2),
            33 => Ok(ContainerSlotType::TradeResult),
            34 => Ok(ContainerSlotType::Offhand),
            35 => Ok(ContainerSlotType::CompcreateInput),
            36 => Ok(ContainerSlotType::CompcreateOutput),
            37 => Ok(ContainerSlotType::ElemconstructOutput),
            38 => Ok(ContainerSlotType::MatreduceInput),
            39 => Ok(ContainerSlotType::MatreduceOutput),
            40 => Ok(ContainerSlotType::LabtableInput),
            41 => Ok(ContainerSlotType::LoomInput),
            42 => Ok(ContainerSlotType::LoomDye),
            43 => Ok(ContainerSlotType::LoomMaterial),
            44 => Ok(ContainerSlotType::LoomResult),
            45 => Ok(ContainerSlotType::BlastFurnaceIngredient),
            46 => Ok(ContainerSlotType::SmokerIngredient),
            47 => Ok(ContainerSlotType::Trade2Ingredient1),
            48 => Ok(ContainerSlotType::Trade2Ingredient2),
            49 => Ok(ContainerSlotType::Trade2Result),
            50 => Ok(ContainerSlotType::GrindstoneInput),
            51 => Ok(ContainerSlotType::GrindstoneAdditional),
            52 => Ok(ContainerSlotType::GrindstoneResult),
            53 => Ok(ContainerSlotType::StonecutterInput),
            54 => Ok(ContainerSlotType::StonecutterResult),
            55 => Ok(ContainerSlotType::CartographyInput),
            56 => Ok(ContainerSlotType::CartographyAdditional),
            57 => Ok(ContainerSlotType::CartographyResult),
            58 => Ok(ContainerSlotType::Barrel),
            59 => Ok(ContainerSlotType::Cursor),
            60 => Ok(ContainerSlotType::CreativeOutput),
            61 => Ok(ContainerSlotType::SmithingTableTemplate),
            62 => Ok(ContainerSlotType::Crafter),
            63 => Ok(ContainerSlotType::Dynamic),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ContainerSlotType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct FullContainerName {
    pub container_id: ContainerSlotType,
    pub dynamic_container_id: u32,
}
impl crate::bedrock::codec::BedrockCodec for FullContainerName {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        self.dynamic_container_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let container_id = <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dynamic_container_id = <u32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            container_id,
            dynamic_container_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentOptional {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
    pub filtered_string_index: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentOptional {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_network_id.encode(buf)?;
        self.times_crafted.encode(buf)?;
        self.filtered_string_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let filtered_string_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
            filtered_string_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftGrindstoneRequest(ItemStackRequestActionsItemContentCraftGrindstoneRequest),
    CraftLoomRequest(ItemStackRequestActionsItemContentCraftLoomRequest),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(Box<ItemStackRequestActionsItemContentCraftRecipeAuto>),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    PlaceInContainer(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
    TakeOutContainer(ItemStackRequestActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeID,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Consume(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftCreative(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftGrindstoneRequest(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::CraftLoomRequest(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipe(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Create(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Destroy(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Drop(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::MineBlock(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Place(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::PlaceInContainer(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::Swap(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Take(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::TakeOutContainer(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestActionsItemTypeID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_id {
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftGrindstoneRequest(
                        <ItemStackRequestActionsItemContentCraftGrindstoneRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftLoomRequest(
                        <ItemStackRequestActionsItemContentCraftLoomRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        Box::new(
                            <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => Some(ItemStackRequestActionsItemContent::NonImplemented),
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::PlaceInContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    ItemStackRequestActionsItemContent::TakeOutContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequest {
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
    pub cause: ItemStackRequestCause,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        let len = self.actions.len() as i32;
        len.encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len() as i32;
        len.encode(buf)?;
        for item in &self.custom_names {
            item.encode(buf)?;
        }
        self.cause.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let cause = <ItemStackRequestCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            request_id,
            actions,
            custom_names,
            cause,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSomeContainersItem {
    pub slot_type: FullContainerName,
    pub slots: Vec<ItemStackResponsesItemContentSomeContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentSomeContainersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_type.encode(buf)?;
        let len = self.slots.len() as i32;
        len.encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot_type = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slots = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { slot_type, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSome {
    pub containers: Vec<ItemStackResponsesItemContentSomeContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContentSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.containers.len() as i32;
        len.encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let containers = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { containers })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub status: ItemStackResponsesItemStatus,
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub content: Option<ItemStackResponsesItemContentSome>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let status = <ItemStackResponsesItemStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match status {
            _ => {
                Some(
                    <ItemStackResponsesItemContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            status,
            request_id,
            content,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventoryContent {
    pub window_id: WindowIDVarint,
    pub input: ItemStacks,
    pub dynamic_window_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventoryContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.input.encode(buf)?;
        self.dynamic_window_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = <ItemStacks as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dynamic_window_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            window_id,
            input,
            dynamic_window_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventorySlot {
    pub window_id: WindowIDVarint,
    pub slot: i32,
    pub dynamic_window_id: i32,
    pub item: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventorySlot {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.slot.encode(buf)?;
        self.dynamic_window_id.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dynamic_window_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            window_id,
            slot,
            dynamic_window_id,
            item,
        })
    }
}
