// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct BlockPropertiesItem {
    pub name: String,
    pub state: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for BlockPropertiesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.state.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let state = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { name, state })
    }
}
pub type BlockProperties = Vec<BlockPropertiesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum ItemExtraDataWithoutBlockingTickHasNBT {
    False = 0,
    True = 65535,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTickHasNBT {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ItemExtraDataWithoutBlockingTickHasNBT::False),
            65535 => Ok(ItemExtraDataWithoutBlockingTickHasNBT::True),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemExtraDataWithoutBlockingTickHasNBT), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithoutBlockingTickNBTSome {
    pub version: u8,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTickNBTSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { version, nbt })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithoutBlockingTick {
    pub has_nbt: ItemExtraDataWithoutBlockingTickHasNBT,
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNBTSome>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTick {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.has_nbt.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len() as i32;
        len.encode(buf)?;
        for item in &self.can_place_on {
            item.encode(buf)?;
        }
        let len = self.can_destroy.len() as i32;
        len.encode(buf)?;
        for item in &self.can_destroy {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let has_nbt = <ItemExtraDataWithoutBlockingTickHasNBT as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let nbt = match has_nbt {
            true => {
                Some(
                    <ItemExtraDataWithoutBlockingTickNBTSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let can_place_on = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            has_nbt,
            nbt,
            can_place_on,
            can_destroy,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum ItemExtraDataWithBlockingTickHasNBT {
    False = 0,
    True = 65535,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithBlockingTickHasNBT {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(ItemExtraDataWithBlockingTickHasNBT::False),
            65535 => Ok(ItemExtraDataWithBlockingTickHasNBT::True),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemExtraDataWithBlockingTickHasNBT), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithBlockingTick {
    pub has_nbt: ItemExtraDataWithBlockingTickHasNBT,
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNBTSome>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
    pub blocking_tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithBlockingTick {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.has_nbt.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len() as i32;
        len.encode(buf)?;
        for item in &self.can_place_on {
            item.encode(buf)?;
        }
        let len = self.can_destroy.len() as i32;
        len.encode(buf)?;
        for item in &self.can_destroy {
            item.encode(buf)?;
        }
        self.blocking_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let has_nbt = <ItemExtraDataWithBlockingTickHasNBT as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let nbt = match has_nbt {
            true => {
                Some(
                    <ItemExtraDataWithoutBlockingTickNBTSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let can_place_on = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let blocking_tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            has_nbt,
            nbt,
            can_place_on,
            can_destroy,
            blocking_tick,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum MapDecorationType {
    MarkerWhite = 0,
    MarkerGreen = 1,
    MarkerRed = 2,
    MarkerBlue = 3,
    CrossWhite = 4,
    TriangleRed = 5,
    SquareWhite = 6,
    MarkerSign = 7,
    MarkerPink = 8,
    MarkerOrange = 9,
    MarkerYellow = 10,
    MarkerTeal = 11,
    TriangleGreen = 12,
    SmallSquareWhite = 13,
    Mansion = 14,
    Monument = 15,
    NoDraw = 16,
    VillageDesert = 17,
    VillagePlains = 18,
    VillageSavanna = 19,
    VillageSnowy = 20,
    VillageTaiga = 21,
    JungleTemple = 22,
    WitchHut = 23,
}
impl crate::bedrock::codec::BedrockCodec for MapDecorationType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(MapDecorationType::MarkerWhite),
            1 => Ok(MapDecorationType::MarkerGreen),
            2 => Ok(MapDecorationType::MarkerRed),
            3 => Ok(MapDecorationType::MarkerBlue),
            4 => Ok(MapDecorationType::CrossWhite),
            5 => Ok(MapDecorationType::TriangleRed),
            6 => Ok(MapDecorationType::SquareWhite),
            7 => Ok(MapDecorationType::MarkerSign),
            8 => Ok(MapDecorationType::MarkerPink),
            9 => Ok(MapDecorationType::MarkerOrange),
            10 => Ok(MapDecorationType::MarkerYellow),
            11 => Ok(MapDecorationType::MarkerTeal),
            12 => Ok(MapDecorationType::TriangleGreen),
            13 => Ok(MapDecorationType::SmallSquareWhite),
            14 => Ok(MapDecorationType::Mansion),
            15 => Ok(MapDecorationType::Monument),
            16 => Ok(MapDecorationType::NoDraw),
            17 => Ok(MapDecorationType::VillageDesert),
            18 => Ok(MapDecorationType::VillagePlains),
            19 => Ok(MapDecorationType::VillageSavanna),
            20 => Ok(MapDecorationType::VillageSnowy),
            21 => Ok(MapDecorationType::VillageTaiga),
            22 => Ok(MapDecorationType::JungleTemple),
            23 => Ok(MapDecorationType::WitchHut),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MapDecorationType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct MapDecoration {
    pub type_: MapDecorationType,
    pub rotation: u8,
    pub x: u8,
    pub y: u8,
    pub label: String,
    pub color_abgr: i32,
}
impl crate::bedrock::codec::BedrockCodec for MapDecoration {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.rotation.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.label.encode(buf)?;
        self.color_abgr.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <MapDecorationType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let rotation = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let x = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let y = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let label = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let color_abgr = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            type_,
            rotation,
            x,
            y,
            label,
            color_abgr,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct StructureBlockSettings {
    pub palette_name: String,
    pub ignore_entities: bool,
    pub ignore_blocks: bool,
    pub size: BlockCoordinates,
    pub structure_offset: BlockCoordinates,
    pub last_editing_player_unique_id: crate::bedrock::codec::ZigZag64,
    pub rotation: u8,
    pub mirror: u8,
    pub integrity: f32,
    pub seed: u32,
    pub pivot: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettings {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.palette_name.encode(buf)?;
        self.ignore_entities.encode(buf)?;
        self.ignore_blocks.encode(buf)?;
        self.size.encode(buf)?;
        self.structure_offset.encode(buf)?;
        self.last_editing_player_unique_id.encode(buf)?;
        self.rotation.encode(buf)?;
        self.mirror.encode(buf)?;
        self.integrity.encode(buf)?;
        self.seed.encode(buf)?;
        self.pivot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let palette_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let ignore_entities = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let ignore_blocks = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let size = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let structure_offset = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let last_editing_player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let rotation = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let mirror = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let integrity = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let seed = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pivot = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            palette_name,
            ignore_entities,
            ignore_blocks,
            size,
            structure_offset,
            last_editing_player_unique_id,
            rotation,
            mirror,
            integrity,
            seed,
            pivot,
        })
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct UpdateMapFlags : u32 {
    const VOID = 1; const TEXTURE = 2; const DECORATION = 4; const INITIALISATION = 8; }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemDataTrackedSome {
    pub objects: Vec<TrackedObject>,
    pub decorations: Vec<MapDecoration>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemDataTrackedSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.objects.len() as i32;
        len.encode(buf)?;
        for item in &self.objects {
            item.encode(buf)?;
        }
        let len = self.decorations.len() as i32;
        len.encode(buf)?;
        for item in &self.decorations {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let objects = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TrackedObject as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let decorations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <MapDecoration as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { objects, decorations })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemData {
    pub map_id: crate::bedrock::codec::ZigZag64,
    pub update_flags: UpdateMapFlags,
    pub dimension: u8,
    pub locked: bool,
    pub included_in: Option<Vec<crate::bedrock::codec::ZigZag64>>,
    pub scale: Option<u8>,
    pub tracked: Option<PacketClientboundMapItemDataTrackedSome>,
    pub texture: Option<PacketClientboundMapItemDataTextureSome>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.map_id.encode(buf)?;
        self.update_flags.encode(buf)?;
        self.dimension.encode(buf)?;
        self.locked.encode(buf)?;
        if let Some(v) = &self.included_in {
            v.encode(buf)?;
        }
        if let Some(v) = &self.scale {
            v.encode(buf)?;
        }
        if let Some(v) = &self.tracked {
            v.encode(buf)?;
        }
        if let Some(v) = &self.texture {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let update_flags = <UpdateMapFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let locked = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let included_in = match update_flags_initialisation {
            true => {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        let scale = match update_flags_initialisation_update_flags_decoration_update_flags_texture {
            true => Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let tracked = match update_flags_decoration {
            true => {
                Some(
                    <PacketClientboundMapItemDataTrackedSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let texture = match update_flags_texture {
            true => {
                Some(
                    <PacketClientboundMapItemDataTextureSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            map_id,
            update_flags,
            dimension,
            locked,
            included_in,
            scale,
            tracked,
            texture,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketLevelEventEvent {
    SoundClick = 1000,
    SoundClickFail = 1001,
    SoundShoot = 1002,
    SoundDoor = 1003,
    SoundFizz = 1004,
    SoundIgnite = 1005,
    SoundGhast = 1007,
    SoundGhastShoot = 1008,
    SoundBlazeShoot = 1009,
    SoundDoorBump = 1010,
    SoundDoorCrash = 1012,
    SoundEndermanTeleport = 1018,
    SoundAnvilBreak = 1020,
    SoundAnvilUse = 1021,
    SoundAnvilFall = 1022,
    SoundPop = 1030,
    SoundPortal = 1032,
    SoundItemframeAddItem = 1040,
    SoundItemframeRemove = 1041,
    SoundItemframePlace = 1042,
    SoundItemframeRemoveItem = 1043,
    SoundItemframeRotateItem = 1044,
    SoundCamera = 1050,
    SoundOrb = 1051,
    SoundTotem = 1052,
    SoundArmorStandBreak = 1060,
    SoundArmorStandHit = 1061,
    SoundArmorStandFall = 1062,
    SoundArmorStandPlace = 1063,
    PointedDripstoneLand = 1064,
    DyeUsed = 1065,
    InkSackUsed = 1066,
    ParticleShoot = 2000,
    ParticleDestroy = 2001,
    ParticleSplash = 2002,
    ParticleEyeDespawn = 2003,
    ParticleSpawn = 2004,
    ParticleCropGrowth = 2005,
    ParticleGuardianCurse = 2006,
    ParticleDeathSmoke = 2007,
    ParticleBlockForceField = 2008,
    ParticleProjectileHit = 2009,
    ParticleDragonEggTeleport = 2010,
    ParticleCropEaten = 2011,
    ParticleCritical = 2012,
    ParticleEndermanTeleport = 2013,
    ParticlePunchBlock = 2014,
    ParticleBubble = 2015,
    ParticleEvaporate = 2016,
    ParticleDestroyArmorStand = 2017,
    ParticleBreakingEgg = 2018,
    ParticleDestroyEgg = 2019,
    ParticleEvaporateWater = 2020,
    ParticleDestroyBlockNoSound = 2021,
    ParticleKnockbackRoar = 2022,
    ParticleTeleportTrail = 2023,
    ParticlePointCloud = 2024,
    ParticleExplosion = 2025,
    ParticleBlockExplosion = 2026,
    ParticleVibrationSignal = 2027,
    ParticleDripstoneDrip = 2028,
    ParticleFizzEffect = 2029,
    ParticleWaxOn = 2030,
    ParticleWaxOff = 2031,
    ParticleScrape = 2032,
    ParticleElectricSpark = 2033,
    StartRain = 3001,
    StartThunder = 3002,
    StopRain = 3003,
    StopThunder = 3004,
    PauseGame = 3005,
    PauseGameNoScreen = 3006,
    SetGameSpeed = 3007,
    RedstoneTrigger = 3500,
    CauldronExplode = 3501,
    CauldronDyeArmor = 3502,
    CauldronCleanArmor = 3503,
    CauldronFillPotion = 3504,
    CauldronTakePotion = 3505,
    CauldronFillWater = 3506,
    CauldronTakeWater = 3507,
    CauldronAddDye = 3508,
    CauldronCleanBanner = 3509,
    BlockStartBreak = 3600,
    BlockStopBreak = 3601,
    SetData = 4000,
    PlayersSleeping = 9800,
    AddParticleMask = 16384,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEventEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1000 => Ok(PacketLevelEventEvent::SoundClick),
            1001 => Ok(PacketLevelEventEvent::SoundClickFail),
            1002 => Ok(PacketLevelEventEvent::SoundShoot),
            1003 => Ok(PacketLevelEventEvent::SoundDoor),
            1004 => Ok(PacketLevelEventEvent::SoundFizz),
            1005 => Ok(PacketLevelEventEvent::SoundIgnite),
            1007 => Ok(PacketLevelEventEvent::SoundGhast),
            1008 => Ok(PacketLevelEventEvent::SoundGhastShoot),
            1009 => Ok(PacketLevelEventEvent::SoundBlazeShoot),
            1010 => Ok(PacketLevelEventEvent::SoundDoorBump),
            1012 => Ok(PacketLevelEventEvent::SoundDoorCrash),
            1018 => Ok(PacketLevelEventEvent::SoundEndermanTeleport),
            1020 => Ok(PacketLevelEventEvent::SoundAnvilBreak),
            1021 => Ok(PacketLevelEventEvent::SoundAnvilUse),
            1022 => Ok(PacketLevelEventEvent::SoundAnvilFall),
            1030 => Ok(PacketLevelEventEvent::SoundPop),
            1032 => Ok(PacketLevelEventEvent::SoundPortal),
            1040 => Ok(PacketLevelEventEvent::SoundItemframeAddItem),
            1041 => Ok(PacketLevelEventEvent::SoundItemframeRemove),
            1042 => Ok(PacketLevelEventEvent::SoundItemframePlace),
            1043 => Ok(PacketLevelEventEvent::SoundItemframeRemoveItem),
            1044 => Ok(PacketLevelEventEvent::SoundItemframeRotateItem),
            1050 => Ok(PacketLevelEventEvent::SoundCamera),
            1051 => Ok(PacketLevelEventEvent::SoundOrb),
            1052 => Ok(PacketLevelEventEvent::SoundTotem),
            1060 => Ok(PacketLevelEventEvent::SoundArmorStandBreak),
            1061 => Ok(PacketLevelEventEvent::SoundArmorStandHit),
            1062 => Ok(PacketLevelEventEvent::SoundArmorStandFall),
            1063 => Ok(PacketLevelEventEvent::SoundArmorStandPlace),
            1064 => Ok(PacketLevelEventEvent::PointedDripstoneLand),
            1065 => Ok(PacketLevelEventEvent::DyeUsed),
            1066 => Ok(PacketLevelEventEvent::InkSackUsed),
            2000 => Ok(PacketLevelEventEvent::ParticleShoot),
            2001 => Ok(PacketLevelEventEvent::ParticleDestroy),
            2002 => Ok(PacketLevelEventEvent::ParticleSplash),
            2003 => Ok(PacketLevelEventEvent::ParticleEyeDespawn),
            2004 => Ok(PacketLevelEventEvent::ParticleSpawn),
            2005 => Ok(PacketLevelEventEvent::ParticleCropGrowth),
            2006 => Ok(PacketLevelEventEvent::ParticleGuardianCurse),
            2007 => Ok(PacketLevelEventEvent::ParticleDeathSmoke),
            2008 => Ok(PacketLevelEventEvent::ParticleBlockForceField),
            2009 => Ok(PacketLevelEventEvent::ParticleProjectileHit),
            2010 => Ok(PacketLevelEventEvent::ParticleDragonEggTeleport),
            2011 => Ok(PacketLevelEventEvent::ParticleCropEaten),
            2012 => Ok(PacketLevelEventEvent::ParticleCritical),
            2013 => Ok(PacketLevelEventEvent::ParticleEndermanTeleport),
            2014 => Ok(PacketLevelEventEvent::ParticlePunchBlock),
            2015 => Ok(PacketLevelEventEvent::ParticleBubble),
            2016 => Ok(PacketLevelEventEvent::ParticleEvaporate),
            2017 => Ok(PacketLevelEventEvent::ParticleDestroyArmorStand),
            2018 => Ok(PacketLevelEventEvent::ParticleBreakingEgg),
            2019 => Ok(PacketLevelEventEvent::ParticleDestroyEgg),
            2020 => Ok(PacketLevelEventEvent::ParticleEvaporateWater),
            2021 => Ok(PacketLevelEventEvent::ParticleDestroyBlockNoSound),
            2022 => Ok(PacketLevelEventEvent::ParticleKnockbackRoar),
            2023 => Ok(PacketLevelEventEvent::ParticleTeleportTrail),
            2024 => Ok(PacketLevelEventEvent::ParticlePointCloud),
            2025 => Ok(PacketLevelEventEvent::ParticleExplosion),
            2026 => Ok(PacketLevelEventEvent::ParticleBlockExplosion),
            2027 => Ok(PacketLevelEventEvent::ParticleVibrationSignal),
            2028 => Ok(PacketLevelEventEvent::ParticleDripstoneDrip),
            2029 => Ok(PacketLevelEventEvent::ParticleFizzEffect),
            2030 => Ok(PacketLevelEventEvent::ParticleWaxOn),
            2031 => Ok(PacketLevelEventEvent::ParticleWaxOff),
            2032 => Ok(PacketLevelEventEvent::ParticleScrape),
            2033 => Ok(PacketLevelEventEvent::ParticleElectricSpark),
            3001 => Ok(PacketLevelEventEvent::StartRain),
            3002 => Ok(PacketLevelEventEvent::StartThunder),
            3003 => Ok(PacketLevelEventEvent::StopRain),
            3004 => Ok(PacketLevelEventEvent::StopThunder),
            3005 => Ok(PacketLevelEventEvent::PauseGame),
            3006 => Ok(PacketLevelEventEvent::PauseGameNoScreen),
            3007 => Ok(PacketLevelEventEvent::SetGameSpeed),
            3500 => Ok(PacketLevelEventEvent::RedstoneTrigger),
            3501 => Ok(PacketLevelEventEvent::CauldronExplode),
            3502 => Ok(PacketLevelEventEvent::CauldronDyeArmor),
            3503 => Ok(PacketLevelEventEvent::CauldronCleanArmor),
            3504 => Ok(PacketLevelEventEvent::CauldronFillPotion),
            3505 => Ok(PacketLevelEventEvent::CauldronTakePotion),
            3506 => Ok(PacketLevelEventEvent::CauldronFillWater),
            3507 => Ok(PacketLevelEventEvent::CauldronTakeWater),
            3508 => Ok(PacketLevelEventEvent::CauldronAddDye),
            3509 => Ok(PacketLevelEventEvent::CauldronCleanBanner),
            3600 => Ok(PacketLevelEventEvent::BlockStartBreak),
            3601 => Ok(PacketLevelEventEvent::BlockStopBreak),
            4000 => Ok(PacketLevelEventEvent::SetData),
            9800 => Ok(PacketLevelEventEvent::PlayersSleeping),
            16384 => Ok(PacketLevelEventEvent::AddParticleMask),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketLevelEventEvent), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelEvent {
    pub event: PacketLevelEventEvent,
    pub position: Vec3F,
    pub data: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.event.encode(buf)?;
        self.position.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let event = <PacketLevelEventEvent as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { event, position, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelSoundEvent {
    pub sound_id: SoundType,
    pub position: Vec3F,
    pub extra_data: crate::bedrock::codec::ZigZag32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelSoundEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        self.extra_data.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let sound_id = <SoundType as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let extra_data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            sound_id,
            position,
            extra_data,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketMapCreateLockedCopy {
    pub original_map_id: crate::bedrock::codec::ZigZag64,
    pub new_map_id: crate::bedrock::codec::ZigZag64,
}
impl crate::bedrock::codec::BedrockCodec for PacketMapCreateLockedCopy {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.original_map_id.encode(buf)?;
        self.new_map_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let original_map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let new_map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            original_map_id,
            new_map_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureBlockUpdate {
    pub position: BlockCoordinates,
    pub structure_name: String,
    pub data_field: String,
    pub include_players: bool,
    pub show_bounding_box: bool,
    pub structure_block_type: crate::bedrock::codec::ZigZag32,
    pub settings: StructureBlockSettings,
    pub redstone_save_mode: crate::bedrock::codec::ZigZag32,
    pub should_trigger: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketStructureBlockUpdate {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.structure_name.encode(buf)?;
        self.data_field.encode(buf)?;
        self.include_players.encode(buf)?;
        self.show_bounding_box.encode(buf)?;
        self.structure_block_type.encode(buf)?;
        self.settings.encode(buf)?;
        self.redstone_save_mode.encode(buf)?;
        self.should_trigger.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let structure_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let data_field = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let include_players = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let show_bounding_box = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let structure_block_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let settings = <StructureBlockSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let redstone_save_mode = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let should_trigger = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            position,
            structure_name,
            data_field,
            include_players,
            show_bounding_box,
            structure_block_type,
            settings,
            redstone_save_mode,
            should_trigger,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketStructureTemplateDataExportRequestRequestType {
    ExportFromSave = 1,
    ExportFromLoad = 2,
    QuerySavedStructure = 3,
}
impl crate::bedrock::codec::BedrockCodec
for PacketStructureTemplateDataExportRequestRequestType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketStructureTemplateDataExportRequestRequestType::ExportFromSave),
            2 => Ok(PacketStructureTemplateDataExportRequestRequestType::ExportFromLoad),
            3 => {
                Ok(
                    PacketStructureTemplateDataExportRequestRequestType::QuerySavedStructure,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStructureTemplateDataExportRequestRequestType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportRequest {
    pub name: String,
    pub position: BlockCoordinates,
    pub settings: StructureBlockSettings,
    pub request_type: PacketStructureTemplateDataExportRequestRequestType,
}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.position.encode(buf)?;
        self.settings.encode(buf)?;
        self.request_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let settings = <StructureBlockSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let request_type = <PacketStructureTemplateDataExportRequestRequestType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            name,
            position,
            settings,
            request_type,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketStructureTemplateDataExportResponseResponseType {
    Export = 1,
    Query = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketStructureTemplateDataExportResponseResponseType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketStructureTemplateDataExportResponseResponseType::Export),
            2 => Ok(PacketStructureTemplateDataExportResponseResponseType::Query),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketStructureTemplateDataExportResponseResponseType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketStructureTemplateDataExportResponse {
    pub name: String,
    pub success: bool,
    pub nbt: Option<Vec<u8>>,
    pub response_type: PacketStructureTemplateDataExportResponseResponseType,
}
impl crate::bedrock::codec::BedrockCodec for PacketStructureTemplateDataExportResponse {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.success.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        self.response_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let success = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let nbt = match success {
            true => Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let response_type = <PacketStructureTemplateDataExportResponseResponseType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            name,
            success,
            nbt,
            response_type,
        })
    }
}
