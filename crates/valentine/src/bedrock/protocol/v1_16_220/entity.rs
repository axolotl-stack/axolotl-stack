// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Option<Vec<bool>>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.records_count.encode(buf)?;
        let len = self.records.len() as i32;
        len.encode(buf)?;
        for item in &self.records {
            if let Some(v) = &item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => v.encode(buf)?,
                    PlayerRecordsRecordsItem::Remove(v) => v.encode(buf)?,
                }
            }
        }
        if let Some(v) = &self.verified {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let records_count = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let records = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            _ => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        let verified = match type_ {
            _ => {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddEntity {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub entity_type: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.entity_type.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.attributes.encode(buf)?;
        self.metadata.encode(buf)?;
        self.links.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_type = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let attributes = <EntityAttributes as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            entity_type,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            attributes,
            metadata,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddItemEntity {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub item: Item,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub metadata: MetadataDictionary,
    pub is_from_fishing: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddItemEntity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.item.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.metadata.encode(buf)?;
        self.is_from_fishing.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let is_from_fishing = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            item,
            position,
            velocity,
            metadata,
            is_from_fishing,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPlayer {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub platform_chat_id: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub metadata: MetadataDictionary,
    pub flags: i32,
    pub command_permission: i32,
    pub action_permissions: i32,
    pub permission_level: i32,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
    pub links: Links,
    pub device_id: String,
    pub device_os: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPlayer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.username.encode(buf)?;
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.held_item.encode(buf)?;
        self.metadata.encode(buf)?;
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.custom_stored_permissions.encode(buf)?;
        self.user_id.encode(buf)?;
        self.links.encode(buf)?;
        self.device_id.encode(buf)?;
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <MetadataDictionary as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let command_permission = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let permission_level = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let custom_stored_permissions = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let user_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let links = <Links as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let device_os = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            username,
            entity_id_self,
            runtime_entity_id,
            platform_chat_id,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            held_item,
            metadata,
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketNpcRequestRequestType {
    SetActions = 0,
    ExecuteAction = 1,
    ExecuteClosingCommands = 2,
    SetName = 3,
    SetSkin = 4,
    SetInteractionText = 5,
    ExecuteOpeningCommands = 6,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequestRequestType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketNpcRequestRequestType::SetActions),
            1 => Ok(PacketNpcRequestRequestType::ExecuteAction),
            2 => Ok(PacketNpcRequestRequestType::ExecuteClosingCommands),
            3 => Ok(PacketNpcRequestRequestType::SetName),
            4 => Ok(PacketNpcRequestRequestType::SetSkin),
            5 => Ok(PacketNpcRequestRequestType::SetInteractionText),
            6 => Ok(PacketNpcRequestRequestType::ExecuteOpeningCommands),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketNpcRequestRequestType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNpcRequest {
    pub runtime_entity_id: i64,
    pub request_type: PacketNpcRequestRequestType,
    pub command: String,
    pub action_type: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNpcRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.request_type.encode(buf)?;
        self.command.encode(buf)?;
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let request_type = <PacketNpcRequestRequestType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let command = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let action_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            runtime_entity_id,
            request_type,
            command,
            action_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerEnchantOptions {
    pub options: Vec<EnchantOption>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerEnchantOptions {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.options.len() as i32;
        len.encode(buf)?;
        for item in &self.options {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let options = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <EnchantOption as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { options })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketSetScoreEntriesItemContentSomeEntityUniqueID {
    Entity(crate::bedrock::codec::ZigZag64),
    Player(crate::bedrock::codec::ZigZag64),
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum PacketSetScoreboardIdentityAction {
    RegisterIdentity = 0,
    ClearIdentity = 1,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentityAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketSetScoreboardIdentityAction::RegisterIdentity),
            1 => Ok(PacketSetScoreboardIdentityAction::ClearIdentity),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreboardIdentityAction), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentityEntriesItem {
    pub scoreboard_id: crate::bedrock::codec::ZigZag64,
    pub entity_unique_id: Option<crate::bedrock::codec::ZigZag64>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentityEntriesItem {
    fn encode<B: bytes::BufMut>(&self, _buf: &mut B) -> Result<(), std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to encode",
            ),
        )
    }
    fn decode<B: bytes::Buf>(_buf: &mut B) -> Result<Self, std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to decode",
            ),
        )
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreboardIdentity {
    pub action: PacketSetScoreboardIdentityAction,
    pub entries: Vec<PacketSetScoreboardIdentityEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreboardIdentity {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        let len = self.entries.len() as i32;
        len.encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action = <PacketSetScoreboardIdentityAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entries = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSetScoreboardIdentityEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { action, entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSpawnParticleEffect {
    pub dimension: u8,
    pub entity_id: crate::bedrock::codec::ZigZag64,
    pub position: Vec3F,
    pub particle_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketSpawnParticleEffect {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension.encode(buf)?;
        self.entity_id.encode(buf)?;
        self.position.encode(buf)?;
        self.particle_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let particle_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            dimension,
            entity_id,
            position,
            particle_name,
        })
    }
}
