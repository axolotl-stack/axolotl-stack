// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct SkinImage {
    pub width: i32,
    pub height: i32,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for SkinImage {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let height = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let data = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { width, height, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Skin {
    pub skin_id: String,
    pub play_fab_id: String,
    pub skin_resource_pack: String,
    pub skin_data: SkinImage,
    pub animations: Vec<SkinAnimationsItem>,
    pub cape_data: SkinImage,
    pub geometry_data: String,
    pub animation_data: String,
    pub premium: bool,
    pub persona: bool,
    pub cape_on_classic: bool,
    pub cape_id: String,
    pub full_skin_id: String,
    pub arm_size: String,
    pub skin_color: String,
    pub personal_pieces: Vec<SkinPersonalPiecesItem>,
    pub piece_tint_colors: Vec<SkinPieceTintColorsItem>,
}
impl crate::bedrock::codec::BedrockCodec for Skin {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.skin_id.encode(buf)?;
        self.play_fab_id.encode(buf)?;
        self.skin_resource_pack.encode(buf)?;
        self.skin_data.encode(buf)?;
        let len = self.animations.len() as i32;
        len.encode(buf)?;
        for item in &self.animations {
            item.encode(buf)?;
        }
        self.cape_data.encode(buf)?;
        self.geometry_data.encode(buf)?;
        self.animation_data.encode(buf)?;
        self.premium.encode(buf)?;
        self.persona.encode(buf)?;
        self.cape_on_classic.encode(buf)?;
        self.cape_id.encode(buf)?;
        self.full_skin_id.encode(buf)?;
        self.arm_size.encode(buf)?;
        self.skin_color.encode(buf)?;
        let len = self.personal_pieces.len() as i32;
        len.encode(buf)?;
        for item in &self.personal_pieces {
            item.encode(buf)?;
        }
        let len = self.piece_tint_colors.len() as i32;
        len.encode(buf)?;
        for item in &self.piece_tint_colors {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let play_fab_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_resource_pack = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let skin_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let animations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinAnimationsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let cape_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let geometry_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let animation_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let persona = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let cape_on_classic = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let cape_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let full_skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let arm_size = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_color = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let personal_pieces = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPersonalPiecesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let piece_tint_colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPieceTintColorsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            skin_id,
            play_fab_id,
            skin_resource_pack,
            skin_data,
            animations,
            cape_data,
            geometry_data,
            animation_data,
            premium,
            persona,
            cape_on_classic,
            cape_id,
            full_skin_id,
            arm_size,
            skin_color,
            personal_pieces,
            piece_tint_colors,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketClientboundMapItemDataTextureSome {
    pub width: crate::bedrock::codec::ZigZag32,
    pub height: crate::bedrock::codec::ZigZag32,
    pub x_offset: crate::bedrock::codec::ZigZag32,
    pub y_offset: crate::bedrock::codec::ZigZag32,
    pub pixels: Vec<i32>,
}
impl crate::bedrock::codec::BedrockCodec for PacketClientboundMapItemDataTextureSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        self.x_offset.encode(buf)?;
        self.y_offset.encode(buf)?;
        let len = self.pixels.len() as i32;
        len.encode(buf)?;
        for item in &self.pixels {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let width = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let x_offset = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let y_offset = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let pixels = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            width,
            height,
            x_offset,
            y_offset,
            pixels,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketOnScreenTextureAnimation {
    pub animation_type: u32,
}
impl crate::bedrock::codec::BedrockCodec for PacketOnScreenTextureAnimation {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.animation_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let animation_type = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { animation_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkData {
    pub pack_id: String,
    pub chunk_index: u32,
    pub progress: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkData {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pack_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        self.progress.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let progress = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            pack_id,
            chunk_index,
            progress,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackChunkRequest {
    pub pack_id: String,
    pub chunk_index: u32,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackChunkRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pack_id.encode(buf)?;
        self.chunk_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chunk_index = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { pack_id, chunk_index })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketResourcePackDataInfoPackType {
    Addon = 1,
    Cached = 2,
    CopyProtected = 3,
    Behavior = 4,
    PersonaPiece = 5,
    Resources = 6,
    Skins = 7,
    WorldTemplate = 8,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackDataInfoPackType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketResourcePackDataInfoPackType::Addon),
            2 => Ok(PacketResourcePackDataInfoPackType::Cached),
            3 => Ok(PacketResourcePackDataInfoPackType::CopyProtected),
            4 => Ok(PacketResourcePackDataInfoPackType::Behavior),
            5 => Ok(PacketResourcePackDataInfoPackType::PersonaPiece),
            6 => Ok(PacketResourcePackDataInfoPackType::Resources),
            7 => Ok(PacketResourcePackDataInfoPackType::Skins),
            8 => Ok(PacketResourcePackDataInfoPackType::WorldTemplate),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketResourcePackDataInfoPackType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketResourcePackDataInfo {
    pub pack_id: String,
    pub max_chunk_size: u32,
    pub chunk_count: u32,
    pub size: u64,
    pub hash: ByteArray,
    pub is_premium: bool,
    pub pack_type: PacketResourcePackDataInfoPackType,
}
impl crate::bedrock::codec::BedrockCodec for PacketResourcePackDataInfo {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pack_id.encode(buf)?;
        self.max_chunk_size.encode(buf)?;
        self.chunk_count.encode(buf)?;
        self.size.encode(buf)?;
        self.hash.encode(buf)?;
        self.is_premium.encode(buf)?;
        self.pack_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let max_chunk_size = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chunk_count = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hash = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let pack_type = <PacketResourcePackDataInfoPackType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            pack_id,
            max_chunk_size,
            chunk_count,
            size,
            hash,
            is_premium,
            pack_type,
        })
    }
}
