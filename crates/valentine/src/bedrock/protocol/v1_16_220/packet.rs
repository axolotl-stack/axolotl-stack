// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAddPainting {
    pub entity_id_self: crate::bedrock::codec::ZigZag64,
    pub runtime_entity_id: i64,
    pub coordinates: Vec3F,
    pub direction: crate::bedrock::codec::ZigZag32,
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketAddPainting {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_id_self.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        self.coordinates.encode(buf)?;
        self.direction.encode(buf)?;
        self.title.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let coordinates = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let direction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            coordinates,
            direction,
            title,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentSetBarProgress {
    pub progress: f32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentSetBarProgress {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.progress.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { progress })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentShowBar {
    pub title: String,
    pub progress: f32,
    pub screen_darkening: i16,
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentShowBar {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.title.encode(buf)?;
        self.progress.encode(buf)?;
        self.screen_darkening.encode(buf)?;
        self.color.encode(buf)?;
        self.overlay.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let title = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let progress = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let screen_darkening = <i16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let color = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let overlay = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            title,
            progress,
            screen_darkening,
            color,
            overlay,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEventContentUpdateProperties {
    pub screen_darkening: i16,
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEventContentUpdateProperties {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.screen_darkening.encode(buf)?;
        self.color.encode(buf)?;
        self.overlay.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let screen_darkening = <i16 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let color = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let overlay = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            screen_darkening,
            color,
            overlay,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketBossEventContent {
    RegisterPlayer(PacketBossEventContentRegisterPlayer),
    SetBarProgress(PacketBossEventContentSetBarProgress),
    SetBarTitle(PacketBossEventContentSetBarTitle),
    ShowBar(Box<PacketBossEventContentShowBar>),
    Texture(PacketBossEventContentTexture),
    UnregisterPlayer(PacketBossEventContentRegisterPlayer),
    UpdateProperties(PacketBossEventContentUpdateProperties),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketBossEvent {
    pub boss_entity_id: crate::bedrock::codec::ZigZag64,
    pub type_: PacketBossEventType,
    pub content: Option<PacketBossEventContent>,
}
impl crate::bedrock::codec::BedrockCodec for PacketBossEvent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.boss_entity_id.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PacketBossEventContent::RegisterPlayer(v) => v.encode(buf)?,
                PacketBossEventContent::SetBarProgress(v) => v.encode(buf)?,
                PacketBossEventContent::SetBarTitle(v) => v.encode(buf)?,
                PacketBossEventContent::ShowBar(v) => v.encode(buf)?,
                PacketBossEventContent::Texture(v) => v.encode(buf)?,
                PacketBossEventContent::UnregisterPlayer(v) => v.encode(buf)?,
                PacketBossEventContent::UpdateProperties(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let boss_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <PacketBossEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_ {
            _ => {
                Some(
                    PacketBossEventContent::RegisterPlayer(
                        <PacketBossEventContentRegisterPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::SetBarProgress(
                        <PacketBossEventContentSetBarProgress as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::SetBarTitle(
                        <PacketBossEventContentSetBarTitle as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::ShowBar(
                        Box::new(
                            <PacketBossEventContentShowBar as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::Texture(
                        <PacketBossEventContentTexture as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::UnregisterPlayer(
                        <PacketBossEventContentRegisterPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                Some(
                    PacketBossEventContent::UpdateProperties(
                        <PacketBossEventContentUpdateProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            boss_entity_id,
            type_,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContent {
    pub items: Vec<PacketCreativeContentItemsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.items.len() as i32;
        len.encode(buf)?;
        for item in &self.items {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let items = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketCreativeContentItemsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { items })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketNetworkStackLatency {
    pub timestamp: u64,
    pub needs_response: u8,
}
impl crate::bedrock::codec::BedrockCodec for PacketNetworkStackLatency {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.timestamp.encode(buf)?;
        self.needs_response.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let timestamp = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let needs_response = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { timestamp, needs_response })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPhotoTransfer {
    pub image_name: String,
    pub image_data: String,
    pub book_id: String,
}
impl crate::bedrock::codec::BedrockCodec for PacketPhotoTransfer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.image_name.encode(buf)?;
        self.image_data.encode(buf)?;
        self.book_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let image_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let image_data = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let book_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            image_name,
            image_data,
            book_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketRespawn {
    pub position: Vec3F,
    pub state: u8,
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PacketRespawn {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        self.state.encode(buf)?;
        self.runtime_entity_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let state = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            position,
            state,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetLastHurtBy {
    pub entity_type: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetLastHurtBy {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entity_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entity_type = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { entity_type })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketShowStoreOffer {
    pub offer_id: String,
    pub show_all: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketShowStoreOffer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.offer_id.encode(buf)?;
        self.show_all.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let offer_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let show_all = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { offer_id, show_all })
    }
}
