// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct EnchantOption {
    pub cost: i32,
    pub slot_flags: i32,
    pub equip_enchants: Vec<Enchant>,
    pub held_enchants: Vec<Enchant>,
    pub self_enchants: Vec<Enchant>,
    pub name: String,
    pub option_id: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for EnchantOption {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cost.encode(buf)?;
        self.slot_flags.encode(buf)?;
        let len = self.equip_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.equip_enchants {
            item.encode(buf)?;
        }
        let len = self.held_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.held_enchants {
            item.encode(buf)?;
        }
        let len = self.self_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.self_enchants {
            item.encode(buf)?;
        }
        self.name.encode(buf)?;
        self.option_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let cost = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let slot_flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let equip_enchants = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let held_enchants = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let self_enchants = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let option_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            cost,
            slot_flags,
            equip_enchants,
            held_enchants,
            self_enchants,
            name,
            option_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemContentExtra {
    Default(Box<ItemExtraDataWithoutBlockingTick>),
    ShieldItemID(Box<ItemExtraDataWithBlockingTick>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContent {
    pub count: u16,
    pub metadata: i32,
    pub stack_id: Option<crate::bedrock::codec::ZigZag32>,
    pub block_runtime_id: crate::bedrock::codec::ZigZag32,
    pub extra: ItemContentExtra,
}
impl crate::bedrock::codec::BedrockCodec for ItemContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.metadata.encode(buf)?;
        let val = self.stack_id.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.stack_id {
            v.encode(buf)?;
        }
        self.block_runtime_id.encode(buf)?;
        match &self.extra {
            ItemContentExtra::ShieldItemID(v) => v.encode(buf)?,
            ItemContentExtra::Default(v) => v.encode(buf)?,
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let has_stack_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let stack_id = match has_stack_id {
            0 => None,
            _ => {
                Some(
                    <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
        };
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let extra = match network_id {
            _ => {
                ItemContentExtra::ShieldItemID(
                    Box::new(
                        <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                ItemContentExtra::Default(
                    Box::new(
                        <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
        };
        Ok(Self {
            count,
            metadata,
            stack_id,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Item {
    pub content: Option<ItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for Item {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match network_id {
            crate::bedrock::codec::ZigZag32(0) => None,
            _ => Some(<ItemContent as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
        };
        Ok(Self { content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemLegacyContentExtra {
    Default(Box<ItemExtraDataWithoutBlockingTick>),
    ShieldItemID(Box<ItemExtraDataWithBlockingTick>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemLegacyContent {
    pub count: u16,
    pub metadata: i32,
    pub block_runtime_id: crate::bedrock::codec::ZigZag32,
    pub extra: ItemLegacyContentExtra,
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacyContent {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.metadata.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        match &self.extra {
            ItemLegacyContentExtra::ShieldItemID(v) => v.encode(buf)?,
            ItemLegacyContentExtra::Default(v) => v.encode(buf)?,
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let count = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let metadata = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let extra = match network_id {
            _ => {
                ItemLegacyContentExtra::ShieldItemID(
                    Box::new(
                        <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => {
                ItemLegacyContentExtra::Default(
                    Box::new(
                        <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
        };
        Ok(Self {
            count,
            metadata,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemLegacy {
    pub content: Option<ItemLegacyContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacy {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match network_id {
            crate::bedrock::codec::ZigZag32(0) => None,
            _ => {
                Some(
                    <ItemLegacyContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
        };
        Ok(Self { content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentResultsDeprecated {
    pub result_items: Vec<ItemLegacy>,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentResultsDeprecated {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.result_items.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result_items {
            item.encode(buf)?;
        }
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let result_items = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            result_items,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(ItemStackRequestActionsItemContentCraftRecipeAuto),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeID,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Consume(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftCreative(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipe(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Create(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Destroy(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Drop(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::MineBlock(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Place(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?
                }
                ItemStackRequestActionsItemContent::Swap(v) => v.encode(buf)?,
                ItemStackRequestActionsItemContent::Take(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestActionsItemTypeID as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match type_id {
            ItemStackRequestActionsItemTypeID::BeaconPayment => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Consume => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftCreative => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftRecipe => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::CraftRecipeAuto => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Create => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Destroy => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Drop => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::MineBlock => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::NonImplemented => {
                Some(ItemStackRequestActionsItemContent::NonImplemented)
            }
            ItemStackRequestActionsItemTypeID::Optional => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Place => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::ResultsDeprecated => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Swap => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeID::Take => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequest {
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.request_id.encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.custom_names {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let actions = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        Ok(Self {
            request_id,
            actions,
            custom_names,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSomeContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: crate::bedrock::codec::ZigZag32,
    pub custom_name: String,
    pub durability_correction: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentSomeContainersItemSlotsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        self.item_stack_id.encode(buf)?;
        self.custom_name.encode(buf)?;
        self.durability_correction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item_stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let durability_correction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
            durability_correction,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSomeContainersItem {
    pub slot_type: ContainerSlotType,
    pub slots: Vec<ItemStackResponsesItemContentSomeContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentSomeContainersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_type.encode(buf)?;
        let len = self.slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let slot_type = <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slots = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { slot_type, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentSome {
    pub containers: Vec<ItemStackResponsesItemContentSomeContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContentSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let containers = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentSomeContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { containers })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub status: ItemStackResponsesItemStatus,
    pub request_id: crate::bedrock::codec::ZigZag32,
    pub content: Option<ItemStackResponsesItemContentSome>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let status = <ItemStackResponsesItemStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match status {
            ItemStackResponsesItemStatus::Ok => {
                Some(
                    <ItemStackResponsesItemContentSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            status,
            request_id,
            content,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
pub type ItemStacks = Vec<Item>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Flags = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    HorseType = 19,
    CreeperSwell = 20,
    CreeperSwellDirection = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeID = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinID = 40,
    URLTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    WitherAerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    RiderSeatRotationOffset = 60,
    AreaEffectCloudRadius = 61,
    AreaEffectCloudWaiting = 62,
    AreaEffectCloudParticleID = 63,
    ShulkerPeekID = 64,
    ShulkerAttachFace = 65,
    ShulkerAttached = 66,
    ShulkerAttachPos = 67,
    TradingPlayerEid = 68,
    TradingCareer = 69,
    HasCommandBlock = 70,
    CommandBlockCommand = 71,
    CommandBlockLastOutput = 72,
    CommandBlockTrackOutput = 73,
    ControllingRiderSeatNumber = 74,
    Strength = 75,
    MaxStrength = 76,
    EvokerSpellCastingColor = 77,
    LimitedLife = 78,
    ArmorStandPoseIndex = 79,
    EnderCrystalTimeOffset = 80,
    AlwaysShowNametag = 81,
    Color2 = 82,
    NameAuthor = 83,
    ScoreTag = 84,
    BalloonAttachedEntity = 85,
    PufferfishSize = 86,
    BubbleTime = 87,
    Agent = 88,
    SittingAmount = 89,
    SittingAmountPrevious = 90,
    EatingCounter = 91,
    FlagsExtended = 92,
    LayingAmount = 93,
    LayingAmountPrevious = 94,
    AreaEffectCloudDuration = 95,
    AreaEffectCloudSpawnTime = 96,
    AreaEffectCloudChangeRate = 97,
    AreaEffectCloudChangeOnPickup = 98,
    AreaEffectCloudPickupCount = 99,
    InteractText = 100,
    TradeTier = 101,
    MaxTradeTier = 102,
    TradeExperience = 103,
    SkinID = 104,
    SpawningFrames = 105,
    CommandBlockTickDelay = 106,
    CommandBlockExecuteOnFirstTick = 107,
    AmbientSoundInterval = 108,
    AmbientSoundIntervalRange = 109,
    AmbientSoundEventName = 110,
    FallDamageMultiplier = 111,
    NameRawText = 112,
    CanRideTarget = 113,
    LowTierCuredDiscount = 114,
    HighTierCuredDiscount = 115,
    NearbyCuredDiscount = 116,
    NearbyCuredDiscountTimestamp = 117,
    Hitbox = 118,
    IsBuoyant = 119,
    FreezingEffectStrength = 120,
    BuoyancyData = 121,
    GoatHornCount = 122,
    BaseRuntimeID = 123,
    DefineProperties = 124,
    UpdateProperties = 125,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Flags),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            19 => Ok(MetadataDictionaryItemKey::HorseType),
            20 => Ok(MetadataDictionaryItemKey::CreeperSwell),
            21 => Ok(MetadataDictionaryItemKey::CreeperSwellDirection),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeID),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinID),
            41 => Ok(MetadataDictionaryItemKey::URLTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::WitherAerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::RiderSeatRotationOffset),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            63 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleID),
            64 => Ok(MetadataDictionaryItemKey::ShulkerPeekID),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            67 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            68 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            69 => Ok(MetadataDictionaryItemKey::TradingCareer),
            70 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            73 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            74 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            75 => Ok(MetadataDictionaryItemKey::Strength),
            76 => Ok(MetadataDictionaryItemKey::MaxStrength),
            77 => Ok(MetadataDictionaryItemKey::EvokerSpellCastingColor),
            78 => Ok(MetadataDictionaryItemKey::LimitedLife),
            79 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            80 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            81 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            82 => Ok(MetadataDictionaryItemKey::Color2),
            83 => Ok(MetadataDictionaryItemKey::NameAuthor),
            84 => Ok(MetadataDictionaryItemKey::ScoreTag),
            85 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            86 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            87 => Ok(MetadataDictionaryItemKey::BubbleTime),
            88 => Ok(MetadataDictionaryItemKey::Agent),
            89 => Ok(MetadataDictionaryItemKey::SittingAmount),
            90 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            91 => Ok(MetadataDictionaryItemKey::EatingCounter),
            92 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            93 => Ok(MetadataDictionaryItemKey::LayingAmount),
            94 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            95 => Ok(MetadataDictionaryItemKey::AreaEffectCloudDuration),
            96 => Ok(MetadataDictionaryItemKey::AreaEffectCloudSpawnTime),
            97 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeRate),
            98 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeOnPickup),
            99 => Ok(MetadataDictionaryItemKey::AreaEffectCloudPickupCount),
            100 => Ok(MetadataDictionaryItemKey::InteractText),
            101 => Ok(MetadataDictionaryItemKey::TradeTier),
            102 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            103 => Ok(MetadataDictionaryItemKey::TradeExperience),
            104 => Ok(MetadataDictionaryItemKey::SkinID),
            105 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            107 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            110 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            111 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            112 => Ok(MetadataDictionaryItemKey::NameRawText),
            113 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            114 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            117 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            118 => Ok(MetadataDictionaryItemKey::Hitbox),
            119 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            120 => Ok(MetadataDictionaryItemKey::FreezingEffectStrength),
            121 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            122 => Ok(MetadataDictionaryItemKey::GoatHornCount),
            123 => Ok(MetadataDictionaryItemKey::BaseRuntimeID),
            124 => Ok(MetadataDictionaryItemKey::DefineProperties),
            125 => Ok(MetadataDictionaryItemKey::UpdateProperties),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: MetadataDictionaryItemValue,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        match &self.value {
            MetadataDictionaryItemValue::Flags(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::FlagsExtended(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::Default(v) => v.encode(buf)?,
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value = match key {
            MetadataDictionaryItemKey::Flags => {
                MetadataDictionaryItemValue::Flags(
                    <MetadataFlags1 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            MetadataDictionaryItemKey::FlagsExtended => {
                MetadataDictionaryItemValue::FlagsExtended(
                    <MetadataFlags2 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::Default(
                    Box::new(
                        match type_ {
                            MetadataDictionaryItemType::Byte => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Byte(
                                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Compound => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Compound(
                                        <Vec<
                                            u8,
                                        > as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Float => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Float(
                                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Int => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Int(
                                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Long => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Long(
                                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Short => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Short(
                                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::String => {
                                Some(
                                    MetadataDictionaryItemValueDefault::String(
                                        <String as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3F => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3F(
                                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3I => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3I(
                                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnace {
    pub input_id: crate::bedrock::codec::ZigZag32,
    pub output: ItemLegacy,
    pub block: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnace {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.input_id.encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let output = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { input_id, output, block })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnaceWithMetadata {
    pub input_id: crate::bedrock::codec::ZigZag32,
    pub input_meta: crate::bedrock::codec::ZigZag32,
    pub output: ItemLegacy,
    pub block: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnaceWithMetadata {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.input_id.encode(buf)?;
        self.input_meta.encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let output = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            input_id,
            input_meta,
            output,
            block,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShaped {
    pub recipe_id: LatinString,
    pub width: crate::bedrock::codec::ZigZag32,
    pub height: crate::bedrock::codec::ZigZag32,
    pub input: Vec<Vec<RecipeIngredient>>,
    pub output: Vec<ItemLegacy>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: crate::bedrock::codec::ZigZag32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShaped {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            let len = item.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            for item in &item {
                item.encode(buf)?;
            }
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        self.priority.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let width = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?
                            .0 as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                    )?,
                                );
                        }
                        tmp_vec
                    });
            }
            tmp_vec
        };
        let output = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_id,
            width,
            height,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShapeless {
    pub recipe_id: LatinString,
    pub input: Vec<RecipeIngredient>,
    pub output: Vec<ItemLegacy>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: crate::bedrock::codec::ZigZag32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShapeless {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        self.priority.encode(buf)?;
        self.network_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        let output = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                    );
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let network_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            recipe_id,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipesItemRecipe {
    Furnace(Box<RecipesItemRecipeFurnace>),
    FurnaceWithMetadata(Box<RecipesItemRecipeFurnaceWithMetadata>),
    Multi(RecipesItemRecipeMulti),
    Shaped(Box<RecipesItemRecipeShaped>),
    ShapedChemistry(Box<RecipesItemRecipeShaped>),
    Shapeless(Box<RecipesItemRecipeShapeless>),
    ShapelessChemistry(Box<RecipesItemRecipeShapeless>),
    ShulkerBox(Box<RecipesItemRecipeShapeless>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItem {
    pub type_: RecipesItemType,
    pub recipe: Option<RecipesItemRecipe>,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.recipe {
            match v {
                RecipesItemRecipe::Furnace(v) => v.encode(buf)?,
                RecipesItemRecipe::FurnaceWithMetadata(v) => v.encode(buf)?,
                RecipesItemRecipe::Multi(v) => v.encode(buf)?,
                RecipesItemRecipe::Shaped(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapedChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::Shapeless(v) => v.encode(buf)?,
                RecipesItemRecipe::ShapelessChemistry(v) => v.encode(buf)?,
                RecipesItemRecipe::ShulkerBox(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <RecipesItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let recipe = match type_ {
            RecipesItemType::Furnace => {
                Some(
                    RecipesItemRecipe::Furnace(
                        Box::new(
                            <RecipesItemRecipeFurnace as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::FurnaceWithMetadata => {
                Some(
                    RecipesItemRecipe::FurnaceWithMetadata(
                        Box::new(
                            <RecipesItemRecipeFurnaceWithMetadata as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Multi => {
                Some(
                    RecipesItemRecipe::Multi(
                        <RecipesItemRecipeMulti as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            RecipesItemType::Shaped => {
                Some(
                    RecipesItemRecipe::Shaped(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapedChemistry => {
                Some(
                    RecipesItemRecipe::ShapedChemistry(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Shapeless => {
                Some(
                    RecipesItemRecipe::Shapeless(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapelessChemistry => {
                Some(
                    RecipesItemRecipe::ShapelessChemistry(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShulkerBox => {
                Some(
                    RecipesItemRecipe::ShulkerBox(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, recipe })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionActionsItemSourceType {
    Container = 0,
    Global = 1,
    WorldInteraction = 2,
    Creative = 3,
    CraftSlot = 100,
    Craft = 99999,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemSourceType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(TransactionActionsItemSourceType::Container),
            1 => Ok(TransactionActionsItemSourceType::Global),
            2 => Ok(TransactionActionsItemSourceType::WorldInteraction),
            3 => Ok(TransactionActionsItemSourceType::Creative),
            100 => Ok(TransactionActionsItemSourceType::CraftSlot),
            99999 => Ok(TransactionActionsItemSourceType::Craft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionActionsItemSourceType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItemContentContainer {
    pub inventory_id: WindowIDVarint,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemContentContainer {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.inventory_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let inventory_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { inventory_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItemContentCraft {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemContentCraft {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { action })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItemContentWorldInteraction {
    pub flags: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionActionsItemContentWorldInteraction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.flags.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionActionsItemContent {
    Container(TransactionActionsItemContentContainer),
    Craft(TransactionActionsItemContentCraft),
    CraftSlot(TransactionActionsItemContentCraft),
    WorldInteraction(TransactionActionsItemContentWorldInteraction),
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItem {
    pub source_type: TransactionActionsItemSourceType,
    pub content: Option<TransactionActionsItemContent>,
    pub slot: i32,
    pub old_item: Item,
    pub new_item: Item,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source_type.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                TransactionActionsItemContent::Container(v) => v.encode(buf)?,
                TransactionActionsItemContent::Craft(v) => v.encode(buf)?,
                TransactionActionsItemContent::CraftSlot(v) => v.encode(buf)?,
                TransactionActionsItemContent::WorldInteraction(v) => v.encode(buf)?,
            }
        }
        self.slot.encode(buf)?;
        self.old_item.encode(buf)?;
        self.new_item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let source_type = <TransactionActionsItemSourceType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let content = match source_type {
            TransactionActionsItemSourceType::Container => {
                Some(
                    TransactionActionsItemContent::Container(
                        <TransactionActionsItemContentContainer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::Craft => {
                Some(
                    TransactionActionsItemContent::Craft(
                        <TransactionActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::CraftSlot => {
                Some(
                    TransactionActionsItemContent::CraftSlot(
                        <TransactionActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::WorldInteraction => {
                Some(
                    TransactionActionsItemContent::WorldInteraction(
                        <TransactionActionsItemContentWorldInteraction as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let old_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let new_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            source_type,
            content,
            slot,
            old_item,
            new_item,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionUseItem {
    pub action_type: TransactionUseItemActionType,
    pub block_position: BlockCoordinates,
    pub face: crate::bedrock::codec::ZigZag32,
    pub hotbar_slot: crate::bedrock::codec::ZigZag32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
    pub block_runtime_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.block_position.encode(buf)?;
        self.face.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        self.block_runtime_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let action_type = <TransactionUseItemActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let block_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let block_runtime_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            action_type,
            block_position,
            face,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
            block_runtime_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    CheatsEnabled = 0,
    OperatorPermissions = 1,
    HostPermissions = 2,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::CheatsEnabled,
                )
            }
            1 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::OperatorPermissions,
                )
            }
            2 => {
                Ok(
                    PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint::HostPermissions,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    pub constraint: PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsEnumConstraintsItemConstraintsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.constraint.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let constraint = <PacketAvailableCommandsEnumConstraintsItemConstraintsItemConstraint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { constraint })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsEnumConstraintsItem {
    pub value_index: i32,
    pub enum_index: i32,
    pub constraints: Vec<PacketAvailableCommandsEnumConstraintsItemConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsEnumConstraintsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.value_index.encode(buf)?;
        self.enum_index.encode(buf)?;
        let len = self.constraints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let value_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let enum_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let constraints = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsEnumConstraintsItemConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            value_index,
            enum_index,
            constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCreativeContentItemsItem {
    pub entry_id: i32,
    pub item: ItemLegacy,
}
impl crate::bedrock::codec::BedrockCodec for PacketCreativeContentItemsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entry_id.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entry_id = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { entry_id, item })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketInventorySlot {
    pub window_id: WindowIDVarint,
    pub slot: i32,
    pub item: Item,
}
impl crate::bedrock::codec::BedrockCodec for PacketInventorySlot {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.window_id.encode(buf)?;
        self.slot.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let window_id = <WindowIDVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let slot = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { window_id, slot, item })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum PacketSetScoreEntriesItemContentSomeEntryType {
    Player = 1,
    Entity = 2,
    FakePlayer = 3,
}
impl crate::bedrock::codec::BedrockCodec
for PacketSetScoreEntriesItemContentSomeEntryType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => Ok(PacketSetScoreEntriesItemContentSomeEntryType::Player),
            2 => Ok(PacketSetScoreEntriesItemContentSomeEntryType::Entity),
            3 => Ok(PacketSetScoreEntriesItemContentSomeEntryType::FakePlayer),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketSetScoreEntriesItemContentSomeEntryType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreEntriesItemContentSome {
    pub entry_type: PacketSetScoreEntriesItemContentSomeEntryType,
    pub entity_unique_id: Option<PacketSetScoreEntriesItemContentSomeEntityUniqueID>,
    pub custom_name: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItemContentSome {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.entry_type.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            match v {
                PacketSetScoreEntriesItemContentSomeEntityUniqueID::Entity(v) => {
                    v.encode(buf)?
                }
                PacketSetScoreEntriesItemContentSomeEntityUniqueID::Player(v) => {
                    v.encode(buf)?
                }
            }
        }
        if let Some(v) = &self.custom_name {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let entry_type = <PacketSetScoreEntriesItemContentSomeEntryType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let entity_unique_id = match entry_type {
            PacketSetScoreEntriesItemContentSomeEntryType::Entity => {
                Some(
                    PacketSetScoreEntriesItemContentSomeEntityUniqueID::Entity(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            PacketSetScoreEntriesItemContentSomeEntryType::Player => {
                Some(
                    PacketSetScoreEntriesItemContentSomeEntityUniqueID::Player(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let custom_name = match entry_type {
            PacketSetScoreEntriesItemContentSomeEntryType::FakePlayer => {
                Some(<String as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            }
            _ => None,
        };
        Ok(Self {
            entry_type,
            entity_unique_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSetScoreEntriesItem {
    pub scoreboard_id: crate::bedrock::codec::ZigZag64,
    pub objective_name: String,
    pub score: i32,
    pub content: Option<PacketSetScoreEntriesItemContentSome>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSetScoreEntriesItem {
    fn encode<B: bytes::BufMut>(&self, _buf: &mut B) -> Result<(), std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to encode",
            ),
        )
    }
    fn decode<B: bytes::Buf>(_buf: &mut B) -> Result<Self, std::io::Error> {
        Err(
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Requires context to decode",
            ),
        )
    }
}
