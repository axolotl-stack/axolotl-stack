// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemAdd {
    pub uuid: uuid::Uuid,
    pub entity_unique_id: crate::bedrock::codec::ZigZag64,
    pub username: String,
    pub xbox_user_id: String,
    pub platform_chat_id: String,
    pub build_platform: i32,
    pub skin_data: Skin,
    pub is_teacher: bool,
    pub is_host: bool,
    pub is_subclient: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemAdd {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.entity_unique_id.encode(buf)?;
        self.username.encode(buf)?;
        self.xbox_user_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.build_platform.encode(buf)?;
        self.skin_data.encode(buf)?;
        self.is_teacher.encode(buf)?;
        self.is_host.encode(buf)?;
        self.is_subclient.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let xbox_user_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let build_platform = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let skin_data = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_teacher = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_host = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let is_subclient = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            uuid,
            entity_unique_id,
            username,
            xbox_user_id,
            platform_chat_id,
            build_platform,
            skin_data,
            is_teacher,
            is_host,
            is_subclient,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerRecordsRecordsItem {
    Add(Box<PlayerRecordsRecordsItemAdd>),
    Remove(PlayerRecordsRecordsItemRemove),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Option<Vec<bool>>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.records_count.encode(buf)?;
        let len = self.records.len() as i32;
        len.encode(buf)?;
        for item in &self.records {
            if let Some(v) = &item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => v.encode(buf)?,
                    PlayerRecordsRecordsItem::Remove(v) => v.encode(buf)?,
                }
            }
        }
        if let Some(v) = &self.verified {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let records_count = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let records = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            _ => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        let verified = match type_ {
            _ => {
                Some({
                    let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                        as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub interaction_model: PacketPlayerAuthInputInteractionModel,
    pub gaze_direction: Option<Vec3F>,
    pub tick: i64,
    pub delta: Vec3F,
    pub transaction: Option<PacketPlayerAuthInputTransactionSome>,
    pub item_stack_request: Option<ItemStackRequest>,
    pub predicted_vehicle: Option<crate::bedrock::codec::ZigZag64>,
    pub block_action: Option<Vec<PacketPlayerAuthInputBlockActionSomeItem>>,
    pub analogue_move_vector: Vec2F,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        self.interaction_model.encode(buf)?;
        if let Some(v) = &self.gaze_direction {
            v.encode(buf)?;
        }
        self.tick.encode(buf)?;
        self.delta.encode(buf)?;
        if let Some(v) = &self.transaction {
            v.encode(buf)?;
        }
        if let Some(v) = &self.item_stack_request {
            v.encode(buf)?;
        }
        if let Some(v) = &self.predicted_vehicle {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_action {
            v.encode(buf)?;
        }
        self.analogue_move_vector.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let interaction_model = <PacketPlayerAuthInputInteractionModel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let gaze_direction = match play_mode {
            _ => Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let transaction = match input_data_item_interact {
            true => {
                Some(
                    <PacketPlayerAuthInputTransactionSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let item_stack_request = match input_data_item_stack_request {
            true => {
                Some(
                    <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let predicted_vehicle = match input_data_client_predicted_vehicle {
            true => {
                Some(
                    <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let block_action = match input_data_block_action {
            true => {
                Some({
                    let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )? as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <PacketPlayerAuthInputBlockActionSomeItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        let analogue_move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            interaction_model,
            gaze_direction,
            tick,
            delta,
            transaction,
            item_stack_request,
            predicted_vehicle,
            block_action,
            analogue_move_vector,
        })
    }
}
