// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use super::*;
use super::super::packets::*;
use crate::bedrock::codec::BedrockCodec;
pub use crate::bedrock::protocol::v1_17_0::MetadataDictionaryItemKey as MetadataDictionaryItemKey;
pub use crate::bedrock::protocol::v1_16_201::MetadataDictionaryItemType as MetadataDictionaryItemType;
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValueDefault {
    Byte(i8),
    Compound(Vec<u8>),
    Float(f32),
    Int(i32),
    Long(i64),
    Short(i16),
    String(String),
    Vec3F(Vec3F),
    Vec3I(Vec3I),
}
pub use crate::bedrock::protocol::v1_16_210::MetadataFlags1 as MetadataFlags1;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct MetadataFlags2 : u64 {
    const SNEEZING = 1; const TRUSTING = 2; const ROLLING = 4; const SCARED = 8; const
    IN_SCAFFOLDING = 16; const OVER_SCAFFOLDING = 32; const FALL_THROUGH_SCAFFOLDING =
    64; const BLOCKING = 128; const TRANSITION_BLOCKING = 256; const BLOCKED_USING_SHIELD
    = 512; const BLOCKED_USING_DAMAGED_SHIELD = 1024; const SLEEPING = 2048; const
    WANTS_TO_WAKE = 4096; const TRADE_INTEREST = 8192; const DOOR_BREAKER = 16384; const
    BREAKING_OBSTRUCTION = 32768; const DOOR_OPENER = 65536; const ILLAGER_CAPTAIN =
    131072; const STUNNED = 262144; const ROARING = 524288; const DELAYED_ATTACKING =
    1048576; const AVOIDING_MOBS = 2097152; const AVOIDING_BLOCK = 4194304; const
    FACING_TARGET_TO_RANGE_ATTACK = 8388608; const HIDDEN_WHEN_INVISIBLE = 16777216;
    const IS_IN_UI = 33554432; const STALKING = 67108864; const EMOTING = 134217728;
    const CELEBRATING = 268435456; const ADMIRING = 536870912; const CELEBRATING_SPECIAL
    = 1073741824; const UNKNOWN_95 = 2147483648; const RAM_ATTACK = 4294967296; const
    PLAYING_DEAD = 8589934592; const IN_ASCENDABLE_BLOCK = 17179869184; const
    OVER_DESCENDABLE_BLOCK = 34359738368; const CROAKING = 68719476736; const EAT_MOB =
    137438953472; }
}
impl crate::bedrock::codec::BedrockCodec for MetadataFlags2 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::ZigZag64(val as i64).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u64;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Default(Box<Option<MetadataDictionaryItemValueDefault>>),
    Flags(MetadataFlags1),
    FlagsExtended(MetadataFlags2),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: MetadataDictionaryItemValue,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        match &self.value {
            MetadataDictionaryItemValue::Flags(v) => {
                v.encode(buf)?;
            }
            MetadataDictionaryItemValue::FlagsExtended(v) => {
                v.encode(buf)?;
            }
            MetadataDictionaryItemValue::Default(v) => {
                if let Some(v) = (&**v) {
                    match v {
                        MetadataDictionaryItemValueDefault::Byte(v) => {
                            (*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Compound(v) => {
                            (*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Float(v) => {
                            crate::bedrock::codec::F32LE(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Int(v) => {
                            crate::bedrock::codec::ZigZag32(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Long(v) => {
                            crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Short(v) => {
                            crate::bedrock::codec::I16LE(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::String(v) => {
                            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                                (v)
                                    .chars()
                                    .map(|ch| {
                                        let code = ch as u32;
                                        if code <= 0xFF { code as u8 } else { b'?' }
                                    })
                                    .collect()
                            } else {
                                (v).as_bytes().to_vec()
                            };
                            let len = bytes.len();
                            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                            buf.put_slice(&bytes);
                        }
                        MetadataDictionaryItemValueDefault::Vec3F(v) => {
                            v.encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Vec3I(v) => {
                            v.encode(buf)?;
                        }
                    }
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match key {
            MetadataDictionaryItemKey::Flags => {
                MetadataDictionaryItemValue::Flags(
                    <MetadataFlags1 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            MetadataDictionaryItemKey::FlagsExtended => {
                MetadataDictionaryItemValue::FlagsExtended(
                    <MetadataFlags2 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::Default(
                    Box::new(
                        match type_ {
                            MetadataDictionaryItemType::Byte => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Byte(
                                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Compound => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Compound(
                                        <Vec<
                                            u8,
                                        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Float => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Float(
                                        <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Int => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Int(
                                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Long => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Long(
                                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Short => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Short(
                                        <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::String => {
                                Some(
                                    MetadataDictionaryItemValueDefault::String({
                                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0) as i64;
                                        if len_raw < 0 {
                                            return Err(
                                                std::io::Error::new(
                                                    std::io::ErrorKind::InvalidData,
                                                    "string length cannot be negative",
                                                ),
                                            );
                                        }
                                        let len = len_raw as usize;
                                        if buf.remaining() < len {
                                            return Err(
                                                std::io::Error::new(
                                                    std::io::ErrorKind::UnexpectedEof,
                                                    format!(
                                                        "string declared length {} exceeds remaining {}", len, buf
                                                        .remaining()
                                                    ),
                                                ),
                                            );
                                        }
                                        let mut bytes = vec![0u8; len];
                                        buf.copy_to_slice(&mut bytes);
                                        let s = if "".eq_ignore_ascii_case("latin1") {
                                            bytes.into_iter().map(|b| b as char).collect::<String>()
                                        } else {
                                            String::from_utf8_lossy(&bytes).into_owned()
                                        };
                                        s
                                    }),
                                )
                            }
                            MetadataDictionaryItemType::Vec3F => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3F(
                                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3I => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3I(
                                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                        },
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
pub type MetadataDictionary = Vec<MetadataDictionaryItem>;
