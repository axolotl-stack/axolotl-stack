// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithCachingItemHeightmapType {
    NoData = 0,
    HasData = 1,
    TooHigh = 2,
    TooLow = 3,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItemHeightmapType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(SubChunkEntryWithCachingItemHeightmapType::NoData),
            1 => Ok(SubChunkEntryWithCachingItemHeightmapType::HasData),
            2 => Ok(SubChunkEntryWithCachingItemHeightmapType::TooHigh),
            3 => Ok(SubChunkEntryWithCachingItemHeightmapType::TooLow),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithCachingItemHeightmapType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithCachingItemResult {
    Undefined = 0,
    Success = 1,
    ChunkNotFound = 2,
    InvalidDimension = 3,
    PlayerNotFound = 4,
    YIndexOutOfBounds = 5,
    SuccessAllAir = 6,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItemResult {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(SubChunkEntryWithCachingItemResult::Undefined),
            1 => Ok(SubChunkEntryWithCachingItemResult::Success),
            2 => Ok(SubChunkEntryWithCachingItemResult::ChunkNotFound),
            3 => Ok(SubChunkEntryWithCachingItemResult::InvalidDimension),
            4 => Ok(SubChunkEntryWithCachingItemResult::PlayerNotFound),
            5 => Ok(SubChunkEntryWithCachingItemResult::YIndexOutOfBounds),
            6 => Ok(SubChunkEntryWithCachingItemResult::SuccessAllAir),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithCachingItemResult), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SubChunkEntryWithCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub payload: Option<ByteArray>,
    pub heightmap_type: SubChunkEntryWithCachingItemHeightmapType,
    pub heightmap: Option<Vec<u8>>,
    pub blob_id: u64,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        let val = self.payload.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.payload {
            v.encode(buf)?;
        }
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            v.encode(buf)?;
        }
        self.blob_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let result = <SubChunkEntryWithCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let payload = match result {
            SubChunkEntryWithCachingItemResult::SuccessAllAir => None,
            _ => Some(<ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
        };
        let heightmap_type = <SubChunkEntryWithCachingItemHeightmapType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let heightmap = match heightmap_type {
            SubChunkEntryWithCachingItemHeightmapType::HasData => {
                Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            }
            _ => None,
        };
        let blob_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            dx,
            dy,
            dz,
            payload,
            heightmap_type,
            heightmap,
            blob_id,
        })
    }
}
pub type SubChunkEntryWithCaching = Vec<SubChunkEntryWithCachingItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithoutCachingItemResult {
    Undefined = 0,
    Success = 1,
    ChunkNotFound = 2,
    InvalidDimension = 3,
    PlayerNotFound = 4,
    YIndexOutOfBounds = 5,
    SuccessAllAir = 6,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithoutCachingItemResult {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(SubChunkEntryWithoutCachingItemResult::Undefined),
            1 => Ok(SubChunkEntryWithoutCachingItemResult::Success),
            2 => Ok(SubChunkEntryWithoutCachingItemResult::ChunkNotFound),
            3 => Ok(SubChunkEntryWithoutCachingItemResult::InvalidDimension),
            4 => Ok(SubChunkEntryWithoutCachingItemResult::PlayerNotFound),
            5 => Ok(SubChunkEntryWithoutCachingItemResult::YIndexOutOfBounds),
            6 => Ok(SubChunkEntryWithoutCachingItemResult::SuccessAllAir),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithoutCachingItemResult), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithoutCachingItemHeightmapType {
    NoData = 0,
    HasData = 1,
    TooHigh = 2,
    TooLow = 3,
}
impl crate::bedrock::codec::BedrockCodec
for SubChunkEntryWithoutCachingItemHeightmapType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::NoData),
            1 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::HasData),
            2 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::TooHigh),
            3 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::TooLow),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithoutCachingItemHeightmapType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SubChunkEntryWithoutCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub result: SubChunkEntryWithoutCachingItemResult,
    pub payload: ByteArray,
    pub heightmap_type: SubChunkEntryWithoutCachingItemHeightmapType,
    pub heightmap: Option<Vec<u8>>,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithoutCachingItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        self.result.encode(buf)?;
        self.payload.encode(buf)?;
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let result = <SubChunkEntryWithoutCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let heightmap_type = <SubChunkEntryWithoutCachingItemHeightmapType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let heightmap = match heightmap_type {
            SubChunkEntryWithoutCachingItemHeightmapType::HasData => {
                Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            }
            _ => None,
        };
        Ok(Self {
            dx,
            dy,
            dz,
            result,
            payload,
            heightmap_type,
            heightmap,
        })
    }
}
pub type SubChunkEntryWithoutCaching = Vec<SubChunkEntryWithoutCachingItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PacketLevelChunk {
    pub x: crate::bedrock::codec::ZigZag32,
    pub z: crate::bedrock::codec::ZigZag32,
    pub sub_chunk_count: i32,
    pub highest_subchunk_count: Option<u16>,
    pub cache_enabled: bool,
    pub blobs: Option<PacketLevelChunkBlobsSome>,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for PacketLevelChunk {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.z.encode(buf)?;
        self.sub_chunk_count.encode(buf)?;
        if let Some(v) = &self.highest_subchunk_count {
            v.encode(buf)?;
        }
        self.cache_enabled.encode(buf)?;
        if let Some(v) = &self.blobs {
            v.encode(buf)?;
        }
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let sub_chunk_count = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let highest_subchunk_count = match sub_chunk_count {
            -2 => Some(<u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?),
            _ => None,
        };
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let blobs = match cache_enabled {
            true => {
                Some(
                    <PacketLevelChunkBlobsSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self {
            x,
            z,
            sub_chunk_count,
            highest_subchunk_count,
            cache_enabled,
            blobs,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PacketSubchunkEntries {
    False(SubChunkEntryWithoutCaching),
    True(SubChunkEntryWithCaching),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunk {
    pub cache_enabled: bool,
    pub dimension: crate::bedrock::codec::ZigZag32,
    pub origin: Vec3I,
    pub entries: Option<PacketSubchunkEntries>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunk {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.cache_enabled.encode(buf)?;
        self.dimension.encode(buf)?;
        self.origin.encode(buf)?;
        if let Some(v) = &self.entries {
            match v {
                PacketSubchunkEntries::False(v) => v.encode(buf)?,
                PacketSubchunkEntries::True(v) => v.encode(buf)?,
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let entries = match cache_enabled {
            false => {
                Some(
                    PacketSubchunkEntries::False(
                        <SubChunkEntryWithoutCaching as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            true => {
                Some(
                    PacketSubchunkEntries::True(
                        <SubChunkEntryWithCaching as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            cache_enabled,
            dimension,
            origin,
            entries,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunkRequestRequestsItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequestRequestsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { dx, dy, dz })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunkRequest {
    pub dimension: crate::bedrock::codec::ZigZag32,
    pub origin: Vec3I,
    pub requests: Vec<PacketSubchunkRequestRequestsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequest {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dimension.encode(buf)?;
        self.origin.encode(buf)?;
        let len = self.requests.len();
        (len as u32).encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let requests = {
            let len = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSubchunkRequestRequestsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            dimension,
            origin,
            requests,
        })
    }
}
