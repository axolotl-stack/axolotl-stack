// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub enum PacketSubchunkEntries {
    False(SubChunkEntryWithoutCaching),
    True(SubChunkEntryWithCaching),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunk {
    pub dimension: i32,
    pub origin: Vec3I,
    pub entries: Option<PacketSubchunkEntries>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunk {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = self.entries.is_none();
        val.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.origin.encode(buf)?;
        if let Some(v) = &self.entries {
            match v {
                PacketSubchunkEntries::False(v) => {
                    let len = v.len();
                    crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
                    for item in v {
                        item.encode(buf)?;
                    }
                }
                PacketSubchunkEntries::True(v) => {
                    let len = v.len();
                    crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
                    for item in v {
                        item.encode(buf)?;
                    }
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entries = if cache_enabled {
            Some(
                PacketSubchunkEntries::True({
                    let res: SubChunkEntryWithCaching = {
                        let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <SubChunkEntryWithCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?,
                                );
                        }
                        tmp_vec
                    };
                    res
                }),
            )
        } else {
            Some(
                PacketSubchunkEntries::False({
                    let res: SubChunkEntryWithoutCaching = {
                        let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <SubChunkEntryWithoutCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?,
                                );
                        }
                        tmp_vec
                    };
                    res
                }),
            )
        };
        Ok(Self { dimension, origin, entries })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunkRequestRequestsItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequestRequestsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { dx, dy, dz })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketSubchunkRequest {
    pub dimension: i32,
    pub origin: Vec3I,
    pub requests: Vec<PacketSubchunkRequestRequestsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.origin.encode(buf)?;
        let len = self.requests.len();
        crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let requests = {
            let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSubchunkRequestRequestsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            dimension,
            origin,
            requests,
        })
    }
}
