// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    Int = 1,
    Float = 3,
    Value = 4,
    WildcardInt = 5,
    Operator = 6,
    CommandOperator = 7,
    Target = 8,
    WildcardTarget = 10,
    FilePath = 17,
    IntegerRange = 23,
    EquipmentSlots = 38,
    String = 39,
    BlockPosition = 47,
    Position = 48,
    Message = 51,
    RawText = 53,
    Json = 57,
    BlockStates = 67,
    Command = 70,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            1 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Int,
                )
            }
            3 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Float,
                )
            }
            4 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Value,
                )
            }
            5 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardInt,
                )
            }
            6 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Operator,
                )
            }
            7 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::CommandOperator,
                )
            }
            8 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Target,
                )
            }
            10 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::WildcardTarget,
                )
            }
            17 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::FilePath,
                )
            }
            23 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::IntegerRange,
                )
            }
            38 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::EquipmentSlots,
                )
            }
            39 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::String,
                )
            }
            47 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::BlockPosition,
                )
            }
            48 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Position,
                )
            }
            51 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Message,
                )
            }
            53 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::RawText,
                )
            }
            57 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Json,
                )
            }
            67 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::BlockStates,
                )
            }
            70 => {
                Ok(
                    PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType::Command,
                )
            }
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    pub parameter_name: String,
    pub value_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType,
    pub enum_type: PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType,
    pub optional: bool,
    pub options: CommandFlags,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.parameter_name.encode(buf)?;
        self.value_type.encode(buf)?;
        self.enum_type.encode(buf)?;
        self.optional.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameter_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let enum_type = <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItemEnumType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let optional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let options = <CommandFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            parameter_name,
            value_type,
            enum_type,
            optional,
            options,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItemOverloadsItem {
    pub parameters: Vec<
        PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem,
    >,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsCommandDataItemOverloadsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let parameters = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?.0
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItemParametersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { parameters })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAction {
    pub runtime_entity_id: i64,
    pub action: Action,
    pub position: BlockCoordinates,
    pub result_position: BlockCoordinates,
    pub face: crate::bedrock::codec::ZigZag32,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAction {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.runtime_entity_id.encode(buf)?;
        self.action.encode(buf)?;
        self.position.encode(buf)?;
        self.result_position.encode(buf)?;
        self.face.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let runtime_entity_id = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let action = <Action as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let result_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self {
            runtime_entity_id,
            action,
            position,
            result_position,
            face,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketPlayerAuthInputInteractionModel {
    Touch = 0,
    Crosshair = 1,
    Classic = 2,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInputInteractionModel {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketPlayerAuthInputInteractionModel::Touch),
            1 => Ok(PacketPlayerAuthInputInteractionModel::Crosshair),
            2 => Ok(PacketPlayerAuthInputInteractionModel::Classic),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketPlayerAuthInputInteractionModel), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketPlayerAuthInput {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PacketPlayerAuthInputInputMode,
    pub play_mode: PacketPlayerAuthInputPlayMode,
    pub interaction_model: PacketPlayerAuthInputInteractionModel,
    pub gaze_direction: Option<Vec3F>,
    pub tick: i64,
    pub delta: Vec3F,
    pub transaction: Option<PacketPlayerAuthInputTransactionSome>,
    pub item_stack_request: Option<ItemStackRequest>,
    pub block_action: Option<Vec<PacketPlayerAuthInputBlockActionSomeItem>>,
}
impl crate::bedrock::codec::BedrockCodec for PacketPlayerAuthInput {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pitch.encode(buf)?;
        self.yaw.encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        self.head_yaw.encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        self.interaction_model.encode(buf)?;
        if let Some(v) = &self.gaze_direction {
            v.encode(buf)?;
        }
        self.tick.encode(buf)?;
        self.delta.encode(buf)?;
        if let Some(v) = &self.transaction {
            v.encode(buf)?;
        }
        if let Some(v) = &self.item_stack_request {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_action {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let pitch = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let head_yaw = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let input_mode = <PacketPlayerAuthInputInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let play_mode = <PacketPlayerAuthInputPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let interaction_model = <PacketPlayerAuthInputInteractionModel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let gaze_direction = match play_mode {
            PacketPlayerAuthInputPlayMode::Reality => {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?)
            }
            _ => None,
        };
        let tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let transaction = match input_data.contains(InputFlag::ITEM_INTERACT) {
            true => {
                Some(
                    <PacketPlayerAuthInputTransactionSome as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let item_stack_request = match input_data.contains(InputFlag::ITEM_STACK_REQUEST)
        {
            true => {
                Some(
                    <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                    )?,
                )
            }
            _ => None,
        };
        let block_action = match input_data.contains(InputFlag::BLOCK_ACTION) {
            true => {
                Some({
                    let len = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?
                        .0 as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <PacketPlayerAuthInputBlockActionSomeItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            interaction_model,
            gaze_direction,
            tick,
            delta,
            transaction,
            item_stack_request,
            block_action,
        })
    }
}
