// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum AbilityLayersType {
    Cache = 0,
    Base = 1,
    Spectator = 2,
    Commands = 3,
    Editor = 4,
}
impl crate::bedrock::codec::BedrockCodec for AbilityLayersType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(AbilityLayersType::Cache),
            1 => Ok(AbilityLayersType::Base),
            2 => Ok(AbilityLayersType::Spectator),
            3 => Ok(AbilityLayersType::Commands),
            4 => Ok(AbilityLayersType::Editor),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(AbilityLayersType), val
                        ),
                    ),
                )
            }
        }
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct AbilitySet : u32 {
    const BUILD = 1; const MINE = 2; const DOORS_AND_SWITCHES = 4; const OPEN_CONTAINERS
    = 8; const ATTACK_PLAYERS = 16; const ATTACK_MOBS = 32; const OPERATOR_COMMANDS = 64;
    const TELEPORT = 128; const INVULNERABLE = 256; const FLYING = 512; const MAY_FLY =
    1024; const INSTANT_BUILD = 2048; const LIGHTNING = 4096; const FLY_SPEED = 8192;
    const WALK_SPEED = 16384; const MUTED = 32768; const WORLD_BUILDER = 65536; const
    NO_CLIP = 131072; const PRIVILEGED_BUILDER = 262144; const COUNT = 524288; }
}
impl crate::bedrock::codec::BedrockCodec for AbilitySet {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        (val as u32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct AbilityLayers {
    pub type_: AbilityLayersType,
    pub allowed: AbilitySet,
    pub enabled: AbilitySet,
    pub fly_speed: f32,
    pub walk_speed: f32,
}
impl crate::bedrock::codec::BedrockCodec for AbilityLayers {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.allowed.encode(buf)?;
        self.enabled.encode(buf)?;
        self.fly_speed.encode(buf)?;
        self.walk_speed.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <AbilityLayersType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let allowed = <AbilitySet as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let enabled = <AbilitySet as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let fly_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let walk_speed = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            type_,
            allowed,
            enabled,
            fly_speed,
            walk_speed,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum Action {
    StartBreak = 0,
    AbortBreak = 1,
    StopBreak = 2,
    GetUpdatedBlock = 3,
    DropItem = 4,
    StartSleeping = 5,
    StopSleeping = 6,
    Respawn = 7,
    Jump = 8,
    StartSprint = 9,
    StopSprint = 10,
    StartSneak = 11,
    StopSneak = 12,
    CreativePlayerDestroyBlock = 13,
    DimensionChangeAck = 14,
    StartGlide = 15,
    StopGlide = 16,
    BuildDenied = 17,
    CrackBreak = 18,
    ChangeSkin = 19,
    SetEnchatnmentSeed = 20,
    Swimming = 21,
    StopSwimming = 22,
    StartSpinAttack = 23,
    StopSpinAttack = 24,
    InteractBlock = 25,
    PredictBreak = 26,
    ContinueBreak = 27,
    StartItemUseOn = 28,
    StopItemUseOn = 29,
    HandledTeleport = 30,
    MissedSwing = 31,
    StartCrawling = 32,
    StopCrawling = 33,
}
impl crate::bedrock::codec::BedrockCodec for Action {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(Action::StartBreak),
            1 => Ok(Action::AbortBreak),
            2 => Ok(Action::StopBreak),
            3 => Ok(Action::GetUpdatedBlock),
            4 => Ok(Action::DropItem),
            5 => Ok(Action::StartSleeping),
            6 => Ok(Action::StopSleeping),
            7 => Ok(Action::Respawn),
            8 => Ok(Action::Jump),
            9 => Ok(Action::StartSprint),
            10 => Ok(Action::StopSprint),
            11 => Ok(Action::StartSneak),
            12 => Ok(Action::StopSneak),
            13 => Ok(Action::CreativePlayerDestroyBlock),
            14 => Ok(Action::DimensionChangeAck),
            15 => Ok(Action::StartGlide),
            16 => Ok(Action::StopGlide),
            17 => Ok(Action::BuildDenied),
            18 => Ok(Action::CrackBreak),
            19 => Ok(Action::ChangeSkin),
            20 => Ok(Action::SetEnchatnmentSeed),
            21 => Ok(Action::Swimming),
            22 => Ok(Action::StopSwimming),
            23 => Ok(Action::StartSpinAttack),
            24 => Ok(Action::StopSpinAttack),
            25 => Ok(Action::InteractBlock),
            26 => Ok(Action::PredictBreak),
            27 => Ok(Action::ContinueBreak),
            28 => Ok(Action::StartItemUseOn),
            29 => Ok(Action::StopItemUseOn),
            30 => Ok(Action::HandledTeleport),
            31 => Ok(Action::MissedSwing),
            32 => Ok(Action::StartCrawling),
            33 => Ok(Action::StopCrawling),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!("Invalid enum value for {}: {}", stringify!(Action), val),
                    ),
                )
            }
        }
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct ActionPermissions : u32
    { const ATTACK_MOBS = 65552; const ATTACK_PLAYERS = 65544; const BUILD = 65792; const
    DEFAULT = 66048; const DOORS_AND_SWITCHES = 65538; const MINE = 65537; const
    OPEN_CONTAINERS = 65540; const OPERATOR = 65568; const TELEPORT = 65664; }
}
impl crate::bedrock::codec::BedrockCodec for ActionPermissions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct AdventureFlags : u32 {
    const ALLOW_FLIGHT = 64; const AUTO_JUMP = 32; const FLYING = 512; const MUTED =
    1024; const NO_CLIP = 128; const NO_PVP = 2; const WORLD_BUILDER = 256; const
    WORLD_IMMUTABLE = 1; }
}
impl crate::bedrock::codec::BedrockCodec for AdventureFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct ArmorDamageType : u8 {
    const CHEST = 2; const FEET = 8; const HEAD = 1; const LEGS = 4; }
}
impl crate::bedrock::codec::BedrockCodec for ArmorDamageType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        (val as u8).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw as u8;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BehaviourPackInfosItem {
    pub uuid: String,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
}
impl crate::bedrock::codec::BedrockCodec for BehaviourPackInfosItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.size.encode(buf)?;
        self.content_key.encode(buf)?;
        self.sub_pack_name.encode(buf)?;
        self.content_identity.encode(buf)?;
        self.has_scripts.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content_key = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let sub_pack_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content_identity = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
        })
    }
}
pub type BehaviourPackInfos = Vec<BehaviourPackInfosItem>;
pub type ByteArray = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Blob {
    pub hash: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for Blob {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.hash.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let hash = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { hash, payload })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BlockCoordinates {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for BlockCoordinates {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.y as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BlockPropertiesItem {
    pub name: String,
    pub state: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for BlockPropertiesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.state.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let state = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, state })
    }
}
pub type BlockProperties = Vec<BlockPropertiesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BlockUpdateTransitionType {
    Entity = 0,
    Create = 1,
    Destroy = 2,
}
impl crate::bedrock::codec::BedrockCodec for BlockUpdateTransitionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(BlockUpdateTransitionType::Entity),
            1 => Ok(BlockUpdateTransitionType::Create),
            2 => Ok(BlockUpdateTransitionType::Destroy),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(BlockUpdateTransitionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BlockUpdate {
    pub position: BlockCoordinates,
    pub runtime_id: i32,
    pub flags: i32,
    pub entity_unique_id: i64,
    pub transition_type: BlockUpdateTransitionType,
}
impl crate::bedrock::codec::BedrockCodec for BlockUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.runtime_id as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.flags as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id as i64).encode(buf)?;
        self.transition_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let flags = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let transition_type = <BlockUpdateTransitionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            position,
            runtime_id,
            flags,
            entity_unique_id,
            transition_type,
        })
    }
}
pub type CommandFlags = u8;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CommandOriginType {
    Player = 0,
    Block = 1,
    MinecartBlock = 2,
    DevConsole = 3,
    Test = 4,
    AutomationPlayer = 5,
    ClientAutomation = 6,
    DedicatedServer = 7,
    Entity = 8,
    Virtual = 9,
    GameArgument = 10,
    EntityServer = 11,
    Precompiled = 12,
    GameDirectorEntityServer = 13,
    Script = 14,
    Executor = 15,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandOriginType::Player),
            1 => Ok(CommandOriginType::Block),
            2 => Ok(CommandOriginType::MinecartBlock),
            3 => Ok(CommandOriginType::DevConsole),
            4 => Ok(CommandOriginType::Test),
            5 => Ok(CommandOriginType::AutomationPlayer),
            6 => Ok(CommandOriginType::ClientAutomation),
            7 => Ok(CommandOriginType::DedicatedServer),
            8 => Ok(CommandOriginType::Entity),
            9 => Ok(CommandOriginType::Virtual),
            10 => Ok(CommandOriginType::GameArgument),
            11 => Ok(CommandOriginType::EntityServer),
            12 => Ok(CommandOriginType::Precompiled),
            13 => Ok(CommandOriginType::GameDirectorEntityServer),
            14 => Ok(CommandOriginType::Script),
            15 => Ok(CommandOriginType::Executor),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CommandOriginType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOriginPlayerEntityIdDevConsole {
    pub player_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginPlayerEntityIdDevConsole {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.player_entity_id as i64).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let player_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        Ok(Self { player_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum CommandOriginPlayerEntityId {
    DevConsole(CommandOriginPlayerEntityIdDevConsole),
    Test(CommandOriginPlayerEntityIdDevConsole),
}
#[derive(Debug, Clone, PartialEq)]
pub struct CommandOrigin {
    pub type_: CommandOriginType,
    pub uuid: uuid::Uuid,
    pub request_id: String,
    pub player_entity_id: Option<CommandOriginPlayerEntityId>,
}
impl crate::bedrock::codec::BedrockCodec for CommandOrigin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.uuid.encode(buf)?;
        self.request_id.encode(buf)?;
        if let Some(v) = &self.player_entity_id {
            match v {
                CommandOriginPlayerEntityId::DevConsole(v) => {
                    v.encode(buf)?;
                }
                CommandOriginPlayerEntityId::Test(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <CommandOriginType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let request_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_entity_id = match type_ {
            CommandOriginType::DevConsole => {
                Some(
                    CommandOriginPlayerEntityId::DevConsole(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            CommandOriginType::Test => {
                Some(
                    CommandOriginPlayerEntityId::Test(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            uuid,
            request_id,
            player_entity_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CommandPermissionLevel {
    Normal = 0,
    Operator = 1,
    Automation = 2,
    Host = 3,
    Owner = 4,
    Internal = 5,
}
impl crate::bedrock::codec::BedrockCodec for CommandPermissionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandPermissionLevel::Normal),
            1 => Ok(CommandPermissionLevel::Operator),
            2 => Ok(CommandPermissionLevel::Automation),
            3 => Ok(CommandPermissionLevel::Host),
            4 => Ok(CommandPermissionLevel::Owner),
            5 => Ok(CommandPermissionLevel::Internal),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CommandPermissionLevel), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CommandPermissionLevelVarint {
    Normal = 0,
    Operator = 1,
    Automation = 2,
    Host = 3,
    Owner = 4,
    Internal = 5,
}
impl crate::bedrock::codec::BedrockCodec for CommandPermissionLevelVarint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandPermissionLevelVarint::Normal),
            1 => Ok(CommandPermissionLevelVarint::Operator),
            2 => Ok(CommandPermissionLevelVarint::Automation),
            3 => Ok(CommandPermissionLevelVarint::Host),
            4 => Ok(CommandPermissionLevelVarint::Owner),
            5 => Ok(CommandPermissionLevelVarint::Internal),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(CommandPermissionLevelVarint), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ContainerSlotType {
    AnvilInput = 0,
    AnvilMaterial = 1,
    AnvilResult = 2,
    SmithingTableInput = 3,
    SmithingTableMaterial = 4,
    SmithingTableResult = 5,
    Armor = 6,
    Container = 7,
    BeaconPayment = 8,
    BrewingInput = 9,
    BrewingResult = 10,
    BrewingFuel = 11,
    HotbarAndInventory = 12,
    CraftingInput = 13,
    CraftingOutput = 14,
    RecipeConstruction = 15,
    RecipeNature = 16,
    RecipeItems = 17,
    RecipeSearch = 18,
    RecipeSearchBar = 19,
    RecipeEquipment = 20,
    RecipeBook = 21,
    EnchantingInput = 22,
    EnchantingLapis = 23,
    FurnaceFuel = 24,
    FurnaceIngredient = 25,
    FurnaceOutput = 26,
    HorseEquip = 27,
    Hotbar = 28,
    Inventory = 29,
    Shulker = 30,
    TradeIngredient1 = 31,
    TradeIngredient2 = 32,
    TradeResult = 33,
    Offhand = 34,
    CompcreateInput = 35,
    CompcreateOutput = 36,
    ElemconstructOutput = 37,
    MatreduceInput = 38,
    MatreduceOutput = 39,
    LabtableInput = 40,
    LoomInput = 41,
    LoomDye = 42,
    LoomMaterial = 43,
    LoomResult = 44,
    BlastFurnaceIngredient = 45,
    SmokerIngredient = 46,
    Trade2Ingredient1 = 47,
    Trade2Ingredient2 = 48,
    Trade2Result = 49,
    GrindstoneInput = 50,
    GrindstoneAdditional = 51,
    GrindstoneResult = 52,
    StonecutterInput = 53,
    StonecutterResult = 54,
    CartographyInput = 55,
    CartographyAdditional = 56,
    CartographyResult = 57,
    Barrel = 58,
    Cursor = 59,
    CreativeOutput = 60,
    SmithingTableTemplate = 61,
}
impl crate::bedrock::codec::BedrockCodec for ContainerSlotType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ContainerSlotType::AnvilInput),
            1 => Ok(ContainerSlotType::AnvilMaterial),
            2 => Ok(ContainerSlotType::AnvilResult),
            3 => Ok(ContainerSlotType::SmithingTableInput),
            4 => Ok(ContainerSlotType::SmithingTableMaterial),
            5 => Ok(ContainerSlotType::SmithingTableResult),
            6 => Ok(ContainerSlotType::Armor),
            7 => Ok(ContainerSlotType::Container),
            8 => Ok(ContainerSlotType::BeaconPayment),
            9 => Ok(ContainerSlotType::BrewingInput),
            10 => Ok(ContainerSlotType::BrewingResult),
            11 => Ok(ContainerSlotType::BrewingFuel),
            12 => Ok(ContainerSlotType::HotbarAndInventory),
            13 => Ok(ContainerSlotType::CraftingInput),
            14 => Ok(ContainerSlotType::CraftingOutput),
            15 => Ok(ContainerSlotType::RecipeConstruction),
            16 => Ok(ContainerSlotType::RecipeNature),
            17 => Ok(ContainerSlotType::RecipeItems),
            18 => Ok(ContainerSlotType::RecipeSearch),
            19 => Ok(ContainerSlotType::RecipeSearchBar),
            20 => Ok(ContainerSlotType::RecipeEquipment),
            21 => Ok(ContainerSlotType::RecipeBook),
            22 => Ok(ContainerSlotType::EnchantingInput),
            23 => Ok(ContainerSlotType::EnchantingLapis),
            24 => Ok(ContainerSlotType::FurnaceFuel),
            25 => Ok(ContainerSlotType::FurnaceIngredient),
            26 => Ok(ContainerSlotType::FurnaceOutput),
            27 => Ok(ContainerSlotType::HorseEquip),
            28 => Ok(ContainerSlotType::Hotbar),
            29 => Ok(ContainerSlotType::Inventory),
            30 => Ok(ContainerSlotType::Shulker),
            31 => Ok(ContainerSlotType::TradeIngredient1),
            32 => Ok(ContainerSlotType::TradeIngredient2),
            33 => Ok(ContainerSlotType::TradeResult),
            34 => Ok(ContainerSlotType::Offhand),
            35 => Ok(ContainerSlotType::CompcreateInput),
            36 => Ok(ContainerSlotType::CompcreateOutput),
            37 => Ok(ContainerSlotType::ElemconstructOutput),
            38 => Ok(ContainerSlotType::MatreduceInput),
            39 => Ok(ContainerSlotType::MatreduceOutput),
            40 => Ok(ContainerSlotType::LabtableInput),
            41 => Ok(ContainerSlotType::LoomInput),
            42 => Ok(ContainerSlotType::LoomDye),
            43 => Ok(ContainerSlotType::LoomMaterial),
            44 => Ok(ContainerSlotType::LoomResult),
            45 => Ok(ContainerSlotType::BlastFurnaceIngredient),
            46 => Ok(ContainerSlotType::SmokerIngredient),
            47 => Ok(ContainerSlotType::Trade2Ingredient1),
            48 => Ok(ContainerSlotType::Trade2Ingredient2),
            49 => Ok(ContainerSlotType::Trade2Result),
            50 => Ok(ContainerSlotType::GrindstoneInput),
            51 => Ok(ContainerSlotType::GrindstoneAdditional),
            52 => Ok(ContainerSlotType::GrindstoneResult),
            53 => Ok(ContainerSlotType::StonecutterInput),
            54 => Ok(ContainerSlotType::StonecutterResult),
            55 => Ok(ContainerSlotType::CartographyInput),
            56 => Ok(ContainerSlotType::CartographyAdditional),
            57 => Ok(ContainerSlotType::CartographyResult),
            58 => Ok(ContainerSlotType::Barrel),
            59 => Ok(ContainerSlotType::Cursor),
            60 => Ok(ContainerSlotType::CreativeOutput),
            61 => Ok(ContainerSlotType::SmithingTableTemplate),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ContainerSlotType), val
                        ),
                    ),
                )
            }
        }
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct DeltaMoveFlags : u16 {
    const FORCE_MOVE = 256; const HAS_ROT_X = 8; const HAS_ROT_Y = 16; const HAS_ROT_Z =
    32; const HAS_X = 1; const HAS_Y = 2; const HAS_Z = 4; const ON_GROUND = 64; const
    TELEPORT = 128; }
}
impl crate::bedrock::codec::BedrockCodec for DeltaMoveFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        (val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw as u16;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum DeviceOs {
    Undefined = 0,
    Android = 1,
    Ios = 2,
    Osx = 3,
    FireOs = 4,
    GearVr = 5,
    Hololens = 6,
    Win10 = 7,
    Win32 = 8,
    Dedicated = 9,
    Tvos = 10,
    Orbis = 11,
    NintendoSwitch = 12,
    Xbox = 13,
    WindowsPhone = 14,
    Linux = 15,
}
impl crate::bedrock::codec::BedrockCodec for DeviceOs {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(DeviceOs::Undefined),
            1 => Ok(DeviceOs::Android),
            2 => Ok(DeviceOs::Ios),
            3 => Ok(DeviceOs::Osx),
            4 => Ok(DeviceOs::FireOs),
            5 => Ok(DeviceOs::GearVr),
            6 => Ok(DeviceOs::Hololens),
            7 => Ok(DeviceOs::Win10),
            8 => Ok(DeviceOs::Win32),
            9 => Ok(DeviceOs::Dedicated),
            10 => Ok(DeviceOs::Tvos),
            11 => Ok(DeviceOs::Orbis),
            12 => Ok(DeviceOs::NintendoSwitch),
            13 => Ok(DeviceOs::Xbox),
            14 => Ok(DeviceOs::WindowsPhone),
            15 => Ok(DeviceOs::Linux),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(DeviceOs), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EducationExternalLinkSettings {
    pub url: String,
    pub display_name: String,
}
impl crate::bedrock::codec::BedrockCodec for EducationExternalLinkSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.url.encode(buf)?;
        self.display_name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let url = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let display_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { url, display_name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EducationSharedResourceUri {
    pub button_name: String,
    pub link_uri: String,
}
impl crate::bedrock::codec::BedrockCodec for EducationSharedResourceUri {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.button_name.encode(buf)?;
        self.link_uri.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let button_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let link_uri = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { button_name, link_uri })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Enchant {
    pub id: u8,
    pub level: u8,
}
impl crate::bedrock::codec::BedrockCodec for Enchant {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        self.level.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { id, level })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EnchantOption {
    pub cost: i32,
    pub slot_flags: i32,
    pub equip_enchants: Vec<Enchant>,
    pub held_enchants: Vec<Enchant>,
    pub self_enchants: Vec<Enchant>,
    pub name: String,
    pub option_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for EnchantOption {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.cost as i32).encode(buf)?;
        self.slot_flags.encode(buf)?;
        let len = self.equip_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.equip_enchants {
            item.encode(buf)?;
        }
        let len = self.held_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.held_enchants {
            item.encode(buf)?;
        }
        let len = self.self_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.self_enchants {
            item.encode(buf)?;
        }
        self.name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.option_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let cost = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let slot_flags = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let equip_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let held_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let self_enchants = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let option_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            cost,
            slot_flags,
            equip_enchants,
            held_enchants,
            self_enchants,
            name,
            option_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EntityAttributesItem {
    pub name: String,
    pub min: f32,
    pub value: f32,
    pub max: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntityAttributesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.min.encode(buf)?;
        self.value.encode(buf)?;
        self.max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let value = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, min, value, max })
    }
}
pub type EntityAttributes = Vec<EntityAttributesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct EntityPropertiesIntsItem {
    pub index: i32,
    pub value: i32,
}
impl crate::bedrock::codec::BedrockCodec for EntityPropertiesIntsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.index as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.value as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let index = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { index, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EntityPropertiesFloatsItem {
    pub index: i32,
    pub value: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntityPropertiesFloatsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.index as i32).encode(buf)?;
        self.value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let index = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let value = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { index, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct EntityProperties {
    pub ints: Vec<EntityPropertiesIntsItem>,
    pub floats: Vec<EntityPropertiesFloatsItem>,
}
impl crate::bedrock::codec::BedrockCodec for EntityProperties {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.ints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.ints {
            item.encode(buf)?;
        }
        let len = self.floats.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.floats {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let ints = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <EntityPropertiesIntsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let floats = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <EntityPropertiesFloatsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { ints, floats })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Experiment {
    pub name: String,
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for Experiment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, enabled })
    }
}
pub type Experiments = Vec<Experiment>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameMode {
    Survival = 0,
    Creative = 1,
    Adventure = 2,
    SurvivalSpectator = 3,
    CreativeSpectator = 4,
    Fallback = 5,
    Spectator = 6,
}
impl crate::bedrock::codec::BedrockCodec for GameMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(GameMode::Survival),
            1 => Ok(GameMode::Creative),
            2 => Ok(GameMode::Adventure),
            3 => Ok(GameMode::SurvivalSpectator),
            4 => Ok(GameMode::CreativeSpectator),
            5 => Ok(GameMode::Fallback),
            6 => Ok(GameMode::Spectator),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(GameMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameRuleType {
    Bool = 1,
    Int = 2,
    Float = 3,
}
impl crate::bedrock::codec::BedrockCodec for GameRuleType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(GameRuleType::Bool),
            2 => Ok(GameRuleType::Int),
            3 => Ok(GameRuleType::Float),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(GameRuleType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum GameRuleValue {
    Bool(bool),
    Float(f32),
    Int(i32),
}
#[derive(Debug, Clone, PartialEq)]
pub struct GameRule {
    pub name: String,
    pub editable: bool,
    pub type_: GameRuleType,
    pub value: Option<GameRuleValue>,
}
impl crate::bedrock::codec::BedrockCodec for GameRule {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.editable.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                GameRuleValue::Bool(v) => {
                    (*v).encode(buf)?;
                }
                GameRuleValue::Float(v) => {
                    (*v).encode(buf)?;
                }
                GameRuleValue::Int(v) => {
                    crate::bedrock::codec::ZigZag32((*v) as i32).encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let editable = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let type_ = <GameRuleType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match type_ {
            GameRuleType::Bool => {
                Some(
                    GameRuleValue::Bool(
                        <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            GameRuleType::Float => {
                Some(
                    GameRuleValue::Float(
                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            GameRuleType::Int => {
                Some(
                    GameRuleValue::Int(
                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as i32,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            name,
            editable,
            type_,
            value,
        })
    }
}
pub type GameRules = Vec<GameRule>;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct InputFlag : u64 { const
    ASCEND = 1; const DESCEND = 2; const NORTH_JUMP = 4; const JUMP_DOWN = 8; const
    SPRINT_DOWN = 16; const CHANGE_HEIGHT = 32; const JUMPING = 64; const
    AUTO_JUMPING_IN_WATER = 128; const SNEAKING = 256; const SNEAK_DOWN = 512; const UP =
    1024; const DOWN = 2048; const LEFT = 4096; const RIGHT = 8192; const UP_LEFT =
    16384; const UP_RIGHT = 32768; const WANT_UP = 65536; const WANT_DOWN = 131072; const
    WANT_DOWN_SLOW = 262144; const WANT_UP_SLOW = 524288; const SPRINTING = 1048576;
    const ASCEND_BLOCK = 2097152; const DESCEND_BLOCK = 4194304; const SNEAK_TOGGLE_DOWN
    = 8388608; const PERSIST_SNEAK = 16777216; const START_SPRINTING = 33554432; const
    STOP_SPRINTING = 67108864; const START_SNEAKING = 134217728; const STOP_SNEAKING =
    268435456; const START_SWIMMING = 536870912; const STOP_SWIMMING = 1073741824; const
    START_JUMPING = 2147483648; const START_GLIDING = 4294967296; const STOP_GLIDING =
    8589934592; const ITEM_INTERACT = 17179869184; const BLOCK_ACTION = 34359738368;
    const ITEM_STACK_REQUEST = 68719476736; const HANDLED_TELEPORT = 137438953472; const
    EMOTING = 274877906944; const MISSED_SWING = 549755813888; const START_CRAWLING =
    1099511627776; const STOP_CRAWLING = 2199023255552; }
}
impl crate::bedrock::codec::BedrockCodec for InputFlag {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarLong(val as i64).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u64;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct InputLockFlags : u32 {
    const DISMOUNT = 32; const JUMP = 4; const MOUNT = 16; const MOVE = 2; const ROTATION
    = 64; const SNEAK = 8; }
}
impl crate::bedrock::codec::BedrockCodec for InputLockFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithoutBlockingTickNbt {
    pub version: u8,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTickNbt {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { version, nbt })
    }
}
pub type ShortString = String;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithoutBlockingTick {
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNbt>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTick {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.nbt.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len();
        (len as i32).encode(buf)?;
        for item in &self.can_place_on {
            item.encode(buf)?;
        }
        let len = self.can_destroy.len();
        (len as i32).encode(buf)?;
        for item in &self.can_destroy {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let has_nbt = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = if has_nbt {
            Some(
                <ItemExtraDataWithoutBlockingTickNbt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let can_place_on = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            nbt,
            can_place_on,
            can_destroy,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemExtraDataWithBlockingTick {
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNbt>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
    pub blocking_tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithBlockingTick {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.nbt.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len();
        (len as i32).encode(buf)?;
        for item in &self.can_place_on {
            item.encode(buf)?;
        }
        let len = self.can_destroy.len();
        (len as i32).encode(buf)?;
        for item in &self.can_destroy {
            item.encode(buf)?;
        }
        self.blocking_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let has_nbt = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = if has_nbt {
            Some(
                <ItemExtraDataWithoutBlockingTickNbt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let can_place_on = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let can_destroy = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ShortString as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let blocking_tick = <i64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            nbt,
            can_place_on,
            can_destroy,
            blocking_tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemContentExtra {
    Default(Box<ItemExtraDataWithoutBlockingTick>),
    ShieldItemId(Box<ItemExtraDataWithBlockingTick>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemContent {
    pub count: u16,
    pub metadata: i32,
    pub stack_id: Option<i32>,
    pub block_runtime_id: i32,
    pub extra: ItemContentExtra,
}
#[derive(Debug, Clone)]
pub struct ItemContentArgs {
    pub network_id: i32,
    pub shield_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemContent {
    type Args = ItemContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        crate::bedrock::codec::VarInt(self.metadata as i32).encode(buf)?;
        let val = self.stack_id.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.stack_id {
            v.encode(buf)?;
        }
        crate::bedrock::codec::ZigZag32(self.block_runtime_id as i32).encode(buf)?;
        match &self.extra {
            ItemContentExtra::ShieldItemId(v) => {
                (&**v).encode(buf)?;
            }
            ItemContentExtra::Default(v) => {
                (&**v).encode(buf)?;
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let has_stack_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stack_id = if (has_stack_id) != 0 {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i32,
            )
        } else {
            None
        };
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let extra = match args.network_id {
            x if x == args.shield_item_id => {
                ItemContentExtra::ShieldItemId(
                    Box::new(
                        <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => {
                ItemContentExtra::Default(
                    Box::new(
                        <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
        };
        Ok(Self {
            count,
            metadata,
            stack_id,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Item {
    pub content: Option<Box<ItemContent>>,
}
#[derive(Debug, Clone)]
pub struct ItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for Item {
    type Args = ItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let content = if (network_id) != 0 {
            Some(
                Box::new(
                    <ItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        ItemContentArgs {
                            network_id: network_id,
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        Ok(Self { content })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemComponentListItem {
    pub name: String,
    pub nbt: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ItemComponentListItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = <Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, nbt })
    }
}
pub type ItemComponentList = Vec<ItemComponentListItem>;
#[derive(Debug, Clone, PartialEq)]
pub enum ItemLegacyContentExtra {
    Default(Box<ItemExtraDataWithoutBlockingTick>),
    ShieldItemId(Box<ItemExtraDataWithBlockingTick>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemLegacyContent {
    pub count: u16,
    pub metadata: i32,
    pub block_runtime_id: i32,
    pub extra: ItemLegacyContentExtra,
}
#[derive(Debug, Clone)]
pub struct ItemLegacyContentArgs {
    pub network_id: i32,
    pub shield_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacyContent {
    type Args = ItemLegacyContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        crate::bedrock::codec::VarInt(self.metadata as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_runtime_id as i32).encode(buf)?;
        match &self.extra {
            ItemLegacyContentExtra::ShieldItemId(v) => {
                (&**v).encode(buf)?;
            }
            ItemLegacyContentExtra::Default(v) => {
                (&**v).encode(buf)?;
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let extra = match args.network_id {
            x if x == args.shield_item_id => {
                ItemLegacyContentExtra::ShieldItemId(
                    Box::new(
                        <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => {
                ItemLegacyContentExtra::Default(
                    Box::new(
                        <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
        };
        Ok(Self {
            count,
            metadata,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemLegacy {
    pub content: Option<Box<ItemLegacyContent>>,
}
#[derive(Debug, Clone)]
pub struct ItemLegacyArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemLegacyArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacy {
    type Args = ItemLegacyArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.content.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let content = if (network_id) != 0 {
            Some(
                Box::new(
                    <ItemLegacyContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        ItemLegacyContentArgs {
                            network_id: network_id,
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        Ok(Self { content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackRequestActionsItemTypeId {
    Take = 0,
    Place = 1,
    Swap = 2,
    Drop = 3,
    Destroy = 4,
    Consume = 5,
    Create = 6,
    PlaceInContainer = 7,
    TakeOutContainer = 8,
    LabTableCombine = 9,
    BeaconPayment = 10,
    MineBlock = 11,
    CraftRecipe = 12,
    CraftRecipeAuto = 13,
    CraftCreative = 14,
    Optional = 15,
    CraftGrindstoneRequest = 16,
    CraftLoomRequest = 17,
    NonImplemented = 18,
    ResultsDeprecated = 19,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemTypeId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackRequestActionsItemTypeId::Take),
            1 => Ok(ItemStackRequestActionsItemTypeId::Place),
            2 => Ok(ItemStackRequestActionsItemTypeId::Swap),
            3 => Ok(ItemStackRequestActionsItemTypeId::Drop),
            4 => Ok(ItemStackRequestActionsItemTypeId::Destroy),
            5 => Ok(ItemStackRequestActionsItemTypeId::Consume),
            6 => Ok(ItemStackRequestActionsItemTypeId::Create),
            7 => Ok(ItemStackRequestActionsItemTypeId::PlaceInContainer),
            8 => Ok(ItemStackRequestActionsItemTypeId::TakeOutContainer),
            9 => Ok(ItemStackRequestActionsItemTypeId::LabTableCombine),
            10 => Ok(ItemStackRequestActionsItemTypeId::BeaconPayment),
            11 => Ok(ItemStackRequestActionsItemTypeId::MineBlock),
            12 => Ok(ItemStackRequestActionsItemTypeId::CraftRecipe),
            13 => Ok(ItemStackRequestActionsItemTypeId::CraftRecipeAuto),
            14 => Ok(ItemStackRequestActionsItemTypeId::CraftCreative),
            15 => Ok(ItemStackRequestActionsItemTypeId::Optional),
            16 => Ok(ItemStackRequestActionsItemTypeId::CraftGrindstoneRequest),
            17 => Ok(ItemStackRequestActionsItemTypeId::CraftLoomRequest),
            18 => Ok(ItemStackRequestActionsItemTypeId::NonImplemented),
            19 => Ok(ItemStackRequestActionsItemTypeId::ResultsDeprecated),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackRequestActionsItemTypeId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentBeaconPayment {
    pub primary_effect: i32,
    pub secondary_effect: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentBeaconPayment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.primary_effect as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.secondary_effect as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let primary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let secondary_effect = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            primary_effect,
            secondary_effect,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct StackRequestSlotInfo {
    pub slot_type: ContainerSlotType,
    pub slot: u8,
    pub stack_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for StackRequestSlotInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_type.encode(buf)?;
        self.slot.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.stack_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let slot_type = <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { slot_type, slot, stack_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentConsume {
    pub count: u8,
    pub source: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentConsume {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { count, source })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftCreative {
    pub item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftCreative {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.item_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { item_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftGrindstoneRequest {
    pub recipe_network_id: i32,
    pub cost: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftGrindstoneRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.recipe_network_id as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.cost as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let cost = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { recipe_network_id, cost })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftLoomRequest {
    pub pattern: String,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftLoomRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.pattern.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let pattern = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { pattern })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipe {
    pub recipe_network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipe {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.recipe_network_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { recipe_network_id })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum RecipeIngredientType {
    Invalid = 0,
    IntIdMeta = 1,
    Molang = 2,
    ItemTag = 3,
    StringIdMeta = 4,
    ComplexAlias = 5,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(RecipeIngredientType::Invalid),
            1 => Ok(RecipeIngredientType::IntIdMeta),
            2 => Ok(RecipeIngredientType::Molang),
            3 => Ok(RecipeIngredientType::ItemTag),
            4 => Ok(RecipeIngredientType::StringIdMeta),
            5 => Ok(RecipeIngredientType::ComplexAlias),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(RecipeIngredientType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredientContentComplexAlias {
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentComplexAlias {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredientContentIntIdMeta {
    pub metadata: Option<i16>,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentIntIdMeta {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.metadata.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.metadata {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = if (network_id) != 0 {
            Some(<i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        Ok(Self { metadata })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredientContentItemTag {
    pub tag: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentItemTag {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.tag.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let tag = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { tag })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredientContentMolang {
    pub expression: String,
    pub version: u8,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentMolang {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.expression.encode(buf)?;
        self.version.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let expression = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { expression, version })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredientContentStringIdMeta {
    pub name: String,
    pub metadata: i16,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentStringIdMeta {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.metadata.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, metadata })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipeIngredientContent {
    ComplexAlias(RecipeIngredientContentComplexAlias),
    IntIdMeta(Box<RecipeIngredientContentIntIdMeta>),
    ItemTag(RecipeIngredientContentItemTag),
    Molang(RecipeIngredientContentMolang),
    StringIdMeta(RecipeIngredientContentStringIdMeta),
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipeIngredient {
    pub type_: RecipeIngredientType,
    pub content: Option<RecipeIngredientContent>,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredient {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                RecipeIngredientContent::ComplexAlias(v) => {
                    v.encode(buf)?;
                }
                RecipeIngredientContent::IntIdMeta(v) => {
                    (&**v).encode(buf)?;
                }
                RecipeIngredientContent::ItemTag(v) => {
                    v.encode(buf)?;
                }
                RecipeIngredientContent::Molang(v) => {
                    v.encode(buf)?;
                }
                RecipeIngredientContent::StringIdMeta(v) => {
                    v.encode(buf)?;
                }
            }
        }
        crate::bedrock::codec::ZigZag32(self.count as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <RecipeIngredientType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            RecipeIngredientType::ComplexAlias => {
                Some(
                    RecipeIngredientContent::ComplexAlias(
                        <RecipeIngredientContentComplexAlias as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipeIngredientType::IntIdMeta => {
                Some(
                    RecipeIngredientContent::IntIdMeta(
                        Box::new(
                            <RecipeIngredientContentIntIdMeta as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipeIngredientType::ItemTag => {
                Some(
                    RecipeIngredientContent::ItemTag(
                        <RecipeIngredientContentItemTag as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipeIngredientType::Molang => {
                Some(
                    RecipeIngredientContent::Molang(
                        <RecipeIngredientContentMolang as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipeIngredientType::StringIdMeta => {
                Some(
                    RecipeIngredientContent::StringIdMeta(
                        <RecipeIngredientContentStringIdMeta as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { type_, content, count })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCraftRecipeAuto {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
    pub ingredients: Vec<RecipeIngredient>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentCraftRecipeAuto {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.recipe_network_id as i32).encode(buf)?;
        self.times_crafted.encode(buf)?;
        let len = self.ingredients.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.ingredients {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let ingredients = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            recipe_network_id,
            times_crafted,
            ingredients,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentCreate {
    pub result_slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCreate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.result_slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let result_slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { result_slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentDrop {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub randomly: bool,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentDrop {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.randomly.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let randomly = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { count, source, randomly })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentMineBlock {
    pub hotbar_slot: i32,
    pub predicted_durability: i32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentMineBlock {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.hotbar_slot as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.predicted_durability as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.network_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let predicted_durability = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            hotbar_slot,
            predicted_durability,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentOptional {
    pub recipe_network_id: i32,
    pub filtered_string_index: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentOptional {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.recipe_network_id as i32).encode(buf)?;
        self.filtered_string_index.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let filtered_string_index = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            recipe_network_id,
            filtered_string_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentPlace {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentPlace {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { count, source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentResultsDeprecated {
    pub result_items: Vec<ItemLegacy>,
    pub times_crafted: u8,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestActionsItemContentResultsDeprecatedArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for ItemStackRequestActionsItemContentResultsDeprecatedArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackRequestActionsItemContentResultsDeprecated {
    type Args = ItemStackRequestActionsItemContentResultsDeprecatedArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.result_items.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result_items {
            item.encode(buf)?;
        }
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let result_items = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemLegacyArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            result_items,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItemContentSwap {
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentSwap {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let source = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let destination = <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { source, destination })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftGrindstoneRequest(ItemStackRequestActionsItemContentCraftGrindstoneRequest),
    CraftLoomRequest(ItemStackRequestActionsItemContentCraftLoomRequest),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(ItemStackRequestActionsItemContentCraftRecipeAuto),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    PlaceInContainer(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
    TakeOutContainer(ItemStackRequestActionsItemContentPlace),
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeId,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestActionsItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for ItemStackRequestActionsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    type Args = ItemStackRequestActionsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Consume(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftCreative(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftGrindstoneRequest(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftLoomRequest(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftRecipe(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Create(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Destroy(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Drop(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::MineBlock(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Place(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::PlaceInContainer(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Swap(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Take(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::TakeOutContainer(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_id = <ItemStackRequestActionsItemTypeId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_id {
            ItemStackRequestActionsItemTypeId::BeaconPayment => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Consume => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftCreative => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftGrindstoneRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftGrindstoneRequest(
                        <ItemStackRequestActionsItemContentCraftGrindstoneRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftLoomRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftLoomRequest(
                        <ItemStackRequestActionsItemContentCraftLoomRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftRecipe => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftRecipeAuto => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Create => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Destroy => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Drop => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::MineBlock => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::NonImplemented => {
                Some(ItemStackRequestActionsItemContent::NonImplemented)
            }
            ItemStackRequestActionsItemTypeId::Optional => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Place => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::PlaceInContainer => {
                Some(
                    ItemStackRequestActionsItemContent::PlaceInContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::ResultsDeprecated => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemStackRequestActionsItemContentResultsDeprecatedArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Swap => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Take => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::TakeOutContainer => {
                Some(
                    ItemStackRequestActionsItemContent::TakeOutContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ItemStackRequestCause {
    ChatPublic = 0,
    ChatWhisper = 1,
    SignText = 2,
    AnvilText = 3,
    BookAndQuillText = 4,
    CommandBlockText = 5,
    BlockActorDataText = 6,
    JoinEventText = 7,
    LeaveEventText = 8,
    SlashCommandChat = 9,
    CartographyText = 10,
    KickCommand = 11,
    TitleCommand = 12,
    SummonCommand = 13,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestCause {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackRequestCause::ChatPublic),
            1 => Ok(ItemStackRequestCause::ChatWhisper),
            2 => Ok(ItemStackRequestCause::SignText),
            3 => Ok(ItemStackRequestCause::AnvilText),
            4 => Ok(ItemStackRequestCause::BookAndQuillText),
            5 => Ok(ItemStackRequestCause::CommandBlockText),
            6 => Ok(ItemStackRequestCause::BlockActorDataText),
            7 => Ok(ItemStackRequestCause::JoinEventText),
            8 => Ok(ItemStackRequestCause::LeaveEventText),
            9 => Ok(ItemStackRequestCause::SlashCommandChat),
            10 => Ok(ItemStackRequestCause::CartographyText),
            11 => Ok(ItemStackRequestCause::KickCommand),
            12 => Ok(ItemStackRequestCause::TitleCommand),
            13 => Ok(ItemStackRequestCause::SummonCommand),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackRequestCause), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackRequest {
    pub request_id: i32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
    pub cause: ItemStackRequestCause,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemStackRequestArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    type Args = ItemStackRequestArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.request_id as i32).encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.custom_names {
            item.encode(buf)?;
        }
        self.cause.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let actions = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemStackRequestActionsItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let custom_names = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        let cause = <ItemStackRequestCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            request_id,
            actions,
            custom_names,
            cause,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackResponsesItemStatus {
    Ok = 0,
    Error = 1,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackResponsesItemStatus::Ok),
            1 => Ok(ItemStackResponsesItemStatus::Error),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(ItemStackResponsesItemStatus), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: i32,
    pub custom_name: String,
    pub durability_correction: i32,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentContainersItemSlotsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.item_stack_id as i32).encode(buf)?;
        self.custom_name.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.durability_correction as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let item_stack_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let custom_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let durability_correction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
            durability_correction,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContentContainersItem {
    pub slot_type: ContainerSlotType,
    pub slots: Vec<ItemStackResponsesItemContentContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec
for ItemStackResponsesItemContentContainersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_type.encode(buf)?;
        let len = self.slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let slot_type = <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slots = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { slot_type, slots })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItemContent {
    pub containers: Vec<ItemStackResponsesItemContentContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let len = self.containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let containers = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { containers })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ItemStackResponsesItem {
    pub status: ItemStackResponsesItemStatus,
    pub request_id: i32,
    pub content: Option<ItemStackResponsesItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.status.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.request_id as i32).encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let status = <ItemStackResponsesItemStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let content = match status {
            ItemStackResponsesItemStatus::Ok => {
                Some(
                    <ItemStackResponsesItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            status,
            request_id,
            content,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
pub type ItemStacks = Vec<Item>;
#[derive(Debug, Clone, PartialEq)]
pub struct ItemstatesItem {
    pub name: String,
    pub runtime_id: i16,
    pub component_based: bool,
}
impl crate::bedrock::codec::BedrockCodec for ItemstatesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.runtime_id.encode(buf)?;
        self.component_based.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let component_based = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            name,
            runtime_id,
            component_based,
        })
    }
}
pub type Itemstates = Vec<ItemstatesItem>;
pub type LatinString = String;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum LegacyEntityType {
    Chicken = 10,
    Cow = 11,
    Pig = 12,
    Sheep = 13,
    Wolf = 14,
    Villager = 15,
    Mooshroom = 16,
    Squid = 17,
    Rabbit = 18,
    Bat = 19,
    IronGolem = 20,
    SnowGolem = 21,
    Ocelot = 22,
    Horse = 23,
    Donkey = 24,
    Mule = 25,
    SkeletonHorse = 26,
    ZombieHorse = 27,
    PolarBear = 28,
    Llama = 29,
    Parrot = 30,
    Dolphin = 31,
    Zombie = 32,
    Creeper = 33,
    Skeleton = 34,
    Spider = 35,
    ZombiePigman = 36,
    Slime = 37,
    Enderman = 38,
    Silverfish = 39,
    CaveSpider = 40,
    Ghast = 41,
    MagmaCube = 42,
    Blaze = 43,
    ZombieVillager = 44,
    Witch = 45,
    Stray = 46,
    Husk = 47,
    WitherSkeleton = 48,
    Guardian = 49,
    ElderGuardian = 50,
    Npc = 51,
    Wither = 52,
    EnderDragon = 53,
    Shulker = 54,
    Endermite = 55,
    Agent = 56,
    Vindicator = 57,
    Phantom = 58,
    ArmorStand = 61,
    TripodCamera = 62,
    Player = 63,
    Item = 64,
    Tnt = 65,
    FallingBlock = 66,
    MovingBlock = 67,
    XpBottle = 68,
    XpOrb = 69,
    EyeOfEnderSignal = 70,
    EnderCrystal = 71,
    FireworksRocket = 72,
    ThrownTrident = 73,
    Turtle = 74,
    Cat = 75,
    ShulkerBullet = 76,
    FishingHook = 77,
    Chalkboard = 78,
    DragonFireball = 79,
    Arrow = 80,
    Snowball = 81,
    Egg = 82,
    Painting = 83,
    Minecart = 84,
    Fireball = 85,
    SplashPotion = 86,
    EnderPearl = 87,
    LeashKnot = 88,
    WitherSkull = 89,
    Boat = 90,
    WitherSkullDangerous = 91,
    LightningBolt = 93,
    SmallFireball = 94,
    AreaEffectCloud = 95,
    HopperMinecart = 96,
    TntMinecart = 97,
    ChestMinecart = 98,
    CommandBlockMinecart = 100,
    LingeringPotion = 101,
    LlamaSpit = 102,
    EvocationFang = 103,
    EvocationIllager = 104,
    Vex = 105,
    IceBomb = 106,
    Balloon = 107,
    Pufferfish = 108,
    Salmon = 109,
    Drowned = 110,
    Tropicalfish = 111,
    Cod = 112,
    Panda = 113,
}
impl crate::bedrock::codec::BedrockCodec for LegacyEntityType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            10 => Ok(LegacyEntityType::Chicken),
            11 => Ok(LegacyEntityType::Cow),
            12 => Ok(LegacyEntityType::Pig),
            13 => Ok(LegacyEntityType::Sheep),
            14 => Ok(LegacyEntityType::Wolf),
            15 => Ok(LegacyEntityType::Villager),
            16 => Ok(LegacyEntityType::Mooshroom),
            17 => Ok(LegacyEntityType::Squid),
            18 => Ok(LegacyEntityType::Rabbit),
            19 => Ok(LegacyEntityType::Bat),
            20 => Ok(LegacyEntityType::IronGolem),
            21 => Ok(LegacyEntityType::SnowGolem),
            22 => Ok(LegacyEntityType::Ocelot),
            23 => Ok(LegacyEntityType::Horse),
            24 => Ok(LegacyEntityType::Donkey),
            25 => Ok(LegacyEntityType::Mule),
            26 => Ok(LegacyEntityType::SkeletonHorse),
            27 => Ok(LegacyEntityType::ZombieHorse),
            28 => Ok(LegacyEntityType::PolarBear),
            29 => Ok(LegacyEntityType::Llama),
            30 => Ok(LegacyEntityType::Parrot),
            31 => Ok(LegacyEntityType::Dolphin),
            32 => Ok(LegacyEntityType::Zombie),
            33 => Ok(LegacyEntityType::Creeper),
            34 => Ok(LegacyEntityType::Skeleton),
            35 => Ok(LegacyEntityType::Spider),
            36 => Ok(LegacyEntityType::ZombiePigman),
            37 => Ok(LegacyEntityType::Slime),
            38 => Ok(LegacyEntityType::Enderman),
            39 => Ok(LegacyEntityType::Silverfish),
            40 => Ok(LegacyEntityType::CaveSpider),
            41 => Ok(LegacyEntityType::Ghast),
            42 => Ok(LegacyEntityType::MagmaCube),
            43 => Ok(LegacyEntityType::Blaze),
            44 => Ok(LegacyEntityType::ZombieVillager),
            45 => Ok(LegacyEntityType::Witch),
            46 => Ok(LegacyEntityType::Stray),
            47 => Ok(LegacyEntityType::Husk),
            48 => Ok(LegacyEntityType::WitherSkeleton),
            49 => Ok(LegacyEntityType::Guardian),
            50 => Ok(LegacyEntityType::ElderGuardian),
            51 => Ok(LegacyEntityType::Npc),
            52 => Ok(LegacyEntityType::Wither),
            53 => Ok(LegacyEntityType::EnderDragon),
            54 => Ok(LegacyEntityType::Shulker),
            55 => Ok(LegacyEntityType::Endermite),
            56 => Ok(LegacyEntityType::Agent),
            57 => Ok(LegacyEntityType::Vindicator),
            58 => Ok(LegacyEntityType::Phantom),
            61 => Ok(LegacyEntityType::ArmorStand),
            62 => Ok(LegacyEntityType::TripodCamera),
            63 => Ok(LegacyEntityType::Player),
            64 => Ok(LegacyEntityType::Item),
            65 => Ok(LegacyEntityType::Tnt),
            66 => Ok(LegacyEntityType::FallingBlock),
            67 => Ok(LegacyEntityType::MovingBlock),
            68 => Ok(LegacyEntityType::XpBottle),
            69 => Ok(LegacyEntityType::XpOrb),
            70 => Ok(LegacyEntityType::EyeOfEnderSignal),
            71 => Ok(LegacyEntityType::EnderCrystal),
            72 => Ok(LegacyEntityType::FireworksRocket),
            73 => Ok(LegacyEntityType::ThrownTrident),
            74 => Ok(LegacyEntityType::Turtle),
            75 => Ok(LegacyEntityType::Cat),
            76 => Ok(LegacyEntityType::ShulkerBullet),
            77 => Ok(LegacyEntityType::FishingHook),
            78 => Ok(LegacyEntityType::Chalkboard),
            79 => Ok(LegacyEntityType::DragonFireball),
            80 => Ok(LegacyEntityType::Arrow),
            81 => Ok(LegacyEntityType::Snowball),
            82 => Ok(LegacyEntityType::Egg),
            83 => Ok(LegacyEntityType::Painting),
            84 => Ok(LegacyEntityType::Minecart),
            85 => Ok(LegacyEntityType::Fireball),
            86 => Ok(LegacyEntityType::SplashPotion),
            87 => Ok(LegacyEntityType::EnderPearl),
            88 => Ok(LegacyEntityType::LeashKnot),
            89 => Ok(LegacyEntityType::WitherSkull),
            90 => Ok(LegacyEntityType::Boat),
            91 => Ok(LegacyEntityType::WitherSkullDangerous),
            93 => Ok(LegacyEntityType::LightningBolt),
            94 => Ok(LegacyEntityType::SmallFireball),
            95 => Ok(LegacyEntityType::AreaEffectCloud),
            96 => Ok(LegacyEntityType::HopperMinecart),
            97 => Ok(LegacyEntityType::TntMinecart),
            98 => Ok(LegacyEntityType::ChestMinecart),
            100 => Ok(LegacyEntityType::CommandBlockMinecart),
            101 => Ok(LegacyEntityType::LingeringPotion),
            102 => Ok(LegacyEntityType::LlamaSpit),
            103 => Ok(LegacyEntityType::EvocationFang),
            104 => Ok(LegacyEntityType::EvocationIllager),
            105 => Ok(LegacyEntityType::Vex),
            106 => Ok(LegacyEntityType::IceBomb),
            107 => Ok(LegacyEntityType::Balloon),
            108 => Ok(LegacyEntityType::Pufferfish),
            109 => Ok(LegacyEntityType::Salmon),
            110 => Ok(LegacyEntityType::Drowned),
            111 => Ok(LegacyEntityType::Tropicalfish),
            112 => Ok(LegacyEntityType::Cod),
            113 => Ok(LegacyEntityType::Panda),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(LegacyEntityType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Link {
    pub ridden_entity_id: i64,
    pub rider_entity_id: i64,
    pub type_: u8,
    pub immediate: bool,
    pub rider_initiated: bool,
}
impl crate::bedrock::codec::BedrockCodec for Link {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag64(self.ridden_entity_id as i64).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.rider_entity_id as i64).encode(buf)?;
        self.type_.encode(buf)?;
        self.immediate.encode(buf)?;
        self.rider_initiated.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let ridden_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let rider_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let immediate = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rider_initiated = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            ridden_entity_id,
            rider_entity_id,
            type_,
            immediate,
            rider_initiated,
        })
    }
}
pub type Links = Vec<Link>;
pub type LittleString = String;
#[derive(Debug, Clone, PartialEq)]
pub struct LoginTokens {
    pub identity: LittleString,
    pub client: LittleString,
}
impl crate::bedrock::codec::BedrockCodec for LoginTokens {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.identity.encode(buf)?;
        self.client.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let identity = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { identity, client })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum MapDecorationType {
    MarkerWhite = 0,
    MarkerGreen = 1,
    MarkerRed = 2,
    MarkerBlue = 3,
    CrossWhite = 4,
    TriangleRed = 5,
    SquareWhite = 6,
    MarkerSign = 7,
    MarkerPink = 8,
    MarkerOrange = 9,
    MarkerYellow = 10,
    MarkerTeal = 11,
    TriangleGreen = 12,
    SmallSquareWhite = 13,
    Mansion = 14,
    Monument = 15,
    NoDraw = 16,
    VillageDesert = 17,
    VillagePlains = 18,
    VillageSavanna = 19,
    VillageSnowy = 20,
    VillageTaiga = 21,
    JungleTemple = 22,
    WitchHut = 23,
}
impl crate::bedrock::codec::BedrockCodec for MapDecorationType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MapDecorationType::MarkerWhite),
            1 => Ok(MapDecorationType::MarkerGreen),
            2 => Ok(MapDecorationType::MarkerRed),
            3 => Ok(MapDecorationType::MarkerBlue),
            4 => Ok(MapDecorationType::CrossWhite),
            5 => Ok(MapDecorationType::TriangleRed),
            6 => Ok(MapDecorationType::SquareWhite),
            7 => Ok(MapDecorationType::MarkerSign),
            8 => Ok(MapDecorationType::MarkerPink),
            9 => Ok(MapDecorationType::MarkerOrange),
            10 => Ok(MapDecorationType::MarkerYellow),
            11 => Ok(MapDecorationType::MarkerTeal),
            12 => Ok(MapDecorationType::TriangleGreen),
            13 => Ok(MapDecorationType::SmallSquareWhite),
            14 => Ok(MapDecorationType::Mansion),
            15 => Ok(MapDecorationType::Monument),
            16 => Ok(MapDecorationType::NoDraw),
            17 => Ok(MapDecorationType::VillageDesert),
            18 => Ok(MapDecorationType::VillagePlains),
            19 => Ok(MapDecorationType::VillageSavanna),
            20 => Ok(MapDecorationType::VillageSnowy),
            21 => Ok(MapDecorationType::VillageTaiga),
            22 => Ok(MapDecorationType::JungleTemple),
            23 => Ok(MapDecorationType::WitchHut),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MapDecorationType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct MapDecoration {
    pub type_: MapDecorationType,
    pub rotation: u8,
    pub x: u8,
    pub y: u8,
    pub label: String,
    pub color_abgr: i32,
}
impl crate::bedrock::codec::BedrockCodec for MapDecoration {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        self.rotation.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.label.encode(buf)?;
        crate::bedrock::codec::VarInt(self.color_abgr as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <MapDecorationType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rotation = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let x = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let label = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let color_abgr = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            type_,
            rotation,
            x,
            y,
            label,
            color_abgr,
        })
    }
}
pub type MapInfo = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct MaterialReducerItems {
    pub network_id: i32,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for MaterialReducerItems {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.network_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.count as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { network_id, count })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct MaterialReducer {
    pub mix: i32,
    pub items: MaterialReducerItems,
}
impl crate::bedrock::codec::BedrockCodec for MaterialReducer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.mix as i32).encode(buf)?;
        self.items.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let mix = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let items = <MaterialReducerItems as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { mix, items })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Flags = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    HorseType = 19,
    CreeperSwell = 20,
    CreeperSwellDirection = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeId = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinId = 40,
    UrlTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    WitherAerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    RiderSeatRotationOffset = 60,
    AreaEffectCloudRadius = 61,
    AreaEffectCloudWaiting = 62,
    AreaEffectCloudParticleId = 63,
    ShulkerPeekId = 64,
    ShulkerAttachFace = 65,
    ShulkerAttached = 66,
    ShulkerAttachPos = 67,
    TradingPlayerEid = 68,
    TradingCareer = 69,
    HasCommandBlock = 70,
    CommandBlockCommand = 71,
    CommandBlockLastOutput = 72,
    CommandBlockTrackOutput = 73,
    ControllingRiderSeatNumber = 74,
    Strength = 75,
    MaxStrength = 76,
    EvokerSpellCastingColor = 77,
    LimitedLife = 78,
    ArmorStandPoseIndex = 79,
    EnderCrystalTimeOffset = 80,
    AlwaysShowNametag = 81,
    Color2 = 82,
    NameAuthor = 83,
    ScoreTag = 84,
    BalloonAttachedEntity = 85,
    PufferfishSize = 86,
    BubbleTime = 87,
    Agent = 88,
    SittingAmount = 89,
    SittingAmountPrevious = 90,
    EatingCounter = 91,
    FlagsExtended = 92,
    LayingAmount = 93,
    LayingAmountPrevious = 94,
    AreaEffectCloudDuration = 95,
    AreaEffectCloudSpawnTime = 96,
    AreaEffectCloudChangeRate = 97,
    AreaEffectCloudChangeOnPickup = 98,
    AreaEffectCloudPickupCount = 99,
    InteractText = 100,
    TradeTier = 101,
    MaxTradeTier = 102,
    TradeExperience = 103,
    SkinId = 104,
    SpawningFrames = 105,
    CommandBlockTickDelay = 106,
    CommandBlockExecuteOnFirstTick = 107,
    AmbientSoundInterval = 108,
    AmbientSoundIntervalRange = 109,
    AmbientSoundEventName = 110,
    FallDamageMultiplier = 111,
    NameRawText = 112,
    CanRideTarget = 113,
    LowTierCuredDiscount = 114,
    HighTierCuredDiscount = 115,
    NearbyCuredDiscount = 116,
    NearbyCuredDiscountTimestamp = 117,
    Hitbox = 118,
    IsBuoyant = 119,
    BaseRuntimeId = 120,
    FreezingEffectStrength = 121,
    BuoyancyData = 122,
    GoatHornCount = 123,
    UpdateProperties = 124,
    MovementSoundDistanceOffset = 125,
    HeartbeatIntervalTicks = 126,
    HeartbeatSoundEvent = 127,
    PlayerLastDeathPosition = 128,
    PlayerLastDeathDimension = 129,
    PlayerHasDied = 130,
    CollisionBox = 131,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Flags),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            19 => Ok(MetadataDictionaryItemKey::HorseType),
            20 => Ok(MetadataDictionaryItemKey::CreeperSwell),
            21 => Ok(MetadataDictionaryItemKey::CreeperSwellDirection),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeId),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinId),
            41 => Ok(MetadataDictionaryItemKey::UrlTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::WitherAerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::RiderSeatRotationOffset),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            63 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleId),
            64 => Ok(MetadataDictionaryItemKey::ShulkerPeekId),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            67 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            68 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            69 => Ok(MetadataDictionaryItemKey::TradingCareer),
            70 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            73 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            74 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            75 => Ok(MetadataDictionaryItemKey::Strength),
            76 => Ok(MetadataDictionaryItemKey::MaxStrength),
            77 => Ok(MetadataDictionaryItemKey::EvokerSpellCastingColor),
            78 => Ok(MetadataDictionaryItemKey::LimitedLife),
            79 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            80 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            81 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            82 => Ok(MetadataDictionaryItemKey::Color2),
            83 => Ok(MetadataDictionaryItemKey::NameAuthor),
            84 => Ok(MetadataDictionaryItemKey::ScoreTag),
            85 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            86 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            87 => Ok(MetadataDictionaryItemKey::BubbleTime),
            88 => Ok(MetadataDictionaryItemKey::Agent),
            89 => Ok(MetadataDictionaryItemKey::SittingAmount),
            90 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            91 => Ok(MetadataDictionaryItemKey::EatingCounter),
            92 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            93 => Ok(MetadataDictionaryItemKey::LayingAmount),
            94 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            95 => Ok(MetadataDictionaryItemKey::AreaEffectCloudDuration),
            96 => Ok(MetadataDictionaryItemKey::AreaEffectCloudSpawnTime),
            97 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeRate),
            98 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeOnPickup),
            99 => Ok(MetadataDictionaryItemKey::AreaEffectCloudPickupCount),
            100 => Ok(MetadataDictionaryItemKey::InteractText),
            101 => Ok(MetadataDictionaryItemKey::TradeTier),
            102 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            103 => Ok(MetadataDictionaryItemKey::TradeExperience),
            104 => Ok(MetadataDictionaryItemKey::SkinId),
            105 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            107 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            110 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            111 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            112 => Ok(MetadataDictionaryItemKey::NameRawText),
            113 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            114 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            117 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            118 => Ok(MetadataDictionaryItemKey::Hitbox),
            119 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            120 => Ok(MetadataDictionaryItemKey::BaseRuntimeId),
            121 => Ok(MetadataDictionaryItemKey::FreezingEffectStrength),
            122 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            123 => Ok(MetadataDictionaryItemKey::GoatHornCount),
            124 => Ok(MetadataDictionaryItemKey::UpdateProperties),
            125 => Ok(MetadataDictionaryItemKey::MovementSoundDistanceOffset),
            126 => Ok(MetadataDictionaryItemKey::HeartbeatIntervalTicks),
            127 => Ok(MetadataDictionaryItemKey::HeartbeatSoundEvent),
            128 => Ok(MetadataDictionaryItemKey::PlayerLastDeathPosition),
            129 => Ok(MetadataDictionaryItemKey::PlayerLastDeathDimension),
            130 => Ok(MetadataDictionaryItemKey::PlayerHasDied),
            131 => Ok(MetadataDictionaryItemKey::CollisionBox),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemType {
    Byte = 0,
    Short = 1,
    Int = 2,
    Float = 3,
    String = 4,
    Compound = 5,
    Vec3I = 6,
    Long = 7,
    Vec3F = 8,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MetadataDictionaryItemType::Byte),
            1 => Ok(MetadataDictionaryItemType::Short),
            2 => Ok(MetadataDictionaryItemType::Int),
            3 => Ok(MetadataDictionaryItemType::Float),
            4 => Ok(MetadataDictionaryItemType::String),
            5 => Ok(MetadataDictionaryItemType::Compound),
            6 => Ok(MetadataDictionaryItemType::Vec3I),
            7 => Ok(MetadataDictionaryItemType::Long),
            8 => Ok(MetadataDictionaryItemType::Vec3F),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3F {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3F {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3I {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3I {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.x as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValueDefault {
    Byte(i8),
    Compound(Vec<u8>),
    Float(f32),
    Int(i32),
    Long(i64),
    Short(i16),
    String(String),
    Vec3F(Vec3F),
    Vec3I(Vec3I),
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct MetadataFlags1 : u64 {
    const ONFIRE = 1; const SNEAKING = 2; const RIDING = 4; const SPRINTING = 8; const
    ACTION = 16; const INVISIBLE = 32; const TEMPTED = 64; const INLOVE = 128; const
    SADDLED = 256; const POWERED = 512; const IGNITED = 1024; const BABY = 2048; const
    CONVERTING = 4096; const CRITICAL = 8192; const CAN_SHOW_NAMETAG = 16384; const
    ALWAYS_SHOW_NAMETAG = 32768; const NO_AI = 65536; const SILENT = 131072; const
    WALLCLIMBING = 262144; const CAN_CLIMB = 524288; const SWIMMER = 1048576; const
    CAN_FLY = 2097152; const WALKER = 4194304; const RESTING = 8388608; const SITTING =
    16777216; const ANGRY = 33554432; const INTERESTED = 67108864; const CHARGED =
    134217728; const TAMED = 268435456; const ORPHANED = 536870912; const LEASHED =
    1073741824; const SHEARED = 2147483648; const GLIDING = 4294967296; const ELDER =
    8589934592; const MOVING = 17179869184; const BREATHING = 34359738368; const CHESTED
    = 68719476736; const STACKABLE = 137438953472; const SHOWBASE = 274877906944; const
    REARING = 549755813888; const VIBRATING = 1099511627776; const IDLING =
    2199023255552; const EVOKER_SPELL = 4398046511104; const CHARGE_ATTACK =
    8796093022208; const WASD_CONTROLLED = 17592186044416; const CAN_POWER_JUMP =
    35184372088832; const CAN_DASH = 70368744177664; const LINGER = 140737488355328;
    const HAS_COLLISION = 281474976710656; const AFFECTED_BY_GRAVITY = 562949953421312;
    const FIRE_IMMUNE = 1125899906842624; const DANCING = 2251799813685248; const
    ENCHANTED = 4503599627370496; const SHOW_TRIDENT_ROPE = 9007199254740992; const
    CONTAINER_PRIVATE = 18014398509481984; const TRANSFORMING = 36028797018963968; const
    SPIN_ATTACK = 72057594037927936; const SWIMMING = 144115188075855872; const BRIBED =
    288230376151711744; const PREGNANT = 576460752303423488; const LAYING_EGG =
    1152921504606846976; const RIDER_CAN_PICK = 2305843009213693952; const
    TRANSITION_SITTING = 4611686018427387904; const EATING = 9223372036854775808; const
    LAYING_DOWN = 0; }
}
impl crate::bedrock::codec::BedrockCodec for MetadataFlags1 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::ZigZag64(val as i64).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u64;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct MetadataFlags2 : u64 {
    const SNEEZING = 1; const TRUSTING = 2; const ROLLING = 4; const SCARED = 8; const
    IN_SCAFFOLDING = 16; const OVER_SCAFFOLDING = 32; const FALL_THROUGH_SCAFFOLDING =
    64; const BLOCKING = 128; const TRANSITION_BLOCKING = 256; const BLOCKED_USING_SHIELD
    = 512; const BLOCKED_USING_DAMAGED_SHIELD = 1024; const SLEEPING = 2048; const
    WANTS_TO_WAKE = 4096; const TRADE_INTEREST = 8192; const DOOR_BREAKER = 16384; const
    BREAKING_OBSTRUCTION = 32768; const DOOR_OPENER = 65536; const ILLAGER_CAPTAIN =
    131072; const STUNNED = 262144; const ROARING = 524288; const DELAYED_ATTACKING =
    1048576; const AVOIDING_MOBS = 2097152; const AVOIDING_BLOCK = 4194304; const
    FACING_TARGET_TO_RANGE_ATTACK = 8388608; const HIDDEN_WHEN_INVISIBLE = 16777216;
    const IS_IN_UI = 33554432; const STALKING = 67108864; const EMOTING = 134217728;
    const CELEBRATING = 268435456; const ADMIRING = 536870912; const CELEBRATING_SPECIAL
    = 1073741824; const UNKNOWN_95 = 2147483648; const RAM_ATTACK = 4294967296; const
    PLAYING_DEAD = 8589934592; const IN_ASCENDABLE_BLOCK = 17179869184; const
    OVER_DESCENDABLE_BLOCK = 34359738368; const CROAKING = 68719476736; const EAT_MOB =
    137438953472; const JUMP_GOAL_JUMP = 274877906944; const EMERGING = 549755813888;
    const SNIFFING = 1099511627776; const DIGGING = 2199023255552; const SONIC_BOOM =
    4398046511104; const HAS_DASH_COOLDOWN = 8796093022208; const
    PUSH_TOWARDS_CLOSEST_SPACE = 17592186044416; const SCENTING = 35184372088832; const
    RISING = 70368744177664; const FEELING_HAPPY = 140737488355328; const SEARCHING =
    281474976710656; const CRAWLING = 562949953421312; }
}
impl crate::bedrock::codec::BedrockCodec for MetadataFlags2 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::ZigZag64(val as i64).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u64;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Default(Box<Option<MetadataDictionaryItemValueDefault>>),
    Flags(MetadataFlags1),
    FlagsExtended(MetadataFlags2),
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: MetadataDictionaryItemValue,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        match &self.value {
            MetadataDictionaryItemValue::Flags(v) => {
                v.encode(buf)?;
            }
            MetadataDictionaryItemValue::FlagsExtended(v) => {
                v.encode(buf)?;
            }
            MetadataDictionaryItemValue::Default(v) => {
                if let Some(v) = (&**v) {
                    match v {
                        MetadataDictionaryItemValueDefault::Byte(v) => {
                            (*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Compound(v) => {
                            v.encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Float(v) => {
                            (*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Int(v) => {
                            crate::bedrock::codec::ZigZag32((*v) as i32).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Long(v) => {
                            crate::bedrock::codec::ZigZag64((*v) as i64).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Short(v) => {
                            (*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::String(v) => {
                            v.encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Vec3F(v) => {
                            v.encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Vec3I(v) => {
                            v.encode(buf)?;
                        }
                    }
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match key {
            MetadataDictionaryItemKey::Flags => {
                MetadataDictionaryItemValue::Flags(
                    <MetadataFlags1 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            MetadataDictionaryItemKey::FlagsExtended => {
                MetadataDictionaryItemValue::FlagsExtended(
                    <MetadataFlags2 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::Default(
                    Box::new(
                        match type_ {
                            MetadataDictionaryItemType::Byte => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Byte(
                                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Compound => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Compound(
                                        <Vec<
                                            u8,
                                        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Float => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Float(
                                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Int => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Int(
                                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0 as i32,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Long => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Long(
                                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0 as i64,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Short => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Short(
                                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::String => {
                                Some(
                                    MetadataDictionaryItemValueDefault::String(
                                        <String as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3F => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3F(
                                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3I => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3I(
                                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
pub type MetadataDictionary = Vec<MetadataDictionaryItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PermissionLevel {
    Visitor = 0,
    Member = 1,
    Operator = 2,
    Custom = 3,
}
impl crate::bedrock::codec::BedrockCodec for PermissionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PermissionLevel::Visitor),
            1 => Ok(PermissionLevel::Member),
            2 => Ok(PermissionLevel::Operator),
            3 => Ok(PermissionLevel::Custom),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(PermissionLevel),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerAttributesItemModifiersItem {
    pub id: String,
    pub name: String,
    pub amount: f32,
    pub operation: i32,
    pub operand: i32,
    pub serializable: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItemModifiersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.id.encode(buf)?;
        self.name.encode(buf)?;
        self.amount.encode(buf)?;
        self.operation.encode(buf)?;
        self.operand.encode(buf)?;
        self.serializable.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let amount = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let operation = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let operand = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let serializable = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            id,
            name,
            amount,
            operation,
            operand,
            serializable,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerAttributesItem {
    pub min: f32,
    pub max: f32,
    pub current: f32,
    pub default: f32,
    pub name: String,
    pub modifiers: Vec<PlayerAttributesItemModifiersItem>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        self.current.encode(buf)?;
        self.default.encode(buf)?;
        self.name.encode(buf)?;
        let len = self.modifiers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.modifiers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let min = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let max = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let current = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let default = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let modifiers = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PlayerAttributesItemModifiersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            min,
            max,
            current,
            default,
            name,
            modifiers,
        })
    }
}
pub type PlayerAttributes = Vec<PlayerAttributesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PlayerRecordsType {
    Add = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PlayerRecordsType::Add),
            1 => Ok(PlayerRecordsType::Remove),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PlayerRecordsType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinImage {
    pub width: i32,
    pub height: i32,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for SkinImage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.width.encode(buf)?;
        self.height.encode(buf)?;
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let width = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let height = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { width, height, data })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinAnimationsItem {
    pub skin_image: SkinImage,
    pub animation_type: i32,
    pub animation_frames: f32,
    pub expression_type: f32,
}
impl crate::bedrock::codec::BedrockCodec for SkinAnimationsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.skin_image.encode(buf)?;
        self.animation_type.encode(buf)?;
        self.animation_frames.encode(buf)?;
        self.expression_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let skin_image = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_type = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_frames = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let expression_type = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            skin_image,
            animation_type,
            animation_frames,
            expression_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPersonalPiecesItem {
    pub piece_id: String,
    pub piece_type: String,
    pub pack_id: String,
    pub is_default_piece: bool,
    pub product_id: String,
}
impl crate::bedrock::codec::BedrockCodec for SkinPersonalPiecesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.piece_id.encode(buf)?;
        self.piece_type.encode(buf)?;
        self.pack_id.encode(buf)?;
        self.is_default_piece.encode(buf)?;
        self.product_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let piece_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let pack_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_default_piece = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let product_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            piece_id,
            piece_type,
            pack_id,
            is_default_piece,
            product_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SkinPieceTintColorsItem {
    pub piece_type: String,
    pub colors: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for SkinPieceTintColorsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.piece_type.encode(buf)?;
        let len = self.colors.len();
        (len as i32).encode(buf)?;
        for item in &self.colors {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let piece_type = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { piece_type, colors })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Skin {
    pub skin_id: String,
    pub play_fab_id: String,
    pub skin_resource_pack: String,
    pub skin_data: SkinImage,
    pub animations: Vec<SkinAnimationsItem>,
    pub cape_data: SkinImage,
    pub geometry_data: String,
    pub geometry_data_version: String,
    pub animation_data: String,
    pub cape_id: String,
    pub full_skin_id: String,
    pub arm_size: String,
    pub skin_color: String,
    pub personal_pieces: Vec<SkinPersonalPiecesItem>,
    pub piece_tint_colors: Vec<SkinPieceTintColorsItem>,
    pub premium: bool,
    pub persona: bool,
    pub cape_on_classic: bool,
    pub primary_user: bool,
    pub overriding_player_appearance: bool,
}
impl crate::bedrock::codec::BedrockCodec for Skin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.skin_id.encode(buf)?;
        self.play_fab_id.encode(buf)?;
        self.skin_resource_pack.encode(buf)?;
        self.skin_data.encode(buf)?;
        let len = self.animations.len();
        (len as i32).encode(buf)?;
        for item in &self.animations {
            item.encode(buf)?;
        }
        self.cape_data.encode(buf)?;
        self.geometry_data.encode(buf)?;
        self.geometry_data_version.encode(buf)?;
        self.animation_data.encode(buf)?;
        self.cape_id.encode(buf)?;
        self.full_skin_id.encode(buf)?;
        self.arm_size.encode(buf)?;
        self.skin_color.encode(buf)?;
        let len = self.personal_pieces.len();
        (len as i32).encode(buf)?;
        for item in &self.personal_pieces {
            item.encode(buf)?;
        }
        let len = self.piece_tint_colors.len();
        (len as i32).encode(buf)?;
        for item in &self.piece_tint_colors {
            item.encode(buf)?;
        }
        self.premium.encode(buf)?;
        self.persona.encode(buf)?;
        self.cape_on_classic.encode(buf)?;
        self.primary_user.encode(buf)?;
        self.overriding_player_appearance.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let play_fab_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let skin_resource_pack = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let skin_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animations = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinAnimationsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let cape_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let geometry_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let geometry_data_version = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_data = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let cape_id = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let full_skin_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let arm_size = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin_color = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let personal_pieces = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPersonalPiecesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let piece_tint_colors = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SkinPieceTintColorsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let persona = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let cape_on_classic = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let primary_user = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let overriding_player_appearance = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            skin_id,
            play_fab_id,
            skin_resource_pack,
            skin_data,
            animations,
            cape_data,
            geometry_data,
            geometry_data_version,
            animation_data,
            cape_id,
            full_skin_id,
            arm_size,
            skin_color,
            personal_pieces,
            piece_tint_colors,
            premium,
            persona,
            cape_on_classic,
            primary_user,
            overriding_player_appearance,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemAdd {
    pub uuid: uuid::Uuid,
    pub entity_unique_id: i64,
    pub username: String,
    pub xbox_user_id: String,
    pub platform_chat_id: String,
    pub build_platform: i32,
    pub skin_data: Skin,
    pub is_teacher: bool,
    pub is_host: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemAdd {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id as i64).encode(buf)?;
        self.username.encode(buf)?;
        self.xbox_user_id.encode(buf)?;
        self.platform_chat_id.encode(buf)?;
        self.build_platform.encode(buf)?;
        self.skin_data.encode(buf)?;
        self.is_teacher.encode(buf)?;
        self.is_host.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let username = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let xbox_user_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let platform_chat_id = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let build_platform = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let skin_data = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_teacher = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_host = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            uuid,
            entity_unique_id,
            username,
            xbox_user_id,
            platform_chat_id,
            build_platform,
            skin_data,
            is_teacher,
            is_host,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecordsRecordsItemRemove {
    pub uuid: uuid::Uuid,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemRemove {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { uuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerRecordsRecordsItem {
    Add(Box<PlayerRecordsRecordsItemAdd>),
    Remove(PlayerRecordsRecordsItemRemove),
}
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Option<Vec<bool>>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        crate::bedrock::codec::VarInt(self.records_count as i32).encode(buf)?;
        let len = self.records.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.records {
            if let Some(v) = item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => {
                        (&**v).encode(buf)?;
                    }
                    PlayerRecordsRecordsItem::Remove(v) => {
                        v.encode(buf)?;
                    }
                }
            }
        }
        if let Some(v) = &self.verified {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let records_count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let records = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            PlayerRecordsType::Add => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            PlayerRecordsType::Remove => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    );
            }
            tmp_vec
        };
        let verified = match type_ {
            PlayerRecordsType::Add => {
                Some({
                    let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <bool as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                })
            }
            _ => None,
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PotionContainerChangeRecipesItem {
    pub input_item_id: i32,
    pub ingredient_id: i32,
    pub output_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PotionContainerChangeRecipesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_item_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let ingredient_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let output_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            input_item_id,
            ingredient_id,
            output_item_id,
        })
    }
}
pub type PotionContainerChangeRecipes = Vec<PotionContainerChangeRecipesItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct PotionTypeRecipesItem {
    pub input_item_id: i32,
    pub input_item_meta: i32,
    pub ingredient_id: i32,
    pub ingredient_meta: i32,
    pub output_item_id: i32,
    pub output_item_meta: i32,
}
impl crate::bedrock::codec::BedrockCodec for PotionTypeRecipesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_item_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.input_item_meta as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_meta as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_meta as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let input_item_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let ingredient_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let ingredient_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let output_item_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let output_item_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            input_item_id,
            input_item_meta,
            ingredient_id,
            ingredient_meta,
            output_item_id,
            output_item_meta,
        })
    }
}
pub type PotionTypeRecipes = Vec<PotionTypeRecipesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum RecipesItemType {
    Shapeless = 0,
    Shaped = 1,
    Furnace = 2,
    FurnaceWithMetadata = 3,
    Multi = 4,
    ShulkerBox = 5,
    ShapelessChemistry = 6,
    ShapedChemistry = 7,
    SmithingTransform = 8,
    SmithingTrim = 9,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(RecipesItemType::Shapeless),
            1 => Ok(RecipesItemType::Shaped),
            2 => Ok(RecipesItemType::Furnace),
            3 => Ok(RecipesItemType::FurnaceWithMetadata),
            4 => Ok(RecipesItemType::Multi),
            5 => Ok(RecipesItemType::ShulkerBox),
            6 => Ok(RecipesItemType::ShapelessChemistry),
            7 => Ok(RecipesItemType::ShapedChemistry),
            8 => Ok(RecipesItemType::SmithingTransform),
            9 => Ok(RecipesItemType::SmithingTrim),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(RecipesItemType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnace {
    pub input_id: i32,
    pub output: ItemLegacy,
    pub block: String,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeFurnaceArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for RecipesItemRecipeFurnaceArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnace {
    type Args = RecipesItemRecipeFurnaceArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_id as i32).encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let output = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { input_id, output, block })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeFurnaceWithMetadata {
    pub input_id: i32,
    pub input_meta: i32,
    pub output: ItemLegacy,
    pub block: String,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeFurnaceWithMetadataArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for RecipesItemRecipeFurnaceWithMetadataArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnaceWithMetadata {
    type Args = RecipesItemRecipeFurnaceWithMetadataArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::ZigZag32(self.input_id as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.input_meta as i32).encode(buf)?;
        self.output.encode(buf)?;
        self.block.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let input_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let input_meta = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let output = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            input_id,
            input_meta,
            output,
            block,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeMulti {
    pub uuid: uuid::Uuid,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeMulti {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { uuid, network_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShaped {
    pub recipe_id: LatinString,
    pub width: i32,
    pub height: i32,
    pub input: Vec<Vec<RecipeIngredient>>,
    pub output: Vec<ItemLegacy>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: i32,
    pub network_id: i32,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeShapedArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for RecipesItemRecipeShapedArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShaped {
    type Args = RecipesItemRecipeShapedArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.width as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.height as i32).encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            let len = item.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            for item in item {
                item.encode(buf)?;
            }
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.priority as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let width = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let height = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let input = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?,
                                );
                        }
                        tmp_vec
                    });
            }
            tmp_vec
        };
        let output = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemLegacyArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            recipe_id,
            width,
            height,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeShapeless {
    pub recipe_id: LatinString,
    pub input: Vec<RecipeIngredient>,
    pub output: Vec<ItemLegacy>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: i32,
    pub network_id: i32,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeShapelessArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for RecipesItemRecipeShapelessArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShapeless {
    type Args = RecipesItemRecipeShapelessArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        self.block.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.priority as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let output = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemLegacyArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let priority = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            recipe_id,
            input,
            output,
            uuid,
            block,
            priority,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeSmithingTransform {
    pub recipe_id: LatinString,
    pub template: RecipeIngredient,
    pub base: RecipeIngredient,
    pub addition: RecipeIngredient,
    pub result: ItemLegacy,
    pub tag: String,
    pub network_id: i32,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeSmithingTransformArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for RecipesItemRecipeSmithingTransformArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeSmithingTransform {
    type Args = RecipesItemRecipeSmithingTransformArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        self.template.encode(buf)?;
        self.base.encode(buf)?;
        self.addition.encode(buf)?;
        self.result.encode(buf)?;
        self.tag.encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let template = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let base = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let addition = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let result = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let tag = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            recipe_id,
            template,
            base,
            addition,
            result,
            tag,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItemRecipeSmithingTrim {
    pub recipe_id: LatinString,
    pub template: RecipeIngredient,
    pub input: RecipeIngredient,
    pub addition: RecipeIngredient,
    pub block: String,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeSmithingTrim {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.recipe_id.encode(buf)?;
        self.template.encode(buf)?;
        self.input.encode(buf)?;
        self.addition.encode(buf)?;
        self.block.encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let recipe_id = <LatinString as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let template = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let addition = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            recipe_id,
            template,
            input,
            addition,
            block,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipesItemRecipe {
    Furnace(Box<RecipesItemRecipeFurnace>),
    FurnaceWithMetadata(Box<RecipesItemRecipeFurnaceWithMetadata>),
    Multi(RecipesItemRecipeMulti),
    Shaped(Box<RecipesItemRecipeShaped>),
    ShapedChemistry(Box<RecipesItemRecipeShaped>),
    Shapeless(Box<RecipesItemRecipeShapeless>),
    ShapelessChemistry(Box<RecipesItemRecipeShapeless>),
    ShulkerBox(Box<RecipesItemRecipeShapeless>),
    SmithingTransform(Box<RecipesItemRecipeSmithingTransform>),
    SmithingTrim(Box<RecipesItemRecipeSmithingTrim>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct RecipesItem {
    pub type_: RecipesItemType,
    pub recipe: Option<RecipesItemRecipe>,
}
#[derive(Debug, Clone)]
pub struct RecipesItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for RecipesItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItem {
    type Args = RecipesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.recipe {
            match v {
                RecipesItemRecipe::Furnace(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::FurnaceWithMetadata(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::Multi(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::Shaped(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::ShapedChemistry(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::Shapeless(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::ShapelessChemistry(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::ShulkerBox(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::SmithingTransform(v) => {
                    (&**v).encode(buf)?;
                }
                RecipesItemRecipe::SmithingTrim(v) => {
                    (&**v).encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <RecipesItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe = match type_ {
            RecipesItemType::Furnace => {
                Some(
                    RecipesItemRecipe::Furnace(
                        Box::new(
                            <RecipesItemRecipeFurnace as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeFurnaceArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::FurnaceWithMetadata => {
                Some(
                    RecipesItemRecipe::FurnaceWithMetadata(
                        Box::new(
                            <RecipesItemRecipeFurnaceWithMetadata as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeFurnaceWithMetadataArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Multi => {
                Some(
                    RecipesItemRecipe::Multi(
                        <RecipesItemRecipeMulti as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipesItemType::Shaped => {
                Some(
                    RecipesItemRecipe::Shaped(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapedArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapedChemistry => {
                Some(
                    RecipesItemRecipe::ShapedChemistry(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapedArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Shapeless => {
                Some(
                    RecipesItemRecipe::Shapeless(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapelessArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapelessChemistry => {
                Some(
                    RecipesItemRecipe::ShapelessChemistry(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapelessArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShulkerBox => {
                Some(
                    RecipesItemRecipe::ShulkerBox(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapelessArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::SmithingTransform => {
                Some(
                    RecipesItemRecipe::SmithingTransform(
                        Box::new(
                            <RecipesItemRecipeSmithingTransform as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeSmithingTransformArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::SmithingTrim => {
                Some(
                    RecipesItemRecipe::SmithingTrim(
                        Box::new(
                            <RecipesItemRecipeSmithingTrim as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_, recipe })
    }
}
pub type Recipes = Vec<RecipesItem>;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct RequestPermissions :
    u16 { const ATTACK_MOBS = 32; const ATTACK_PLAYERS = 16; const BUILD = 1; const
    DOORS_AND_SWITCHES = 4; const MINE = 2; const OPEN_CONTAINERS = 8; const OPERATOR =
    64; const TELEPORT = 128; }
}
impl crate::bedrock::codec::BedrockCodec for RequestPermissions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        (val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw as u16;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ResourcePackIdVersionsItem {
    pub uuid: String,
    pub version: String,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackIdVersionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.name.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { uuid, version, name })
    }
}
pub type ResourcePackIdVersions = Vec<ResourcePackIdVersionsItem>;
pub type ResourcePackIds = Vec<String>;
pub type Byterot = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Rotation {
    pub yaw: Byterot,
    pub pitch: Byterot,
    pub head_yaw: Byterot,
}
impl crate::bedrock::codec::BedrockCodec for Rotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.yaw.encode(buf)?;
        self.pitch.encode(buf)?;
        self.head_yaw.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { yaw, pitch, head_yaw })
    }
}
pub type ShortArray = Vec<u8>;
pub type SignedByteArray = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SoundType {
    ItemUseOn = 0,
    Hit = 1,
    Step = 2,
    Fly = 3,
    Jump = 4,
    Break = 5,
    Place = 6,
    HeavyStep = 7,
    Gallop = 8,
    Fall = 9,
    Ambient = 10,
    AmbientBaby = 11,
    AmbientInWater = 12,
    Breathe = 13,
    Death = 14,
    DeathInWater = 15,
    DeathToZombie = 16,
    Hurt = 17,
    HurtInWater = 18,
    Mad = 19,
    Boost = 20,
    Bow = 21,
    SquishBig = 22,
    SquishSmall = 23,
    FallBig = 24,
    FallSmall = 25,
    Splash = 26,
    Fizz = 27,
    Flap = 28,
    Swim = 29,
    Drink = 30,
    Eat = 31,
    Takeoff = 32,
    Shake = 33,
    Plop = 34,
    Land = 35,
    Saddle = 36,
    Armor = 37,
    MobArmorStandPlace = 38,
    AddChest = 39,
    Throw = 40,
    Attack = 41,
    AttackNoDamage = 42,
    AttackStrong = 43,
    Warn = 44,
    Shear = 45,
    Milk = 46,
    Thunder = 47,
    Explode = 48,
    Fire = 49,
    Ignite = 50,
    Fuse = 51,
    Stare = 52,
    Spawn = 53,
    Shoot = 54,
    BreakBlock = 55,
    Launch = 56,
    Blast = 57,
    LargeBlast = 58,
    Twinkle = 59,
    Remedy = 60,
    Infect = 61,
    LevelUp = 62,
    BowHit = 63,
    BulletHit = 64,
    ExtinguishFire = 65,
    ItemFizz = 66,
    ChestOpen = 67,
    ChestClosed = 68,
    ShulkerBoxOpen = 69,
    ShulkerBoxClosed = 70,
    EnderChestOpen = 71,
    EnderChestClosed = 72,
    PowerOn = 73,
    PowerOff = 74,
    Attach = 75,
    Detach = 76,
    Deny = 77,
    Tripod = 78,
    Pop = 79,
    DropSlot = 80,
    Note = 81,
    Thorns = 82,
    PistonIn = 83,
    PistonOut = 84,
    Portal = 85,
    Water = 86,
    LavaPop = 87,
    Lava = 88,
    Burp = 89,
    BucketFillWater = 90,
    BucketFillLava = 91,
    BucketEmptyWater = 92,
    BucketEmptyLava = 93,
    ArmorEquipChain = 94,
    ArmorEquipDiamond = 95,
    ArmorEquipGeneric = 96,
    ArmorEquipGold = 97,
    ArmorEquipIron = 98,
    ArmorEquipLeather = 99,
    ArmorEquipElytra = 100,
    Record13 = 101,
    RecordCat = 102,
    RecordBlocks = 103,
    RecordChirp = 104,
    RecordFar = 105,
    RecordMall = 106,
    RecordMellohi = 107,
    RecordStal = 108,
    RecordStrad = 109,
    RecordWard = 110,
    Record11 = 111,
    RecordWait = 112,
    StopRecord = 113,
    Flop = 114,
    GuardianCurse = 115,
    MobWarning = 116,
    MobWarningBaby = 117,
    Teleport = 118,
    ShulkerOpen = 119,
    ShulkerClose = 120,
    Haggle = 121,
    HaggleYes = 122,
    HaggleNo = 123,
    HaggleIdle = 124,
    ChorusGrow = 125,
    ChorusDeath = 126,
    Glass = 127,
    PotionBrewed = 128,
    CastSpell = 129,
    PrepareAttackSpell = 130,
    PrepareSummon = 131,
    PrepareWololo = 132,
    Fang = 133,
    Charge = 134,
    CameraTakePicture = 135,
    LeashKnotPlace = 136,
    LeashKnotBreak = 137,
    AmbientGrowl = 138,
    AmbientWhine = 139,
    AmbientPant = 140,
    AmbientPurr = 141,
    AmbientPurreow = 142,
    DeathMinVolume = 143,
    DeathMidVolume = 144,
    ImitateBlaze = 145,
    ImitateCaveSpider = 146,
    ImitateCreeper = 147,
    ImitateElderGuardian = 148,
    ImitateEnderDragon = 149,
    ImitateEnderman = 150,
    ImitateEndermite = 151,
    ImitateEvocationIllager = 152,
    ImitateGhast = 153,
    ImitateHusk = 154,
    ImitateIllusionIllager = 155,
    ImitateMagmaCube = 156,
    ImitatePolarBear = 157,
    ImitateShulker = 158,
    ImitateSilverfish = 159,
    ImitateSkeleton = 160,
    ImitateSlime = 161,
    ImitateSpider = 162,
    ImitateStray = 163,
    ImitateVex = 164,
    ImitateVindicationIllager = 165,
    ImitateWitch = 166,
    ImitateWither = 167,
    ImitateWitherSkeleton = 168,
    ImitateWolf = 169,
    ImitateZombie = 170,
    ImitateZombiePigman = 171,
    ImitateZombieVillager = 172,
    EnderEyePlaced = 173,
    EndPortalCreated = 174,
    AnvilUse = 175,
    BottleDragonBreath = 176,
    PortalTravel = 177,
    TridentHit = 178,
    TridentReturn = 179,
    TridentRiptide1 = 180,
    TridentRiptide2 = 181,
    TridentRiptide3 = 182,
    TridentThrow = 183,
    TridentThunder = 184,
    TridentHitGround = 185,
    Default = 186,
    FletchingTableUse = 187,
    ElemConstructOpen = 188,
    IceBombHit = 189,
    BalloonPop = 190,
    LtReactionIceBomb = 191,
    LtReactionBleach = 192,
    LtReactionElephantToothpaste = 193,
    LtReactionElephantToothpaste2 = 194,
    LtReactionGlowStick = 195,
    LtReactionGlowStick2 = 196,
    LtReactionLuminol = 197,
    LtReactionSalt = 198,
    LtReactionFertilizer = 199,
    LtReactionFireball = 200,
    LtReactionMagnesiumSalt = 201,
    LtReactionMiscFire = 202,
    LtReactionFire = 203,
    LtReactionMiscExplosion = 204,
    LtReactionMiscMystical = 205,
    LtReactionMiscMystical2 = 206,
    LtReactionProduct = 207,
    SparklerUse = 208,
    GlowStickUse = 209,
    SparklerActive = 210,
    ConvertToDrowned = 211,
    BucketFillFish = 212,
    BucketEmptyFish = 213,
    BubbleColumnUpwards = 214,
    BubbleColumnDownwards = 215,
    BubblePop = 216,
    BubbleUpInside = 217,
    BubbleDownInside = 218,
    HurtBaby = 219,
    DeathBaby = 220,
    StepBaby = 221,
    SpawnBaby = 222,
    Born = 223,
    TurtleEggBreak = 224,
    TurtleEggCrack = 225,
    TurtleEggHatched = 226,
    LayEgg = 227,
    TurtleEggAttacked = 228,
    BeaconActivate = 229,
    BeaconAmbient = 230,
    BeaconDeactivate = 231,
    BeaconPower = 232,
    ConduitActivate = 233,
    ConduitAmbient = 234,
    ConduitAttack = 235,
    ConduitDeactivate = 236,
    ConduitShort = 237,
    Swoop = 238,
    BambooSaplingPlace = 239,
    PreSneeze = 240,
    Sneeze = 241,
    AmbientTame = 242,
    Scared = 243,
    ScaffoldingClimb = 244,
    CrossbowLoadingStart = 245,
    CrossbowLoadingMiddle = 246,
    CrossbowLoadingEnd = 247,
    CrossbowShoot = 248,
    CrossbowQuickChargeStart = 249,
    CrossbowQuickChargeMiddle = 250,
    CrossbowQuickChargeEnd = 251,
    AmbientAggressive = 252,
    AmbientWorried = 253,
    CantBreed = 254,
    ShieldBlock = 255,
    LecternBookPlace = 256,
    GrindstoneUse = 257,
    Bell = 258,
    CampfireCrackle = 259,
    Roar = 260,
    Stun = 261,
    SweetBerryBushHurt = 262,
    SweetBerryBushPick = 263,
    CartographyTableUse = 264,
    StonecutterUse = 265,
    ComposterEmpty = 266,
    ComposterFill = 267,
    ComposterFillLayer = 268,
    ComposterReady = 269,
    BarrelOpen = 270,
    BarrelClose = 271,
    RaidHorn = 272,
    LoomUse = 273,
    AmbientInRaid = 274,
    UicartographyTableUse = 275,
    UistonecutterUse = 276,
    UiloomUse = 277,
    SmokerUse = 278,
    BlastFurnaceUse = 279,
    SmithingTableUse = 280,
    Screech = 281,
    Sleep = 282,
    FurnaceUse = 283,
    MooshroomConvert = 284,
    MilkSuspiciously = 285,
    Celebrate = 286,
    JumpPrevent = 287,
    AmbientPollinate = 288,
    BeehiveDrip = 289,
    BeehiveEnter = 290,
    BeehiveExit = 291,
    BeehiveWork = 292,
    BeehiveShear = 293,
    HoneybottleDrink = 294,
    AmbientCave = 295,
    Retreat = 296,
    ConvertToZombified = 297,
    Admire = 298,
    StepLava = 299,
    Tempt = 300,
    Panic = 301,
    Angry = 302,
    AmbientMoodWarpedForest = 303,
    AmbientMoodSoulsandValley = 304,
    AmbientMoodNetherWastes = 305,
    AmbientMoodBasaltDeltas = 306,
    AmbientMoodCrimsonForest = 307,
    RespawnAnchorCharge = 308,
    RespawnAnchorDeplete = 309,
    RespawnAnchorSetSpawn = 310,
    RespawnAnchorAmbient = 311,
    SoulEscapeQuiet = 312,
    SoulEscapeLoud = 313,
    RecordPigstep = 314,
    LinkCompassToLodestone = 315,
    UseSmithingTable = 316,
    EquipNetherite = 317,
    AmbientLoopWarpedForest = 318,
    AmbientLoopSoulsandValley = 319,
    AmbientLoopNetherWastes = 320,
    AmbientLoopBasaltDeltas = 321,
    AmbientLoopCrimsonForest = 322,
    AmbientAdditionWarpedForest = 323,
    AmbientAdditionSoulsandValley = 324,
    AmbientAdditionNetherWastes = 325,
    AmbientAdditionBasaltDeltas = 326,
    AmbientAdditionCrimsonForest = 327,
    SculkSensorPowerOn = 328,
    SculkSensorPowerOff = 329,
    BucketFillPowderSnow = 330,
    BucketEmptyPowderSnow = 331,
    PointedDripstoneCauldronDripWater = 332,
    PointedDripstoneCauldronDripLava = 333,
    PointedDripstoneDripWater = 334,
    PointedDripstoneDripLava = 335,
    CaveVinesPickBerries = 336,
    BigDripleafTiltDown = 337,
    BigDripleafTiltUp = 338,
    CopperWaxOn = 339,
    CopperWaxOff = 340,
    Scrape = 341,
    PlayerHurtDrown = 342,
    PlayerHurtOnFire = 343,
    PlayerHurtFreeze = 344,
    UseSpyglass = 345,
    StopUsingSpyglass = 346,
    AmethystBlockChime = 347,
    AmbientScreamer = 348,
    HurtScreamer = 349,
    DeathScreamer = 350,
    MilkScreamer = 351,
    JumpToBlock = 352,
    PreRam = 353,
    PreRamScreamer = 354,
    RamImpact = 355,
    RamImpactScreamer = 356,
    SquidInkSquirt = 357,
    GlowSquidInkSquirt = 358,
    ConvertToStray = 359,
    CakeAddCandle = 360,
    ExtinguishCandle = 361,
    AmbientCandle = 362,
    BlockClick = 363,
    BlockClickFail = 364,
    SculkCatalystBloom = 365,
    SculkShriekerShriek = 366,
    WardenNearbyClose = 367,
    WardenNearbyCloser = 368,
    WardenNearbyClosest = 369,
    WardenSlightlyAngry = 370,
    RecordOtherside = 371,
    Tongue = 372,
    CrackIronGolem = 373,
    RepairIronGolem = 374,
    Listening = 375,
    Heartbeat = 376,
    HornBreak = 377,
    SculkPlace = 378,
    SculkSpread = 379,
    SculkCharge = 380,
    SculkSensorPlace = 381,
    SculkShriekerPlace = 382,
    GoatCall0 = 383,
    GoatCall1 = 384,
    GoatCall2 = 385,
    GoatCall3 = 386,
    GoatCall4 = 387,
    GoatCall5 = 388,
    GoatCall6 = 389,
    GoatCall7 = 390,
    GoatCall8 = 391,
    GoatCall9 = 392,
    GoatHarmony0 = 393,
    GoatHarmony1 = 394,
    GoatHarmony2 = 395,
    GoatHarmony3 = 396,
    GoatHarmony4 = 397,
    GoatHarmony5 = 398,
    GoatHarmony6 = 399,
    GoatHarmony7 = 400,
    GoatHarmony8 = 401,
    GoatHarmony9 = 402,
    GoatMelody0 = 403,
    GoatMelody1 = 404,
    GoatMelody2 = 405,
    GoatMelody3 = 406,
    GoatMelody4 = 407,
    GoatMelody5 = 408,
    GoatMelody6 = 409,
    GoatMelody7 = 410,
    GoatMelody8 = 411,
    GoatMelody9 = 412,
    GoatBass0 = 413,
    GoatBass1 = 414,
    GoatBass2 = 415,
    GoatBass3 = 416,
    GoatBass4 = 417,
    GoatBass5 = 418,
    GoatBass6 = 419,
    GoatBass7 = 420,
    GoatBass8 = 421,
    GoatBass9 = 422,
    Unknown = 423,
    Unknown424 = 424,
    Unknown425 = 425,
    ImitateWarden = 426,
    ListeningAngry = 427,
    ItemGiven = 428,
    ItemTaken = 429,
    Disappeared = 430,
    Reappeared = 431,
    DrinkMilk = 432,
    FrogspawnHatched = 433,
    LaySpawn = 434,
    FrogspawnBreak = 435,
    SonicBoom = 436,
    SonicCharge = 437,
    SoundeventItemThrown = 438,
    Record5 = 439,
    ConvertToFrog = 440,
    RecordPlaying = 441,
    EnchantingTableUse = 442,
    StepSand = 443,
    DashReady = 444,
    BundleDropContents = 445,
    BundleInsert = 446,
    BundleRemoveOne = 447,
    PressurePlateClickOff = 448,
    PressurePlateClickOn = 449,
    ButtonClickOff = 450,
    ButtonClickOn = 451,
    DoorOpen = 452,
    DoorClose = 453,
    TrapdoorOpen = 454,
    TrapdoorClose = 455,
    FenceGateOpen = 456,
    FenceGateClose = 457,
    Insert = 458,
    Pickup = 459,
    InsertEnchanted = 460,
    PickupEnchanted = 461,
    Brush = 462,
    BrushCompleted = 463,
    ShatterDecoratedPot = 464,
    BreakDecoratedPot = 465,
    SnifferEggCrack = 466,
    SnifferEggHatched = 467,
    WaxedSignInteractFail = 468,
    RecordRelic = 469,
}
impl crate::bedrock::codec::BedrockCodec for SoundType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SoundType::ItemUseOn),
            1 => Ok(SoundType::Hit),
            2 => Ok(SoundType::Step),
            3 => Ok(SoundType::Fly),
            4 => Ok(SoundType::Jump),
            5 => Ok(SoundType::Break),
            6 => Ok(SoundType::Place),
            7 => Ok(SoundType::HeavyStep),
            8 => Ok(SoundType::Gallop),
            9 => Ok(SoundType::Fall),
            10 => Ok(SoundType::Ambient),
            11 => Ok(SoundType::AmbientBaby),
            12 => Ok(SoundType::AmbientInWater),
            13 => Ok(SoundType::Breathe),
            14 => Ok(SoundType::Death),
            15 => Ok(SoundType::DeathInWater),
            16 => Ok(SoundType::DeathToZombie),
            17 => Ok(SoundType::Hurt),
            18 => Ok(SoundType::HurtInWater),
            19 => Ok(SoundType::Mad),
            20 => Ok(SoundType::Boost),
            21 => Ok(SoundType::Bow),
            22 => Ok(SoundType::SquishBig),
            23 => Ok(SoundType::SquishSmall),
            24 => Ok(SoundType::FallBig),
            25 => Ok(SoundType::FallSmall),
            26 => Ok(SoundType::Splash),
            27 => Ok(SoundType::Fizz),
            28 => Ok(SoundType::Flap),
            29 => Ok(SoundType::Swim),
            30 => Ok(SoundType::Drink),
            31 => Ok(SoundType::Eat),
            32 => Ok(SoundType::Takeoff),
            33 => Ok(SoundType::Shake),
            34 => Ok(SoundType::Plop),
            35 => Ok(SoundType::Land),
            36 => Ok(SoundType::Saddle),
            37 => Ok(SoundType::Armor),
            38 => Ok(SoundType::MobArmorStandPlace),
            39 => Ok(SoundType::AddChest),
            40 => Ok(SoundType::Throw),
            41 => Ok(SoundType::Attack),
            42 => Ok(SoundType::AttackNoDamage),
            43 => Ok(SoundType::AttackStrong),
            44 => Ok(SoundType::Warn),
            45 => Ok(SoundType::Shear),
            46 => Ok(SoundType::Milk),
            47 => Ok(SoundType::Thunder),
            48 => Ok(SoundType::Explode),
            49 => Ok(SoundType::Fire),
            50 => Ok(SoundType::Ignite),
            51 => Ok(SoundType::Fuse),
            52 => Ok(SoundType::Stare),
            53 => Ok(SoundType::Spawn),
            54 => Ok(SoundType::Shoot),
            55 => Ok(SoundType::BreakBlock),
            56 => Ok(SoundType::Launch),
            57 => Ok(SoundType::Blast),
            58 => Ok(SoundType::LargeBlast),
            59 => Ok(SoundType::Twinkle),
            60 => Ok(SoundType::Remedy),
            61 => Ok(SoundType::Infect),
            62 => Ok(SoundType::LevelUp),
            63 => Ok(SoundType::BowHit),
            64 => Ok(SoundType::BulletHit),
            65 => Ok(SoundType::ExtinguishFire),
            66 => Ok(SoundType::ItemFizz),
            67 => Ok(SoundType::ChestOpen),
            68 => Ok(SoundType::ChestClosed),
            69 => Ok(SoundType::ShulkerBoxOpen),
            70 => Ok(SoundType::ShulkerBoxClosed),
            71 => Ok(SoundType::EnderChestOpen),
            72 => Ok(SoundType::EnderChestClosed),
            73 => Ok(SoundType::PowerOn),
            74 => Ok(SoundType::PowerOff),
            75 => Ok(SoundType::Attach),
            76 => Ok(SoundType::Detach),
            77 => Ok(SoundType::Deny),
            78 => Ok(SoundType::Tripod),
            79 => Ok(SoundType::Pop),
            80 => Ok(SoundType::DropSlot),
            81 => Ok(SoundType::Note),
            82 => Ok(SoundType::Thorns),
            83 => Ok(SoundType::PistonIn),
            84 => Ok(SoundType::PistonOut),
            85 => Ok(SoundType::Portal),
            86 => Ok(SoundType::Water),
            87 => Ok(SoundType::LavaPop),
            88 => Ok(SoundType::Lava),
            89 => Ok(SoundType::Burp),
            90 => Ok(SoundType::BucketFillWater),
            91 => Ok(SoundType::BucketFillLava),
            92 => Ok(SoundType::BucketEmptyWater),
            93 => Ok(SoundType::BucketEmptyLava),
            94 => Ok(SoundType::ArmorEquipChain),
            95 => Ok(SoundType::ArmorEquipDiamond),
            96 => Ok(SoundType::ArmorEquipGeneric),
            97 => Ok(SoundType::ArmorEquipGold),
            98 => Ok(SoundType::ArmorEquipIron),
            99 => Ok(SoundType::ArmorEquipLeather),
            100 => Ok(SoundType::ArmorEquipElytra),
            101 => Ok(SoundType::Record13),
            102 => Ok(SoundType::RecordCat),
            103 => Ok(SoundType::RecordBlocks),
            104 => Ok(SoundType::RecordChirp),
            105 => Ok(SoundType::RecordFar),
            106 => Ok(SoundType::RecordMall),
            107 => Ok(SoundType::RecordMellohi),
            108 => Ok(SoundType::RecordStal),
            109 => Ok(SoundType::RecordStrad),
            110 => Ok(SoundType::RecordWard),
            111 => Ok(SoundType::Record11),
            112 => Ok(SoundType::RecordWait),
            113 => Ok(SoundType::StopRecord),
            114 => Ok(SoundType::Flop),
            115 => Ok(SoundType::GuardianCurse),
            116 => Ok(SoundType::MobWarning),
            117 => Ok(SoundType::MobWarningBaby),
            118 => Ok(SoundType::Teleport),
            119 => Ok(SoundType::ShulkerOpen),
            120 => Ok(SoundType::ShulkerClose),
            121 => Ok(SoundType::Haggle),
            122 => Ok(SoundType::HaggleYes),
            123 => Ok(SoundType::HaggleNo),
            124 => Ok(SoundType::HaggleIdle),
            125 => Ok(SoundType::ChorusGrow),
            126 => Ok(SoundType::ChorusDeath),
            127 => Ok(SoundType::Glass),
            128 => Ok(SoundType::PotionBrewed),
            129 => Ok(SoundType::CastSpell),
            130 => Ok(SoundType::PrepareAttackSpell),
            131 => Ok(SoundType::PrepareSummon),
            132 => Ok(SoundType::PrepareWololo),
            133 => Ok(SoundType::Fang),
            134 => Ok(SoundType::Charge),
            135 => Ok(SoundType::CameraTakePicture),
            136 => Ok(SoundType::LeashKnotPlace),
            137 => Ok(SoundType::LeashKnotBreak),
            138 => Ok(SoundType::AmbientGrowl),
            139 => Ok(SoundType::AmbientWhine),
            140 => Ok(SoundType::AmbientPant),
            141 => Ok(SoundType::AmbientPurr),
            142 => Ok(SoundType::AmbientPurreow),
            143 => Ok(SoundType::DeathMinVolume),
            144 => Ok(SoundType::DeathMidVolume),
            145 => Ok(SoundType::ImitateBlaze),
            146 => Ok(SoundType::ImitateCaveSpider),
            147 => Ok(SoundType::ImitateCreeper),
            148 => Ok(SoundType::ImitateElderGuardian),
            149 => Ok(SoundType::ImitateEnderDragon),
            150 => Ok(SoundType::ImitateEnderman),
            151 => Ok(SoundType::ImitateEndermite),
            152 => Ok(SoundType::ImitateEvocationIllager),
            153 => Ok(SoundType::ImitateGhast),
            154 => Ok(SoundType::ImitateHusk),
            155 => Ok(SoundType::ImitateIllusionIllager),
            156 => Ok(SoundType::ImitateMagmaCube),
            157 => Ok(SoundType::ImitatePolarBear),
            158 => Ok(SoundType::ImitateShulker),
            159 => Ok(SoundType::ImitateSilverfish),
            160 => Ok(SoundType::ImitateSkeleton),
            161 => Ok(SoundType::ImitateSlime),
            162 => Ok(SoundType::ImitateSpider),
            163 => Ok(SoundType::ImitateStray),
            164 => Ok(SoundType::ImitateVex),
            165 => Ok(SoundType::ImitateVindicationIllager),
            166 => Ok(SoundType::ImitateWitch),
            167 => Ok(SoundType::ImitateWither),
            168 => Ok(SoundType::ImitateWitherSkeleton),
            169 => Ok(SoundType::ImitateWolf),
            170 => Ok(SoundType::ImitateZombie),
            171 => Ok(SoundType::ImitateZombiePigman),
            172 => Ok(SoundType::ImitateZombieVillager),
            173 => Ok(SoundType::EnderEyePlaced),
            174 => Ok(SoundType::EndPortalCreated),
            175 => Ok(SoundType::AnvilUse),
            176 => Ok(SoundType::BottleDragonBreath),
            177 => Ok(SoundType::PortalTravel),
            178 => Ok(SoundType::TridentHit),
            179 => Ok(SoundType::TridentReturn),
            180 => Ok(SoundType::TridentRiptide1),
            181 => Ok(SoundType::TridentRiptide2),
            182 => Ok(SoundType::TridentRiptide3),
            183 => Ok(SoundType::TridentThrow),
            184 => Ok(SoundType::TridentThunder),
            185 => Ok(SoundType::TridentHitGround),
            186 => Ok(SoundType::Default),
            187 => Ok(SoundType::FletchingTableUse),
            188 => Ok(SoundType::ElemConstructOpen),
            189 => Ok(SoundType::IceBombHit),
            190 => Ok(SoundType::BalloonPop),
            191 => Ok(SoundType::LtReactionIceBomb),
            192 => Ok(SoundType::LtReactionBleach),
            193 => Ok(SoundType::LtReactionElephantToothpaste),
            194 => Ok(SoundType::LtReactionElephantToothpaste2),
            195 => Ok(SoundType::LtReactionGlowStick),
            196 => Ok(SoundType::LtReactionGlowStick2),
            197 => Ok(SoundType::LtReactionLuminol),
            198 => Ok(SoundType::LtReactionSalt),
            199 => Ok(SoundType::LtReactionFertilizer),
            200 => Ok(SoundType::LtReactionFireball),
            201 => Ok(SoundType::LtReactionMagnesiumSalt),
            202 => Ok(SoundType::LtReactionMiscFire),
            203 => Ok(SoundType::LtReactionFire),
            204 => Ok(SoundType::LtReactionMiscExplosion),
            205 => Ok(SoundType::LtReactionMiscMystical),
            206 => Ok(SoundType::LtReactionMiscMystical2),
            207 => Ok(SoundType::LtReactionProduct),
            208 => Ok(SoundType::SparklerUse),
            209 => Ok(SoundType::GlowStickUse),
            210 => Ok(SoundType::SparklerActive),
            211 => Ok(SoundType::ConvertToDrowned),
            212 => Ok(SoundType::BucketFillFish),
            213 => Ok(SoundType::BucketEmptyFish),
            214 => Ok(SoundType::BubbleColumnUpwards),
            215 => Ok(SoundType::BubbleColumnDownwards),
            216 => Ok(SoundType::BubblePop),
            217 => Ok(SoundType::BubbleUpInside),
            218 => Ok(SoundType::BubbleDownInside),
            219 => Ok(SoundType::HurtBaby),
            220 => Ok(SoundType::DeathBaby),
            221 => Ok(SoundType::StepBaby),
            222 => Ok(SoundType::SpawnBaby),
            223 => Ok(SoundType::Born),
            224 => Ok(SoundType::TurtleEggBreak),
            225 => Ok(SoundType::TurtleEggCrack),
            226 => Ok(SoundType::TurtleEggHatched),
            227 => Ok(SoundType::LayEgg),
            228 => Ok(SoundType::TurtleEggAttacked),
            229 => Ok(SoundType::BeaconActivate),
            230 => Ok(SoundType::BeaconAmbient),
            231 => Ok(SoundType::BeaconDeactivate),
            232 => Ok(SoundType::BeaconPower),
            233 => Ok(SoundType::ConduitActivate),
            234 => Ok(SoundType::ConduitAmbient),
            235 => Ok(SoundType::ConduitAttack),
            236 => Ok(SoundType::ConduitDeactivate),
            237 => Ok(SoundType::ConduitShort),
            238 => Ok(SoundType::Swoop),
            239 => Ok(SoundType::BambooSaplingPlace),
            240 => Ok(SoundType::PreSneeze),
            241 => Ok(SoundType::Sneeze),
            242 => Ok(SoundType::AmbientTame),
            243 => Ok(SoundType::Scared),
            244 => Ok(SoundType::ScaffoldingClimb),
            245 => Ok(SoundType::CrossbowLoadingStart),
            246 => Ok(SoundType::CrossbowLoadingMiddle),
            247 => Ok(SoundType::CrossbowLoadingEnd),
            248 => Ok(SoundType::CrossbowShoot),
            249 => Ok(SoundType::CrossbowQuickChargeStart),
            250 => Ok(SoundType::CrossbowQuickChargeMiddle),
            251 => Ok(SoundType::CrossbowQuickChargeEnd),
            252 => Ok(SoundType::AmbientAggressive),
            253 => Ok(SoundType::AmbientWorried),
            254 => Ok(SoundType::CantBreed),
            255 => Ok(SoundType::ShieldBlock),
            256 => Ok(SoundType::LecternBookPlace),
            257 => Ok(SoundType::GrindstoneUse),
            258 => Ok(SoundType::Bell),
            259 => Ok(SoundType::CampfireCrackle),
            260 => Ok(SoundType::Roar),
            261 => Ok(SoundType::Stun),
            262 => Ok(SoundType::SweetBerryBushHurt),
            263 => Ok(SoundType::SweetBerryBushPick),
            264 => Ok(SoundType::CartographyTableUse),
            265 => Ok(SoundType::StonecutterUse),
            266 => Ok(SoundType::ComposterEmpty),
            267 => Ok(SoundType::ComposterFill),
            268 => Ok(SoundType::ComposterFillLayer),
            269 => Ok(SoundType::ComposterReady),
            270 => Ok(SoundType::BarrelOpen),
            271 => Ok(SoundType::BarrelClose),
            272 => Ok(SoundType::RaidHorn),
            273 => Ok(SoundType::LoomUse),
            274 => Ok(SoundType::AmbientInRaid),
            275 => Ok(SoundType::UicartographyTableUse),
            276 => Ok(SoundType::UistonecutterUse),
            277 => Ok(SoundType::UiloomUse),
            278 => Ok(SoundType::SmokerUse),
            279 => Ok(SoundType::BlastFurnaceUse),
            280 => Ok(SoundType::SmithingTableUse),
            281 => Ok(SoundType::Screech),
            282 => Ok(SoundType::Sleep),
            283 => Ok(SoundType::FurnaceUse),
            284 => Ok(SoundType::MooshroomConvert),
            285 => Ok(SoundType::MilkSuspiciously),
            286 => Ok(SoundType::Celebrate),
            287 => Ok(SoundType::JumpPrevent),
            288 => Ok(SoundType::AmbientPollinate),
            289 => Ok(SoundType::BeehiveDrip),
            290 => Ok(SoundType::BeehiveEnter),
            291 => Ok(SoundType::BeehiveExit),
            292 => Ok(SoundType::BeehiveWork),
            293 => Ok(SoundType::BeehiveShear),
            294 => Ok(SoundType::HoneybottleDrink),
            295 => Ok(SoundType::AmbientCave),
            296 => Ok(SoundType::Retreat),
            297 => Ok(SoundType::ConvertToZombified),
            298 => Ok(SoundType::Admire),
            299 => Ok(SoundType::StepLava),
            300 => Ok(SoundType::Tempt),
            301 => Ok(SoundType::Panic),
            302 => Ok(SoundType::Angry),
            303 => Ok(SoundType::AmbientMoodWarpedForest),
            304 => Ok(SoundType::AmbientMoodSoulsandValley),
            305 => Ok(SoundType::AmbientMoodNetherWastes),
            306 => Ok(SoundType::AmbientMoodBasaltDeltas),
            307 => Ok(SoundType::AmbientMoodCrimsonForest),
            308 => Ok(SoundType::RespawnAnchorCharge),
            309 => Ok(SoundType::RespawnAnchorDeplete),
            310 => Ok(SoundType::RespawnAnchorSetSpawn),
            311 => Ok(SoundType::RespawnAnchorAmbient),
            312 => Ok(SoundType::SoulEscapeQuiet),
            313 => Ok(SoundType::SoulEscapeLoud),
            314 => Ok(SoundType::RecordPigstep),
            315 => Ok(SoundType::LinkCompassToLodestone),
            316 => Ok(SoundType::UseSmithingTable),
            317 => Ok(SoundType::EquipNetherite),
            318 => Ok(SoundType::AmbientLoopWarpedForest),
            319 => Ok(SoundType::AmbientLoopSoulsandValley),
            320 => Ok(SoundType::AmbientLoopNetherWastes),
            321 => Ok(SoundType::AmbientLoopBasaltDeltas),
            322 => Ok(SoundType::AmbientLoopCrimsonForest),
            323 => Ok(SoundType::AmbientAdditionWarpedForest),
            324 => Ok(SoundType::AmbientAdditionSoulsandValley),
            325 => Ok(SoundType::AmbientAdditionNetherWastes),
            326 => Ok(SoundType::AmbientAdditionBasaltDeltas),
            327 => Ok(SoundType::AmbientAdditionCrimsonForest),
            328 => Ok(SoundType::SculkSensorPowerOn),
            329 => Ok(SoundType::SculkSensorPowerOff),
            330 => Ok(SoundType::BucketFillPowderSnow),
            331 => Ok(SoundType::BucketEmptyPowderSnow),
            332 => Ok(SoundType::PointedDripstoneCauldronDripWater),
            333 => Ok(SoundType::PointedDripstoneCauldronDripLava),
            334 => Ok(SoundType::PointedDripstoneDripWater),
            335 => Ok(SoundType::PointedDripstoneDripLava),
            336 => Ok(SoundType::CaveVinesPickBerries),
            337 => Ok(SoundType::BigDripleafTiltDown),
            338 => Ok(SoundType::BigDripleafTiltUp),
            339 => Ok(SoundType::CopperWaxOn),
            340 => Ok(SoundType::CopperWaxOff),
            341 => Ok(SoundType::Scrape),
            342 => Ok(SoundType::PlayerHurtDrown),
            343 => Ok(SoundType::PlayerHurtOnFire),
            344 => Ok(SoundType::PlayerHurtFreeze),
            345 => Ok(SoundType::UseSpyglass),
            346 => Ok(SoundType::StopUsingSpyglass),
            347 => Ok(SoundType::AmethystBlockChime),
            348 => Ok(SoundType::AmbientScreamer),
            349 => Ok(SoundType::HurtScreamer),
            350 => Ok(SoundType::DeathScreamer),
            351 => Ok(SoundType::MilkScreamer),
            352 => Ok(SoundType::JumpToBlock),
            353 => Ok(SoundType::PreRam),
            354 => Ok(SoundType::PreRamScreamer),
            355 => Ok(SoundType::RamImpact),
            356 => Ok(SoundType::RamImpactScreamer),
            357 => Ok(SoundType::SquidInkSquirt),
            358 => Ok(SoundType::GlowSquidInkSquirt),
            359 => Ok(SoundType::ConvertToStray),
            360 => Ok(SoundType::CakeAddCandle),
            361 => Ok(SoundType::ExtinguishCandle),
            362 => Ok(SoundType::AmbientCandle),
            363 => Ok(SoundType::BlockClick),
            364 => Ok(SoundType::BlockClickFail),
            365 => Ok(SoundType::SculkCatalystBloom),
            366 => Ok(SoundType::SculkShriekerShriek),
            367 => Ok(SoundType::WardenNearbyClose),
            368 => Ok(SoundType::WardenNearbyCloser),
            369 => Ok(SoundType::WardenNearbyClosest),
            370 => Ok(SoundType::WardenSlightlyAngry),
            371 => Ok(SoundType::RecordOtherside),
            372 => Ok(SoundType::Tongue),
            373 => Ok(SoundType::CrackIronGolem),
            374 => Ok(SoundType::RepairIronGolem),
            375 => Ok(SoundType::Listening),
            376 => Ok(SoundType::Heartbeat),
            377 => Ok(SoundType::HornBreak),
            378 => Ok(SoundType::SculkPlace),
            379 => Ok(SoundType::SculkSpread),
            380 => Ok(SoundType::SculkCharge),
            381 => Ok(SoundType::SculkSensorPlace),
            382 => Ok(SoundType::SculkShriekerPlace),
            383 => Ok(SoundType::GoatCall0),
            384 => Ok(SoundType::GoatCall1),
            385 => Ok(SoundType::GoatCall2),
            386 => Ok(SoundType::GoatCall3),
            387 => Ok(SoundType::GoatCall4),
            388 => Ok(SoundType::GoatCall5),
            389 => Ok(SoundType::GoatCall6),
            390 => Ok(SoundType::GoatCall7),
            391 => Ok(SoundType::GoatCall8),
            392 => Ok(SoundType::GoatCall9),
            393 => Ok(SoundType::GoatHarmony0),
            394 => Ok(SoundType::GoatHarmony1),
            395 => Ok(SoundType::GoatHarmony2),
            396 => Ok(SoundType::GoatHarmony3),
            397 => Ok(SoundType::GoatHarmony4),
            398 => Ok(SoundType::GoatHarmony5),
            399 => Ok(SoundType::GoatHarmony6),
            400 => Ok(SoundType::GoatHarmony7),
            401 => Ok(SoundType::GoatHarmony8),
            402 => Ok(SoundType::GoatHarmony9),
            403 => Ok(SoundType::GoatMelody0),
            404 => Ok(SoundType::GoatMelody1),
            405 => Ok(SoundType::GoatMelody2),
            406 => Ok(SoundType::GoatMelody3),
            407 => Ok(SoundType::GoatMelody4),
            408 => Ok(SoundType::GoatMelody5),
            409 => Ok(SoundType::GoatMelody6),
            410 => Ok(SoundType::GoatMelody7),
            411 => Ok(SoundType::GoatMelody8),
            412 => Ok(SoundType::GoatMelody9),
            413 => Ok(SoundType::GoatBass0),
            414 => Ok(SoundType::GoatBass1),
            415 => Ok(SoundType::GoatBass2),
            416 => Ok(SoundType::GoatBass3),
            417 => Ok(SoundType::GoatBass4),
            418 => Ok(SoundType::GoatBass5),
            419 => Ok(SoundType::GoatBass6),
            420 => Ok(SoundType::GoatBass7),
            421 => Ok(SoundType::GoatBass8),
            422 => Ok(SoundType::GoatBass9),
            423 => Ok(SoundType::Unknown),
            424 => Ok(SoundType::Unknown),
            425 => Ok(SoundType::Unknown),
            426 => Ok(SoundType::ImitateWarden),
            427 => Ok(SoundType::ListeningAngry),
            428 => Ok(SoundType::ItemGiven),
            429 => Ok(SoundType::ItemTaken),
            430 => Ok(SoundType::Disappeared),
            431 => Ok(SoundType::Reappeared),
            432 => Ok(SoundType::DrinkMilk),
            433 => Ok(SoundType::FrogspawnHatched),
            434 => Ok(SoundType::LaySpawn),
            435 => Ok(SoundType::FrogspawnBreak),
            436 => Ok(SoundType::SonicBoom),
            437 => Ok(SoundType::SonicCharge),
            438 => Ok(SoundType::SoundeventItemThrown),
            439 => Ok(SoundType::Record5),
            440 => Ok(SoundType::ConvertToFrog),
            441 => Ok(SoundType::RecordPlaying),
            442 => Ok(SoundType::EnchantingTableUse),
            443 => Ok(SoundType::StepSand),
            444 => Ok(SoundType::DashReady),
            445 => Ok(SoundType::BundleDropContents),
            446 => Ok(SoundType::BundleInsert),
            447 => Ok(SoundType::BundleRemoveOne),
            448 => Ok(SoundType::PressurePlateClickOff),
            449 => Ok(SoundType::PressurePlateClickOn),
            450 => Ok(SoundType::ButtonClickOff),
            451 => Ok(SoundType::ButtonClickOn),
            452 => Ok(SoundType::DoorOpen),
            453 => Ok(SoundType::DoorClose),
            454 => Ok(SoundType::TrapdoorOpen),
            455 => Ok(SoundType::TrapdoorClose),
            456 => Ok(SoundType::FenceGateOpen),
            457 => Ok(SoundType::FenceGateClose),
            458 => Ok(SoundType::Insert),
            459 => Ok(SoundType::Pickup),
            460 => Ok(SoundType::InsertEnchanted),
            461 => Ok(SoundType::PickupEnchanted),
            462 => Ok(SoundType::Brush),
            463 => Ok(SoundType::BrushCompleted),
            464 => Ok(SoundType::ShatterDecoratedPot),
            465 => Ok(SoundType::BreakDecoratedPot),
            466 => Ok(SoundType::SnifferEggCrack),
            467 => Ok(SoundType::SnifferEggHatched),
            468 => Ok(SoundType::WaxedSignInteractFail),
            469 => Ok(SoundType::RecordRelic),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(SoundType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureBlockSettingsRotation {
    None = 0,
    T90Deg = 1,
    T180Deg = 2,
    T270Deg = 3,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettingsRotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(StructureBlockSettingsRotation::None),
            1 => Ok(StructureBlockSettingsRotation::T90Deg),
            2 => Ok(StructureBlockSettingsRotation::T180Deg),
            3 => Ok(StructureBlockSettingsRotation::T270Deg),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(StructureBlockSettingsRotation), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureBlockSettingsMirror {
    None = 0,
    XAxis = 1,
    ZAxis = 2,
    BothAxes = 3,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettingsMirror {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(StructureBlockSettingsMirror::None),
            1 => Ok(StructureBlockSettingsMirror::XAxis),
            2 => Ok(StructureBlockSettingsMirror::ZAxis),
            3 => Ok(StructureBlockSettingsMirror::BothAxes),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(StructureBlockSettingsMirror), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureBlockSettingsAnimationMode {
    None = 0,
    Layers = 1,
    Blocks = 2,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettingsAnimationMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(StructureBlockSettingsAnimationMode::None),
            1 => Ok(StructureBlockSettingsAnimationMode::Layers),
            2 => Ok(StructureBlockSettingsAnimationMode::Blocks),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(StructureBlockSettingsAnimationMode), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct StructureBlockSettings {
    pub palette_name: String,
    pub ignore_entities: bool,
    pub ignore_blocks: bool,
    pub non_ticking_players_and_ticking_areas: bool,
    pub size: BlockCoordinates,
    pub structure_offset: BlockCoordinates,
    pub last_editing_player_unique_id: i64,
    pub rotation: StructureBlockSettingsRotation,
    pub mirror: StructureBlockSettingsMirror,
    pub animation_mode: StructureBlockSettingsAnimationMode,
    pub animation_duration: f32,
    pub integrity: f32,
    pub seed: u32,
    pub pivot: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.palette_name.encode(buf)?;
        self.ignore_entities.encode(buf)?;
        self.ignore_blocks.encode(buf)?;
        self.non_ticking_players_and_ticking_areas.encode(buf)?;
        self.size.encode(buf)?;
        self.structure_offset.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.last_editing_player_unique_id as i64)
            .encode(buf)?;
        self.rotation.encode(buf)?;
        self.mirror.encode(buf)?;
        self.animation_mode.encode(buf)?;
        self.animation_duration.encode(buf)?;
        self.integrity.encode(buf)?;
        self.seed.encode(buf)?;
        self.pivot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let palette_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let ignore_entities = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let ignore_blocks = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let non_ticking_players_and_ticking_areas = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let size = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let structure_offset = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let last_editing_player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let rotation = <StructureBlockSettingsRotation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let mirror = <StructureBlockSettingsMirror as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_mode = <StructureBlockSettingsAnimationMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let animation_duration = <f32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let integrity = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let seed = <u32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pivot = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            palette_name,
            ignore_entities,
            ignore_blocks,
            non_ticking_players_and_ticking_areas,
            size,
            structure_offset,
            last_editing_player_unique_id,
            rotation,
            mirror,
            animation_mode,
            animation_duration,
            integrity,
            seed,
            pivot,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithCachingItemResult {
    Undefined = 0,
    Success = 1,
    ChunkNotFound = 2,
    InvalidDimension = 3,
    PlayerNotFound = 4,
    YIndexOutOfBounds = 5,
    SuccessAllAir = 6,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItemResult {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SubChunkEntryWithCachingItemResult::Undefined),
            1 => Ok(SubChunkEntryWithCachingItemResult::Success),
            2 => Ok(SubChunkEntryWithCachingItemResult::ChunkNotFound),
            3 => Ok(SubChunkEntryWithCachingItemResult::InvalidDimension),
            4 => Ok(SubChunkEntryWithCachingItemResult::PlayerNotFound),
            5 => Ok(SubChunkEntryWithCachingItemResult::YIndexOutOfBounds),
            6 => Ok(SubChunkEntryWithCachingItemResult::SuccessAllAir),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithCachingItemResult), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithCachingItemHeightmapType {
    NoData = 0,
    HasData = 1,
    TooHigh = 2,
    TooLow = 3,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItemHeightmapType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SubChunkEntryWithCachingItemHeightmapType::NoData),
            1 => Ok(SubChunkEntryWithCachingItemHeightmapType::HasData),
            2 => Ok(SubChunkEntryWithCachingItemHeightmapType::TooHigh),
            3 => Ok(SubChunkEntryWithCachingItemHeightmapType::TooLow),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithCachingItemHeightmapType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SubChunkEntryWithCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub result: SubChunkEntryWithCachingItemResult,
    pub payload: Option<ByteArray>,
    pub heightmap_type: SubChunkEntryWithCachingItemHeightmapType,
    pub heightmap: Option<Vec<u8>>,
    pub blob_id: u64,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        self.result.encode(buf)?;
        if let Some(v) = &self.payload {
            v.encode(buf)?;
        }
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            v.encode(buf)?;
        }
        self.blob_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let result = <SubChunkEntryWithCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let payload = match result {
            SubChunkEntryWithCachingItemResult::SuccessAllAir => None,
            _ => {
                Some(
                    <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                )
            }
        };
        let heightmap_type = <SubChunkEntryWithCachingItemHeightmapType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let heightmap = match heightmap_type {
            SubChunkEntryWithCachingItemHeightmapType::HasData => {
                Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        let blob_id = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            dx,
            dy,
            dz,
            result,
            payload,
            heightmap_type,
            heightmap,
            blob_id,
        })
    }
}
pub type SubChunkEntryWithCaching = Vec<SubChunkEntryWithCachingItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithoutCachingItemResult {
    Undefined = 0,
    Success = 1,
    ChunkNotFound = 2,
    InvalidDimension = 3,
    PlayerNotFound = 4,
    YIndexOutOfBounds = 5,
    SuccessAllAir = 6,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithoutCachingItemResult {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SubChunkEntryWithoutCachingItemResult::Undefined),
            1 => Ok(SubChunkEntryWithoutCachingItemResult::Success),
            2 => Ok(SubChunkEntryWithoutCachingItemResult::ChunkNotFound),
            3 => Ok(SubChunkEntryWithoutCachingItemResult::InvalidDimension),
            4 => Ok(SubChunkEntryWithoutCachingItemResult::PlayerNotFound),
            5 => Ok(SubChunkEntryWithoutCachingItemResult::YIndexOutOfBounds),
            6 => Ok(SubChunkEntryWithoutCachingItemResult::SuccessAllAir),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithoutCachingItemResult), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithoutCachingItemHeightmapType {
    NoData = 0,
    HasData = 1,
    TooHigh = 2,
    TooLow = 3,
}
impl crate::bedrock::codec::BedrockCodec
for SubChunkEntryWithoutCachingItemHeightmapType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::NoData),
            1 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::HasData),
            2 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::TooHigh),
            3 => Ok(SubChunkEntryWithoutCachingItemHeightmapType::TooLow),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(SubChunkEntryWithoutCachingItemHeightmapType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SubChunkEntryWithoutCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub result: SubChunkEntryWithoutCachingItemResult,
    pub payload: ByteArray,
    pub heightmap_type: SubChunkEntryWithoutCachingItemHeightmapType,
    pub heightmap: Option<Vec<u8>>,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithoutCachingItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        self.result.encode(buf)?;
        self.payload.encode(buf)?;
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let result = <SubChunkEntryWithoutCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let payload = <ByteArray as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let heightmap_type = <SubChunkEntryWithoutCachingItemHeightmapType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let heightmap = match heightmap_type {
            SubChunkEntryWithoutCachingItemHeightmapType::HasData => {
                Some(<Vec<u8> as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        Ok(Self {
            dx,
            dy,
            dz,
            result,
            payload,
            heightmap_type,
            heightmap,
        })
    }
}
pub type SubChunkEntryWithoutCaching = Vec<SubChunkEntryWithoutCachingItem>;
#[derive(Debug, Clone, PartialEq)]
pub struct TexturePackInfosItem {
    pub uuid: String,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
    pub rtx_enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for TexturePackInfosItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.uuid.encode(buf)?;
        self.version.encode(buf)?;
        self.size.encode(buf)?;
        self.content_key.encode(buf)?;
        self.sub_pack_name.encode(buf)?;
        self.content_identity.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.rtx_enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let uuid = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = <String as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let size = <u64 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content_key = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let sub_pack_name = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content_identity = <String as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rtx_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
            rtx_enabled,
        })
    }
}
pub type TexturePackInfos = Vec<TexturePackInfosItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TrackedObjectType {
    Entity = 0,
    Block = 1,
}
impl crate::bedrock::codec::BedrockCodec for TrackedObjectType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TrackedObjectType::Entity),
            1 => Ok(TrackedObjectType::Block),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TrackedObjectType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TrackedObject {
    pub type_: TrackedObjectType,
    pub entity_unique_id: Option<i64>,
    pub block_position: Option<BlockCoordinates>,
}
impl crate::bedrock::codec::BedrockCodec for TrackedObject {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.type_.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_position {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let type_ = <TrackedObjectType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_unique_id = match type_ {
            TrackedObjectType::Entity => {
                Some(
                    <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as i64,
                )
            }
            _ => None,
        };
        let block_position = match type_ {
            TrackedObjectType::Block => {
                Some(
                    <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            entity_unique_id,
            block_position,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyLegacyTransactionsItemChangedSlotsItem {
    pub slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionLegacyLegacyTransactionsItemChangedSlotsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { slot_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacyLegacyTransactionsItem {
    pub container_id: u8,
    pub changed_slots: Vec<TransactionLegacyLegacyTransactionsItemChangedSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacyLegacyTransactionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.container_id.encode(buf)?;
        let len = self.changed_slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.changed_slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let changed_slots = {
            let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionLegacyLegacyTransactionsItemChangedSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            container_id,
            changed_slots,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionLegacy {
    pub legacy_transactions: Option<Vec<TransactionLegacyLegacyTransactionsItem>>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacy {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.legacy_transactions.is_none();
        val.encode(buf)?;
        if let Some(v) = &self.legacy_transactions {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let legacy_request_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let legacy_transactions = if (legacy_request_id) != 0 {
            Some({
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TransactionLegacyLegacyTransactionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            })
        } else {
            None
        };
        Ok(Self { legacy_transactions })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionType {
    Normal = 0,
    InventoryMismatch = 1,
    ItemUse = 2,
    ItemUseOnEntity = 3,
    ItemRelease = 4,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionTransactionType::Normal),
            1 => Ok(TransactionTransactionType::InventoryMismatch),
            2 => Ok(TransactionTransactionType::ItemUse),
            3 => Ok(TransactionTransactionType::ItemUseOnEntity),
            4 => Ok(TransactionTransactionType::ItemRelease),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionActionsItemSourceType {
    Container = 0,
    Global = 1,
    WorldInteraction = 2,
    Creative = 3,
    CraftSlot = 100,
    Craft = 99999,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemSourceType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionActionsItemSourceType::Container),
            1 => Ok(TransactionActionsItemSourceType::Global),
            2 => Ok(TransactionActionsItemSourceType::WorldInteraction),
            3 => Ok(TransactionActionsItemSourceType::Creative),
            100 => Ok(TransactionActionsItemSourceType::CraftSlot),
            99999 => Ok(TransactionActionsItemSourceType::Craft),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionActionsItemSourceType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum WindowIdVarint {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
}
impl crate::bedrock::codec::BedrockCodec for WindowIdVarint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            -100 => Ok(WindowIdVarint::DropContents),
            -24 => Ok(WindowIdVarint::Beacon),
            -23 => Ok(WindowIdVarint::TradingOutput),
            -22 => Ok(WindowIdVarint::TradingUseInputs),
            -21 => Ok(WindowIdVarint::TradingInput2),
            -20 => Ok(WindowIdVarint::TradingInput1),
            -17 => Ok(WindowIdVarint::EnchantOutput),
            -16 => Ok(WindowIdVarint::EnchantMaterial),
            -15 => Ok(WindowIdVarint::EnchantInput),
            -13 => Ok(WindowIdVarint::AnvilOutput),
            -12 => Ok(WindowIdVarint::AnvilResult),
            -11 => Ok(WindowIdVarint::AnvilMaterial),
            -10 => Ok(WindowIdVarint::ContainerInput),
            -5 => Ok(WindowIdVarint::CraftingUseIngredient),
            -4 => Ok(WindowIdVarint::CraftingResult),
            -3 => Ok(WindowIdVarint::CraftingRemoveIngredient),
            -2 => Ok(WindowIdVarint::CraftingAddIngredient),
            -1 => Ok(WindowIdVarint::None),
            0 => Ok(WindowIdVarint::Inventory),
            1 => Ok(WindowIdVarint::First),
            100 => Ok(WindowIdVarint::Last),
            119 => Ok(WindowIdVarint::Offhand),
            120 => Ok(WindowIdVarint::Armor),
            121 => Ok(WindowIdVarint::Creative),
            122 => Ok(WindowIdVarint::Hotbar),
            123 => Ok(WindowIdVarint::FixedInventory),
            124 => Ok(WindowIdVarint::Ui),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowIdVarint),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItemContentContainer {
    pub inventory_id: WindowIdVarint,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemContentContainer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.inventory_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let inventory_id = <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { inventory_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItemContentCraft {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemContentCraft {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.action as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { action })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItemContentWorldInteraction {
    pub flags: i32,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionActionsItemContentWorldInteraction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.flags as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let flags = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionActionsItemContent {
    Container(TransactionActionsItemContentContainer),
    Craft(TransactionActionsItemContentCraft),
    CraftSlot(TransactionActionsItemContentCraft),
    WorldInteraction(TransactionActionsItemContentWorldInteraction),
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionActionsItem {
    pub source_type: TransactionActionsItemSourceType,
    pub content: Option<TransactionActionsItemContent>,
    pub slot: i32,
    pub old_item: Item,
    pub new_item: Item,
}
#[derive(Debug, Clone)]
pub struct TransactionActionsItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for TransactionActionsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItem {
    type Args = TransactionActionsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.source_type.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                TransactionActionsItemContent::Container(v) => {
                    v.encode(buf)?;
                }
                TransactionActionsItemContent::Craft(v) => {
                    v.encode(buf)?;
                }
                TransactionActionsItemContent::CraftSlot(v) => {
                    v.encode(buf)?;
                }
                TransactionActionsItemContent::WorldInteraction(v) => {
                    v.encode(buf)?;
                }
            }
        }
        crate::bedrock::codec::VarInt(self.slot as i32).encode(buf)?;
        self.old_item.encode(buf)?;
        self.new_item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let source_type = <TransactionActionsItemSourceType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match source_type {
            TransactionActionsItemSourceType::Container => {
                Some(
                    TransactionActionsItemContent::Container(
                        <TransactionActionsItemContentContainer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::Craft => {
                Some(
                    TransactionActionsItemContent::Craft(
                        <TransactionActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::CraftSlot => {
                Some(
                    TransactionActionsItemContent::CraftSlot(
                        <TransactionActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::WorldInteraction => {
                Some(
                    TransactionActionsItemContent::WorldInteraction(
                        <TransactionActionsItemContentWorldInteraction as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let old_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let new_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            source_type,
            content,
            slot,
            old_item,
            new_item,
        })
    }
}
pub type TransactionActions = Vec<TransactionActionsItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemReleaseActionType {
    Release = 0,
    Consume = 1,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemReleaseActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionTransactionDataItemReleaseActionType::Release),
            1 => Ok(TransactionTransactionDataItemReleaseActionType::Consume),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemReleaseActionType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemRelease {
    pub action_type: TransactionTransactionDataItemReleaseActionType,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub head_pos: Vec3F,
}
#[derive(Debug, Clone)]
pub struct TransactionTransactionDataItemReleaseArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for TransactionTransactionDataItemReleaseArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemRelease {
    type Args = TransactionTransactionDataItemReleaseArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot as i32).encode(buf)?;
        self.held_item.encode(buf)?;
        self.head_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <TransactionTransactionDataItemReleaseActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let head_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            action_type,
            hotbar_slot,
            held_item,
            head_pos,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionUseItemActionType {
    ClickBlock = 0,
    ClickAir = 1,
    BreakBlock = 2,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItemActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionUseItemActionType::ClickBlock),
            1 => Ok(TransactionUseItemActionType::ClickAir),
            2 => Ok(TransactionUseItemActionType::BreakBlock),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionUseItemActionType), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionUseItem {
    pub action_type: TransactionUseItemActionType,
    pub block_position: BlockCoordinates,
    pub face: i32,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
    pub block_runtime_id: i32,
}
#[derive(Debug, Clone)]
pub struct TransactionUseItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for TransactionUseItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItem {
    type Args = TransactionUseItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.action_type.encode(buf)?;
        self.block_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.face as i32).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot as i32).encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let action_type = <TransactionUseItemActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_runtime_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self {
            action_type,
            block_position,
            face,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
            block_runtime_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemUseOnEntityActionType {
    Interact = 0,
    Attack = 1,
}
impl crate::bedrock::codec::BedrockCodec
for TransactionTransactionDataItemUseOnEntityActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Interact),
            1 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Attack),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(TransactionTransactionDataItemUseOnEntityActionType),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransactionTransactionDataItemUseOnEntity {
    pub entity_runtime_id: i64,
    pub action_type: TransactionTransactionDataItemUseOnEntityActionType,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
}
#[derive(Debug, Clone)]
pub struct TransactionTransactionDataItemUseOnEntityArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for TransactionTransactionDataItemUseOnEntityArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemUseOnEntity {
    type Args = TransactionTransactionDataItemUseOnEntityArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarLong(self.entity_runtime_id as i64).encode(buf)?;
        self.action_type.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot as i32).encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let entity_runtime_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
        let action_type = <TransactionTransactionDataItemUseOnEntityActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hotbar_slot = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_runtime_id,
            action_type,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionTransactionData {
    InventoryMismatch,
    ItemRelease(Box<TransactionTransactionDataItemRelease>),
    ItemUse(Box<TransactionUseItem>),
    ItemUseOnEntity(Box<TransactionTransactionDataItemUseOnEntity>),
    Normal,
}
#[derive(Debug, Clone, PartialEq)]
pub struct Transaction {
    pub legacy: TransactionLegacy,
    pub transaction_type: TransactionTransactionType,
    pub actions: TransactionActions,
    pub transaction_data: Option<TransactionTransactionData>,
}
#[derive(Debug, Clone)]
pub struct TransactionArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for TransactionArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for Transaction {
    type Args = TransactionArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.legacy.encode(buf)?;
        self.transaction_type.encode(buf)?;
        self.actions.encode(buf)?;
        if let Some(v) = &self.transaction_data {
            match v {
                TransactionTransactionData::InventoryMismatch => {}
                TransactionTransactionData::ItemRelease(v) => {
                    (&**v).encode(buf)?;
                }
                TransactionTransactionData::ItemUse(v) => {
                    (&**v).encode(buf)?;
                }
                TransactionTransactionData::ItemUseOnEntity(v) => {
                    (&**v).encode(buf)?;
                }
                TransactionTransactionData::Normal => {}
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let legacy = <TransactionLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let transaction_type = <TransactionTransactionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let actions = {
            let res: TransactionActions = {
                let len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TransactionActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionActionsItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let transaction_data = match transaction_type {
            TransactionTransactionType::InventoryMismatch => {
                Some(TransactionTransactionData::InventoryMismatch)
            }
            TransactionTransactionType::ItemRelease => {
                Some(
                    TransactionTransactionData::ItemRelease(
                        Box::new(
                            <TransactionTransactionDataItemRelease as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionTransactionDataItemReleaseArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUse => {
                Some(
                    TransactionTransactionData::ItemUse(
                        Box::new(
                            <TransactionUseItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionUseItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUseOnEntity => {
                Some(
                    TransactionTransactionData::ItemUseOnEntity(
                        Box::new(
                            <TransactionTransactionDataItemUseOnEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionTransactionDataItemUseOnEntityArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::Normal => {
                Some(TransactionTransactionData::Normal)
            }
            _ => None,
        };
        Ok(Self {
            legacy,
            transaction_type,
            actions,
            transaction_data,
        })
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct UpdateBlockFlags : u32
    { const NEIGHBORS = 1; const NETWORK = 2; const NO_GRAPHIC = 4; const PRIORITY = 16;
    const UNUSED = 8; }
}
impl crate::bedrock::codec::BedrockCodec for UpdateBlockFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub struct UpdateMapFlags : u32 {
    const VOID = 1; const TEXTURE = 2; const DECORATION = 4; const INITIALISATION = 8; }
}
impl crate::bedrock::codec::BedrockCodec for UpdateMapFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum WindowId {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
}
impl crate::bedrock::codec::BedrockCodec for WindowId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            -100 => Ok(WindowId::DropContents),
            -24 => Ok(WindowId::Beacon),
            -23 => Ok(WindowId::TradingOutput),
            -22 => Ok(WindowId::TradingUseInputs),
            -21 => Ok(WindowId::TradingInput2),
            -20 => Ok(WindowId::TradingInput1),
            -17 => Ok(WindowId::EnchantOutput),
            -16 => Ok(WindowId::EnchantMaterial),
            -15 => Ok(WindowId::EnchantInput),
            -13 => Ok(WindowId::AnvilOutput),
            -12 => Ok(WindowId::AnvilResult),
            -11 => Ok(WindowId::AnvilMaterial),
            -10 => Ok(WindowId::ContainerInput),
            -5 => Ok(WindowId::CraftingUseIngredient),
            -4 => Ok(WindowId::CraftingResult),
            -3 => Ok(WindowId::CraftingRemoveIngredient),
            -2 => Ok(WindowId::CraftingAddIngredient),
            -1 => Ok(WindowId::None),
            0 => Ok(WindowId::Inventory),
            1 => Ok(WindowId::First),
            100 => Ok(WindowId::Last),
            119 => Ok(WindowId::Offhand),
            120 => Ok(WindowId::Armor),
            121 => Ok(WindowId::Creative),
            122 => Ok(WindowId::Hotbar),
            123 => Ok(WindowId::FixedInventory),
            124 => Ok(WindowId::Ui),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowId), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum WindowType {
    None = -9,
    Inventory = -1,
    Container = 0,
    Workbench = 1,
    Furnace = 2,
    Enchantment = 3,
    BrewingStand = 4,
    Anvil = 5,
    Dispenser = 6,
    Dropper = 7,
    Hopper = 8,
    Cauldron = 9,
    MinecartChest = 10,
    MinecartHopper = 11,
    Horse = 12,
    Beacon = 13,
    StructureEditor = 14,
    Trading = 15,
    CommandBlock = 16,
    Jukebox = 17,
    Armor = 18,
    Hand = 19,
    CompoundCreator = 20,
    ElementConstructor = 21,
    MaterialReducer = 22,
    LabTable = 23,
    Loom = 24,
    Lectern = 25,
    Grindstone = 26,
    BlastFurnace = 27,
    Smoker = 28,
    Stonecutter = 29,
    Cartography = 30,
    Hud = 31,
    JigsawEditor = 32,
    SmithingTable = 33,
    ChestBoat = 34,
}
impl crate::bedrock::codec::BedrockCodec for WindowType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            -9 => Ok(WindowType::None),
            -1 => Ok(WindowType::Inventory),
            0 => Ok(WindowType::Container),
            1 => Ok(WindowType::Workbench),
            2 => Ok(WindowType::Furnace),
            3 => Ok(WindowType::Enchantment),
            4 => Ok(WindowType::BrewingStand),
            5 => Ok(WindowType::Anvil),
            6 => Ok(WindowType::Dispenser),
            7 => Ok(WindowType::Dropper),
            8 => Ok(WindowType::Hopper),
            9 => Ok(WindowType::Cauldron),
            10 => Ok(WindowType::MinecartChest),
            11 => Ok(WindowType::MinecartHopper),
            12 => Ok(WindowType::Horse),
            13 => Ok(WindowType::Beacon),
            14 => Ok(WindowType::StructureEditor),
            15 => Ok(WindowType::Trading),
            16 => Ok(WindowType::CommandBlock),
            17 => Ok(WindowType::Jukebox),
            18 => Ok(WindowType::Armor),
            19 => Ok(WindowType::Hand),
            20 => Ok(WindowType::CompoundCreator),
            21 => Ok(WindowType::ElementConstructor),
            22 => Ok(WindowType::MaterialReducer),
            23 => Ok(WindowType::LabTable),
            24 => Ok(WindowType::Loom),
            25 => Ok(WindowType::Lectern),
            26 => Ok(WindowType::Grindstone),
            27 => Ok(WindowType::BlastFurnace),
            28 => Ok(WindowType::Smoker),
            29 => Ok(WindowType::Stonecutter),
            30 => Ok(WindowType::Cartography),
            31 => Ok(WindowType::Hud),
            32 => Ok(WindowType::JigsawEditor),
            33 => Ok(WindowType::SmithingTable),
            34 => Ok(WindowType::ChestBoat),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(WindowType), val
                        ),
                    ),
                )
            }
        }
    }
}
pub type Bitflags = Vec<u8>;
pub type Encapsulated = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum EnumSizeBasedOnValuesLen {
    Byte = 0,
    Short = 1,
    Int = 2,
}
impl crate::bedrock::codec::BedrockCodec for EnumSizeBasedOnValuesLen {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(EnumSizeBasedOnValuesLen::Byte),
            1 => Ok(EnumSizeBasedOnValuesLen::Short),
            2 => Ok(EnumSizeBasedOnValuesLen::Int),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(EnumSizeBasedOnValuesLen), val
                        ),
                    ),
                )
            }
        }
    }
}
pub type Lnbt = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum McpePacketName {
    Login = 1,
    PlayStatus = 2,
    ServerToClientHandshake = 3,
    ClientToServerHandshake = 4,
    Disconnect = 5,
    ResourcePacksInfo = 6,
    ResourcePackStack = 7,
    ResourcePackClientResponse = 8,
    Text = 9,
    SetTime = 10,
    StartGame = 11,
    AddPlayer = 12,
    AddEntity = 13,
    RemoveEntity = 14,
    AddItemEntity = 15,
    TakeItemEntity = 17,
    MoveEntity = 18,
    MovePlayer = 19,
    RiderJump = 20,
    UpdateBlock = 21,
    AddPainting = 22,
    TickSync = 23,
    LevelSoundEventOld = 24,
    LevelEvent = 25,
    BlockEvent = 26,
    EntityEvent = 27,
    MobEffect = 28,
    UpdateAttributes = 29,
    InventoryTransaction = 30,
    MobEquipment = 31,
    MobArmorEquipment = 32,
    Interact = 33,
    BlockPickRequest = 34,
    EntityPickRequest = 35,
    PlayerAction = 36,
    HurtArmor = 38,
    SetEntityData = 39,
    SetEntityMotion = 40,
    SetEntityLink = 41,
    SetHealth = 42,
    SetSpawnPosition = 43,
    Animate = 44,
    Respawn = 45,
    ContainerOpen = 46,
    ContainerClose = 47,
    PlayerHotbar = 48,
    InventoryContent = 49,
    InventorySlot = 50,
    ContainerSetData = 51,
    CraftingData = 52,
    CraftingEvent = 53,
    GuiDataPickItem = 54,
    AdventureSettings = 55,
    BlockEntityData = 56,
    PlayerInput = 57,
    LevelChunk = 58,
    SetCommandsEnabled = 59,
    SetDifficulty = 60,
    ChangeDimension = 61,
    SetPlayerGameType = 62,
    PlayerList = 63,
    SimpleEvent = 64,
    Event = 65,
    SpawnExperienceOrb = 66,
    ClientboundMapItemData = 67,
    MapInfoRequest = 68,
    RequestChunkRadius = 69,
    ChunkRadiusUpdate = 70,
    ItemFrameDropItem = 71,
    GameRulesChanged = 72,
    Camera = 73,
    BossEvent = 74,
    ShowCredits = 75,
    AvailableCommands = 76,
    CommandRequest = 77,
    CommandBlockUpdate = 78,
    CommandOutput = 79,
    UpdateTrade = 80,
    UpdateEquipment = 81,
    ResourcePackDataInfo = 82,
    ResourcePackChunkData = 83,
    ResourcePackChunkRequest = 84,
    Transfer = 85,
    PlaySound = 86,
    StopSound = 87,
    SetTitle = 88,
    AddBehaviorTree = 89,
    StructureBlockUpdate = 90,
    ShowStoreOffer = 91,
    PurchaseReceipt = 92,
    PlayerSkin = 93,
    SubClientLogin = 94,
    InitiateWebSocketConnection = 95,
    SetLastHurtBy = 96,
    BookEdit = 97,
    NpcRequest = 98,
    PhotoTransfer = 99,
    ModalFormRequest = 100,
    ModalFormResponse = 101,
    ServerSettingsRequest = 102,
    ServerSettingsResponse = 103,
    ShowProfile = 104,
    SetDefaultGameType = 105,
    RemoveObjective = 106,
    SetDisplayObjective = 107,
    SetScore = 108,
    LabTable = 109,
    UpdateBlockSynced = 110,
    MoveEntityDelta = 111,
    SetScoreboardIdentity = 112,
    SetLocalPlayerAsInitialized = 113,
    UpdateSoftEnum = 114,
    NetworkStackLatency = 115,
    ScriptCustomEvent = 117,
    SpawnParticleEffect = 118,
    AvailableEntityIdentifiers = 119,
    LevelSoundEventV2 = 120,
    NetworkChunkPublisherUpdate = 121,
    BiomeDefinitionList = 122,
    LevelSoundEvent = 123,
    LevelEventGeneric = 124,
    LecternUpdate = 125,
    VideoStreamConnect = 126,
    AddEcsEntity = 127,
    RemoveEcsEntity = 128,
    ClientCacheStatus = 129,
    OnScreenTextureAnimation = 130,
    MapCreateLockedCopy = 131,
    StructureTemplateDataExportRequest = 132,
    StructureTemplateDataExportResponse = 133,
    UpdateBlockProperties = 134,
    ClientCacheBlobStatus = 135,
    ClientCacheMissResponse = 136,
    EducationSettings = 137,
    Emote = 138,
    MultiplayerSettings = 139,
    SettingsCommand = 140,
    AnvilDamage = 141,
    CompletedUsingItem = 142,
    NetworkSettings = 143,
    PlayerAuthInput = 144,
    CreativeContent = 145,
    PlayerEnchantOptions = 146,
    ItemStackRequest = 147,
    ItemStackResponse = 148,
    PlayerArmorDamage = 149,
    CodeBuilder = 150,
    UpdatePlayerGameType = 151,
    EmoteList = 152,
    PositionTrackingDbBroadcast = 153,
    PositionTrackingDbRequest = 154,
    DebugInfo = 155,
    PacketViolationWarning = 156,
    MotionPredictionHints = 157,
    AnimateEntity = 158,
    CameraShake = 159,
    PlayerFog = 160,
    CorrectPlayerMovePrediction = 161,
    ItemComponent = 162,
    FilterTextPacket = 163,
    DebugRenderer = 164,
    SyncEntityProperty = 165,
    AddVolumeEntity = 166,
    RemoveVolumeEntity = 167,
    SimulationType = 168,
    NpcDialogue = 169,
    EduUriResourcePacket = 170,
    CreatePhoto = 171,
    UpdateSubchunkBlocks = 172,
    PhotoInfoRequest = 173,
    Subchunk = 174,
    SubchunkRequest = 175,
    ClientStartItemCooldown = 176,
    ScriptMessage = 177,
    CodeBuilderSource = 178,
    TickingAreasLoadStatus = 179,
    DimensionData = 180,
    AgentAction = 181,
    ChangeMobProperty = 182,
    LessonProgress = 183,
    RequestAbility = 184,
    RequestPermissions = 185,
    ToastRequest = 186,
    UpdateAbilities = 187,
    UpdateAdventureSettings = 188,
    DeathInfo = 189,
    EditorNetwork = 190,
    FeatureRegistry = 191,
    ServerStats = 192,
    RequestNetworkSettings = 193,
    GameTestRequest = 194,
    GameTestResults = 195,
    UpdateClientInputLocks = 196,
    ClientCheatAbility = 197,
    CameraPresets = 198,
    UnlockedRecipes = 199,
    CameraInstruction = 300,
    CompressedBiomeDefinitions = 301,
    TrimData = 302,
    OpenSign = 303,
    AgentAnimation = 304,
}
impl crate::bedrock::codec::BedrockCodec for McpePacketName {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(McpePacketName::Login),
            2 => Ok(McpePacketName::PlayStatus),
            3 => Ok(McpePacketName::ServerToClientHandshake),
            4 => Ok(McpePacketName::ClientToServerHandshake),
            5 => Ok(McpePacketName::Disconnect),
            6 => Ok(McpePacketName::ResourcePacksInfo),
            7 => Ok(McpePacketName::ResourcePackStack),
            8 => Ok(McpePacketName::ResourcePackClientResponse),
            9 => Ok(McpePacketName::Text),
            10 => Ok(McpePacketName::SetTime),
            11 => Ok(McpePacketName::StartGame),
            12 => Ok(McpePacketName::AddPlayer),
            13 => Ok(McpePacketName::AddEntity),
            14 => Ok(McpePacketName::RemoveEntity),
            15 => Ok(McpePacketName::AddItemEntity),
            17 => Ok(McpePacketName::TakeItemEntity),
            18 => Ok(McpePacketName::MoveEntity),
            19 => Ok(McpePacketName::MovePlayer),
            20 => Ok(McpePacketName::RiderJump),
            21 => Ok(McpePacketName::UpdateBlock),
            22 => Ok(McpePacketName::AddPainting),
            23 => Ok(McpePacketName::TickSync),
            24 => Ok(McpePacketName::LevelSoundEventOld),
            25 => Ok(McpePacketName::LevelEvent),
            26 => Ok(McpePacketName::BlockEvent),
            27 => Ok(McpePacketName::EntityEvent),
            28 => Ok(McpePacketName::MobEffect),
            29 => Ok(McpePacketName::UpdateAttributes),
            30 => Ok(McpePacketName::InventoryTransaction),
            31 => Ok(McpePacketName::MobEquipment),
            32 => Ok(McpePacketName::MobArmorEquipment),
            33 => Ok(McpePacketName::Interact),
            34 => Ok(McpePacketName::BlockPickRequest),
            35 => Ok(McpePacketName::EntityPickRequest),
            36 => Ok(McpePacketName::PlayerAction),
            38 => Ok(McpePacketName::HurtArmor),
            39 => Ok(McpePacketName::SetEntityData),
            40 => Ok(McpePacketName::SetEntityMotion),
            41 => Ok(McpePacketName::SetEntityLink),
            42 => Ok(McpePacketName::SetHealth),
            43 => Ok(McpePacketName::SetSpawnPosition),
            44 => Ok(McpePacketName::Animate),
            45 => Ok(McpePacketName::Respawn),
            46 => Ok(McpePacketName::ContainerOpen),
            47 => Ok(McpePacketName::ContainerClose),
            48 => Ok(McpePacketName::PlayerHotbar),
            49 => Ok(McpePacketName::InventoryContent),
            50 => Ok(McpePacketName::InventorySlot),
            51 => Ok(McpePacketName::ContainerSetData),
            52 => Ok(McpePacketName::CraftingData),
            53 => Ok(McpePacketName::CraftingEvent),
            54 => Ok(McpePacketName::GuiDataPickItem),
            55 => Ok(McpePacketName::AdventureSettings),
            56 => Ok(McpePacketName::BlockEntityData),
            57 => Ok(McpePacketName::PlayerInput),
            58 => Ok(McpePacketName::LevelChunk),
            59 => Ok(McpePacketName::SetCommandsEnabled),
            60 => Ok(McpePacketName::SetDifficulty),
            61 => Ok(McpePacketName::ChangeDimension),
            62 => Ok(McpePacketName::SetPlayerGameType),
            63 => Ok(McpePacketName::PlayerList),
            64 => Ok(McpePacketName::SimpleEvent),
            65 => Ok(McpePacketName::Event),
            66 => Ok(McpePacketName::SpawnExperienceOrb),
            67 => Ok(McpePacketName::ClientboundMapItemData),
            68 => Ok(McpePacketName::MapInfoRequest),
            69 => Ok(McpePacketName::RequestChunkRadius),
            70 => Ok(McpePacketName::ChunkRadiusUpdate),
            71 => Ok(McpePacketName::ItemFrameDropItem),
            72 => Ok(McpePacketName::GameRulesChanged),
            73 => Ok(McpePacketName::Camera),
            74 => Ok(McpePacketName::BossEvent),
            75 => Ok(McpePacketName::ShowCredits),
            76 => Ok(McpePacketName::AvailableCommands),
            77 => Ok(McpePacketName::CommandRequest),
            78 => Ok(McpePacketName::CommandBlockUpdate),
            79 => Ok(McpePacketName::CommandOutput),
            80 => Ok(McpePacketName::UpdateTrade),
            81 => Ok(McpePacketName::UpdateEquipment),
            82 => Ok(McpePacketName::ResourcePackDataInfo),
            83 => Ok(McpePacketName::ResourcePackChunkData),
            84 => Ok(McpePacketName::ResourcePackChunkRequest),
            85 => Ok(McpePacketName::Transfer),
            86 => Ok(McpePacketName::PlaySound),
            87 => Ok(McpePacketName::StopSound),
            88 => Ok(McpePacketName::SetTitle),
            89 => Ok(McpePacketName::AddBehaviorTree),
            90 => Ok(McpePacketName::StructureBlockUpdate),
            91 => Ok(McpePacketName::ShowStoreOffer),
            92 => Ok(McpePacketName::PurchaseReceipt),
            93 => Ok(McpePacketName::PlayerSkin),
            94 => Ok(McpePacketName::SubClientLogin),
            95 => Ok(McpePacketName::InitiateWebSocketConnection),
            96 => Ok(McpePacketName::SetLastHurtBy),
            97 => Ok(McpePacketName::BookEdit),
            98 => Ok(McpePacketName::NpcRequest),
            99 => Ok(McpePacketName::PhotoTransfer),
            100 => Ok(McpePacketName::ModalFormRequest),
            101 => Ok(McpePacketName::ModalFormResponse),
            102 => Ok(McpePacketName::ServerSettingsRequest),
            103 => Ok(McpePacketName::ServerSettingsResponse),
            104 => Ok(McpePacketName::ShowProfile),
            105 => Ok(McpePacketName::SetDefaultGameType),
            106 => Ok(McpePacketName::RemoveObjective),
            107 => Ok(McpePacketName::SetDisplayObjective),
            108 => Ok(McpePacketName::SetScore),
            109 => Ok(McpePacketName::LabTable),
            110 => Ok(McpePacketName::UpdateBlockSynced),
            111 => Ok(McpePacketName::MoveEntityDelta),
            112 => Ok(McpePacketName::SetScoreboardIdentity),
            113 => Ok(McpePacketName::SetLocalPlayerAsInitialized),
            114 => Ok(McpePacketName::UpdateSoftEnum),
            115 => Ok(McpePacketName::NetworkStackLatency),
            117 => Ok(McpePacketName::ScriptCustomEvent),
            118 => Ok(McpePacketName::SpawnParticleEffect),
            119 => Ok(McpePacketName::AvailableEntityIdentifiers),
            120 => Ok(McpePacketName::LevelSoundEventV2),
            121 => Ok(McpePacketName::NetworkChunkPublisherUpdate),
            122 => Ok(McpePacketName::BiomeDefinitionList),
            123 => Ok(McpePacketName::LevelSoundEvent),
            124 => Ok(McpePacketName::LevelEventGeneric),
            125 => Ok(McpePacketName::LecternUpdate),
            126 => Ok(McpePacketName::VideoStreamConnect),
            127 => Ok(McpePacketName::AddEcsEntity),
            128 => Ok(McpePacketName::RemoveEcsEntity),
            129 => Ok(McpePacketName::ClientCacheStatus),
            130 => Ok(McpePacketName::OnScreenTextureAnimation),
            131 => Ok(McpePacketName::MapCreateLockedCopy),
            132 => Ok(McpePacketName::StructureTemplateDataExportRequest),
            133 => Ok(McpePacketName::StructureTemplateDataExportResponse),
            134 => Ok(McpePacketName::UpdateBlockProperties),
            135 => Ok(McpePacketName::ClientCacheBlobStatus),
            136 => Ok(McpePacketName::ClientCacheMissResponse),
            137 => Ok(McpePacketName::EducationSettings),
            138 => Ok(McpePacketName::Emote),
            139 => Ok(McpePacketName::MultiplayerSettings),
            140 => Ok(McpePacketName::SettingsCommand),
            141 => Ok(McpePacketName::AnvilDamage),
            142 => Ok(McpePacketName::CompletedUsingItem),
            143 => Ok(McpePacketName::NetworkSettings),
            144 => Ok(McpePacketName::PlayerAuthInput),
            145 => Ok(McpePacketName::CreativeContent),
            146 => Ok(McpePacketName::PlayerEnchantOptions),
            147 => Ok(McpePacketName::ItemStackRequest),
            148 => Ok(McpePacketName::ItemStackResponse),
            149 => Ok(McpePacketName::PlayerArmorDamage),
            150 => Ok(McpePacketName::CodeBuilder),
            151 => Ok(McpePacketName::UpdatePlayerGameType),
            152 => Ok(McpePacketName::EmoteList),
            153 => Ok(McpePacketName::PositionTrackingDbBroadcast),
            154 => Ok(McpePacketName::PositionTrackingDbRequest),
            155 => Ok(McpePacketName::DebugInfo),
            156 => Ok(McpePacketName::PacketViolationWarning),
            157 => Ok(McpePacketName::MotionPredictionHints),
            158 => Ok(McpePacketName::AnimateEntity),
            159 => Ok(McpePacketName::CameraShake),
            160 => Ok(McpePacketName::PlayerFog),
            161 => Ok(McpePacketName::CorrectPlayerMovePrediction),
            162 => Ok(McpePacketName::ItemComponent),
            163 => Ok(McpePacketName::FilterTextPacket),
            164 => Ok(McpePacketName::DebugRenderer),
            165 => Ok(McpePacketName::SyncEntityProperty),
            166 => Ok(McpePacketName::AddVolumeEntity),
            167 => Ok(McpePacketName::RemoveVolumeEntity),
            168 => Ok(McpePacketName::SimulationType),
            169 => Ok(McpePacketName::NpcDialogue),
            170 => Ok(McpePacketName::EduUriResourcePacket),
            171 => Ok(McpePacketName::CreatePhoto),
            172 => Ok(McpePacketName::UpdateSubchunkBlocks),
            173 => Ok(McpePacketName::PhotoInfoRequest),
            174 => Ok(McpePacketName::Subchunk),
            175 => Ok(McpePacketName::SubchunkRequest),
            176 => Ok(McpePacketName::ClientStartItemCooldown),
            177 => Ok(McpePacketName::ScriptMessage),
            178 => Ok(McpePacketName::CodeBuilderSource),
            179 => Ok(McpePacketName::TickingAreasLoadStatus),
            180 => Ok(McpePacketName::DimensionData),
            181 => Ok(McpePacketName::AgentAction),
            182 => Ok(McpePacketName::ChangeMobProperty),
            183 => Ok(McpePacketName::LessonProgress),
            184 => Ok(McpePacketName::RequestAbility),
            185 => Ok(McpePacketName::RequestPermissions),
            186 => Ok(McpePacketName::ToastRequest),
            187 => Ok(McpePacketName::UpdateAbilities),
            188 => Ok(McpePacketName::UpdateAdventureSettings),
            189 => Ok(McpePacketName::DeathInfo),
            190 => Ok(McpePacketName::EditorNetwork),
            191 => Ok(McpePacketName::FeatureRegistry),
            192 => Ok(McpePacketName::ServerStats),
            193 => Ok(McpePacketName::RequestNetworkSettings),
            194 => Ok(McpePacketName::GameTestRequest),
            195 => Ok(McpePacketName::GameTestResults),
            196 => Ok(McpePacketName::UpdateClientInputLocks),
            197 => Ok(McpePacketName::ClientCheatAbility),
            198 => Ok(McpePacketName::CameraPresets),
            199 => Ok(McpePacketName::UnlockedRecipes),
            300 => Ok(McpePacketName::CameraInstruction),
            301 => Ok(McpePacketName::CompressedBiomeDefinitions),
            302 => Ok(McpePacketName::TrimData),
            303 => Ok(McpePacketName::OpenSign),
            304 => Ok(McpePacketName::AgentAnimation),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}", stringify!(McpePacketName),
                            val
                        ),
                    ),
                )
            }
        }
    }
}
pub type NbtLoop = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Vec2F {
    pub x: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec2F {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.x.encode(buf)?;
        self.z.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let z = <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { x, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum McpePacketParams {
    AddBehaviorTree(PacketAddBehaviorTree),
    AddEcsEntity(PacketAddEcsEntity),
    AddEntity(Box<PacketAddEntity>),
    AddItemEntity(Box<PacketAddItemEntity>),
    AddPainting(Box<PacketAddPainting>),
    AddPlayer(Box<PacketAddPlayer>),
    AddVolumeEntity(Box<PacketAddVolumeEntity>),
    AdventureSettings(Box<PacketAdventureSettings>),
    AgentAction(PacketAgentAction),
    AgentAnimation(PacketAgentAnimation),
    Animate(Box<PacketAnimate>),
    AnimateEntity(Box<PacketAnimateEntity>),
    AnvilDamage(PacketAnvilDamage),
    AvailableCommands(Box<PacketAvailableCommands>),
    AvailableEntityIdentifiers(PacketAvailableEntityIdentifiers),
    BiomeDefinitionList(PacketBiomeDefinitionList),
    BlockEntityData(PacketBlockEntityData),
    BlockEvent(PacketBlockEvent),
    BlockPickRequest(Box<PacketBlockPickRequest>),
    BookEdit(Box<PacketBookEdit>),
    BossEvent(Box<PacketBossEvent>),
    Camera(PacketCamera),
    CameraInstruction(PacketCameraInstruction),
    CameraPresets(PacketCameraPresets),
    CameraShake(Box<PacketCameraShake>),
    ChangeDimension(PacketChangeDimension),
    ChangeMobProperty(Box<PacketChangeMobProperty>),
    ChunkRadiusUpdate(PacketChunkRadiusUpdate),
    ClientCacheBlobStatus(Box<PacketClientCacheBlobStatus>),
    ClientCacheMissResponse(PacketClientCacheMissResponse),
    ClientCacheStatus(PacketClientCacheStatus),
    ClientCheatAbility(Box<PacketClientCheatAbility>),
    ClientStartItemCooldown(PacketClientStartItemCooldown),
    ClientToServerHandshake(PacketClientToServerHandshake),
    ClientboundMapItemData(Box<PacketClientboundMapItemData>),
    CodeBuilder(PacketCodeBuilder),
    CodeBuilderSource(PacketCodeBuilderSource),
    CommandBlockUpdate(Box<PacketCommandBlockUpdate>),
    CommandOutput(Box<PacketCommandOutput>),
    CommandRequest(Box<PacketCommandRequest>),
    CompletedUsingItem(PacketCompletedUsingItem),
    CompressedBiomeDefinitions(PacketCompressedBiomeDefinitions),
    ContainerClose(PacketContainerClose),
    ContainerOpen(Box<PacketContainerOpen>),
    ContainerSetData(PacketContainerSetData),
    CorrectPlayerMovePrediction(Box<PacketCorrectPlayerMovePrediction>),
    CraftingData(Box<PacketCraftingData>),
    CraftingEvent(Box<PacketCraftingEvent>),
    CreatePhoto(PacketCreatePhoto),
    CreativeContent(PacketCreativeContent),
    DeathInfo(PacketDeathInfo),
    DebugInfo(PacketDebugInfo),
    DebugRenderer(Box<PacketDebugRenderer>),
    DimensionData(PacketDimensionData),
    Disconnect(PacketDisconnect),
    EditorNetwork(PacketEditorNetwork),
    EduUriResourcePacket(PacketEduUriResourcePacket),
    EducationSettings(Box<PacketEducationSettings>),
    Emote(Box<PacketEmote>),
    EmoteList(PacketEmoteList),
    EntityEvent(PacketEntityEvent),
    EntityPickRequest(PacketEntityPickRequest),
    Event(Box<PacketEvent>),
    FeatureRegistry(PacketFeatureRegistry),
    FilterTextPacket(PacketFilterTextPacket),
    GameRulesChanged(PacketGameRulesChanged),
    GameTestRequest(Box<PacketGameTestRequest>),
    GameTestResults(PacketGameTestResults),
    GuiDataPickItem(PacketGuiDataPickItem),
    HurtArmor(PacketHurtArmor),
    InitiateWebSocketConnection(PacketInitiateWebSocketConnection),
    Interact(Box<PacketInteract>),
    InventoryContent(PacketInventoryContent),
    InventorySlot(Box<PacketInventorySlot>),
    InventoryTransaction(Box<PacketInventoryTransaction>),
    ItemComponent(PacketItemComponent),
    ItemFrameDropItem(PacketItemFrameDropItem),
    ItemStackRequest(PacketItemStackRequest),
    ItemStackResponse(PacketItemStackResponse),
    LabTable(PacketLabTable),
    LecternUpdate(Box<PacketLecternUpdate>),
    LessonProgress(PacketLessonProgress),
    LevelChunk(Box<PacketLevelChunk>),
    LevelEvent(PacketLevelEvent),
    LevelEventGeneric(PacketLevelEventGeneric),
    LevelSoundEvent(Box<PacketLevelSoundEvent>),
    LevelSoundEventOld(Box<PacketLevelSoundEventOld>),
    LevelSoundEventV2(Box<PacketLevelSoundEventV2>),
    Login(PacketLogin),
    MapCreateLockedCopy(PacketMapCreateLockedCopy),
    MapInfoRequest(PacketMapInfoRequest),
    MobArmorEquipment(Box<PacketMobArmorEquipment>),
    MobEffect(Box<PacketMobEffect>),
    MobEquipment(Box<PacketMobEquipment>),
    ModalFormRequest(PacketModalFormRequest),
    ModalFormResponse(Box<PacketModalFormResponse>),
    MotionPredictionHints(PacketMotionPredictionHints),
    MoveEntity(Box<PacketMoveEntity>),
    MoveEntityDelta(Box<PacketMoveEntityDelta>),
    MovePlayer(Box<PacketMovePlayer>),
    MultiplayerSettings(PacketMultiplayerSettings),
    NetworkChunkPublisherUpdate(PacketNetworkChunkPublisherUpdate),
    NetworkSettings(Box<PacketNetworkSettings>),
    NetworkStackLatency(PacketNetworkStackLatency),
    NpcDialogue(Box<PacketNpcDialogue>),
    NpcRequest(Box<PacketNpcRequest>),
    OnScreenTextureAnimation(PacketOnScreenTextureAnimation),
    OpenSign(PacketOpenSign),
    PacketViolationWarning(Box<PacketPacketViolationWarning>),
    PhotoInfoRequest(PacketPhotoInfoRequest),
    PhotoTransfer(Box<PacketPhotoTransfer>),
    PlaySound(Box<PacketPlaySound>),
    PlayStatus(PacketPlayStatus),
    PlayerAction(Box<PacketPlayerAction>),
    PlayerArmorDamage(Box<PacketPlayerArmorDamage>),
    PlayerAuthInput(Box<PacketPlayerAuthInput>),
    PlayerEnchantOptions(PacketPlayerEnchantOptions),
    PlayerFog(PacketPlayerFog),
    PlayerHotbar(PacketPlayerHotbar),
    PlayerInput(Box<PacketPlayerInput>),
    PlayerList(Box<PacketPlayerList>),
    PlayerSkin(Box<PacketPlayerSkin>),
    PositionTrackingDbBroadcast(PacketPositionTrackingDbBroadcast),
    PositionTrackingDbRequest(PacketPositionTrackingDbRequest),
    PurchaseReceipt(PacketPurchaseReceipt),
    RemoveEcsEntity(PacketRemoveEcsEntity),
    RemoveEntity(PacketRemoveEntity),
    RemoveObjective(PacketRemoveObjective),
    RemoveVolumeEntity(PacketRemoveVolumeEntity),
    RequestAbility(Box<PacketRequestAbility>),
    RequestChunkRadius(PacketRequestChunkRadius),
    RequestNetworkSettings(PacketRequestNetworkSettings),
    RequestPermissions(PacketRequestPermissions),
    ResourcePackChunkData(Box<PacketResourcePackChunkData>),
    ResourcePackChunkRequest(PacketResourcePackChunkRequest),
    ResourcePackClientResponse(PacketResourcePackClientResponse),
    ResourcePackDataInfo(Box<PacketResourcePackDataInfo>),
    ResourcePackStack(Box<PacketResourcePackStack>),
    ResourcePacksInfo(Box<PacketResourcePacksInfo>),
    Respawn(PacketRespawn),
    RiderJump(PacketRiderJump),
    ScriptCustomEvent(PacketScriptCustomEvent),
    ScriptMessage(PacketScriptMessage),
    ServerSettingsRequest(PacketServerSettingsRequest),
    ServerSettingsResponse(PacketServerSettingsResponse),
    ServerStats(PacketServerStats),
    ServerToClientHandshake(PacketServerToClientHandshake),
    SetCommandsEnabled(PacketSetCommandsEnabled),
    SetDefaultGameType(PacketSetDefaultGameType),
    SetDifficulty(PacketSetDifficulty),
    SetDisplayObjective(Box<PacketSetDisplayObjective>),
    SetEntityData(Box<PacketSetEntityData>),
    SetEntityLink(Box<PacketSetEntityLink>),
    SetEntityMotion(PacketSetEntityMotion),
    SetHealth(PacketSetHealth),
    SetLastHurtBy(PacketSetLastHurtBy),
    SetLocalPlayerAsInitialized(PacketSetLocalPlayerAsInitialized),
    SetPlayerGameType(PacketSetPlayerGameType),
    SetScore(PacketSetScore),
    SetScoreboardIdentity(PacketSetScoreboardIdentity),
    SetSpawnPosition(Box<PacketSetSpawnPosition>),
    SetTime(PacketSetTime),
    SetTitle(Box<PacketSetTitle>),
    SettingsCommand(PacketSettingsCommand),
    ShowCredits(PacketShowCredits),
    ShowProfile(PacketShowProfile),
    ShowStoreOffer(PacketShowStoreOffer),
    SimpleEvent(PacketSimpleEvent),
    SimulationType(PacketSimulationType),
    SpawnExperienceOrb(PacketSpawnExperienceOrb),
    SpawnParticleEffect(Box<PacketSpawnParticleEffect>),
    StartGame(Box<PacketStartGame>),
    StopSound(PacketStopSound),
    StructureBlockUpdate(Box<PacketStructureBlockUpdate>),
    StructureTemplateDataExportRequest(Box<PacketStructureTemplateDataExportRequest>),
    StructureTemplateDataExportResponse(Box<PacketStructureTemplateDataExportResponse>),
    SubClientLogin(PacketSubClientLogin),
    Subchunk(Box<PacketSubchunk>),
    SubchunkRequest(PacketSubchunkRequest),
    SyncEntityProperty(PacketSyncEntityProperty),
    TakeItemEntity(PacketTakeItemEntity),
    Text(Box<PacketText>),
    TickSync(PacketTickSync),
    TickingAreasLoadStatus(PacketTickingAreasLoadStatus),
    ToastRequest(PacketToastRequest),
    Transfer(PacketTransfer),
    TrimData(PacketTrimData),
    UnlockedRecipes(PacketUnlockedRecipes),
    UpdateAbilities(Box<PacketUpdateAbilities>),
    UpdateAdventureSettings(Box<PacketUpdateAdventureSettings>),
    UpdateAttributes(PacketUpdateAttributes),
    UpdateBlock(Box<PacketUpdateBlock>),
    UpdateBlockProperties(PacketUpdateBlockProperties),
    UpdateBlockSynced(Box<PacketUpdateBlockSynced>),
    UpdateClientInputLocks(PacketUpdateClientInputLocks),
    UpdateEquipment(Box<PacketUpdateEquipment>),
    UpdatePlayerGameType(PacketUpdatePlayerGameType),
    UpdateSoftEnum(PacketUpdateSoftEnum),
    UpdateSubchunkBlocks(Box<PacketUpdateSubchunkBlocks>),
    UpdateTrade(Box<PacketUpdateTrade>),
    VideoStreamConnect(Box<PacketVideoStreamConnect>),
}
#[derive(Debug, Clone, PartialEq)]
pub struct McpePacket {
    pub name: McpePacketName,
    pub params: Option<McpePacketParams>,
}
#[derive(Debug, Clone)]
pub struct McpePacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for McpePacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for McpePacket {
    type Args = McpePacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        if let Some(v) = &self.params {
            match v {
                McpePacketParams::AddBehaviorTree(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AddEcsEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AddEntity(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AddItemEntity(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AddPainting(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AddPlayer(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AddVolumeEntity(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AdventureSettings(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AgentAction(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AgentAnimation(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Animate(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AnimateEntity(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AnvilDamage(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::AvailableCommands(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::AvailableEntityIdentifiers(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BiomeDefinitionList(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BlockEntityData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BlockEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::BlockPickRequest(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::BookEdit(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::BossEvent(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::Camera(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CameraInstruction(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CameraPresets(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CameraShake(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ChangeDimension(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ChangeMobProperty(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ChunkRadiusUpdate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientCacheBlobStatus(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ClientCacheMissResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientCacheStatus(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientCheatAbility(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ClientStartItemCooldown(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientToServerHandshake(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ClientboundMapItemData(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::CodeBuilder(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CodeBuilderSource(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CommandBlockUpdate(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::CommandOutput(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::CommandRequest(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::CompletedUsingItem(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CompressedBiomeDefinitions(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ContainerClose(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ContainerOpen(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ContainerSetData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CorrectPlayerMovePrediction(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::CraftingData(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::CraftingEvent(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::CreatePhoto(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::CreativeContent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::DeathInfo(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::DebugInfo(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::DebugRenderer(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::DimensionData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Disconnect(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EditorNetwork(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EduUriResourcePacket(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EducationSettings(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::Emote(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::EmoteList(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EntityEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::EntityPickRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Event(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::FeatureRegistry(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::FilterTextPacket(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::GameRulesChanged(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::GameTestRequest(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::GameTestResults(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::GuiDataPickItem(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::HurtArmor(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::InitiateWebSocketConnection(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Interact(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::InventoryContent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::InventorySlot(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::InventoryTransaction(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ItemComponent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ItemFrameDropItem(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ItemStackRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ItemStackResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LabTable(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LecternUpdate(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::LessonProgress(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelChunk(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::LevelEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelEventGeneric(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::LevelSoundEvent(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::LevelSoundEventOld(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::LevelSoundEventV2(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::Login(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MapCreateLockedCopy(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MapInfoRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MobArmorEquipment(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::MobEffect(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::MobEquipment(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ModalFormRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ModalFormResponse(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::MotionPredictionHints(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::MoveEntity(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::MoveEntityDelta(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::MovePlayer(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::MultiplayerSettings(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::NetworkChunkPublisherUpdate(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::NetworkSettings(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::NetworkStackLatency(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::NpcDialogue(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::NpcRequest(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::OnScreenTextureAnimation(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::OpenSign(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PacketViolationWarning(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PhotoInfoRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PhotoTransfer(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PlaySound(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PlayStatus(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerAction(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PlayerArmorDamage(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PlayerAuthInput(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PlayerEnchantOptions(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerFog(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerHotbar(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PlayerInput(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PlayerList(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PlayerSkin(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::PositionTrackingDbBroadcast(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PositionTrackingDbRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::PurchaseReceipt(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RemoveEcsEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RemoveEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RemoveObjective(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RemoveVolumeEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RequestAbility(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::RequestChunkRadius(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RequestNetworkSettings(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RequestPermissions(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackChunkData(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ResourcePackChunkRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackClientResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ResourcePackDataInfo(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ResourcePackStack(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::ResourcePacksInfo(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::Respawn(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::RiderJump(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ScriptCustomEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ScriptMessage(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ServerSettingsRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ServerSettingsResponse(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ServerStats(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ServerToClientHandshake(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetCommandsEnabled(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetDefaultGameType(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetDifficulty(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetDisplayObjective(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::SetEntityData(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::SetEntityLink(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::SetEntityMotion(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetHealth(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetLastHurtBy(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetLocalPlayerAsInitialized(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetPlayerGameType(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetScore(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetScoreboardIdentity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetSpawnPosition(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::SetTime(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SetTitle(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::SettingsCommand(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ShowCredits(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ShowProfile(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ShowStoreOffer(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SimpleEvent(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SimulationType(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SpawnExperienceOrb(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SpawnParticleEffect(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::StartGame(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::StopSound(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::StructureBlockUpdate(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::StructureTemplateDataExportRequest(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::StructureTemplateDataExportResponse(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::SubClientLogin(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Subchunk(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::SubchunkRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::SyncEntityProperty(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::TakeItemEntity(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Text(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::TickSync(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::TickingAreasLoadStatus(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::ToastRequest(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::Transfer(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::TrimData(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UnlockedRecipes(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateAbilities(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::UpdateAdventureSettings(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::UpdateAttributes(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateBlock(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::UpdateBlockProperties(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateBlockSynced(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::UpdateClientInputLocks(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateEquipment(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::UpdatePlayerGameType(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateSoftEnum(v) => {
                    v.encode(buf)?;
                }
                McpePacketParams::UpdateSubchunkBlocks(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::UpdateTrade(v) => {
                    (&**v).encode(buf)?;
                }
                McpePacketParams::VideoStreamConnect(v) => {
                    (&**v).encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let name = <McpePacketName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let params = match name {
            McpePacketName::AddBehaviorTree => {
                Some(
                    McpePacketParams::AddBehaviorTree(
                        <PacketAddBehaviorTree as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::AddEcsEntity => {
                Some(
                    McpePacketParams::AddEcsEntity(
                        <PacketAddEcsEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::AddEntity => {
                Some(
                    McpePacketParams::AddEntity(
                        Box::new(
                            <PacketAddEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AddItemEntity => {
                Some(
                    McpePacketParams::AddItemEntity(
                        Box::new(
                            <PacketAddItemEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketAddItemEntityArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AddPainting => {
                Some(
                    McpePacketParams::AddPainting(
                        Box::new(
                            <PacketAddPainting as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AddPlayer => {
                Some(
                    McpePacketParams::AddPlayer(
                        Box::new(
                            <PacketAddPlayer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketAddPlayerArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AddVolumeEntity => {
                Some(
                    McpePacketParams::AddVolumeEntity(
                        Box::new(
                            <PacketAddVolumeEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AdventureSettings => {
                Some(
                    McpePacketParams::AdventureSettings(
                        Box::new(
                            <PacketAdventureSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AgentAction => {
                Some(
                    McpePacketParams::AgentAction(
                        <PacketAgentAction as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::AgentAnimation => {
                Some(
                    McpePacketParams::AgentAnimation(
                        <PacketAgentAnimation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Animate => {
                Some(
                    McpePacketParams::Animate(
                        Box::new(
                            <PacketAnimate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AnimateEntity => {
                Some(
                    McpePacketParams::AnimateEntity(
                        Box::new(
                            <PacketAnimateEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AnvilDamage => {
                Some(
                    McpePacketParams::AnvilDamage(
                        <PacketAnvilDamage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::AvailableCommands => {
                Some(
                    McpePacketParams::AvailableCommands(
                        Box::new(
                            <PacketAvailableCommands as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::AvailableEntityIdentifiers => {
                Some(
                    McpePacketParams::AvailableEntityIdentifiers(
                        <PacketAvailableEntityIdentifiers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BiomeDefinitionList => {
                Some(
                    McpePacketParams::BiomeDefinitionList(
                        <PacketBiomeDefinitionList as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BlockEntityData => {
                Some(
                    McpePacketParams::BlockEntityData(
                        <PacketBlockEntityData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BlockEvent => {
                Some(
                    McpePacketParams::BlockEvent(
                        <PacketBlockEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::BlockPickRequest => {
                Some(
                    McpePacketParams::BlockPickRequest(
                        Box::new(
                            <PacketBlockPickRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::BookEdit => {
                Some(
                    McpePacketParams::BookEdit(
                        Box::new(
                            <PacketBookEdit as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::BossEvent => {
                Some(
                    McpePacketParams::BossEvent(
                        Box::new(
                            <PacketBossEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Camera => {
                Some(
                    McpePacketParams::Camera(
                        <PacketCamera as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CameraInstruction => {
                Some(
                    McpePacketParams::CameraInstruction(
                        <PacketCameraInstruction as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CameraPresets => {
                Some(
                    McpePacketParams::CameraPresets(
                        <PacketCameraPresets as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CameraShake => {
                Some(
                    McpePacketParams::CameraShake(
                        Box::new(
                            <PacketCameraShake as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ChangeDimension => {
                Some(
                    McpePacketParams::ChangeDimension(
                        <PacketChangeDimension as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ChangeMobProperty => {
                Some(
                    McpePacketParams::ChangeMobProperty(
                        Box::new(
                            <PacketChangeMobProperty as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ChunkRadiusUpdate => {
                Some(
                    McpePacketParams::ChunkRadiusUpdate(
                        <PacketChunkRadiusUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientCacheBlobStatus => {
                Some(
                    McpePacketParams::ClientCacheBlobStatus(
                        Box::new(
                            <PacketClientCacheBlobStatus as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ClientCacheMissResponse => {
                Some(
                    McpePacketParams::ClientCacheMissResponse(
                        <PacketClientCacheMissResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientCacheStatus => {
                Some(
                    McpePacketParams::ClientCacheStatus(
                        <PacketClientCacheStatus as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientCheatAbility => {
                Some(
                    McpePacketParams::ClientCheatAbility(
                        Box::new(
                            <PacketClientCheatAbility as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ClientStartItemCooldown => {
                Some(
                    McpePacketParams::ClientStartItemCooldown(
                        <PacketClientStartItemCooldown as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientToServerHandshake => {
                Some(
                    McpePacketParams::ClientToServerHandshake(
                        <PacketClientToServerHandshake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ClientboundMapItemData => {
                Some(
                    McpePacketParams::ClientboundMapItemData(
                        Box::new(
                            <PacketClientboundMapItemData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CodeBuilder => {
                Some(
                    McpePacketParams::CodeBuilder(
                        <PacketCodeBuilder as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CodeBuilderSource => {
                Some(
                    McpePacketParams::CodeBuilderSource(
                        <PacketCodeBuilderSource as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CommandBlockUpdate => {
                Some(
                    McpePacketParams::CommandBlockUpdate(
                        Box::new(
                            <PacketCommandBlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CommandOutput => {
                Some(
                    McpePacketParams::CommandOutput(
                        Box::new(
                            <PacketCommandOutput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CommandRequest => {
                Some(
                    McpePacketParams::CommandRequest(
                        Box::new(
                            <PacketCommandRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CompletedUsingItem => {
                Some(
                    McpePacketParams::CompletedUsingItem(
                        <PacketCompletedUsingItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CompressedBiomeDefinitions => {
                Some(
                    McpePacketParams::CompressedBiomeDefinitions(
                        <PacketCompressedBiomeDefinitions as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ContainerClose => {
                Some(
                    McpePacketParams::ContainerClose(
                        <PacketContainerClose as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ContainerOpen => {
                Some(
                    McpePacketParams::ContainerOpen(
                        Box::new(
                            <PacketContainerOpen as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ContainerSetData => {
                Some(
                    McpePacketParams::ContainerSetData(
                        <PacketContainerSetData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CorrectPlayerMovePrediction => {
                Some(
                    McpePacketParams::CorrectPlayerMovePrediction(
                        Box::new(
                            <PacketCorrectPlayerMovePrediction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CraftingData => {
                Some(
                    McpePacketParams::CraftingData(
                        Box::new(
                            <PacketCraftingData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketCraftingDataArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CraftingEvent => {
                Some(
                    McpePacketParams::CraftingEvent(
                        Box::new(
                            <PacketCraftingEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketCraftingEventArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::CreatePhoto => {
                Some(
                    McpePacketParams::CreatePhoto(
                        <PacketCreatePhoto as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::CreativeContent => {
                Some(
                    McpePacketParams::CreativeContent(
                        <PacketCreativeContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketCreativeContentArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    ),
                )
            }
            McpePacketName::DeathInfo => {
                Some(
                    McpePacketParams::DeathInfo(
                        <PacketDeathInfo as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::DebugInfo => {
                Some(
                    McpePacketParams::DebugInfo(
                        <PacketDebugInfo as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::DebugRenderer => {
                Some(
                    McpePacketParams::DebugRenderer(
                        Box::new(
                            <PacketDebugRenderer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::DimensionData => {
                Some(
                    McpePacketParams::DimensionData(
                        <PacketDimensionData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Disconnect => {
                Some(
                    McpePacketParams::Disconnect(
                        <PacketDisconnect as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EditorNetwork => {
                Some(
                    McpePacketParams::EditorNetwork(
                        <PacketEditorNetwork as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EduUriResourcePacket => {
                Some(
                    McpePacketParams::EduUriResourcePacket(
                        <PacketEduUriResourcePacket as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EducationSettings => {
                Some(
                    McpePacketParams::EducationSettings(
                        Box::new(
                            <PacketEducationSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Emote => {
                Some(
                    McpePacketParams::Emote(
                        Box::new(
                            <PacketEmote as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::EmoteList => {
                Some(
                    McpePacketParams::EmoteList(
                        <PacketEmoteList as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EntityEvent => {
                Some(
                    McpePacketParams::EntityEvent(
                        <PacketEntityEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::EntityPickRequest => {
                Some(
                    McpePacketParams::EntityPickRequest(
                        <PacketEntityPickRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Event => {
                Some(
                    McpePacketParams::Event(
                        Box::new(
                            <PacketEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::FeatureRegistry => {
                Some(
                    McpePacketParams::FeatureRegistry(
                        <PacketFeatureRegistry as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::FilterTextPacket => {
                Some(
                    McpePacketParams::FilterTextPacket(
                        <PacketFilterTextPacket as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::GameRulesChanged => {
                Some(
                    McpePacketParams::GameRulesChanged(
                        <PacketGameRulesChanged as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::GameTestRequest => {
                Some(
                    McpePacketParams::GameTestRequest(
                        Box::new(
                            <PacketGameTestRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::GameTestResults => {
                Some(
                    McpePacketParams::GameTestResults(
                        <PacketGameTestResults as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::GuiDataPickItem => {
                Some(
                    McpePacketParams::GuiDataPickItem(
                        <PacketGuiDataPickItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::HurtArmor => {
                Some(
                    McpePacketParams::HurtArmor(
                        <PacketHurtArmor as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::InitiateWebSocketConnection => {
                Some(
                    McpePacketParams::InitiateWebSocketConnection(
                        <PacketInitiateWebSocketConnection as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Interact => {
                Some(
                    McpePacketParams::Interact(
                        Box::new(
                            <PacketInteract as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::InventoryContent => {
                Some(
                    McpePacketParams::InventoryContent(
                        <PacketInventoryContent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketInventoryContentArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    ),
                )
            }
            McpePacketName::InventorySlot => {
                Some(
                    McpePacketParams::InventorySlot(
                        Box::new(
                            <PacketInventorySlot as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketInventorySlotArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::InventoryTransaction => {
                Some(
                    McpePacketParams::InventoryTransaction(
                        Box::new(
                            <PacketInventoryTransaction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketInventoryTransactionArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ItemComponent => {
                Some(
                    McpePacketParams::ItemComponent(
                        <PacketItemComponent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ItemFrameDropItem => {
                Some(
                    McpePacketParams::ItemFrameDropItem(
                        <PacketItemFrameDropItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ItemStackRequest => {
                Some(
                    McpePacketParams::ItemStackRequest(
                        <PacketItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            PacketItemStackRequestArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    ),
                )
            }
            McpePacketName::ItemStackResponse => {
                Some(
                    McpePacketParams::ItemStackResponse(
                        <PacketItemStackResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LabTable => {
                Some(
                    McpePacketParams::LabTable(
                        <PacketLabTable as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LecternUpdate => {
                Some(
                    McpePacketParams::LecternUpdate(
                        Box::new(
                            <PacketLecternUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LessonProgress => {
                Some(
                    McpePacketParams::LessonProgress(
                        <PacketLessonProgress as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LevelChunk => {
                Some(
                    McpePacketParams::LevelChunk(
                        Box::new(
                            <PacketLevelChunk as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LevelEvent => {
                Some(
                    McpePacketParams::LevelEvent(
                        <PacketLevelEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LevelEventGeneric => {
                Some(
                    McpePacketParams::LevelEventGeneric(
                        <PacketLevelEventGeneric as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::LevelSoundEvent => {
                Some(
                    McpePacketParams::LevelSoundEvent(
                        Box::new(
                            <PacketLevelSoundEvent as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LevelSoundEventOld => {
                Some(
                    McpePacketParams::LevelSoundEventOld(
                        Box::new(
                            <PacketLevelSoundEventOld as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::LevelSoundEventV2 => {
                Some(
                    McpePacketParams::LevelSoundEventV2(
                        Box::new(
                            <PacketLevelSoundEventV2 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Login => {
                Some(
                    McpePacketParams::Login(
                        <PacketLogin as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MapCreateLockedCopy => {
                Some(
                    McpePacketParams::MapCreateLockedCopy(
                        <PacketMapCreateLockedCopy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MapInfoRequest => {
                Some(
                    McpePacketParams::MapInfoRequest(
                        <PacketMapInfoRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MobArmorEquipment => {
                Some(
                    McpePacketParams::MobArmorEquipment(
                        Box::new(
                            <PacketMobArmorEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketMobArmorEquipmentArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MobEffect => {
                Some(
                    McpePacketParams::MobEffect(
                        Box::new(
                            <PacketMobEffect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MobEquipment => {
                Some(
                    McpePacketParams::MobEquipment(
                        Box::new(
                            <PacketMobEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketMobEquipmentArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ModalFormRequest => {
                Some(
                    McpePacketParams::ModalFormRequest(
                        <PacketModalFormRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ModalFormResponse => {
                Some(
                    McpePacketParams::ModalFormResponse(
                        Box::new(
                            <PacketModalFormResponse as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MotionPredictionHints => {
                Some(
                    McpePacketParams::MotionPredictionHints(
                        <PacketMotionPredictionHints as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::MoveEntity => {
                Some(
                    McpePacketParams::MoveEntity(
                        Box::new(
                            <PacketMoveEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MoveEntityDelta => {
                Some(
                    McpePacketParams::MoveEntityDelta(
                        Box::new(
                            <PacketMoveEntityDelta as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MovePlayer => {
                Some(
                    McpePacketParams::MovePlayer(
                        Box::new(
                            <PacketMovePlayer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::MultiplayerSettings => {
                Some(
                    McpePacketParams::MultiplayerSettings(
                        <PacketMultiplayerSettings as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::NetworkChunkPublisherUpdate => {
                Some(
                    McpePacketParams::NetworkChunkPublisherUpdate(
                        <PacketNetworkChunkPublisherUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::NetworkSettings => {
                Some(
                    McpePacketParams::NetworkSettings(
                        Box::new(
                            <PacketNetworkSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::NetworkStackLatency => {
                Some(
                    McpePacketParams::NetworkStackLatency(
                        <PacketNetworkStackLatency as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::NpcDialogue => {
                Some(
                    McpePacketParams::NpcDialogue(
                        Box::new(
                            <PacketNpcDialogue as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::NpcRequest => {
                Some(
                    McpePacketParams::NpcRequest(
                        Box::new(
                            <PacketNpcRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::OnScreenTextureAnimation => {
                Some(
                    McpePacketParams::OnScreenTextureAnimation(
                        <PacketOnScreenTextureAnimation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::OpenSign => {
                Some(
                    McpePacketParams::OpenSign(
                        <PacketOpenSign as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PacketViolationWarning => {
                Some(
                    McpePacketParams::PacketViolationWarning(
                        Box::new(
                            <PacketPacketViolationWarning as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PhotoInfoRequest => {
                Some(
                    McpePacketParams::PhotoInfoRequest(
                        <PacketPhotoInfoRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PhotoTransfer => {
                Some(
                    McpePacketParams::PhotoTransfer(
                        Box::new(
                            <PacketPhotoTransfer as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlaySound => {
                Some(
                    McpePacketParams::PlaySound(
                        Box::new(
                            <PacketPlaySound as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayStatus => {
                Some(
                    McpePacketParams::PlayStatus(
                        <PacketPlayStatus as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerAction => {
                Some(
                    McpePacketParams::PlayerAction(
                        Box::new(
                            <PacketPlayerAction as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerArmorDamage => {
                Some(
                    McpePacketParams::PlayerArmorDamage(
                        Box::new(
                            <PacketPlayerArmorDamage as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerAuthInput => {
                Some(
                    McpePacketParams::PlayerAuthInput(
                        Box::new(
                            <PacketPlayerAuthInput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                PacketPlayerAuthInputArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerEnchantOptions => {
                Some(
                    McpePacketParams::PlayerEnchantOptions(
                        <PacketPlayerEnchantOptions as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerFog => {
                Some(
                    McpePacketParams::PlayerFog(
                        <PacketPlayerFog as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerHotbar => {
                Some(
                    McpePacketParams::PlayerHotbar(
                        <PacketPlayerHotbar as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PlayerInput => {
                Some(
                    McpePacketParams::PlayerInput(
                        Box::new(
                            <PacketPlayerInput as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerList => {
                Some(
                    McpePacketParams::PlayerList(
                        Box::new(
                            <PacketPlayerList as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PlayerSkin => {
                Some(
                    McpePacketParams::PlayerSkin(
                        Box::new(
                            <PacketPlayerSkin as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::PositionTrackingDbBroadcast => {
                Some(
                    McpePacketParams::PositionTrackingDbBroadcast(
                        <PacketPositionTrackingDbBroadcast as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PositionTrackingDbRequest => {
                Some(
                    McpePacketParams::PositionTrackingDbRequest(
                        <PacketPositionTrackingDbRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::PurchaseReceipt => {
                Some(
                    McpePacketParams::PurchaseReceipt(
                        <PacketPurchaseReceipt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RemoveEcsEntity => {
                Some(
                    McpePacketParams::RemoveEcsEntity(
                        <PacketRemoveEcsEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RemoveEntity => {
                Some(
                    McpePacketParams::RemoveEntity(
                        <PacketRemoveEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RemoveObjective => {
                Some(
                    McpePacketParams::RemoveObjective(
                        <PacketRemoveObjective as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RemoveVolumeEntity => {
                Some(
                    McpePacketParams::RemoveVolumeEntity(
                        <PacketRemoveVolumeEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RequestAbility => {
                Some(
                    McpePacketParams::RequestAbility(
                        Box::new(
                            <PacketRequestAbility as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::RequestChunkRadius => {
                Some(
                    McpePacketParams::RequestChunkRadius(
                        <PacketRequestChunkRadius as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RequestNetworkSettings => {
                Some(
                    McpePacketParams::RequestNetworkSettings(
                        <PacketRequestNetworkSettings as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RequestPermissions => {
                Some(
                    McpePacketParams::RequestPermissions(
                        <PacketRequestPermissions as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ResourcePackChunkData => {
                Some(
                    McpePacketParams::ResourcePackChunkData(
                        Box::new(
                            <PacketResourcePackChunkData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ResourcePackChunkRequest => {
                Some(
                    McpePacketParams::ResourcePackChunkRequest(
                        <PacketResourcePackChunkRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ResourcePackClientResponse => {
                Some(
                    McpePacketParams::ResourcePackClientResponse(
                        <PacketResourcePackClientResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ResourcePackDataInfo => {
                Some(
                    McpePacketParams::ResourcePackDataInfo(
                        Box::new(
                            <PacketResourcePackDataInfo as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ResourcePackStack => {
                Some(
                    McpePacketParams::ResourcePackStack(
                        Box::new(
                            <PacketResourcePackStack as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::ResourcePacksInfo => {
                Some(
                    McpePacketParams::ResourcePacksInfo(
                        Box::new(
                            <PacketResourcePacksInfo as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::Respawn => {
                Some(
                    McpePacketParams::Respawn(
                        <PacketRespawn as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::RiderJump => {
                Some(
                    McpePacketParams::RiderJump(
                        <PacketRiderJump as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ScriptCustomEvent => {
                Some(
                    McpePacketParams::ScriptCustomEvent(
                        <PacketScriptCustomEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ScriptMessage => {
                Some(
                    McpePacketParams::ScriptMessage(
                        <PacketScriptMessage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ServerSettingsRequest => {
                Some(
                    McpePacketParams::ServerSettingsRequest(
                        <PacketServerSettingsRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ServerSettingsResponse => {
                Some(
                    McpePacketParams::ServerSettingsResponse(
                        <PacketServerSettingsResponse as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ServerStats => {
                Some(
                    McpePacketParams::ServerStats(
                        <PacketServerStats as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ServerToClientHandshake => {
                Some(
                    McpePacketParams::ServerToClientHandshake(
                        <PacketServerToClientHandshake as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetCommandsEnabled => {
                Some(
                    McpePacketParams::SetCommandsEnabled(
                        <PacketSetCommandsEnabled as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetDefaultGameType => {
                Some(
                    McpePacketParams::SetDefaultGameType(
                        <PacketSetDefaultGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetDifficulty => {
                Some(
                    McpePacketParams::SetDifficulty(
                        <PacketSetDifficulty as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetDisplayObjective => {
                Some(
                    McpePacketParams::SetDisplayObjective(
                        Box::new(
                            <PacketSetDisplayObjective as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SetEntityData => {
                Some(
                    McpePacketParams::SetEntityData(
                        Box::new(
                            <PacketSetEntityData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SetEntityLink => {
                Some(
                    McpePacketParams::SetEntityLink(
                        Box::new(
                            <PacketSetEntityLink as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SetEntityMotion => {
                Some(
                    McpePacketParams::SetEntityMotion(
                        <PacketSetEntityMotion as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetHealth => {
                Some(
                    McpePacketParams::SetHealth(
                        <PacketSetHealth as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetLastHurtBy => {
                Some(
                    McpePacketParams::SetLastHurtBy(
                        <PacketSetLastHurtBy as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetLocalPlayerAsInitialized => {
                Some(
                    McpePacketParams::SetLocalPlayerAsInitialized(
                        <PacketSetLocalPlayerAsInitialized as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetPlayerGameType => {
                Some(
                    McpePacketParams::SetPlayerGameType(
                        <PacketSetPlayerGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetScore => {
                Some(
                    McpePacketParams::SetScore(
                        <PacketSetScore as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetScoreboardIdentity => {
                Some(
                    McpePacketParams::SetScoreboardIdentity(
                        <PacketSetScoreboardIdentity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetSpawnPosition => {
                Some(
                    McpePacketParams::SetSpawnPosition(
                        Box::new(
                            <PacketSetSpawnPosition as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SetTime => {
                Some(
                    McpePacketParams::SetTime(
                        <PacketSetTime as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SetTitle => {
                Some(
                    McpePacketParams::SetTitle(
                        Box::new(
                            <PacketSetTitle as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SettingsCommand => {
                Some(
                    McpePacketParams::SettingsCommand(
                        <PacketSettingsCommand as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ShowCredits => {
                Some(
                    McpePacketParams::ShowCredits(
                        <PacketShowCredits as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ShowProfile => {
                Some(
                    McpePacketParams::ShowProfile(
                        <PacketShowProfile as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ShowStoreOffer => {
                Some(
                    McpePacketParams::ShowStoreOffer(
                        <PacketShowStoreOffer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SimpleEvent => {
                Some(
                    McpePacketParams::SimpleEvent(
                        <PacketSimpleEvent as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SimulationType => {
                Some(
                    McpePacketParams::SimulationType(
                        <PacketSimulationType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SpawnExperienceOrb => {
                Some(
                    McpePacketParams::SpawnExperienceOrb(
                        <PacketSpawnExperienceOrb as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SpawnParticleEffect => {
                Some(
                    McpePacketParams::SpawnParticleEffect(
                        Box::new(
                            <PacketSpawnParticleEffect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::StartGame => {
                Some(
                    McpePacketParams::StartGame(
                        Box::new(
                            <PacketStartGame as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::StopSound => {
                Some(
                    McpePacketParams::StopSound(
                        <PacketStopSound as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::StructureBlockUpdate => {
                Some(
                    McpePacketParams::StructureBlockUpdate(
                        Box::new(
                            <PacketStructureBlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::StructureTemplateDataExportRequest => {
                Some(
                    McpePacketParams::StructureTemplateDataExportRequest(
                        Box::new(
                            <PacketStructureTemplateDataExportRequest as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::StructureTemplateDataExportResponse => {
                Some(
                    McpePacketParams::StructureTemplateDataExportResponse(
                        Box::new(
                            <PacketStructureTemplateDataExportResponse as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SubClientLogin => {
                Some(
                    McpePacketParams::SubClientLogin(
                        <PacketSubClientLogin as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Subchunk => {
                Some(
                    McpePacketParams::Subchunk(
                        Box::new(
                            <PacketSubchunk as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::SubchunkRequest => {
                Some(
                    McpePacketParams::SubchunkRequest(
                        <PacketSubchunkRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::SyncEntityProperty => {
                Some(
                    McpePacketParams::SyncEntityProperty(
                        <PacketSyncEntityProperty as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::TakeItemEntity => {
                Some(
                    McpePacketParams::TakeItemEntity(
                        <PacketTakeItemEntity as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Text => {
                Some(
                    McpePacketParams::Text(
                        Box::new(
                            <PacketText as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::TickSync => {
                Some(
                    McpePacketParams::TickSync(
                        <PacketTickSync as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::TickingAreasLoadStatus => {
                Some(
                    McpePacketParams::TickingAreasLoadStatus(
                        <PacketTickingAreasLoadStatus as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::ToastRequest => {
                Some(
                    McpePacketParams::ToastRequest(
                        <PacketToastRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::Transfer => {
                Some(
                    McpePacketParams::Transfer(
                        <PacketTransfer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::TrimData => {
                Some(
                    McpePacketParams::TrimData(
                        <PacketTrimData as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UnlockedRecipes => {
                Some(
                    McpePacketParams::UnlockedRecipes(
                        <PacketUnlockedRecipes as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateAbilities => {
                Some(
                    McpePacketParams::UpdateAbilities(
                        Box::new(
                            <PacketUpdateAbilities as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdateAdventureSettings => {
                Some(
                    McpePacketParams::UpdateAdventureSettings(
                        Box::new(
                            <PacketUpdateAdventureSettings as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdateAttributes => {
                Some(
                    McpePacketParams::UpdateAttributes(
                        <PacketUpdateAttributes as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateBlock => {
                Some(
                    McpePacketParams::UpdateBlock(
                        Box::new(
                            <PacketUpdateBlock as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdateBlockProperties => {
                Some(
                    McpePacketParams::UpdateBlockProperties(
                        <PacketUpdateBlockProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateBlockSynced => {
                Some(
                    McpePacketParams::UpdateBlockSynced(
                        Box::new(
                            <PacketUpdateBlockSynced as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdateClientInputLocks => {
                Some(
                    McpePacketParams::UpdateClientInputLocks(
                        <PacketUpdateClientInputLocks as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateEquipment => {
                Some(
                    McpePacketParams::UpdateEquipment(
                        Box::new(
                            <PacketUpdateEquipment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdatePlayerGameType => {
                Some(
                    McpePacketParams::UpdatePlayerGameType(
                        <PacketUpdatePlayerGameType as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateSoftEnum => {
                Some(
                    McpePacketParams::UpdateSoftEnum(
                        <PacketUpdateSoftEnum as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            McpePacketName::UpdateSubchunkBlocks => {
                Some(
                    McpePacketParams::UpdateSubchunkBlocks(
                        Box::new(
                            <PacketUpdateSubchunkBlocks as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::UpdateTrade => {
                Some(
                    McpePacketParams::UpdateTrade(
                        Box::new(
                            <PacketUpdateTrade as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            McpePacketName::VideoStreamConnect => {
                Some(
                    McpePacketParams::VideoStreamConnect(
                        Box::new(
                            <PacketVideoStreamConnect as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { name, params })
    }
}
pub type Nbt = Vec<u8>;
pub type RestBuffer = Vec<u8>;
#[derive(Debug, Clone, PartialEq)]
pub struct Vec3U {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3U {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        crate::bedrock::codec::VarInt(self.x as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.y as i32).encode(buf)?;
        crate::bedrock::codec::VarInt(self.z as i32).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i32;
        Ok(Self { x, y, z })
    }
}
