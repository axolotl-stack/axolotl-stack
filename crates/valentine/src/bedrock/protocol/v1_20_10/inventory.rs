// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use bitflags::bitflags;
use super::*;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Flags = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    HorseType = 19,
    CreeperSwell = 20,
    CreeperSwellDirection = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeID = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinID = 40,
    URLTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    WitherAerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    RiderSeatRotationOffset = 60,
    AreaEffectCloudRadius = 61,
    AreaEffectCloudWaiting = 62,
    AreaEffectCloudParticleID = 63,
    ShulkerPeekID = 64,
    ShulkerAttachFace = 65,
    ShulkerAttached = 66,
    ShulkerAttachPos = 67,
    TradingPlayerEid = 68,
    TradingCareer = 69,
    HasCommandBlock = 70,
    CommandBlockCommand = 71,
    CommandBlockLastOutput = 72,
    CommandBlockTrackOutput = 73,
    ControllingRiderSeatNumber = 74,
    Strength = 75,
    MaxStrength = 76,
    EvokerSpellCastingColor = 77,
    LimitedLife = 78,
    ArmorStandPoseIndex = 79,
    EnderCrystalTimeOffset = 80,
    AlwaysShowNametag = 81,
    Color2 = 82,
    NameAuthor = 83,
    ScoreTag = 84,
    BalloonAttachedEntity = 85,
    PufferfishSize = 86,
    BubbleTime = 87,
    Agent = 88,
    SittingAmount = 89,
    SittingAmountPrevious = 90,
    EatingCounter = 91,
    FlagsExtended = 92,
    LayingAmount = 93,
    LayingAmountPrevious = 94,
    AreaEffectCloudDuration = 95,
    AreaEffectCloudSpawnTime = 96,
    AreaEffectCloudChangeRate = 97,
    AreaEffectCloudChangeOnPickup = 98,
    AreaEffectCloudPickupCount = 99,
    InteractText = 100,
    TradeTier = 101,
    MaxTradeTier = 102,
    TradeExperience = 103,
    SkinID = 104,
    SpawningFrames = 105,
    CommandBlockTickDelay = 106,
    CommandBlockExecuteOnFirstTick = 107,
    AmbientSoundInterval = 108,
    AmbientSoundIntervalRange = 109,
    AmbientSoundEventName = 110,
    FallDamageMultiplier = 111,
    NameRawText = 112,
    CanRideTarget = 113,
    LowTierCuredDiscount = 114,
    HighTierCuredDiscount = 115,
    NearbyCuredDiscount = 116,
    NearbyCuredDiscountTimestamp = 117,
    Hitbox = 118,
    IsBuoyant = 119,
    BaseRuntimeID = 120,
    FreezingEffectStrength = 121,
    BuoyancyData = 122,
    GoatHornCount = 123,
    UpdateProperties = 124,
    MovementSoundDistanceOffset = 125,
    HeartbeatIntervalTicks = 126,
    HeartbeatSoundEvent = 127,
    PlayerLastDeathPosition = 128,
    PlayerLastDeathDimension = 129,
    PlayerHasDied = 130,
    CollisionBox = 131,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Flags),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            19 => Ok(MetadataDictionaryItemKey::HorseType),
            20 => Ok(MetadataDictionaryItemKey::CreeperSwell),
            21 => Ok(MetadataDictionaryItemKey::CreeperSwellDirection),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeID),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinID),
            41 => Ok(MetadataDictionaryItemKey::URLTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::WitherAerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::RiderSeatRotationOffset),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            63 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleID),
            64 => Ok(MetadataDictionaryItemKey::ShulkerPeekID),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            67 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            68 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            69 => Ok(MetadataDictionaryItemKey::TradingCareer),
            70 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            73 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            74 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            75 => Ok(MetadataDictionaryItemKey::Strength),
            76 => Ok(MetadataDictionaryItemKey::MaxStrength),
            77 => Ok(MetadataDictionaryItemKey::EvokerSpellCastingColor),
            78 => Ok(MetadataDictionaryItemKey::LimitedLife),
            79 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            80 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            81 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            82 => Ok(MetadataDictionaryItemKey::Color2),
            83 => Ok(MetadataDictionaryItemKey::NameAuthor),
            84 => Ok(MetadataDictionaryItemKey::ScoreTag),
            85 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            86 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            87 => Ok(MetadataDictionaryItemKey::BubbleTime),
            88 => Ok(MetadataDictionaryItemKey::Agent),
            89 => Ok(MetadataDictionaryItemKey::SittingAmount),
            90 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            91 => Ok(MetadataDictionaryItemKey::EatingCounter),
            92 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            93 => Ok(MetadataDictionaryItemKey::LayingAmount),
            94 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            95 => Ok(MetadataDictionaryItemKey::AreaEffectCloudDuration),
            96 => Ok(MetadataDictionaryItemKey::AreaEffectCloudSpawnTime),
            97 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeRate),
            98 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeOnPickup),
            99 => Ok(MetadataDictionaryItemKey::AreaEffectCloudPickupCount),
            100 => Ok(MetadataDictionaryItemKey::InteractText),
            101 => Ok(MetadataDictionaryItemKey::TradeTier),
            102 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            103 => Ok(MetadataDictionaryItemKey::TradeExperience),
            104 => Ok(MetadataDictionaryItemKey::SkinID),
            105 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            107 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            110 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            111 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            112 => Ok(MetadataDictionaryItemKey::NameRawText),
            113 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            114 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            117 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            118 => Ok(MetadataDictionaryItemKey::Hitbox),
            119 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            120 => Ok(MetadataDictionaryItemKey::BaseRuntimeID),
            121 => Ok(MetadataDictionaryItemKey::FreezingEffectStrength),
            122 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            123 => Ok(MetadataDictionaryItemKey::GoatHornCount),
            124 => Ok(MetadataDictionaryItemKey::UpdateProperties),
            125 => Ok(MetadataDictionaryItemKey::MovementSoundDistanceOffset),
            126 => Ok(MetadataDictionaryItemKey::HeartbeatIntervalTicks),
            127 => Ok(MetadataDictionaryItemKey::HeartbeatSoundEvent),
            128 => Ok(MetadataDictionaryItemKey::PlayerLastDeathPosition),
            129 => Ok(MetadataDictionaryItemKey::PlayerLastDeathDimension),
            130 => Ok(MetadataDictionaryItemKey::PlayerHasDied),
            131 => Ok(MetadataDictionaryItemKey::CollisionBox),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(MetadataDictionaryItemKey), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: MetadataDictionaryItemValue,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        match &self.value {
            MetadataDictionaryItemValue::Flags(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::FlagsExtended(v) => v.encode(buf)?,
            MetadataDictionaryItemValue::Default(v) => v.encode(buf)?,
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let key = <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let type_ = <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        let value = match key {
            _ => {
                MetadataDictionaryItemValue::Flags(
                    <MetadataFlags1 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::FlagsExtended(
                    <MetadataFlags2 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                )
            }
            _ => {
                MetadataDictionaryItemValue::Default(
                    Box::new(
                        match type_ {
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Byte(
                                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Compound(
                                        <Vec<
                                            u8,
                                        > as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Float(
                                        <f32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Int(
                                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Long(
                                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Short(
                                        <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::String(
                                        <String as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                        )?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3F(
                                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3I(
                                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf)?,
                                    ),
                                )
                            }
                            _ => None,
                        },
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsChainedSubcommandsItemValuesItem {
    pub index: u16,
    pub value: u16,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsChainedSubcommandsItemValuesItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.index.encode(buf)?;
        self.value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let index = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let value = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        Ok(Self { index, value })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsChainedSubcommandsItem {
    pub name: String,
    pub values: Vec<PacketAvailableCommandsChainedSubcommandsItemValuesItem>,
}
impl crate::bedrock::codec::BedrockCodec
for PacketAvailableCommandsChainedSubcommandsItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        let len = self.values.len() as i32;
        len.encode(buf)?;
        for item in &self.values {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let values = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsChainedSubcommandsItemValuesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketAvailableCommandsCommandDataItem {
    pub name: String,
    pub description: String,
    pub flags: u16,
    pub permission_level: u8,
    pub alias: i32,
    pub chained_subcommand_offsets: Vec<u16>,
    pub overloads: Vec<PacketAvailableCommandsCommandDataItemOverloadsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketAvailableCommandsCommandDataItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.name.encode(buf)?;
        self.description.encode(buf)?;
        self.flags.encode(buf)?;
        self.permission_level.encode(buf)?;
        self.alias.encode(buf)?;
        let len = self.chained_subcommand_offsets.len() as i32;
        len.encode(buf)?;
        for item in &self.chained_subcommand_offsets {
            item.encode(buf)?;
        }
        let len = self.overloads.len() as i32;
        len.encode(buf)?;
        for item in &self.overloads {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let name = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let description = <String as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let flags = <u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let permission_level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let alias = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let chained_subcommand_offsets = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<u16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?);
            }
            tmp_vec
        };
        let overloads = {
            let len = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketAvailableCommandsCommandDataItemOverloadsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            name,
            description,
            flags,
            permission_level,
            alias,
            chained_subcommand_offsets,
            overloads,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PacketCompletedUsingItemUseMethod {
    EquipArmor = 0,
    Eat = 1,
    Attack = 2,
    Consume = 3,
    Throw = 4,
    Shoot = 5,
    Place = 6,
    FillBottle = 7,
    FillBucket = 8,
    PourBucket = 9,
    UseTool = 10,
    Interact = 11,
    Retrieved = 12,
    Dyed = 13,
    Traded = 14,
    BrushingCompleted = 15,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItemUseMethod {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        match val {
            0 => Ok(PacketCompletedUsingItemUseMethod::EquipArmor),
            1 => Ok(PacketCompletedUsingItemUseMethod::Eat),
            2 => Ok(PacketCompletedUsingItemUseMethod::Attack),
            3 => Ok(PacketCompletedUsingItemUseMethod::Consume),
            4 => Ok(PacketCompletedUsingItemUseMethod::Throw),
            5 => Ok(PacketCompletedUsingItemUseMethod::Shoot),
            6 => Ok(PacketCompletedUsingItemUseMethod::Place),
            7 => Ok(PacketCompletedUsingItemUseMethod::FillBottle),
            8 => Ok(PacketCompletedUsingItemUseMethod::FillBucket),
            9 => Ok(PacketCompletedUsingItemUseMethod::PourBucket),
            10 => Ok(PacketCompletedUsingItemUseMethod::UseTool),
            11 => Ok(PacketCompletedUsingItemUseMethod::Interact),
            12 => Ok(PacketCompletedUsingItemUseMethod::Retrieved),
            13 => Ok(PacketCompletedUsingItemUseMethod::Dyed),
            14 => Ok(PacketCompletedUsingItemUseMethod::Traded),
            15 => Ok(PacketCompletedUsingItemUseMethod::BrushingCompleted),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketCompletedUsingItemUseMethod), val
                        ),
                    ),
                )
            }
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct PacketCompletedUsingItem {
    pub used_item_id: i16,
    pub use_method: PacketCompletedUsingItemUseMethod,
}
impl crate::bedrock::codec::BedrockCodec for PacketCompletedUsingItem {
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        self.used_item_id.encode(buf)?;
        self.use_method.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(buf: &mut B) -> Result<Self, std::io::Error> {
        let used_item_id = <i16 as crate::bedrock::codec::BedrockCodec>::decode(buf)?;
        let use_method = <PacketCompletedUsingItemUseMethod as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
        )?;
        Ok(Self { used_item_id, use_method })
    }
}
