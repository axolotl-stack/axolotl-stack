// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PacketEntityEventEventId {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    Caravan = 64,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
    GrowUp = 76,
    VibrationDetected = 77,
    DrinkMilk = 78,
    WetnessStop = 79,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEventEventId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(PacketEntityEventEventId::Jump),
            2 => Ok(PacketEntityEventEventId::HurtAnimation),
            3 => Ok(PacketEntityEventEventId::DeathAnimation),
            4 => Ok(PacketEntityEventEventId::ArmSwing),
            5 => Ok(PacketEntityEventEventId::StopAttack),
            6 => Ok(PacketEntityEventEventId::TameFail),
            7 => Ok(PacketEntityEventEventId::TameSuccess),
            8 => Ok(PacketEntityEventEventId::ShakeWet),
            9 => Ok(PacketEntityEventEventId::UseItem),
            10 => Ok(PacketEntityEventEventId::EatGrassAnimation),
            11 => Ok(PacketEntityEventEventId::FishHookBubble),
            12 => Ok(PacketEntityEventEventId::FishHookPosition),
            13 => Ok(PacketEntityEventEventId::FishHookHook),
            14 => Ok(PacketEntityEventEventId::FishHookTease),
            15 => Ok(PacketEntityEventEventId::SquidInkCloud),
            16 => Ok(PacketEntityEventEventId::ZombieVillagerCure),
            18 => Ok(PacketEntityEventEventId::Respawn),
            19 => Ok(PacketEntityEventEventId::IronGolemOfferFlower),
            20 => Ok(PacketEntityEventEventId::IronGolemWithdrawFlower),
            21 => Ok(PacketEntityEventEventId::LoveParticles),
            22 => Ok(PacketEntityEventEventId::VillagerAngry),
            23 => Ok(PacketEntityEventEventId::VillagerHappy),
            24 => Ok(PacketEntityEventEventId::WitchSpellParticles),
            25 => Ok(PacketEntityEventEventId::FireworkParticles),
            26 => Ok(PacketEntityEventEventId::InLoveParticles),
            27 => Ok(PacketEntityEventEventId::SilverfishSpawnAnimation),
            28 => Ok(PacketEntityEventEventId::GuardianAttack),
            29 => Ok(PacketEntityEventEventId::WitchDrinkPotion),
            30 => Ok(PacketEntityEventEventId::WitchThrowPotion),
            31 => Ok(PacketEntityEventEventId::MinecartTntPrimeFuse),
            32 => Ok(PacketEntityEventEventId::CreeperPrimeFuse),
            33 => Ok(PacketEntityEventEventId::AirSupplyExpired),
            34 => Ok(PacketEntityEventEventId::PlayerAddXpLevels),
            35 => Ok(PacketEntityEventEventId::ElderGuardianCurse),
            36 => Ok(PacketEntityEventEventId::AgentArmSwing),
            37 => Ok(PacketEntityEventEventId::EnderDragonDeath),
            38 => Ok(PacketEntityEventEventId::DustParticles),
            39 => Ok(PacketEntityEventEventId::ArrowShake),
            57 => Ok(PacketEntityEventEventId::EatingItem),
            60 => Ok(PacketEntityEventEventId::BabyAnimalFeed),
            61 => Ok(PacketEntityEventEventId::DeathSmokeCloud),
            62 => Ok(PacketEntityEventEventId::CompleteTrade),
            63 => Ok(PacketEntityEventEventId::RemoveLeash),
            64 => Ok(PacketEntityEventEventId::Caravan),
            65 => Ok(PacketEntityEventEventId::ConsumeTotem),
            66 => Ok(PacketEntityEventEventId::PlayerCheckTreasureHunterAchievement),
            67 => Ok(PacketEntityEventEventId::EntitySpawn),
            68 => Ok(PacketEntityEventEventId::DragonPuke),
            69 => Ok(PacketEntityEventEventId::ItemEntityMerge),
            70 => Ok(PacketEntityEventEventId::StartSwim),
            71 => Ok(PacketEntityEventEventId::BalloonPop),
            72 => Ok(PacketEntityEventEventId::TreasureHunt),
            73 => Ok(PacketEntityEventEventId::AgentSummon),
            74 => Ok(PacketEntityEventEventId::ChargedItem),
            75 => Ok(PacketEntityEventEventId::Fall),
            76 => Ok(PacketEntityEventEventId::GrowUp),
            77 => Ok(PacketEntityEventEventId::VibrationDetected),
            78 => Ok(PacketEntityEventEventId::DrinkMilk),
            79 => Ok(PacketEntityEventEventId::WetnessStop),
            _ => {
                Err(
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!(
                            "Invalid enum value for {}: {}",
                            stringify!(PacketEntityEventEventId), val
                        ),
                    ),
                )
            }
        }
    }
}
impl Default for PacketEntityEventEventId {
    fn default() -> Self {
        Self::Jump
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PacketEntityEvent {
    pub runtime_entity_id: i64,
    pub event_id: PacketEntityEventEventId,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.event_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let event_id = <PacketEntityEventEventId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PacketEntityPickRequest {
    pub runtime_entity_id: u64,
    pub selected_slot: u8,
    pub with_data: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketEntityPickRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U64LE(self.runtime_entity_id).encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.with_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let with_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            selected_slot,
            with_data,
        })
    }
}
