// Generated by valentine_gen. Do not edit.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use super::*;
use super::super::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq)]
pub enum PacketSubchunkEntries {
    SubChunkEntryWithoutCaching(SubChunkEntryWithoutCaching),
    SubChunkEntryWithCaching(SubChunkEntryWithCaching),
}
impl Default for PacketSubchunkEntries {
    fn default() -> Self {
        Self::SubChunkEntryWithoutCaching(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PacketSubchunk {
    pub dimension: i32,
    pub origin: Vec3I,
    pub entries: PacketSubchunkEntries,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunk {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = matches!(
            self.entries, PacketSubchunkEntries::SubChunkEntryWithCaching(_)
        );
        val.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.origin.encode(buf)?;
        match &self.entries {
            PacketSubchunkEntries::SubChunkEntryWithoutCaching(v) => {
                let len = v.len();
                crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
            PacketSubchunkEntries::SubChunkEntryWithCaching(v) => {
                let len = v.len();
                crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entries = if cache_enabled {
            PacketSubchunkEntries::SubChunkEntryWithCaching({
                let res: SubChunkEntryWithCaching = {
                    let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <SubChunkEntryWithCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                };
                res
            })
        } else {
            PacketSubchunkEntries::SubChunkEntryWithoutCaching({
                let res: SubChunkEntryWithoutCaching = {
                    let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <SubChunkEntryWithoutCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                };
                res
            })
        };
        Ok(Self { dimension, origin, entries })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PacketSubchunkRequestRequestsItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequestRequestsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { dx, dy, dz })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PacketSubchunkRequest {
    pub dimension: i32,
    pub origin: Vec3I,
    pub requests: Vec<PacketSubchunkRequestRequestsItem>,
}
impl crate::bedrock::codec::BedrockCodec for PacketSubchunkRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.origin.encode(buf)?;
        let len = self.requests.len();
        crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, std::io::Error> {
        let _ = buf;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let requests = {
            let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PacketSubchunkRequestRequestsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            dimension,
            origin,
            requests,
        })
    }
}
