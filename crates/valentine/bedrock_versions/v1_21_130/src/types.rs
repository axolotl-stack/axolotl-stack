// Generated by valentine_gen. Do not edit.

//! Generated protocol type definitions.
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use crate::bedrock::codec::BedrockCodec;
use crate::proto::*;
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum AbilityLayersType {
    Cache = 0,
    Base = 1,
    Spectator = 2,
    Commands = 3,
    Editor = 4,
    LoadingScreen = 5,
}
impl crate::bedrock::codec::BedrockCodec for AbilityLayersType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        crate::bedrock::codec::U16LE(val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as u16;
        match val {
            0 => Ok(AbilityLayersType::Cache),
            1 => Ok(AbilityLayersType::Base),
            2 => Ok(AbilityLayersType::Spectator),
            3 => Ok(AbilityLayersType::Commands),
            4 => Ok(AbilityLayersType::Editor),
            5 => Ok(AbilityLayersType::LoadingScreen),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(AbilityLayersType),
                value: val as i64,
            }),
        }
    }
}
impl Default for AbilityLayersType {
    fn default() -> Self {
        Self::Cache
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct AbilitySet :
    u32 { const BUILD = 1; const MINE = 2; const DOORS_AND_SWITCHES = 4; const
    OPEN_CONTAINERS = 8; const ATTACK_PLAYERS = 16; const ATTACK_MOBS = 32; const
    OPERATOR_COMMANDS = 64; const TELEPORT = 128; const INVULNERABLE = 256; const FLYING
    = 512; const MAY_FLY = 1024; const INSTANT_BUILD = 2048; const LIGHTNING = 4096;
    const FLY_SPEED = 8192; const WALK_SPEED = 16384; const MUTED = 32768; const
    WORLD_BUILDER = 65536; const NO_CLIP = 131072; const PRIVILEGED_BUILDER = 262144;
    const VERTICAL_FLY_SPEED = 524288; const COUNT = 1048576; }
}
impl crate::bedrock::codec::BedrockCodec for AbilitySet {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::U32LE(val as u32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AbilityLayers {
    pub type_: AbilityLayersType,
    pub allowed: AbilitySet,
    pub enabled: AbilitySet,
    pub fly_speed: f32,
    pub vertical_fly_speed: f32,
    pub walk_speed: f32,
}
impl crate::bedrock::codec::BedrockCodec for AbilityLayers {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        self.allowed.encode(buf)?;
        self.enabled.encode(buf)?;
        crate::bedrock::codec::F32LE(self.fly_speed).encode(buf)?;
        crate::bedrock::codec::F32LE(self.vertical_fly_speed).encode(buf)?;
        crate::bedrock::codec::F32LE(self.walk_speed).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <AbilityLayersType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let allowed = <AbilitySet as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let enabled = <AbilitySet as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let fly_speed =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let vertical_fly_speed =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let walk_speed =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            type_,
            allowed,
            enabled,
            fly_speed,
            vertical_fly_speed,
            walk_speed,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum Action {
    StartBreak = 0,
    AbortBreak = 1,
    StopBreak = 2,
    GetUpdatedBlock = 3,
    DropItem = 4,
    StartSleeping = 5,
    StopSleeping = 6,
    Respawn = 7,
    Jump = 8,
    StartSprint = 9,
    StopSprint = 10,
    StartSneak = 11,
    StopSneak = 12,
    CreativePlayerDestroyBlock = 13,
    DimensionChangeAck = 14,
    StartGlide = 15,
    StopGlide = 16,
    BuildDenied = 17,
    CrackBreak = 18,
    ChangeSkin = 19,
    SetEnchatnmentSeed = 20,
    Swimming = 21,
    StopSwimming = 22,
    StartSpinAttack = 23,
    StopSpinAttack = 24,
    InteractBlock = 25,
    PredictBreak = 26,
    ContinueBreak = 27,
    StartItemUseOn = 28,
    StopItemUseOn = 29,
    HandledTeleport = 30,
    MissedSwing = 31,
    StartCrawling = 32,
    StopCrawling = 33,
    StartFlying = 34,
    StopFlying = 35,
    ReceivedServerData = 36,
    StartUsingItem = 37,
}
impl crate::bedrock::codec::BedrockCodec for Action {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(Action::StartBreak),
            1 => Ok(Action::AbortBreak),
            2 => Ok(Action::StopBreak),
            3 => Ok(Action::GetUpdatedBlock),
            4 => Ok(Action::DropItem),
            5 => Ok(Action::StartSleeping),
            6 => Ok(Action::StopSleeping),
            7 => Ok(Action::Respawn),
            8 => Ok(Action::Jump),
            9 => Ok(Action::StartSprint),
            10 => Ok(Action::StopSprint),
            11 => Ok(Action::StartSneak),
            12 => Ok(Action::StopSneak),
            13 => Ok(Action::CreativePlayerDestroyBlock),
            14 => Ok(Action::DimensionChangeAck),
            15 => Ok(Action::StartGlide),
            16 => Ok(Action::StopGlide),
            17 => Ok(Action::BuildDenied),
            18 => Ok(Action::CrackBreak),
            19 => Ok(Action::ChangeSkin),
            20 => Ok(Action::SetEnchatnmentSeed),
            21 => Ok(Action::Swimming),
            22 => Ok(Action::StopSwimming),
            23 => Ok(Action::StartSpinAttack),
            24 => Ok(Action::StopSpinAttack),
            25 => Ok(Action::InteractBlock),
            26 => Ok(Action::PredictBreak),
            27 => Ok(Action::ContinueBreak),
            28 => Ok(Action::StartItemUseOn),
            29 => Ok(Action::StopItemUseOn),
            30 => Ok(Action::HandledTeleport),
            31 => Ok(Action::MissedSwing),
            32 => Ok(Action::StartCrawling),
            33 => Ok(Action::StopCrawling),
            34 => Ok(Action::StartFlying),
            35 => Ok(Action::StopFlying),
            36 => Ok(Action::ReceivedServerData),
            37 => Ok(Action::StartUsingItem),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(Action),
                value: val as i64,
            }),
        }
    }
}
impl Default for Action {
    fn default() -> Self {
        Self::StartBreak
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct
    ActionPermissions : u32 { const ATTACK_MOBS = 65552; const ATTACK_PLAYERS = 65544;
    const BUILD = 65792; const DEFAULT = 66048; const DOORS_AND_SWITCHES = 65538; const
    MINE = 65537; const OPEN_CONTAINERS = 65540; const OPERATOR = 65568; const TELEPORT =
    65664; }
}
impl crate::bedrock::codec::BedrockCodec for ActionPermissions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct AdventureFlags
    : u32 { const ALLOW_FLIGHT = 64; const AUTO_JUMP = 32; const FLYING = 512; const
    MUTED = 1024; const NO_CLIP = 128; const NO_PVP = 2; const WORLD_BUILDER = 256; const
    WORLD_IMMUTABLE = 1; }
}
impl crate::bedrock::codec::BedrockCodec for AdventureFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ArmorDamageEntryArmorSlot {
    Helmet = 0,
    Chestplate = 1,
    Leggings = 2,
    Boots = 3,
    Body = 4,
}
impl crate::bedrock::codec::BedrockCodec for ArmorDamageEntryArmorSlot {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ArmorDamageEntryArmorSlot::Helmet),
            1 => Ok(ArmorDamageEntryArmorSlot::Chestplate),
            2 => Ok(ArmorDamageEntryArmorSlot::Leggings),
            3 => Ok(ArmorDamageEntryArmorSlot::Boots),
            4 => Ok(ArmorDamageEntryArmorSlot::Body),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ArmorDamageEntryArmorSlot),
                value: val as i64,
            }),
        }
    }
}
impl Default for ArmorDamageEntryArmorSlot {
    fn default() -> Self {
        Self::Helmet
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ArmorDamageEntry {
    pub armor_slot: ArmorDamageEntryArmorSlot,
    pub damage: i16,
}
impl crate::bedrock::codec::BedrockCodec for ArmorDamageEntry {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.armor_slot.encode(buf)?;
        crate::bedrock::codec::I16LE(self.damage).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let armor_slot =
            <ArmorDamageEntryArmorSlot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let damage =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { armor_slot, damage })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeCappedSurface {
    pub floor_blocks: Vec<i32>,
    pub ceiling_blocks: Vec<i32>,
    pub sea_block: Option<u32>,
    pub foundation_block: Option<u32>,
    pub beach_block: Option<u32>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeCappedSurface {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.floor_blocks.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.floor_blocks {
            crate::bedrock::codec::I32LE(*item).encode(buf)?;
        }
        let len = self.ceiling_blocks.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.ceiling_blocks {
            crate::bedrock::codec::I32LE(*item).encode(buf)?;
        }
        match &self.sea_block {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::U32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.foundation_block {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::U32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.beach_block {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::U32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let floor_blocks = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        let ceiling_blocks = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        let sea_block = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let foundation_block = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let beach_block = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        Ok(Self {
            floor_blocks,
            ceiling_blocks,
            sea_block,
            foundation_block,
            beach_block,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeClimate {
    pub temperature: f32,
    pub downfall: f32,
    pub snow_accumulation_min: f32,
    pub snow_accumulation_max: f32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeClimate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.temperature).encode(buf)?;
        crate::bedrock::codec::F32LE(self.downfall).encode(buf)?;
        crate::bedrock::codec::F32LE(self.snow_accumulation_min).encode(buf)?;
        crate::bedrock::codec::F32LE(self.snow_accumulation_max).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let temperature =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let downfall =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let snow_accumulation_min =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let snow_accumulation_max =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            temperature,
            downfall,
            snow_accumulation_min,
            snow_accumulation_max,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BiomeCoordinateDistribution {
    SingleValued = 0,
    Uniform = 1,
    Gaussian = 2,
    InverseGaussian = 3,
    FixedGrid = 4,
    JitteredGrid = 5,
    Triangle = 6,
}
impl crate::bedrock::codec::BedrockCodec for BiomeCoordinateDistribution {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(BiomeCoordinateDistribution::SingleValued),
            1 => Ok(BiomeCoordinateDistribution::Uniform),
            2 => Ok(BiomeCoordinateDistribution::Gaussian),
            3 => Ok(BiomeCoordinateDistribution::InverseGaussian),
            4 => Ok(BiomeCoordinateDistribution::FixedGrid),
            5 => Ok(BiomeCoordinateDistribution::JitteredGrid),
            6 => Ok(BiomeCoordinateDistribution::Triangle),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(BiomeCoordinateDistribution),
                value: val as i64,
            }),
        }
    }
}
impl Default for BiomeCoordinateDistribution {
    fn default() -> Self {
        Self::SingleValued
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeCoordinate {
    pub min_value_type: i32,
    pub min_value: i16,
    pub max_value_type: i32,
    pub max_value: i16,
    pub grid_offset: u32,
    pub grid_step_size: u32,
    pub distribution: BiomeCoordinateDistribution,
}
impl crate::bedrock::codec::BedrockCodec for BiomeCoordinate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.min_value_type).encode(buf)?;
        crate::bedrock::codec::I16LE(self.min_value).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.max_value_type).encode(buf)?;
        crate::bedrock::codec::I16LE(self.max_value).encode(buf)?;
        crate::bedrock::codec::U32LE(self.grid_offset).encode(buf)?;
        crate::bedrock::codec::U32LE(self.grid_step_size).encode(buf)?;
        self.distribution.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let min_value_type =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let min_value =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let max_value_type =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let max_value =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let grid_offset =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let grid_step_size =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let distribution =
            <BiomeCoordinateDistribution as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            min_value_type,
            min_value,
            max_value_type,
            max_value,
            grid_offset,
            grid_step_size,
            distribution,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BiomeScatterParameterEvaluationOrder {
    Xyz = 0,
    Xzy = 1,
    Yxz = 2,
    Yzx = 3,
    Zxy = 4,
    Zyx = 5,
}
impl crate::bedrock::codec::BedrockCodec for BiomeScatterParameterEvaluationOrder {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(BiomeScatterParameterEvaluationOrder::Xyz),
            1 => Ok(BiomeScatterParameterEvaluationOrder::Xzy),
            2 => Ok(BiomeScatterParameterEvaluationOrder::Yxz),
            3 => Ok(BiomeScatterParameterEvaluationOrder::Yzx),
            4 => Ok(BiomeScatterParameterEvaluationOrder::Zxy),
            5 => Ok(BiomeScatterParameterEvaluationOrder::Zyx),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(BiomeScatterParameterEvaluationOrder),
                value: val as i64,
            }),
        }
    }
}
impl Default for BiomeScatterParameterEvaluationOrder {
    fn default() -> Self {
        Self::Xyz
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeScatterParameter {
    pub coordinates: Vec<BiomeCoordinate>,
    pub evaluation_order: BiomeScatterParameterEvaluationOrder,
    pub chance_percent_type: i32,
    pub chance_percent: i16,
    pub chance_numerator: i32,
    pub chance_denominator: i32,
    pub iterations_type: i32,
    pub iterations: i16,
}
impl crate::bedrock::codec::BedrockCodec for BiomeScatterParameter {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.coordinates.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.coordinates {
            item.encode(buf)?;
        }
        self.evaluation_order.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.chance_percent_type).encode(buf)?;
        crate::bedrock::codec::I16LE(self.chance_percent).encode(buf)?;
        crate::bedrock::codec::I32LE(self.chance_numerator).encode(buf)?;
        crate::bedrock::codec::I32LE(self.chance_denominator).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.iterations_type).encode(buf)?;
        crate::bedrock::codec::I16LE(self.iterations).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let coordinates = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <BiomeCoordinate as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                );
            }
            tmp_vec
        };
        let evaluation_order =
            <BiomeScatterParameterEvaluationOrder as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let chance_percent_type =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let chance_percent =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let chance_numerator =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let chance_denominator =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let iterations_type =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let iterations =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            coordinates,
            evaluation_order,
            chance_percent_type,
            chance_percent,
            chance_numerator,
            chance_denominator,
            iterations_type,
            iterations,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeConsolidatedFeature {
    pub scatter: BiomeScatterParameter,
    pub feature: i16,
    pub identifier: i16,
    pub pass: i16,
    pub can_use_internal: bool,
}
impl crate::bedrock::codec::BedrockCodec for BiomeConsolidatedFeature {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.scatter.encode(buf)?;
        crate::bedrock::codec::I16LE(self.feature).encode(buf)?;
        crate::bedrock::codec::I16LE(self.identifier).encode(buf)?;
        crate::bedrock::codec::I16LE(self.pass).encode(buf)?;
        self.can_use_internal.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let scatter =
            <BiomeScatterParameter as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let feature =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let identifier =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let pass =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let can_use_internal = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            scatter,
            feature,
            identifier,
            pass,
            can_use_internal,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeMountainParameters {
    pub steep_block: i32,
    pub north_slopes: bool,
    pub south_slopes: bool,
    pub west_slopes: bool,
    pub east_slopes: bool,
    pub top_slide_enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for BiomeMountainParameters {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.steep_block).encode(buf)?;
        self.north_slopes.encode(buf)?;
        self.south_slopes.encode(buf)?;
        self.west_slopes.encode(buf)?;
        self.east_slopes.encode(buf)?;
        self.top_slide_enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let steep_block =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let north_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let south_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let west_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let east_slopes = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let top_slide_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            steep_block,
            north_slopes,
            south_slopes,
            west_slopes,
            east_slopes,
            top_slide_enabled,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeSurfaceMaterial {
    pub top_block: i32,
    pub mid_block: i32,
    pub sea_floor_block: i32,
    pub foundation_block: i32,
    pub sea_block: i32,
    pub sea_floor_depth: i32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeSurfaceMaterial {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.top_block).encode(buf)?;
        crate::bedrock::codec::I32LE(self.mid_block).encode(buf)?;
        crate::bedrock::codec::I32LE(self.sea_floor_block).encode(buf)?;
        crate::bedrock::codec::I32LE(self.foundation_block).encode(buf)?;
        crate::bedrock::codec::I32LE(self.sea_block).encode(buf)?;
        crate::bedrock::codec::I32LE(self.sea_floor_depth).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let top_block =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let mid_block =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let sea_floor_block =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let foundation_block =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let sea_block =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let sea_floor_depth =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            top_block,
            mid_block,
            sea_floor_block,
            foundation_block,
            sea_block,
            sea_floor_depth,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeElementData {
    pub noise_frequency_scale: f32,
    pub noise_lower_bound: f32,
    pub noise_upper_bound: f32,
    pub height_min_type: i32,
    pub height_min: i16,
    pub height_max_type: i32,
    pub height_max: i16,
    pub adjusted_materials: BiomeSurfaceMaterial,
}
impl crate::bedrock::codec::BedrockCodec for BiomeElementData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.noise_frequency_scale).encode(buf)?;
        crate::bedrock::codec::F32LE(self.noise_lower_bound).encode(buf)?;
        crate::bedrock::codec::F32LE(self.noise_upper_bound).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.height_min_type).encode(buf)?;
        crate::bedrock::codec::I16LE(self.height_min).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.height_max_type).encode(buf)?;
        crate::bedrock::codec::I16LE(self.height_max).encode(buf)?;
        self.adjusted_materials.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let noise_frequency_scale =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let noise_lower_bound =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let noise_upper_bound =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let height_min_type =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let height_min =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let height_max_type =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let height_max =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let adjusted_materials =
            <BiomeSurfaceMaterial as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            noise_frequency_scale,
            noise_lower_bound,
            noise_upper_bound,
            height_min_type,
            height_min,
            height_max_type,
            height_max,
            adjusted_materials,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeMesaSurface {
    pub clay_material: u32,
    pub hard_clay_material: u32,
    pub bryce_pillars: bool,
    pub has_forest: bool,
}
impl crate::bedrock::codec::BedrockCodec for BiomeMesaSurface {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U32LE(self.clay_material).encode(buf)?;
        crate::bedrock::codec::U32LE(self.hard_clay_material).encode(buf)?;
        self.bryce_pillars.encode(buf)?;
        self.has_forest.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let clay_material =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let hard_clay_material =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let bryce_pillars = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let has_forest = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            clay_material,
            hard_clay_material,
            bryce_pillars,
            has_forest,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeWeight {
    pub biome: i16,
    pub weight: u32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeWeight {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I16LE(self.biome).encode(buf)?;
        crate::bedrock::codec::U32LE(self.weight).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let biome =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let weight =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { biome, weight })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeConditionalTransformation {
    pub weighted_biomes: Vec<BiomeWeight>,
    pub condition_json: i16,
    pub min_passing_neighbours: u32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeConditionalTransformation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.weighted_biomes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.weighted_biomes {
            item.encode(buf)?;
        }
        crate::bedrock::codec::I16LE(self.condition_json).encode(buf)?;
        crate::bedrock::codec::U32LE(self.min_passing_neighbours).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let weighted_biomes = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?);
            }
            tmp_vec
        };
        let condition_json =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let min_passing_neighbours =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            weighted_biomes,
            condition_json,
            min_passing_neighbours,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeTemperatureWeight {
    pub temperature: i32,
    pub weight: u32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeTemperatureWeight {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.temperature).encode(buf)?;
        crate::bedrock::codec::U32LE(self.weight).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let temperature =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let weight =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            temperature,
            weight,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeOverworldRules {
    pub hills_transformations: Vec<BiomeWeight>,
    pub mutate_transformations: Vec<BiomeWeight>,
    pub river_transformations: Vec<BiomeWeight>,
    pub shore_transformations: Vec<BiomeWeight>,
    pub pre_hills_edge_transformations: Vec<BiomeConditionalTransformation>,
    pub post_shore_edge_transformations: Vec<BiomeConditionalTransformation>,
    pub climate_transformations: Vec<BiomeTemperatureWeight>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeOverworldRules {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.hills_transformations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.hills_transformations {
            item.encode(buf)?;
        }
        let len = self.mutate_transformations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.mutate_transformations {
            item.encode(buf)?;
        }
        let len = self.river_transformations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.river_transformations {
            item.encode(buf)?;
        }
        let len = self.shore_transformations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.shore_transformations {
            item.encode(buf)?;
        }
        let len = self.pre_hills_edge_transformations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.pre_hills_edge_transformations {
            item.encode(buf)?;
        }
        let len = self.post_shore_edge_transformations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.post_shore_edge_transformations {
            item.encode(buf)?;
        }
        let len = self.climate_transformations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.climate_transformations {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let hills_transformations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?);
            }
            tmp_vec
        };
        let mutate_transformations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?);
            }
            tmp_vec
        };
        let river_transformations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?);
            }
            tmp_vec
        };
        let shore_transformations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<BiomeWeight as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?);
            }
            tmp_vec
        };
        let pre_hills_edge_transformations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeConditionalTransformation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let post_shore_edge_transformations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeConditionalTransformation as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let climate_transformations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <BiomeTemperatureWeight as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                );
            }
            tmp_vec
        };
        Ok(Self {
            hills_transformations,
            mutate_transformations,
            river_transformations,
            shore_transformations,
            pre_hills_edge_transformations,
            post_shore_edge_transformations,
            climate_transformations,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeMultiNoiseRules {
    pub temperature: f32,
    pub humidity: f32,
    pub altitude: f32,
    pub weirdness: f32,
    pub weight: f32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeMultiNoiseRules {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.temperature).encode(buf)?;
        crate::bedrock::codec::F32LE(self.humidity).encode(buf)?;
        crate::bedrock::codec::F32LE(self.altitude).encode(buf)?;
        crate::bedrock::codec::F32LE(self.weirdness).encode(buf)?;
        crate::bedrock::codec::F32LE(self.weight).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let temperature =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let humidity =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let altitude =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let weirdness =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let weight =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            temperature,
            humidity,
            altitude,
            weirdness,
            weight,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeReplacementData {
    pub biome: i16,
    pub dimension: i16,
    pub target_biomes: Vec<i16>,
    pub amount: f32,
    pub noise_frequency_scale: f32,
    pub replacement_index: u32,
}
impl crate::bedrock::codec::BedrockCodec for BiomeReplacementData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I16LE(self.biome).encode(buf)?;
        crate::bedrock::codec::I16LE(self.dimension).encode(buf)?;
        let len = self.target_biomes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.target_biomes {
            crate::bedrock::codec::I16LE(*item).encode(buf)?;
        }
        crate::bedrock::codec::F32LE(self.amount).encode(buf)?;
        crate::bedrock::codec::F32LE(self.noise_frequency_scale).encode(buf)?;
        crate::bedrock::codec::U32LE(self.replacement_index).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let biome =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let dimension =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let target_biomes = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        let amount =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let noise_frequency_scale =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let replacement_index =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            biome,
            dimension,
            target_biomes,
            amount,
            noise_frequency_scale,
            replacement_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeChunkGeneration {
    pub climate: Option<BiomeClimate>,
    pub consolidated_features: Option<Vec<BiomeConsolidatedFeature>>,
    pub mountain_parameters: Option<BiomeMountainParameters>,
    pub surface_material_adjustments: Option<Vec<BiomeElementData>>,
    pub surface_materials: Option<BiomeSurfaceMaterial>,
    pub has_default_overworld_surface: Option<bool>,
    pub has_swamp_surface: bool,
    pub has_frozen_ocean_surface: bool,
    pub has_end_surface: bool,
    pub mesa_surface: Option<BiomeMesaSurface>,
    pub capped_surface: Option<BiomeCappedSurface>,
    pub overworld_rules: Option<BiomeOverworldRules>,
    pub multi_noise_rules: Option<BiomeMultiNoiseRules>,
    pub legacy_rules: Option<Vec<BiomeConditionalTransformation>>,
    pub replacements_data: Option<Vec<BiomeReplacementData>>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeChunkGeneration {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        match &self.climate {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.consolidated_features {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        match &self.mountain_parameters {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.surface_material_adjustments {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        match &self.surface_materials {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.has_default_overworld_surface {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.has_swamp_surface.encode(buf)?;
        self.has_frozen_ocean_surface.encode(buf)?;
        self.has_end_surface.encode(buf)?;
        match &self.mesa_surface {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.capped_surface {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.overworld_rules {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.multi_noise_rules {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.legacy_rules {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        match &self.replacements_data {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let climate = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<BiomeClimate as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let consolidated_features = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as i64;
                    if raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: raw,
                        });
                    }
                    let len = raw as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <BiomeConsolidatedFeature as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        let mountain_parameters = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <BiomeMountainParameters as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let surface_material_adjustments = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as i64;
                    if raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: raw,
                        });
                    }
                    let len = raw as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec.push(
                            <BiomeElementData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        let surface_materials = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <BiomeSurfaceMaterial as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                )
            } else {
                None
            }
        };
        let has_default_overworld_surface = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let has_swamp_surface = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let has_frozen_ocean_surface =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let has_end_surface = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let mesa_surface = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<BiomeMesaSurface as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let capped_surface = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<BiomeCappedSurface as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let overworld_rules = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<BiomeOverworldRules as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let multi_noise_rules = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <BiomeMultiNoiseRules as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                )
            } else {
                None
            }
        };
        let legacy_rules = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as i64;
                    if raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: raw,
                        });
                    }
                    let len = raw as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <BiomeConditionalTransformation as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        let replacements_data = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as i64;
                    if raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: raw,
                        });
                    }
                    let len = raw as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec.push(
                            <BiomeReplacementData as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        Ok(Self {
            climate,
            consolidated_features,
            mountain_parameters,
            surface_material_adjustments,
            surface_materials,
            has_default_overworld_surface,
            has_swamp_surface,
            has_frozen_ocean_surface,
            has_end_surface,
            mesa_surface,
            capped_surface,
            overworld_rules,
            multi_noise_rules,
            legacy_rules,
            replacements_data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeDefinition {
    pub name_index: i16,
    pub biome_id: u16,
    pub temperature: f32,
    pub downfall: f32,
    pub snow_foliage: f32,
    pub depth: f32,
    pub scale: f32,
    pub map_water_colour: i32,
    pub rain: bool,
    pub tags: Option<Vec<u16>>,
    pub chunk_generation: Option<BiomeChunkGeneration>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeDefinition {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I16LE(self.name_index).encode(buf)?;
        crate::bedrock::codec::U16LE(self.biome_id).encode(buf)?;
        crate::bedrock::codec::F32LE(self.temperature).encode(buf)?;
        crate::bedrock::codec::F32LE(self.downfall).encode(buf)?;
        crate::bedrock::codec::F32LE(self.snow_foliage).encode(buf)?;
        crate::bedrock::codec::F32LE(self.depth).encode(buf)?;
        crate::bedrock::codec::F32LE(self.scale).encode(buf)?;
        crate::bedrock::codec::I32LE(self.map_water_colour).encode(buf)?;
        self.rain.encode(buf)?;
        match &self.tags {
            Some(v) => {
                buf.put_u8(1);
                let len = v.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                for item in v {
                    crate::bedrock::codec::U16LE(*item).encode(buf)?;
                }
            }
            None => buf.put_u8(0),
        }
        match &self.chunk_generation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name_index =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let biome_id =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let temperature =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let downfall =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let snow_foliage =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let depth =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let scale =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let map_water_colour =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let rain = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let tags = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0 as i64;
                    if raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: raw,
                        });
                    }
                    let len = raw as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?
                                    .0,
                            );
                    }
                    tmp_vec
                })
            } else {
                None
            }
        };
        let chunk_generation = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <BiomeChunkGeneration as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                )
            } else {
                None
            }
        };
        Ok(Self {
            name_index,
            biome_id,
            temperature,
            downfall,
            snow_foliage,
            depth,
            scale,
            map_water_colour,
            rain,
            tags,
            chunk_generation,
        })
    }
}
pub type ByteArray = Vec<u8>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Blob {
    pub hash: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for Blob {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U64LE(self.hash).encode(buf)?;
        let len = self.payload.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.payload {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let hash =
            <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let payload = {
            let res: ByteArray = {
                let raw =
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec.push(<u8 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?);
                }
                tmp_vec
            };
            res
        };
        Ok(Self { hash, payload })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BlockCoordinates {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for BlockCoordinates {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::VarInt(self.y).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let y = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BlockPropertiesItem {
    pub name: String,
    pub state: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for BlockPropertiesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.state.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let state =
            <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, state })
    }
}
pub type BlockProperties = Vec<BlockPropertiesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BlockUpdateTransitionType {
    Entity = 0,
    Create = 1,
    Destroy = 2,
}
impl crate::bedrock::codec::BedrockCodec for BlockUpdateTransitionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(BlockUpdateTransitionType::Entity),
            1 => Ok(BlockUpdateTransitionType::Create),
            2 => Ok(BlockUpdateTransitionType::Destroy),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(BlockUpdateTransitionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for BlockUpdateTransitionType {
    fn default() -> Self {
        Self::Entity
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BlockUpdate {
    pub position: BlockCoordinates,
    pub runtime_id: i32,
    pub flags: i32,
    pub entity_unique_id: i64,
    pub transition_type: BlockUpdateTransitionType,
}
impl crate::bedrock::codec::BedrockCodec for BlockUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.runtime_id).encode(buf)?;
        crate::bedrock::codec::VarInt(self.flags).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id).encode(buf)?;
        self.transition_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let flags = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let entity_unique_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let transition_type =
            <BlockUpdateTransitionType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            position,
            runtime_id,
            flags,
            entity_unique_id,
            transition_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3Fopts {
    pub x: Option<f32>,
    pub y: Option<f32>,
    pub z: Option<f32>,
}
impl crate::bedrock::codec::BedrockCodec for Vec3Fopts {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        match &self.x {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.y {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.z {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let y = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let z = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec2Fopts {
    pub x: Option<f32>,
    pub y: Option<f32>,
}
impl crate::bedrock::codec::BedrockCodec for Vec2Fopts {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        match &self.x {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.y {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let y = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        Ok(Self { x, y })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec2F {
    pub x: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec2F {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.x).encode(buf)?;
        crate::bedrock::codec::F32LE(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let z =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { x, z })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3F {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3F {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.x).encode(buf)?;
        crate::bedrock::codec::F32LE(self.y).encode(buf)?;
        crate::bedrock::codec::F32LE(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let y =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let z =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CameraPresetsAimAssistTargetMode {
    Angle = 0,
    Distance = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresetsAimAssistTargetMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(CameraPresetsAimAssistTargetMode::Angle),
            1 => Ok(CameraPresetsAimAssistTargetMode::Distance),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CameraPresetsAimAssistTargetMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for CameraPresetsAimAssistTargetMode {
    fn default() -> Self {
        Self::Angle
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraPresetsAimAssist {
    pub preset_id: Option<String>,
    pub target_mode: Option<CameraPresetsAimAssistTargetMode>,
    pub angle: Option<Vec2F>,
    pub distance: Option<f32>,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresetsAimAssist {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        match &self.preset_id {
            Some(v) => {
                buf.put_u8(1);
                let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                    (v).chars()
                        .map(|ch| {
                            let code = ch as u32;
                            if code <= 0xFF { code as u8 } else { b'?' }
                        })
                        .collect()
                } else {
                    (v).as_bytes().to_vec()
                };
                let len = bytes.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&bytes);
            }
            None => buf.put_u8(0),
        }
        match &self.target_mode {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.angle {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.distance {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let preset_id = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                })
            } else {
                None
            }
        };
        let target_mode = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraPresetsAimAssistTargetMode as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let angle = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let distance = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        Ok(Self {
            preset_id,
            target_mode,
            angle,
            distance,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraPresetsControlScheme {
    LockedPlayerRelativeStrafe = 0,
    CameraRelative = 1,
    CameraRelativeStrafe = 2,
    PlayerRelative = 3,
    PlayerRelativeStrafe = 4,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresetsControlScheme {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CameraPresetsControlScheme::LockedPlayerRelativeStrafe),
            1 => Ok(CameraPresetsControlScheme::CameraRelative),
            2 => Ok(CameraPresetsControlScheme::CameraRelativeStrafe),
            3 => Ok(CameraPresetsControlScheme::PlayerRelative),
            4 => Ok(CameraPresetsControlScheme::PlayerRelativeStrafe),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CameraPresetsControlScheme),
                value: val as i64,
            }),
        }
    }
}
impl Default for CameraPresetsControlScheme {
    fn default() -> Self {
        Self::LockedPlayerRelativeStrafe
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraPresets {
    pub name: String,
    pub parent: String,
    pub position: Vec3Fopts,
    pub rotation: Vec2Fopts,
    pub rotation_speed: Option<f32>,
    pub snap_to_target: Option<bool>,
    pub horizontal_rotation_limit: Option<Vec2F>,
    pub vertical_rotation_limit: Option<Vec2F>,
    pub continue_targeting: Option<bool>,
    pub tracking_radius: Option<f32>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub radius: Option<f32>,
    pub yaw_limit_min: Option<f32>,
    pub yaw_limit_max: Option<f32>,
    pub audio_listener: Option<u8>,
    pub player_effects: Option<bool>,
    pub aim_assist: Option<CameraPresetsAimAssist>,
    pub control_scheme: Option<CameraPresetsControlScheme>,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresets {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.parent)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.parent).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        match &self.rotation_speed {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.snap_to_target {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.horizontal_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.vertical_rotation_limit {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.continue_targeting {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.tracking_radius {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.radius {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.yaw_limit_min {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.yaw_limit_max {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.audio_listener {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.player_effects {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.aim_assist {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.control_scheme {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let parent = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let position = <Vec3Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation = <Vec2Fopts as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation_speed = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let snap_to_target = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let horizontal_rotation_limit = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let vertical_rotation_limit = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let continue_targeting = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let tracking_radius = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let radius = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let yaw_limit_min = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let yaw_limit_max = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let audio_listener = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let player_effects = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let aim_assist = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraPresetsAimAssist as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let control_scheme = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraPresetsControlScheme as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        Ok(Self {
            name,
            parent,
            position,
            rotation,
            rotation_speed,
            snap_to_target,
            horizontal_rotation_limit,
            vertical_rotation_limit,
            continue_targeting,
            tracking_radius,
            offset,
            entity_offset,
            radius,
            yaw_limit_min,
            yaw_limit_max,
            audio_listener,
            player_effects,
            aim_assist,
            control_scheme,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraRotationOption {
    pub value: Vec3F,
    pub time: f32,
}
impl crate::bedrock::codec::BedrockCodec for CameraRotationOption {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.value.encode(buf)?;
        crate::bedrock::codec::F32LE(self.time).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let value = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let time =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { value, time })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraSplineEaseType {
    CatmullRom = 0,
    Linear = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraSplineEaseType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CameraSplineEaseType::CatmullRom),
            1 => Ok(CameraSplineEaseType::Linear),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CameraSplineEaseType),
                value: val as i64,
            }),
        }
    }
}
impl Default for CameraSplineEaseType {
    fn default() -> Self {
        Self::CatmullRom
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraSplineInstruction {
    pub total_time: f32,
    pub ease_type: CameraSplineEaseType,
    pub curve: Vec<Vec3F>,
    pub progress_key_frames: Vec<Vec2F>,
    pub rotation_options: Vec<CameraRotationOption>,
}
impl crate::bedrock::codec::BedrockCodec for CameraSplineInstruction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.total_time).encode(buf)?;
        self.ease_type.encode(buf)?;
        let len = self.curve.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.curve {
            item.encode(buf)?;
        }
        let len = self.progress_key_frames.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.progress_key_frames {
            item.encode(buf)?;
        }
        let len = self.rotation_options.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.rotation_options {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let total_time =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let ease_type =
            <CameraSplineEaseType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let curve = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?);
            }
            tmp_vec
        };
        let progress_key_frames = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?);
            }
            tmp_vec
        };
        let rotation_options = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <CameraRotationOption as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                );
            }
            tmp_vec
        };
        Ok(Self {
            total_time,
            ease_type,
            curve,
            progress_key_frames,
            rotation_options,
        })
    }
}
pub type CommandFlags = u8;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CommandOriginType {
    Player = 0,
    Block = 1,
    MinecartBlock = 2,
    DevConsole = 3,
    Test = 4,
    AutomationPlayer = 5,
    ClientAutomation = 6,
    DedicatedServer = 7,
    Entity = 8,
    Virtual = 9,
    GameArgument = 10,
    EntityServer = 11,
    Precompiled = 12,
    GameDirectorEntityServer = 13,
    Script = 14,
    Executor = 15,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(CommandOriginType::Player),
            1 => Ok(CommandOriginType::Block),
            2 => Ok(CommandOriginType::MinecartBlock),
            3 => Ok(CommandOriginType::DevConsole),
            4 => Ok(CommandOriginType::Test),
            5 => Ok(CommandOriginType::AutomationPlayer),
            6 => Ok(CommandOriginType::ClientAutomation),
            7 => Ok(CommandOriginType::DedicatedServer),
            8 => Ok(CommandOriginType::Entity),
            9 => Ok(CommandOriginType::Virtual),
            10 => Ok(CommandOriginType::GameArgument),
            11 => Ok(CommandOriginType::EntityServer),
            12 => Ok(CommandOriginType::Precompiled),
            13 => Ok(CommandOriginType::GameDirectorEntityServer),
            14 => Ok(CommandOriginType::Script),
            15 => Ok(CommandOriginType::Executor),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CommandOriginType),
                value: val as i64,
            }),
        }
    }
}
impl Default for CommandOriginType {
    fn default() -> Self {
        Self::Player
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandOriginPlayerEntityIdDevConsole {
    pub player_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for CommandOriginPlayerEntityIdDevConsole {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.player_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let player_entity_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { player_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum CommandOriginPlayerEntityId {
    DevConsole(CommandOriginPlayerEntityIdDevConsole),
    Test(CommandOriginPlayerEntityIdDevConsole),
}
impl Default for CommandOriginPlayerEntityId {
    fn default() -> Self {
        Self::DevConsole(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandOrigin {
    pub type_: CommandOriginType,
    pub uuid: uuid::Uuid,
    pub request_id: String,
    pub player_entity_id: Option<CommandOriginPlayerEntityId>,
}
impl crate::bedrock::codec::BedrockCodec for CommandOrigin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        self.uuid.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.request_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.request_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        if let Some(v) = &self.player_entity_id {
            match v {
                CommandOriginPlayerEntityId::DevConsole(v) => {
                    v.encode(buf)?;
                }
                CommandOriginPlayerEntityId::Test(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <CommandOriginType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let request_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let player_entity_id = match type_ {
            CommandOriginType::DevConsole => {
                Some(
                    CommandOriginPlayerEntityId::DevConsole(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            CommandOriginType::Test => {
                Some(
                    CommandOriginPlayerEntityId::Test(
                        <CommandOriginPlayerEntityIdDevConsole as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            type_,
            uuid,
            request_id,
            player_entity_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CommandPermissionLevel {
    Normal = 0,
    Operator = 1,
    Automation = 2,
    Host = 3,
    Owner = 4,
    Internal = 5,
}
impl crate::bedrock::codec::BedrockCodec for CommandPermissionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandPermissionLevel::Normal),
            1 => Ok(CommandPermissionLevel::Operator),
            2 => Ok(CommandPermissionLevel::Automation),
            3 => Ok(CommandPermissionLevel::Host),
            4 => Ok(CommandPermissionLevel::Owner),
            5 => Ok(CommandPermissionLevel::Internal),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CommandPermissionLevel),
                value: val as i64,
            }),
        }
    }
}
impl Default for CommandPermissionLevel {
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CommandPermissionLevelVarint {
    Normal = 0,
    Operator = 1,
    Automation = 2,
    Host = 3,
    Owner = 4,
    Internal = 5,
}
impl crate::bedrock::codec::BedrockCodec for CommandPermissionLevelVarint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CommandPermissionLevelVarint::Normal),
            1 => Ok(CommandPermissionLevelVarint::Operator),
            2 => Ok(CommandPermissionLevelVarint::Automation),
            3 => Ok(CommandPermissionLevelVarint::Host),
            4 => Ok(CommandPermissionLevelVarint::Owner),
            5 => Ok(CommandPermissionLevelVarint::Internal),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CommandPermissionLevelVarint),
                value: val as i64,
            }),
        }
    }
}
impl Default for CommandPermissionLevelVarint {
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ContainerSlotType {
    AnvilInput = 0,
    AnvilMaterial = 1,
    AnvilResult = 2,
    SmithingTableInput = 3,
    SmithingTableMaterial = 4,
    SmithingTableResult = 5,
    Armor = 6,
    Container = 7,
    BeaconPayment = 8,
    BrewingInput = 9,
    BrewingResult = 10,
    BrewingFuel = 11,
    HotbarAndInventory = 12,
    CraftingInput = 13,
    CraftingOutput = 14,
    RecipeConstruction = 15,
    RecipeNature = 16,
    RecipeItems = 17,
    RecipeSearch = 18,
    RecipeSearchBar = 19,
    RecipeEquipment = 20,
    RecipeBook = 21,
    EnchantingInput = 22,
    EnchantingLapis = 23,
    FurnaceFuel = 24,
    FurnaceIngredient = 25,
    FurnaceOutput = 26,
    HorseEquip = 27,
    Hotbar = 28,
    Inventory = 29,
    Shulker = 30,
    TradeIngredient1 = 31,
    TradeIngredient2 = 32,
    TradeResult = 33,
    Offhand = 34,
    CompcreateInput = 35,
    CompcreateOutput = 36,
    ElemconstructOutput = 37,
    MatreduceInput = 38,
    MatreduceOutput = 39,
    LabtableInput = 40,
    LoomInput = 41,
    LoomDye = 42,
    LoomMaterial = 43,
    LoomResult = 44,
    BlastFurnaceIngredient = 45,
    SmokerIngredient = 46,
    Trade2Ingredient1 = 47,
    Trade2Ingredient2 = 48,
    Trade2Result = 49,
    GrindstoneInput = 50,
    GrindstoneAdditional = 51,
    GrindstoneResult = 52,
    StonecutterInput = 53,
    StonecutterResult = 54,
    CartographyInput = 55,
    CartographyAdditional = 56,
    CartographyResult = 57,
    Barrel = 58,
    Cursor = 59,
    CreativeOutput = 60,
    SmithingTableTemplate = 61,
    Crafter = 62,
    Dynamic = 63,
    Registry = 64,
}
impl crate::bedrock::codec::BedrockCodec for ContainerSlotType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ContainerSlotType::AnvilInput),
            1 => Ok(ContainerSlotType::AnvilMaterial),
            2 => Ok(ContainerSlotType::AnvilResult),
            3 => Ok(ContainerSlotType::SmithingTableInput),
            4 => Ok(ContainerSlotType::SmithingTableMaterial),
            5 => Ok(ContainerSlotType::SmithingTableResult),
            6 => Ok(ContainerSlotType::Armor),
            7 => Ok(ContainerSlotType::Container),
            8 => Ok(ContainerSlotType::BeaconPayment),
            9 => Ok(ContainerSlotType::BrewingInput),
            10 => Ok(ContainerSlotType::BrewingResult),
            11 => Ok(ContainerSlotType::BrewingFuel),
            12 => Ok(ContainerSlotType::HotbarAndInventory),
            13 => Ok(ContainerSlotType::CraftingInput),
            14 => Ok(ContainerSlotType::CraftingOutput),
            15 => Ok(ContainerSlotType::RecipeConstruction),
            16 => Ok(ContainerSlotType::RecipeNature),
            17 => Ok(ContainerSlotType::RecipeItems),
            18 => Ok(ContainerSlotType::RecipeSearch),
            19 => Ok(ContainerSlotType::RecipeSearchBar),
            20 => Ok(ContainerSlotType::RecipeEquipment),
            21 => Ok(ContainerSlotType::RecipeBook),
            22 => Ok(ContainerSlotType::EnchantingInput),
            23 => Ok(ContainerSlotType::EnchantingLapis),
            24 => Ok(ContainerSlotType::FurnaceFuel),
            25 => Ok(ContainerSlotType::FurnaceIngredient),
            26 => Ok(ContainerSlotType::FurnaceOutput),
            27 => Ok(ContainerSlotType::HorseEquip),
            28 => Ok(ContainerSlotType::Hotbar),
            29 => Ok(ContainerSlotType::Inventory),
            30 => Ok(ContainerSlotType::Shulker),
            31 => Ok(ContainerSlotType::TradeIngredient1),
            32 => Ok(ContainerSlotType::TradeIngredient2),
            33 => Ok(ContainerSlotType::TradeResult),
            34 => Ok(ContainerSlotType::Offhand),
            35 => Ok(ContainerSlotType::CompcreateInput),
            36 => Ok(ContainerSlotType::CompcreateOutput),
            37 => Ok(ContainerSlotType::ElemconstructOutput),
            38 => Ok(ContainerSlotType::MatreduceInput),
            39 => Ok(ContainerSlotType::MatreduceOutput),
            40 => Ok(ContainerSlotType::LabtableInput),
            41 => Ok(ContainerSlotType::LoomInput),
            42 => Ok(ContainerSlotType::LoomDye),
            43 => Ok(ContainerSlotType::LoomMaterial),
            44 => Ok(ContainerSlotType::LoomResult),
            45 => Ok(ContainerSlotType::BlastFurnaceIngredient),
            46 => Ok(ContainerSlotType::SmokerIngredient),
            47 => Ok(ContainerSlotType::Trade2Ingredient1),
            48 => Ok(ContainerSlotType::Trade2Ingredient2),
            49 => Ok(ContainerSlotType::Trade2Result),
            50 => Ok(ContainerSlotType::GrindstoneInput),
            51 => Ok(ContainerSlotType::GrindstoneAdditional),
            52 => Ok(ContainerSlotType::GrindstoneResult),
            53 => Ok(ContainerSlotType::StonecutterInput),
            54 => Ok(ContainerSlotType::StonecutterResult),
            55 => Ok(ContainerSlotType::CartographyInput),
            56 => Ok(ContainerSlotType::CartographyAdditional),
            57 => Ok(ContainerSlotType::CartographyResult),
            58 => Ok(ContainerSlotType::Barrel),
            59 => Ok(ContainerSlotType::Cursor),
            60 => Ok(ContainerSlotType::CreativeOutput),
            61 => Ok(ContainerSlotType::SmithingTableTemplate),
            62 => Ok(ContainerSlotType::Crafter),
            63 => Ok(ContainerSlotType::Dynamic),
            64 => Ok(ContainerSlotType::Registry),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ContainerSlotType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ContainerSlotType {
    fn default() -> Self {
        Self::AnvilInput
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DebugMarkerData {
    pub text: String,
    pub position: Vec3F,
    pub color: u32,
    pub duration: u64,
}
impl crate::bedrock::codec::BedrockCodec for DebugMarkerData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.text)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.text).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.position.encode(buf)?;
        crate::bedrock::codec::U32LE(self.color).encode(buf)?;
        crate::bedrock::codec::U64LE(self.duration).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let text = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let color =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let duration =
            <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            text,
            position,
            color,
            duration,
        })
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct DeltaMoveFlags
    : u16 { const FORCE_MOVE = 256; const HAS_ROT_X = 8; const HAS_ROT_Y = 16; const
    HAS_ROT_Z = 32; const HAS_X = 1; const HAS_Y = 2; const HAS_Z = 4; const ON_GROUND =
    64; const TELEPORT = 128; }
}
impl crate::bedrock::codec::BedrockCodec for DeltaMoveFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::U16LE(val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw.0 as u16;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum DeviceOs {
    Undefined = 0,
    Android = 1,
    Ios = 2,
    Osx = 3,
    FireOs = 4,
    GearVr = 5,
    Hololens = 6,
    Win10 = 7,
    Win32 = 8,
    Dedicated = 9,
    Tvos = 10,
    Orbis = 11,
    NintendoSwitch = 12,
    Xbox = 13,
    WindowsPhone = 14,
    Linux = 15,
}
impl crate::bedrock::codec::BedrockCodec for DeviceOs {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(DeviceOs::Undefined),
            1 => Ok(DeviceOs::Android),
            2 => Ok(DeviceOs::Ios),
            3 => Ok(DeviceOs::Osx),
            4 => Ok(DeviceOs::FireOs),
            5 => Ok(DeviceOs::GearVr),
            6 => Ok(DeviceOs::Hololens),
            7 => Ok(DeviceOs::Win10),
            8 => Ok(DeviceOs::Win32),
            9 => Ok(DeviceOs::Dedicated),
            10 => Ok(DeviceOs::Tvos),
            11 => Ok(DeviceOs::Orbis),
            12 => Ok(DeviceOs::NintendoSwitch),
            13 => Ok(DeviceOs::Xbox),
            14 => Ok(DeviceOs::WindowsPhone),
            15 => Ok(DeviceOs::Linux),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(DeviceOs),
                value: val as i64,
            }),
        }
    }
}
impl Default for DeviceOs {
    fn default() -> Self {
        Self::Undefined
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum DisconnectFailReason {
    Unknown = 0,
    CantConnectNoInternet = 1,
    NoPermissions = 2,
    UnrecoverableError = 3,
    ThirdPartyBlocked = 4,
    ThirdPartyNoInternet = 5,
    ThirdPartyBadIp = 6,
    ThirdPartyNoServerOrServerLocked = 7,
    VersionMismatch = 8,
    SkinIssue = 9,
    InviteSessionNotFound = 10,
    EduLevelSettingsMissing = 11,
    LocalServerNotFound = 12,
    LegacyDisconnect = 13,
    UserLeaveGameAttempted = 14,
    PlatformLockedSkinsError = 15,
    RealmsWorldUnassigned = 16,
    RealmsServerCantConnect = 17,
    RealmsServerHidden = 18,
    RealmsServerDisabledBeta = 19,
    RealmsServerDisabled = 20,
    CrossPlatformDisallowed = 21,
    CantConnect = 22,
    SessionNotFound = 23,
    ClientSettingsIncompatibleWithServer = 24,
    ServerFull = 25,
    InvalidPlatformSkin = 26,
    EditionVersionMismatch = 27,
    EditionMismatch = 28,
    LevelNewerThanExeVersion = 29,
    NoFailOccurred = 30,
    BannedSkin = 31,
    Timeout = 32,
    ServerNotFound = 33,
    OutdatedServer = 34,
    OutdatedClient = 35,
    NoPremiumPlatform = 36,
    MultiplayerDisabled = 37,
    NoWifi = 38,
    WorldCorruption = 39,
    NoReason = 40,
    Disconnected = 41,
    InvalidPlayer = 42,
    LoggedInOtherLocation = 43,
    ServerIdConflict = 44,
    NotAllowed = 45,
    NotAuthenticated = 46,
    InvalidTenant = 47,
    UnknownPacket = 48,
    UnexpectedPacket = 49,
    InvalidCommandRequestPacket = 50,
    HostSuspended = 51,
    LoginPacketNoRequest = 52,
    LoginPacketNoCert = 53,
    MissingClient = 54,
    Kicked = 55,
    KickedForExploit = 56,
    KickedForIdle = 57,
    ResourcePackProblem = 58,
    IncompatiblePack = 59,
    OutOfStorage = 60,
    InvalidLevel = 61,
    DisconnectPacketDeprecated = 62,
    BlockMismatch = 63,
    InvalidHeights = 64,
    InvalidWidths = 65,
    ConnectionLost = 66,
    ZombieConnection = 67,
    Shutdown = 68,
    ReasonNotSet = 69,
    LoadingStateTimeout = 70,
    ResourcePackLoadingFailed = 71,
    SearchingForSessionLoadingScreenFailed = 72,
    ConnProtocolVersion = 73,
    SubsystemStatusError = 74,
    EmptyAuthFromDiscovery = 75,
    EmptyUrlFromDiscovery = 76,
    ExpiredAuthFromDiscovery = 77,
    UnknownSignalServiceSignInFailure = 78,
    XblJoinLobbyFailure = 79,
    UnspecifiedClientInstanceDisconnection = 80,
    ConnSessionNotFound = 81,
    ConnCreatePeerConnection = 82,
    ConnIce = 83,
    ConnConnectRequest = 84,
    ConnConnectResponse = 85,
    ConnNegotiationTimeout = 86,
    ConnInactivityTimeout = 87,
    StaleConnectionBeingReplaced = 88,
    RealmsSessionNotFound = 89,
    BadPacket = 90,
    ConnFailedToCreateOffer = 91,
    ConnFailedToCreateAnswer = 92,
    ConnFailedToSetLocalDescription = 93,
    ConnFailedToSetRemoteDescription = 94,
    ConnNegotiationTimeoutWaitingForResponse = 95,
    ConnNegotiationTimeoutWaitingForAccept = 96,
    ConnIncomingConnectionIgnored = 97,
    ConnSignalingParsingFailure = 98,
    ConnSignalingUnknownError = 99,
    ConnSignalingUnicastDeliveryFailed = 100,
    ConnSignalingBroadcastDeliveryFailed = 101,
    ConnSignalingGenericDeliveryFailed = 102,
    EditorMismatchEditorWorld = 103,
    EditorMismatchVanillaWorld = 104,
    WorldTransferNotPrimaryClient = 105,
    ServerShutdown = 106,
    GameSetupCancelled = 107,
    GameSetupFailed = 108,
    NoVenue = 109,
    ConnSignallingSignInFailed = 110,
    SessionAccessDenied = 111,
    ServiceSignInIssue = 112,
    ConnNoSignalingChannel = 113,
    ConnNotLoggedIn = 114,
    ConnClientSignallingError = 115,
    SubClientLoginDisabled = 116,
    DeepLinkTryingToOpenDemoWorldWhileSignedIn = 117,
    AsyncJoinTaskDenied = 118,
    RealmsTimelineRequired = 119,
    GuestWithoughHost = 120,
    FailedToJoinExperience = 121,
}
impl crate::bedrock::codec::BedrockCodec for DisconnectFailReason {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(DisconnectFailReason::Unknown),
            1 => Ok(DisconnectFailReason::CantConnectNoInternet),
            2 => Ok(DisconnectFailReason::NoPermissions),
            3 => Ok(DisconnectFailReason::UnrecoverableError),
            4 => Ok(DisconnectFailReason::ThirdPartyBlocked),
            5 => Ok(DisconnectFailReason::ThirdPartyNoInternet),
            6 => Ok(DisconnectFailReason::ThirdPartyBadIp),
            7 => Ok(DisconnectFailReason::ThirdPartyNoServerOrServerLocked),
            8 => Ok(DisconnectFailReason::VersionMismatch),
            9 => Ok(DisconnectFailReason::SkinIssue),
            10 => Ok(DisconnectFailReason::InviteSessionNotFound),
            11 => Ok(DisconnectFailReason::EduLevelSettingsMissing),
            12 => Ok(DisconnectFailReason::LocalServerNotFound),
            13 => Ok(DisconnectFailReason::LegacyDisconnect),
            14 => Ok(DisconnectFailReason::UserLeaveGameAttempted),
            15 => Ok(DisconnectFailReason::PlatformLockedSkinsError),
            16 => Ok(DisconnectFailReason::RealmsWorldUnassigned),
            17 => Ok(DisconnectFailReason::RealmsServerCantConnect),
            18 => Ok(DisconnectFailReason::RealmsServerHidden),
            19 => Ok(DisconnectFailReason::RealmsServerDisabledBeta),
            20 => Ok(DisconnectFailReason::RealmsServerDisabled),
            21 => Ok(DisconnectFailReason::CrossPlatformDisallowed),
            22 => Ok(DisconnectFailReason::CantConnect),
            23 => Ok(DisconnectFailReason::SessionNotFound),
            24 => Ok(DisconnectFailReason::ClientSettingsIncompatibleWithServer),
            25 => Ok(DisconnectFailReason::ServerFull),
            26 => Ok(DisconnectFailReason::InvalidPlatformSkin),
            27 => Ok(DisconnectFailReason::EditionVersionMismatch),
            28 => Ok(DisconnectFailReason::EditionMismatch),
            29 => Ok(DisconnectFailReason::LevelNewerThanExeVersion),
            30 => Ok(DisconnectFailReason::NoFailOccurred),
            31 => Ok(DisconnectFailReason::BannedSkin),
            32 => Ok(DisconnectFailReason::Timeout),
            33 => Ok(DisconnectFailReason::ServerNotFound),
            34 => Ok(DisconnectFailReason::OutdatedServer),
            35 => Ok(DisconnectFailReason::OutdatedClient),
            36 => Ok(DisconnectFailReason::NoPremiumPlatform),
            37 => Ok(DisconnectFailReason::MultiplayerDisabled),
            38 => Ok(DisconnectFailReason::NoWifi),
            39 => Ok(DisconnectFailReason::WorldCorruption),
            40 => Ok(DisconnectFailReason::NoReason),
            41 => Ok(DisconnectFailReason::Disconnected),
            42 => Ok(DisconnectFailReason::InvalidPlayer),
            43 => Ok(DisconnectFailReason::LoggedInOtherLocation),
            44 => Ok(DisconnectFailReason::ServerIdConflict),
            45 => Ok(DisconnectFailReason::NotAllowed),
            46 => Ok(DisconnectFailReason::NotAuthenticated),
            47 => Ok(DisconnectFailReason::InvalidTenant),
            48 => Ok(DisconnectFailReason::UnknownPacket),
            49 => Ok(DisconnectFailReason::UnexpectedPacket),
            50 => Ok(DisconnectFailReason::InvalidCommandRequestPacket),
            51 => Ok(DisconnectFailReason::HostSuspended),
            52 => Ok(DisconnectFailReason::LoginPacketNoRequest),
            53 => Ok(DisconnectFailReason::LoginPacketNoCert),
            54 => Ok(DisconnectFailReason::MissingClient),
            55 => Ok(DisconnectFailReason::Kicked),
            56 => Ok(DisconnectFailReason::KickedForExploit),
            57 => Ok(DisconnectFailReason::KickedForIdle),
            58 => Ok(DisconnectFailReason::ResourcePackProblem),
            59 => Ok(DisconnectFailReason::IncompatiblePack),
            60 => Ok(DisconnectFailReason::OutOfStorage),
            61 => Ok(DisconnectFailReason::InvalidLevel),
            62 => Ok(DisconnectFailReason::DisconnectPacketDeprecated),
            63 => Ok(DisconnectFailReason::BlockMismatch),
            64 => Ok(DisconnectFailReason::InvalidHeights),
            65 => Ok(DisconnectFailReason::InvalidWidths),
            66 => Ok(DisconnectFailReason::ConnectionLost),
            67 => Ok(DisconnectFailReason::ZombieConnection),
            68 => Ok(DisconnectFailReason::Shutdown),
            69 => Ok(DisconnectFailReason::ReasonNotSet),
            70 => Ok(DisconnectFailReason::LoadingStateTimeout),
            71 => Ok(DisconnectFailReason::ResourcePackLoadingFailed),
            72 => Ok(DisconnectFailReason::SearchingForSessionLoadingScreenFailed),
            73 => Ok(DisconnectFailReason::ConnProtocolVersion),
            74 => Ok(DisconnectFailReason::SubsystemStatusError),
            75 => Ok(DisconnectFailReason::EmptyAuthFromDiscovery),
            76 => Ok(DisconnectFailReason::EmptyUrlFromDiscovery),
            77 => Ok(DisconnectFailReason::ExpiredAuthFromDiscovery),
            78 => Ok(DisconnectFailReason::UnknownSignalServiceSignInFailure),
            79 => Ok(DisconnectFailReason::XblJoinLobbyFailure),
            80 => Ok(DisconnectFailReason::UnspecifiedClientInstanceDisconnection),
            81 => Ok(DisconnectFailReason::ConnSessionNotFound),
            82 => Ok(DisconnectFailReason::ConnCreatePeerConnection),
            83 => Ok(DisconnectFailReason::ConnIce),
            84 => Ok(DisconnectFailReason::ConnConnectRequest),
            85 => Ok(DisconnectFailReason::ConnConnectResponse),
            86 => Ok(DisconnectFailReason::ConnNegotiationTimeout),
            87 => Ok(DisconnectFailReason::ConnInactivityTimeout),
            88 => Ok(DisconnectFailReason::StaleConnectionBeingReplaced),
            89 => Ok(DisconnectFailReason::RealmsSessionNotFound),
            90 => Ok(DisconnectFailReason::BadPacket),
            91 => Ok(DisconnectFailReason::ConnFailedToCreateOffer),
            92 => Ok(DisconnectFailReason::ConnFailedToCreateAnswer),
            93 => Ok(DisconnectFailReason::ConnFailedToSetLocalDescription),
            94 => Ok(DisconnectFailReason::ConnFailedToSetRemoteDescription),
            95 => Ok(DisconnectFailReason::ConnNegotiationTimeoutWaitingForResponse),
            96 => Ok(DisconnectFailReason::ConnNegotiationTimeoutWaitingForAccept),
            97 => Ok(DisconnectFailReason::ConnIncomingConnectionIgnored),
            98 => Ok(DisconnectFailReason::ConnSignalingParsingFailure),
            99 => Ok(DisconnectFailReason::ConnSignalingUnknownError),
            100 => Ok(DisconnectFailReason::ConnSignalingUnicastDeliveryFailed),
            101 => Ok(DisconnectFailReason::ConnSignalingBroadcastDeliveryFailed),
            102 => Ok(DisconnectFailReason::ConnSignalingGenericDeliveryFailed),
            103 => Ok(DisconnectFailReason::EditorMismatchEditorWorld),
            104 => Ok(DisconnectFailReason::EditorMismatchVanillaWorld),
            105 => Ok(DisconnectFailReason::WorldTransferNotPrimaryClient),
            106 => Ok(DisconnectFailReason::ServerShutdown),
            107 => Ok(DisconnectFailReason::GameSetupCancelled),
            108 => Ok(DisconnectFailReason::GameSetupFailed),
            109 => Ok(DisconnectFailReason::NoVenue),
            110 => Ok(DisconnectFailReason::ConnSignallingSignInFailed),
            111 => Ok(DisconnectFailReason::SessionAccessDenied),
            112 => Ok(DisconnectFailReason::ServiceSignInIssue),
            113 => Ok(DisconnectFailReason::ConnNoSignalingChannel),
            114 => Ok(DisconnectFailReason::ConnNotLoggedIn),
            115 => Ok(DisconnectFailReason::ConnClientSignallingError),
            116 => Ok(DisconnectFailReason::SubClientLoginDisabled),
            117 => Ok(DisconnectFailReason::DeepLinkTryingToOpenDemoWorldWhileSignedIn),
            118 => Ok(DisconnectFailReason::AsyncJoinTaskDenied),
            119 => Ok(DisconnectFailReason::RealmsTimelineRequired),
            120 => Ok(DisconnectFailReason::GuestWithoughHost),
            121 => Ok(DisconnectFailReason::FailedToJoinExperience),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(DisconnectFailReason),
                value: val as i64,
            }),
        }
    }
}
impl Default for DisconnectFailReason {
    fn default() -> Self {
        Self::Unknown
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum EaseType {
    Linear = 0,
    Spring = 1,
    InQuad = 2,
    OutQuad = 3,
    InOutQuad = 4,
    InCubic = 5,
    OutCubic = 6,
    InOutCubic = 7,
    InQuart = 8,
    OutQuart = 9,
    InOutQuart = 10,
    InQuint = 11,
    OutQuint = 12,
    InOutQuint = 13,
    InSine = 14,
    OutSine = 15,
    InOutSine = 16,
    InExpo = 17,
    OutExpo = 18,
    InOutExpo = 19,
    InCirc = 20,
    OutCirc = 21,
    InOutCirc = 22,
    InBounce = 23,
    OutBounce = 24,
    InOutBounce = 25,
    InBack = 26,
    OutBack = 27,
    InOutBack = 28,
    InElastic = 29,
    OutElastic = 30,
    InOutElastic = 31,
}
impl crate::bedrock::codec::BedrockCodec for EaseType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(EaseType::Linear),
            1 => Ok(EaseType::Spring),
            2 => Ok(EaseType::InQuad),
            3 => Ok(EaseType::OutQuad),
            4 => Ok(EaseType::InOutQuad),
            5 => Ok(EaseType::InCubic),
            6 => Ok(EaseType::OutCubic),
            7 => Ok(EaseType::InOutCubic),
            8 => Ok(EaseType::InQuart),
            9 => Ok(EaseType::OutQuart),
            10 => Ok(EaseType::InOutQuart),
            11 => Ok(EaseType::InQuint),
            12 => Ok(EaseType::OutQuint),
            13 => Ok(EaseType::InOutQuint),
            14 => Ok(EaseType::InSine),
            15 => Ok(EaseType::OutSine),
            16 => Ok(EaseType::InOutSine),
            17 => Ok(EaseType::InExpo),
            18 => Ok(EaseType::OutExpo),
            19 => Ok(EaseType::InOutExpo),
            20 => Ok(EaseType::InCirc),
            21 => Ok(EaseType::OutCirc),
            22 => Ok(EaseType::InOutCirc),
            23 => Ok(EaseType::InBounce),
            24 => Ok(EaseType::OutBounce),
            25 => Ok(EaseType::InOutBounce),
            26 => Ok(EaseType::InBack),
            27 => Ok(EaseType::OutBack),
            28 => Ok(EaseType::InOutBack),
            29 => Ok(EaseType::InElastic),
            30 => Ok(EaseType::OutElastic),
            31 => Ok(EaseType::InOutElastic),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(EaseType),
                value: val as i64,
            }),
        }
    }
}
impl Default for EaseType {
    fn default() -> Self {
        Self::Linear
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EducationExternalLinkSettings {
    pub url: String,
    pub display_name: String,
}
impl crate::bedrock::codec::BedrockCodec for EducationExternalLinkSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.url)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.url).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.display_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.display_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let url = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let display_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { url, display_name })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EducationSharedResourceUri {
    pub button_name: String,
    pub link_uri: String,
}
impl crate::bedrock::codec::BedrockCodec for EducationSharedResourceUri {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.button_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.button_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.link_uri)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.link_uri).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let button_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let link_uri = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            button_name,
            link_uri,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum Element {
    PaperDoll = 0,
    Armour = 1,
    ToolTips = 2,
    TouchControls = 3,
    Crosshair = 4,
    HotBar = 5,
    Health = 6,
    ProgressBar = 7,
    Hunger = 8,
    AirBubbles = 9,
    VehicleHealth = 10,
    EffectsBar = 11,
    ItemTextPopup = 12,
}
impl crate::bedrock::codec::BedrockCodec for Element {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(Element::PaperDoll),
            1 => Ok(Element::Armour),
            2 => Ok(Element::ToolTips),
            3 => Ok(Element::TouchControls),
            4 => Ok(Element::Crosshair),
            5 => Ok(Element::HotBar),
            6 => Ok(Element::Health),
            7 => Ok(Element::ProgressBar),
            8 => Ok(Element::Hunger),
            9 => Ok(Element::AirBubbles),
            10 => Ok(Element::VehicleHealth),
            11 => Ok(Element::EffectsBar),
            12 => Ok(Element::ItemTextPopup),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(Element),
                value: val as i64,
            }),
        }
    }
}
impl Default for Element {
    fn default() -> Self {
        Self::PaperDoll
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Enchant {
    pub id: u8,
    pub level: u8,
}
impl crate::bedrock::codec::BedrockCodec for Enchant {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.id.encode(buf)?;
        self.level.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let level = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { id, level })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EnchantOption {
    pub cost: i32,
    pub slot_flags: i32,
    pub equip_enchants: Vec<Enchant>,
    pub held_enchants: Vec<Enchant>,
    pub self_enchants: Vec<Enchant>,
    pub name: String,
    pub option_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for EnchantOption {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.cost).encode(buf)?;
        crate::bedrock::codec::I32LE(self.slot_flags).encode(buf)?;
        let len = self.equip_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.equip_enchants {
            item.encode(buf)?;
        }
        let len = self.held_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.held_enchants {
            item.encode(buf)?;
        }
        let len = self.self_enchants.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.self_enchants {
            item.encode(buf)?;
        }
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.option_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let cost = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let slot_flags =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let equip_enchants = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?);
            }
            tmp_vec
        };
        let held_enchants = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?);
            }
            tmp_vec
        };
        let self_enchants = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<Enchant as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?);
            }
            tmp_vec
        };
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let option_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            cost,
            slot_flags,
            equip_enchants,
            held_enchants,
            self_enchants,
            name,
            option_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EntityAttributesItem {
    pub name: String,
    pub min: f32,
    pub value: f32,
    pub max: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntityAttributesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::F32LE(self.min).encode(buf)?;
        crate::bedrock::codec::F32LE(self.value).encode(buf)?;
        crate::bedrock::codec::F32LE(self.max).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let min =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let value =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let max =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            name,
            min,
            value,
            max,
        })
    }
}
pub type EntityAttributes = Vec<EntityAttributesItem>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EntityPropertiesIntsItem {
    pub index: i32,
    pub value: i32,
}
impl crate::bedrock::codec::BedrockCodec for EntityPropertiesIntsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.index).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.value).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let index = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let value =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { index, value })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EntityPropertiesFloatsItem {
    pub index: i32,
    pub value: f32,
}
impl crate::bedrock::codec::BedrockCodec for EntityPropertiesFloatsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.index).encode(buf)?;
        crate::bedrock::codec::F32LE(self.value).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let index = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let value =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { index, value })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EntityProperties {
    pub ints: Vec<EntityPropertiesIntsItem>,
    pub floats: Vec<EntityPropertiesFloatsItem>,
}
impl crate::bedrock::codec::BedrockCodec for EntityProperties {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.ints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.ints {
            item.encode(buf)?;
        }
        let len = self.floats.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.floats {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let ints = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <EntityPropertiesIntsItem as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                );
            }
            tmp_vec
        };
        let floats = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <EntityPropertiesFloatsItem as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                );
            }
            tmp_vec
        };
        Ok(Self { ints, floats })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Experiment {
    pub name: String,
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for Experiment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { name, enabled })
    }
}
pub type Experiments = Vec<Experiment>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct FullContainerName {
    pub container_id: ContainerSlotType,
    pub dynamic_container_id: Option<u32>,
}
impl crate::bedrock::codec::BedrockCodec for FullContainerName {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.container_id.encode(buf)?;
        match &self.dynamic_container_id {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let container_id =
            <ContainerSlotType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dynamic_container_id = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<u32 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        Ok(Self {
            container_id,
            dynamic_container_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameMode {
    Survival = 0,
    Creative = 1,
    Adventure = 2,
    SurvivalSpectator = 3,
    CreativeSpectator = 4,
    Fallback = 5,
    Spectator = 6,
}
impl crate::bedrock::codec::BedrockCodec for GameMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(GameMode::Survival),
            1 => Ok(GameMode::Creative),
            2 => Ok(GameMode::Adventure),
            3 => Ok(GameMode::SurvivalSpectator),
            4 => Ok(GameMode::CreativeSpectator),
            5 => Ok(GameMode::Fallback),
            6 => Ok(GameMode::Spectator),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(GameMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for GameMode {
    fn default() -> Self {
        Self::Survival
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameRuleI32Type {
    Bool = 1,
    Int = 2,
    Float = 3,
}
impl crate::bedrock::codec::BedrockCodec for GameRuleI32Type {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            1 => Ok(GameRuleI32Type::Bool),
            2 => Ok(GameRuleI32Type::Int),
            3 => Ok(GameRuleI32Type::Float),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(GameRuleI32Type),
                value: val as i64,
            }),
        }
    }
}
impl Default for GameRuleI32Type {
    fn default() -> Self {
        Self::Bool
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum GameRuleI32Value {
    Bool(bool),
    Float(f32),
    Int(i32),
}
impl Default for GameRuleI32Value {
    fn default() -> Self {
        Self::Bool(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GameRuleI32 {
    pub name: String,
    pub editable: bool,
    pub type_: GameRuleI32Type,
    pub value: Option<GameRuleI32Value>,
}
impl crate::bedrock::codec::BedrockCodec for GameRuleI32 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.editable.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                GameRuleI32Value::Bool(v) => {
                    (*v).encode(buf)?;
                }
                GameRuleI32Value::Float(v) => {
                    crate::bedrock::codec::F32LE(*v).encode(buf)?;
                }
                GameRuleI32Value::Int(v) => {
                    crate::bedrock::codec::I32LE(*v).encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let editable = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let type_ = <GameRuleI32Type as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let value = match type_ {
            GameRuleI32Type::Bool => Some(GameRuleI32Value::Bool(
                <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
            )),
            GameRuleI32Type::Float => Some(GameRuleI32Value::Float(
                <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            )),
            GameRuleI32Type::Int => Some(GameRuleI32Value::Int(
                <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            )),
        };
        Ok(Self {
            name,
            editable,
            type_,
            value,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum GameRuleVarintType {
    Bool = 1,
    Int = 2,
    Float = 3,
}
impl crate::bedrock::codec::BedrockCodec for GameRuleVarintType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            1 => Ok(GameRuleVarintType::Bool),
            2 => Ok(GameRuleVarintType::Int),
            3 => Ok(GameRuleVarintType::Float),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(GameRuleVarintType),
                value: val as i64,
            }),
        }
    }
}
impl Default for GameRuleVarintType {
    fn default() -> Self {
        Self::Bool
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum GameRuleVarintValue {
    Bool(bool),
    Float(f32),
    Int(i32),
}
impl Default for GameRuleVarintValue {
    fn default() -> Self {
        Self::Bool(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GameRuleVarint {
    pub name: String,
    pub editable: bool,
    pub type_: GameRuleVarintType,
    pub value: Option<GameRuleVarintValue>,
}
impl crate::bedrock::codec::BedrockCodec for GameRuleVarint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.editable.encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                GameRuleVarintValue::Bool(v) => {
                    (*v).encode(buf)?;
                }
                GameRuleVarintValue::Float(v) => {
                    crate::bedrock::codec::F32LE(*v).encode(buf)?;
                }
                GameRuleVarintValue::Int(v) => {
                    crate::bedrock::codec::VarInt(*v).encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let editable = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let type_ = <GameRuleVarintType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let value = match type_ {
            GameRuleVarintType::Bool => Some(GameRuleVarintValue::Bool(
                <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
            )),
            GameRuleVarintType::Float => Some(GameRuleVarintValue::Float(
                <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            )),
            GameRuleVarintType::Int => Some(GameRuleVarintValue::Int(
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            )),
        };
        Ok(Self {
            name,
            editable,
            type_,
            value,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum GraphicsOverrideParameterType {
    SkyZenithColor = 0,
    SkyHorizonColor = 1,
    HorizonBlendMin = 2,
    HorizonBlendMax = 3,
    HorizonBlendStart = 4,
    HorizonBlendMieStart = 5,
    RayleighStrength = 6,
    SunMieStrength = 7,
    MoonMieStrength = 8,
    SunGlareShape = 9,
}
impl crate::bedrock::codec::BedrockCodec for GraphicsOverrideParameterType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(GraphicsOverrideParameterType::SkyZenithColor),
            1 => Ok(GraphicsOverrideParameterType::SkyHorizonColor),
            2 => Ok(GraphicsOverrideParameterType::HorizonBlendMin),
            3 => Ok(GraphicsOverrideParameterType::HorizonBlendMax),
            4 => Ok(GraphicsOverrideParameterType::HorizonBlendStart),
            5 => Ok(GraphicsOverrideParameterType::HorizonBlendMieStart),
            6 => Ok(GraphicsOverrideParameterType::RayleighStrength),
            7 => Ok(GraphicsOverrideParameterType::SunMieStrength),
            8 => Ok(GraphicsOverrideParameterType::MoonMieStrength),
            9 => Ok(GraphicsOverrideParameterType::SunGlareShape),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(GraphicsOverrideParameterType),
                value: val as i64,
            }),
        }
    }
}
impl Default for GraphicsOverrideParameterType {
    fn default() -> Self {
        Self::SkyZenithColor
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum HeightMapDataType {
    NoData = 0,
    HasData = 1,
    TooHigh = 2,
    TooLow = 3,
    AllCopied = 4,
}
impl crate::bedrock::codec::BedrockCodec for HeightMapDataType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(HeightMapDataType::NoData),
            1 => Ok(HeightMapDataType::HasData),
            2 => Ok(HeightMapDataType::TooHigh),
            3 => Ok(HeightMapDataType::TooLow),
            4 => Ok(HeightMapDataType::AllCopied),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(HeightMapDataType),
                value: val as i64,
            }),
        }
    }
}
impl Default for HeightMapDataType {
    fn default() -> Self {
        Self::NoData
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct InputFlag :
    u64 { const ASCEND = 1; const DESCEND = 2; const NORTH_JUMP = 4; const JUMP_DOWN = 8;
    const SPRINT_DOWN = 16; const CHANGE_HEIGHT = 32; const JUMPING = 64; const
    AUTO_JUMPING_IN_WATER = 128; const SNEAKING = 256; const SNEAK_DOWN = 512; const UP =
    1024; const DOWN = 2048; const LEFT = 4096; const RIGHT = 8192; const UP_LEFT =
    16384; const UP_RIGHT = 32768; const WANT_UP = 65536; const WANT_DOWN = 131072; const
    WANT_DOWN_SLOW = 262144; const WANT_UP_SLOW = 524288; const SPRINTING = 1048576;
    const ASCEND_BLOCK = 2097152; const DESCEND_BLOCK = 4194304; const SNEAK_TOGGLE_DOWN
    = 8388608; const PERSIST_SNEAK = 16777216; const START_SPRINTING = 33554432; const
    STOP_SPRINTING = 67108864; const START_SNEAKING = 134217728; const STOP_SNEAKING =
    268435456; const START_SWIMMING = 536870912; const STOP_SWIMMING = 1073741824; const
    START_JUMPING = 2147483648; const START_GLIDING = 4294967296; const STOP_GLIDING =
    8589934592; const ITEM_INTERACT = 17179869184; const BLOCK_ACTION = 34359738368;
    const ITEM_STACK_REQUEST = 68719476736; const HANDLED_TELEPORT = 137438953472; const
    EMOTING = 274877906944; const MISSED_SWING = 549755813888; const START_CRAWLING =
    1099511627776; const STOP_CRAWLING = 2199023255552; const START_FLYING =
    4398046511104; const STOP_FLYING = 8796093022208; const RECEIVED_SERVER_DATA =
    17592186044416; const CLIENT_PREDICTED_VEHICLE = 35184372088832; const PADDLING_LEFT
    = 70368744177664; const PADDLING_RIGHT = 140737488355328; const
    BLOCK_BREAKING_DELAY_ENABLED = 281474976710656; const HORIZONTAL_COLLISION =
    562949953421312; const VERTICAL_COLLISION = 1125899906842624; const DOWN_LEFT =
    2251799813685248; const DOWN_RIGHT = 4503599627370496; const START_USING_ITEM =
    9007199254740992; const CAMERA_RELATIVE_MOVEMENT_ENABLED = 18014398509481984; const
    ROT_CONTROLLED_BY_MOVE_DIRECTION = 36028797018963968; const START_SPIN_ATTACK =
    72057594037927936; const STOP_SPIN_ATTACK = 144115188075855872; const
    HOTBAR_ONLY_TOUCH = 288230376151711744; const JUMP_RELEASED_RAW = 576460752303423488;
    const JUMP_PRESSED_RAW = 1152921504606846976; const JUMP_CURRENT_RAW =
    2305843009213693952; const SNEAK_RELEASED_RAW = 4611686018427387904; const
    SNEAK_PRESSED_RAW = 9223372036854775808; const SNEAK_CURRENT_RAW = 0; }
}
impl crate::bedrock::codec::BedrockCodec for InputFlag {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarLong(val as i64).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u64;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct InputLockFlags
    : u32 { const DISMOUNT = 32; const JUMP = 4; const MOUNT = 16; const MOVE = 2; const
    ROTATION = 64; const SNEAK = 8; }
}
impl crate::bedrock::codec::BedrockCodec for InputLockFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemExtraDataWithoutBlockingTickNbt {
    pub version: u8,
    pub nbt: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTickNbt {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt =
            <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { version, nbt })
    }
}
pub type ShortString = String;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemExtraDataWithoutBlockingTick {
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNbt>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithoutBlockingTick {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let disc: u16 = if self.nbt.is_some() {
            65535 as u16
        } else {
            0 as u16
        };
        crate::bedrock::codec::U16LE(disc).encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_place_on {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::I16LE(len as i16).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.can_destroy.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_destroy {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::I16LE(len as i16).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let has_nbt =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0
                != 0;
        let nbt = if has_nbt {
            Some(
                <ItemExtraDataWithoutBlockingTickNbt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let can_place_on = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let res: ShortString = {
                            let len_raw = (<crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?
                                .0) as i64;
                            if len_raw < 0 {
                                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                    value: len_raw,
                                });
                            }
                            let len = len_raw as usize;
                            if buf.remaining() < len {
                                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                    declared: len,
                                    available: buf.remaining(),
                                });
                            }
                            let mut bytes = vec![0u8; len];
                            buf.copy_to_slice(&mut bytes);
                            let s = if "".eq_ignore_ascii_case("latin1") {
                                bytes.into_iter().map(|b| b as char).collect::<String>()
                            } else {
                                String::from_utf8_lossy(&bytes).into_owned()
                            };
                            s
                        };
                        res
                    });
            }
            tmp_vec
        };
        let can_destroy = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let res: ShortString = {
                            let len_raw = (<crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?
                                .0) as i64;
                            if len_raw < 0 {
                                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                    value: len_raw,
                                });
                            }
                            let len = len_raw as usize;
                            if buf.remaining() < len {
                                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                    declared: len,
                                    available: buf.remaining(),
                                });
                            }
                            let mut bytes = vec![0u8; len];
                            buf.copy_to_slice(&mut bytes);
                            let s = if "".eq_ignore_ascii_case("latin1") {
                                bytes.into_iter().map(|b| b as char).collect::<String>()
                            } else {
                                String::from_utf8_lossy(&bytes).into_owned()
                            };
                            s
                        };
                        res
                    });
            }
            tmp_vec
        };
        Ok(Self {
            nbt,
            can_place_on,
            can_destroy,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemExtraDataWithBlockingTick {
    pub nbt: Option<ItemExtraDataWithoutBlockingTickNbt>,
    pub can_place_on: Vec<ShortString>,
    pub can_destroy: Vec<ShortString>,
    pub blocking_tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for ItemExtraDataWithBlockingTick {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let disc: u16 = if self.nbt.is_some() {
            65535 as u16
        } else {
            0 as u16
        };
        crate::bedrock::codec::U16LE(disc).encode(buf)?;
        if let Some(v) = &self.nbt {
            v.encode(buf)?;
        }
        let len = self.can_place_on.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_place_on {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::I16LE(len as i16).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.can_destroy.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.can_destroy {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::I16LE(len as i16).encode(buf)?;
            buf.put_slice(&bytes);
        }
        crate::bedrock::codec::I64LE(self.blocking_tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let has_nbt =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0
                != 0;
        let nbt = if has_nbt {
            Some(
                <ItemExtraDataWithoutBlockingTickNbt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let can_place_on = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let res: ShortString = {
                            let len_raw = (<crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?
                                .0) as i64;
                            if len_raw < 0 {
                                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                    value: len_raw,
                                });
                            }
                            let len = len_raw as usize;
                            if buf.remaining() < len {
                                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                    declared: len,
                                    available: buf.remaining(),
                                });
                            }
                            let mut bytes = vec![0u8; len];
                            buf.copy_to_slice(&mut bytes);
                            let s = if "".eq_ignore_ascii_case("latin1") {
                                bytes.into_iter().map(|b| b as char).collect::<String>()
                            } else {
                                String::from_utf8_lossy(&bytes).into_owned()
                            };
                            s
                        };
                        res
                    });
            }
            tmp_vec
        };
        let can_destroy = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let res: ShortString = {
                            let len_raw = (<crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?
                                .0) as i64;
                            if len_raw < 0 {
                                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                    value: len_raw,
                                });
                            }
                            let len = len_raw as usize;
                            if buf.remaining() < len {
                                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                    declared: len,
                                    available: buf.remaining(),
                                });
                            }
                            let mut bytes = vec![0u8; len];
                            buf.copy_to_slice(&mut bytes);
                            let s = if "".eq_ignore_ascii_case("latin1") {
                                bytes.into_iter().map(|b| b as char).collect::<String>()
                            } else {
                                String::from_utf8_lossy(&bytes).into_owned()
                            };
                            s
                        };
                        res
                    });
            }
            tmp_vec
        };
        let blocking_tick =
            <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            nbt,
            can_place_on,
            can_destroy,
            blocking_tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemContentExtra {
    Default(ItemExtraDataWithoutBlockingTick),
    ShieldItemId(ItemExtraDataWithBlockingTick),
}
impl Default for ItemContentExtra {
    fn default() -> Self {
        Self::Default(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemContent {
    pub count: u16,
    pub metadata: i32,
    pub has_stack_id: u8,
    pub stack_id: Option<i32>,
    pub block_runtime_id: i32,
    pub extra: ItemContentExtra,
}
#[derive(Debug, Clone)]
pub struct ItemContentArgs {
    pub network_id: i32,
    pub shield_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemContent {
    type Args = ItemContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U16LE(self.count).encode(buf)?;
        crate::bedrock::codec::VarInt(self.metadata).encode(buf)?;
        self.has_stack_id.encode(buf)?;
        if let Some(v) = &self.stack_id {
            v.encode(buf)?;
        }
        crate::bedrock::codec::ZigZag32(self.block_runtime_id).encode(buf)?;
        match &self.extra {
            ItemContentExtra::ShieldItemId(v) => {
                let mut __encap_tmp = bytes::BytesMut::new();
                {
                    let buf = &mut __encap_tmp;
                    v.encode(buf)?;
                }
                let len = __encap_tmp.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&__encap_tmp);
            }
            ItemContentExtra::Default(v) => {
                let mut __encap_tmp = bytes::BytesMut::new();
                {
                    let buf = &mut __encap_tmp;
                    v.encode(buf)?;
                }
                let len = __encap_tmp.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&__encap_tmp);
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        println!("DEBUG: Decoding ItemContent. Rem: {}", buf.remaining());
        let count =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        println!(
            "DEBUG: Item count: {}. Raw bytes: {:?}. Rem: {}",
            count,
            count.to_le_bytes(),
            buf.remaining()
        );

        if count == 0 {
            return Ok(Self {
                count,
                metadata: 0,
                has_stack_id: 0,
                stack_id: None,
                block_runtime_id: 0,
                extra: ItemContentExtra::Default(Default::default()),
            });
        }

        let metadata =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        println!(
            "DEBUG: Item metadata: {}. Rem: {}",
            metadata,
            buf.remaining()
        );
        let has_stack_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        println!(
            "DEBUG: Item has_stack_id: {} (0x{:X}). Rem: {}",
            has_stack_id,
            has_stack_id,
            buf.remaining()
        );
        let stack_id = if (has_stack_id) != 0 {
            Some(
                <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            )
        } else {
            None
        };
        println!(
            "DEBUG: Item stack_id: {:?}. Rem: {}",
            stack_id,
            buf.remaining()
        );
        let block_runtime_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        println!(
            "DEBUG: Item block_runtime_id: {}. Rem: {}",
            block_runtime_id,
            buf.remaining()
        );
        let extra = match args.network_id {
            x if x == args.shield_item_id => ItemContentExtra::ShieldItemId({
                println!("DEBUG: ItemContentExtra::ShieldItemId decoding...");
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                println!(
                    "DEBUG: ShieldItemId len_raw: {}. Rem: {}",
                    len_raw,
                    buf.remaining()
                );
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                if len_raw == 0 {
                    Default::default()
                } else {
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::ArrayLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut slice = bytes::Buf::take(&mut *buf, len);
                    let value = {
                        let buf = &mut slice;
                        <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                    };
                    let _ = slice.remaining();
                    value
                }
            }),
            _ => ItemContentExtra::Default({
                println!("DEBUG: ItemContentExtra::Default decoding...");
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                println!(
                    "DEBUG: Default len_raw: {}. Rem: {}",
                    len_raw,
                    buf.remaining()
                );
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                if len_raw == 0 {
                    Default::default()
                } else {
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::ArrayLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut slice = bytes::Buf::take(&mut *buf, len);
                    let value = {
                        let buf = &mut slice;
                        <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                    };
                    let _ = slice.remaining();
                    value
                }
            }),
        };
        Ok(Self {
            count,
            metadata,
            has_stack_id,
            stack_id,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Item {
    pub network_id: i32,
    pub content: Option<Box<ItemContent>>,
}
#[derive(Debug, Clone)]
pub struct ItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for Item {
    type Args = ItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        println!("DEBUG: ===== Decoding Item. Rem: {} =====", buf.remaining());

        // Check if we have enough bytes for at least the network_id (VarInt minimum is 1 byte)
        if buf.remaining() < 1 {
            println!(
                "ERROR: Not enough bytes to decode Item network_id. Rem: {}",
                buf.remaining()
            );
            return Err(crate::bedrock::error::DecodeError::UnexpectedEof {
                needed: 1,
                available: buf.remaining(),
            });
        }

        let network_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        println!(
            "DEBUG: Item network_id: {} (0x{:X}). Rem: {}",
            network_id,
            network_id,
            buf.remaining()
        );

        let content = if (network_id) != 0 {
            println!("DEBUG: Item has content, decoding ItemContent...");
            Some(Box::new(
                <ItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    ItemContentArgs {
                        network_id: network_id,
                        shield_item_id: args.shield_item_id,
                    },
                )?,
            ))
        } else {
            println!("DEBUG: Item network_id is 0, no content");
            None
        };
        println!(
            "DEBUG: ===== Item decode complete. Rem: {} =====",
            buf.remaining()
        );
        Ok(Self {
            network_id,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemLegacyContentExtra {
    Default(ItemExtraDataWithoutBlockingTick),
    ShieldItemId(ItemExtraDataWithBlockingTick),
}
impl Default for ItemLegacyContentExtra {
    fn default() -> Self {
        Self::Default(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemLegacyContent {
    pub count: u16,
    pub metadata: i32,
    pub block_runtime_id: i32,
    pub extra: ItemLegacyContentExtra,
}
#[derive(Debug, Clone)]
pub struct ItemLegacyContentArgs {
    pub network_id: i32,
    pub shield_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacyContent {
    type Args = ItemLegacyContentArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U16LE(self.count).encode(buf)?;
        crate::bedrock::codec::VarInt(self.metadata).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_runtime_id).encode(buf)?;
        match &self.extra {
            ItemLegacyContentExtra::ShieldItemId(v) => {
                let mut __encap_tmp = bytes::BytesMut::new();
                {
                    let buf = &mut __encap_tmp;
                    v.encode(buf)?;
                }
                let len = __encap_tmp.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&__encap_tmp);
            }
            ItemLegacyContentExtra::Default(v) => {
                let mut __encap_tmp = bytes::BytesMut::new();
                {
                    let buf = &mut __encap_tmp;
                    v.encode(buf)?;
                }
                let len = __encap_tmp.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&__encap_tmp);
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let count =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let metadata =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let block_runtime_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let extra = match args.network_id {
            x if x == args.shield_item_id => ItemLegacyContentExtra::ShieldItemId({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::ArrayLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut slice = bytes::Buf::take(&mut *buf, len);
                let value = {
                    let buf = &mut slice;
                    <ItemExtraDataWithBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                };
                let _ = slice.remaining();
                value
            }),
            _ => ItemLegacyContentExtra::Default({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::ArrayLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut slice = bytes::Buf::take(&mut *buf, len);
                let value = {
                    let buf = &mut slice;
                    <ItemExtraDataWithoutBlockingTick as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                };
                let _ = slice.remaining();
                value
            }),
        };
        Ok(Self {
            count,
            metadata,
            block_runtime_id,
            extra,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemLegacy {
    pub network_id: i32,
    pub content: Option<Box<ItemLegacyContent>>,
}
#[derive(Debug, Clone)]
pub struct ItemLegacyArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemLegacyArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemLegacy {
    type Args = ItemLegacyArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let network_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = if (network_id) != 0 {
            Some(Box::new(
                <ItemLegacyContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    ItemLegacyContentArgs {
                        network_id: network_id,
                        shield_item_id: args.shield_item_id,
                    },
                )?,
            ))
        } else {
            None
        };
        Ok(Self {
            network_id,
            content,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackRequestActionsItemTypeId {
    Take = 0,
    Place = 1,
    Swap = 2,
    Drop = 3,
    Destroy = 4,
    Consume = 5,
    Create = 6,
    PlaceInContainer = 7,
    TakeOutContainer = 8,
    LabTableCombine = 9,
    BeaconPayment = 10,
    MineBlock = 11,
    CraftRecipe = 12,
    CraftRecipeAuto = 13,
    CraftCreative = 14,
    Optional = 15,
    CraftGrindstoneRequest = 16,
    CraftLoomRequest = 17,
    NonImplemented = 18,
    ResultsDeprecated = 19,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemTypeId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackRequestActionsItemTypeId::Take),
            1 => Ok(ItemStackRequestActionsItemTypeId::Place),
            2 => Ok(ItemStackRequestActionsItemTypeId::Swap),
            3 => Ok(ItemStackRequestActionsItemTypeId::Drop),
            4 => Ok(ItemStackRequestActionsItemTypeId::Destroy),
            5 => Ok(ItemStackRequestActionsItemTypeId::Consume),
            6 => Ok(ItemStackRequestActionsItemTypeId::Create),
            7 => Ok(ItemStackRequestActionsItemTypeId::PlaceInContainer),
            8 => Ok(ItemStackRequestActionsItemTypeId::TakeOutContainer),
            9 => Ok(ItemStackRequestActionsItemTypeId::LabTableCombine),
            10 => Ok(ItemStackRequestActionsItemTypeId::BeaconPayment),
            11 => Ok(ItemStackRequestActionsItemTypeId::MineBlock),
            12 => Ok(ItemStackRequestActionsItemTypeId::CraftRecipe),
            13 => Ok(ItemStackRequestActionsItemTypeId::CraftRecipeAuto),
            14 => Ok(ItemStackRequestActionsItemTypeId::CraftCreative),
            15 => Ok(ItemStackRequestActionsItemTypeId::Optional),
            16 => Ok(ItemStackRequestActionsItemTypeId::CraftGrindstoneRequest),
            17 => Ok(ItemStackRequestActionsItemTypeId::CraftLoomRequest),
            18 => Ok(ItemStackRequestActionsItemTypeId::NonImplemented),
            19 => Ok(ItemStackRequestActionsItemTypeId::ResultsDeprecated),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ItemStackRequestActionsItemTypeId),
                value: val as i64,
            }),
        }
    }
}
impl Default for ItemStackRequestActionsItemTypeId {
    fn default() -> Self {
        Self::Take
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentBeaconPayment {
    pub primary_effect: i32,
    pub secondary_effect: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentBeaconPayment {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.primary_effect).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.secondary_effect).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let primary_effect =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let secondary_effect =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            primary_effect,
            secondary_effect,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StackRequestSlotInfo {
    pub slot_type: FullContainerName,
    pub slot: u8,
    pub stack_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for StackRequestSlotInfo {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.slot_type.encode(buf)?;
        self.slot.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.stack_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let slot_type =
            <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stack_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            slot_type,
            slot,
            stack_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentConsume {
    pub count: u8,
    pub source: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentConsume {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source =
            <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { count, source })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentCraftCreative {
    pub item_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCraftCreative {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.item_id).encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let item_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            item_id,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentCraftGrindstoneRequest {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
    pub cost: i32,
}
impl crate::bedrock::codec::BedrockCodec
    for ItemStackRequestActionsItemContentCraftGrindstoneRequest
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.times_crafted.encode(buf)?;
        crate::bedrock::codec::VarInt(self.cost).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let cost = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        Ok(Self {
            recipe_network_id,
            times_crafted,
            cost,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentCraftLoomRequest {
    pub pattern: String,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCraftLoomRequest {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.pattern)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.pattern).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let pattern = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            pattern,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentCraftRecipe {
    pub recipe_network_id: i32,
    pub times_crafted: u8,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCraftRecipe {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            recipe_network_id,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum RecipeIngredientType {
    Invalid = 0,
    IntIdMeta = 1,
    Molang = 2,
    ItemTag = 3,
    StringIdMeta = 4,
    ComplexAlias = 5,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(RecipeIngredientType::Invalid),
            1 => Ok(RecipeIngredientType::IntIdMeta),
            2 => Ok(RecipeIngredientType::Molang),
            3 => Ok(RecipeIngredientType::ItemTag),
            4 => Ok(RecipeIngredientType::StringIdMeta),
            5 => Ok(RecipeIngredientType::ComplexAlias),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(RecipeIngredientType),
                value: val as i64,
            }),
        }
    }
}
impl Default for RecipeIngredientType {
    fn default() -> Self {
        Self::Invalid
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipeIngredientContentComplexAlias {
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentComplexAlias {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { name })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipeIngredientContentIntIdMeta {
    pub network_id: i16,
    pub metadata: Option<i16>,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentIntIdMeta {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I16LE(self.network_id).encode(buf)?;
        if let Some(v) = &self.metadata {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let network_id =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let metadata = if (network_id) != 0 {
            Some(
                <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            )
        } else {
            None
        };
        Ok(Self {
            network_id,
            metadata,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipeIngredientContentItemTag {
    pub tag: String,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentItemTag {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.tag)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.tag).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let tag = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { tag })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipeIngredientContentMolang {
    pub expression: String,
    pub version: u8,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentMolang {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.expression)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.expression).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.version.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let expression = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let version = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            expression,
            version,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipeIngredientContentStringIdMeta {
    pub name: String,
    pub metadata: i16,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredientContentStringIdMeta {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I16LE(self.metadata).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let metadata =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { name, metadata })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipeIngredientContent {
    ComplexAlias(RecipeIngredientContentComplexAlias),
    IntIdMeta(Box<RecipeIngredientContentIntIdMeta>),
    ItemTag(RecipeIngredientContentItemTag),
    Molang(RecipeIngredientContentMolang),
    StringIdMeta(RecipeIngredientContentStringIdMeta),
}
impl Default for RecipeIngredientContent {
    fn default() -> Self {
        Self::ComplexAlias(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipeIngredient {
    pub type_: RecipeIngredientType,
    pub content: Option<RecipeIngredientContent>,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipeIngredient {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                RecipeIngredientContent::ComplexAlias(v) => {
                    v.encode(buf)?;
                }
                RecipeIngredientContent::IntIdMeta(v) => {
                    v.encode(buf)?;
                }
                RecipeIngredientContent::ItemTag(v) => {
                    v.encode(buf)?;
                }
                RecipeIngredientContent::Molang(v) => {
                    v.encode(buf)?;
                }
                RecipeIngredientContent::StringIdMeta(v) => {
                    v.encode(buf)?;
                }
            }
        }
        crate::bedrock::codec::ZigZag32(self.count).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <RecipeIngredientType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match type_ {
            RecipeIngredientType::ComplexAlias => {
                Some(
                    RecipeIngredientContent::ComplexAlias(
                        <RecipeIngredientContentComplexAlias as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipeIngredientType::IntIdMeta => {
                Some(
                    RecipeIngredientContent::IntIdMeta(
                        Box::new(
                            <RecipeIngredientContentIntIdMeta as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            RecipeIngredientType::ItemTag => {
                Some(
                    RecipeIngredientContent::ItemTag(
                        <RecipeIngredientContentItemTag as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipeIngredientType::Molang => {
                Some(
                    RecipeIngredientContent::Molang(
                        <RecipeIngredientContentMolang as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipeIngredientType::StringIdMeta => {
                Some(
                    RecipeIngredientContent::StringIdMeta(
                        <RecipeIngredientContentStringIdMeta as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let count =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            type_,
            content,
            count,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentCraftRecipeAuto {
    pub recipe_network_id: i32,
    pub times_crafted_2: u8,
    pub times_crafted: u8,
    pub ingredients: Vec<RecipeIngredient>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCraftRecipeAuto {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        self.times_crafted_2.encode(buf)?;
        self.times_crafted.encode(buf)?;
        let len = self.ingredients.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.ingredients {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let times_crafted_2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let ingredients = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                );
            }
            tmp_vec
        };
        Ok(Self {
            recipe_network_id,
            times_crafted_2,
            times_crafted,
            ingredients,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentCreate {
    pub result_slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentCreate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.result_slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let result_slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { result_slot_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentDrop {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub randomly: bool,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentDrop {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.randomly.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source =
            <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let randomly = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            count,
            source,
            randomly,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentMineBlock {
    pub hotbar_slot: i32,
    pub predicted_durability: i32,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentMineBlock {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.predicted_durability).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let hotbar_slot =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let predicted_durability =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let network_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            hotbar_slot,
            predicted_durability,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentOptional {
    pub recipe_network_id: i32,
    pub filtered_string_index: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentOptional {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.recipe_network_id).encode(buf)?;
        crate::bedrock::codec::I32LE(self.filtered_string_index).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let filtered_string_index =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            recipe_network_id,
            filtered_string_index,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentPlace {
    pub count: u8,
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentPlace {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.count.encode(buf)?;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source =
            <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let destination =
            <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            count,
            source,
            destination,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentResultsDeprecated {
    pub result_items: Vec<ItemLegacy>,
    pub times_crafted: u8,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestActionsItemContentResultsDeprecatedArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
    for ItemStackRequestActionsItemContentResultsDeprecatedArgs
{
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentResultsDeprecated {
    type Args = ItemStackRequestActionsItemContentResultsDeprecatedArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.result_items.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result_items {
            item.encode(buf)?;
        }
        self.times_crafted.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let result_items = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    ItemLegacyArgs {
                        shield_item_id: args.shield_item_id,
                    },
                )?);
            }
            tmp_vec
        };
        let times_crafted = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            result_items,
            times_crafted,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItemContentSwap {
    pub source: StackRequestSlotInfo,
    pub destination: StackRequestSlotInfo,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItemContentSwap {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.source.encode(buf)?;
        self.destination.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let source =
            <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let destination =
            <StackRequestSlotInfo as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            source,
            destination,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ItemStackRequestActionsItemContent {
    BeaconPayment(ItemStackRequestActionsItemContentBeaconPayment),
    Consume(ItemStackRequestActionsItemContentConsume),
    CraftCreative(ItemStackRequestActionsItemContentCraftCreative),
    CraftGrindstoneRequest(ItemStackRequestActionsItemContentCraftGrindstoneRequest),
    CraftLoomRequest(ItemStackRequestActionsItemContentCraftLoomRequest),
    CraftRecipe(ItemStackRequestActionsItemContentCraftRecipe),
    CraftRecipeAuto(Box<ItemStackRequestActionsItemContentCraftRecipeAuto>),
    Create(ItemStackRequestActionsItemContentCreate),
    Destroy(ItemStackRequestActionsItemContentConsume),
    Drop(ItemStackRequestActionsItemContentDrop),
    MineBlock(ItemStackRequestActionsItemContentMineBlock),
    NonImplemented,
    Optional(ItemStackRequestActionsItemContentOptional),
    Place(ItemStackRequestActionsItemContentPlace),
    PlaceInContainer(ItemStackRequestActionsItemContentPlace),
    ResultsDeprecated(ItemStackRequestActionsItemContentResultsDeprecated),
    Swap(ItemStackRequestActionsItemContentSwap),
    Take(ItemStackRequestActionsItemContentPlace),
    TakeOutContainer(ItemStackRequestActionsItemContentPlace),
}
impl Default for ItemStackRequestActionsItemContent {
    fn default() -> Self {
        Self::BeaconPayment(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestActionsItem {
    pub type_id: ItemStackRequestActionsItemTypeId,
    pub content: Option<ItemStackRequestActionsItemContent>,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestActionsItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemStackRequestActionsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestActionsItem {
    type Args = ItemStackRequestActionsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_id.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ItemStackRequestActionsItemContent::BeaconPayment(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Consume(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftCreative(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftGrindstoneRequest(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftLoomRequest(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftRecipe(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::CraftRecipeAuto(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Create(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Destroy(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Drop(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::MineBlock(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::NonImplemented => {}
                ItemStackRequestActionsItemContent::Optional(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Place(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::PlaceInContainer(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::ResultsDeprecated(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Swap(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::Take(v) => {
                    v.encode(buf)?;
                }
                ItemStackRequestActionsItemContent::TakeOutContainer(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_id =
            <ItemStackRequestActionsItemTypeId as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let content = match type_id {
            ItemStackRequestActionsItemTypeId::BeaconPayment => {
                Some(
                    ItemStackRequestActionsItemContent::BeaconPayment(
                        <ItemStackRequestActionsItemContentBeaconPayment as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Consume => {
                Some(
                    ItemStackRequestActionsItemContent::Consume(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftCreative => {
                Some(
                    ItemStackRequestActionsItemContent::CraftCreative(
                        <ItemStackRequestActionsItemContentCraftCreative as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftGrindstoneRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftGrindstoneRequest(
                        <ItemStackRequestActionsItemContentCraftGrindstoneRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftLoomRequest => {
                Some(
                    ItemStackRequestActionsItemContent::CraftLoomRequest(
                        <ItemStackRequestActionsItemContentCraftLoomRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftRecipe => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipe(
                        <ItemStackRequestActionsItemContentCraftRecipe as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::CraftRecipeAuto => {
                Some(
                    ItemStackRequestActionsItemContent::CraftRecipeAuto(
                        Box::new(
                            <ItemStackRequestActionsItemContentCraftRecipeAuto as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Create => {
                Some(
                    ItemStackRequestActionsItemContent::Create(
                        <ItemStackRequestActionsItemContentCreate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Destroy => {
                Some(
                    ItemStackRequestActionsItemContent::Destroy(
                        <ItemStackRequestActionsItemContentConsume as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Drop => {
                Some(
                    ItemStackRequestActionsItemContent::Drop(
                        <ItemStackRequestActionsItemContentDrop as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::MineBlock => {
                Some(
                    ItemStackRequestActionsItemContent::MineBlock(
                        <ItemStackRequestActionsItemContentMineBlock as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::NonImplemented => {
                Some(ItemStackRequestActionsItemContent::NonImplemented)
            }
            ItemStackRequestActionsItemTypeId::Optional => {
                Some(
                    ItemStackRequestActionsItemContent::Optional(
                        <ItemStackRequestActionsItemContentOptional as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Place => {
                Some(
                    ItemStackRequestActionsItemContent::Place(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::PlaceInContainer => {
                Some(
                    ItemStackRequestActionsItemContent::PlaceInContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::ResultsDeprecated => {
                Some(
                    ItemStackRequestActionsItemContent::ResultsDeprecated(
                        <ItemStackRequestActionsItemContentResultsDeprecated as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemStackRequestActionsItemContentResultsDeprecatedArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Swap => {
                Some(
                    ItemStackRequestActionsItemContent::Swap(
                        <ItemStackRequestActionsItemContentSwap as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::Take => {
                Some(
                    ItemStackRequestActionsItemContent::Take(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ItemStackRequestActionsItemTypeId::TakeOutContainer => {
                Some(
                    ItemStackRequestActionsItemContent::TakeOutContainer(
                        <ItemStackRequestActionsItemContentPlace as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { type_id, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ItemStackRequestCause {
    ChatPublic = 0,
    ChatWhisper = 1,
    SignText = 2,
    AnvilText = 3,
    BookAndQuillText = 4,
    CommandBlockText = 5,
    BlockActorDataText = 6,
    JoinEventText = 7,
    LeaveEventText = 8,
    SlashCommandChat = 9,
    CartographyText = 10,
    KickCommand = 11,
    TitleCommand = 12,
    SummonCommand = 13,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestCause {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ItemStackRequestCause::ChatPublic),
            1 => Ok(ItemStackRequestCause::ChatWhisper),
            2 => Ok(ItemStackRequestCause::SignText),
            3 => Ok(ItemStackRequestCause::AnvilText),
            4 => Ok(ItemStackRequestCause::BookAndQuillText),
            5 => Ok(ItemStackRequestCause::CommandBlockText),
            6 => Ok(ItemStackRequestCause::BlockActorDataText),
            7 => Ok(ItemStackRequestCause::JoinEventText),
            8 => Ok(ItemStackRequestCause::LeaveEventText),
            9 => Ok(ItemStackRequestCause::SlashCommandChat),
            10 => Ok(ItemStackRequestCause::CartographyText),
            11 => Ok(ItemStackRequestCause::KickCommand),
            12 => Ok(ItemStackRequestCause::TitleCommand),
            13 => Ok(ItemStackRequestCause::SummonCommand),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ItemStackRequestCause),
                value: val as i64,
            }),
        }
    }
}
impl Default for ItemStackRequestCause {
    fn default() -> Self {
        Self::ChatPublic
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequest {
    pub request_id: i32,
    pub actions: Vec<ItemStackRequestActionsItem>,
    pub custom_names: Vec<String>,
    pub cause: ItemStackRequestCause,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for ItemStackRequestArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequest {
    type Args = ItemStackRequestArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.request_id).encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        let len = self.custom_names.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.custom_names {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        self.cause.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let request_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let actions = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <ItemStackRequestActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        ItemStackRequestActionsItemArgs {
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                );
            }
            tmp_vec
        };
        let custom_names = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let cause =
            <ItemStackRequestCause as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            request_id,
            actions,
            custom_names,
            cause,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ItemStackResponsesItemStatus {
    Ok = 0,
    Error = 1,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ItemStackResponsesItemStatus::Ok),
            1 => Ok(ItemStackResponsesItemStatus::Error),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ItemStackResponsesItemStatus),
                value: val as i64,
            }),
        }
    }
}
impl Default for ItemStackResponsesItemStatus {
    fn default() -> Self {
        Self::Ok
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackResponsesItemContentContainersItemSlotsItem {
    pub slot: u8,
    pub hotbar_slot: u8,
    pub count: u8,
    pub item_stack_id: i32,
    pub custom_name: String,
    pub filtered_custom_name: String,
    pub durability_correction: i32,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContentContainersItemSlotsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.slot.encode(buf)?;
        self.hotbar_slot.encode(buf)?;
        self.count.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.item_stack_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.custom_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.custom_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.filtered_custom_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.filtered_custom_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.durability_correction).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let hotbar_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let item_stack_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let custom_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let filtered_custom_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let durability_correction =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            slot,
            hotbar_slot,
            count,
            item_stack_id,
            custom_name,
            filtered_custom_name,
            durability_correction,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackResponsesItemContentContainersItem {
    pub slot_type: FullContainerName,
    pub slots: Vec<ItemStackResponsesItemContentContainersItemSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContentContainersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.slot_type.encode(buf)?;
        let len = self.slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let slot_type =
            <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let slots = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentContainersItemSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { slot_type, slots })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackResponsesItemContent {
    pub containers: Vec<ItemStackResponsesItemContentContainersItem>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let containers = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackResponsesItemContentContainersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { containers })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackResponsesItem {
    pub status: ItemStackResponsesItemStatus,
    pub request_id: i32,
    pub content: Option<ItemStackResponsesItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.status.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.request_id).encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let status =
            <ItemStackResponsesItemStatus as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let request_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let content = match status {
            ItemStackResponsesItemStatus::Ok => Some(
                <ItemStackResponsesItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            ),
            _ => None,
        };
        Ok(Self {
            status,
            request_id,
            content,
        })
    }
}
pub type ItemStackResponses = Vec<ItemStackResponsesItem>;
pub type ItemStacks = Vec<Item>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ItemstatesItemVersion {
    Legacy = 0,
    DataDriven = 1,
    None = 2,
}
impl crate::bedrock::codec::BedrockCodec for ItemstatesItemVersion {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ItemstatesItemVersion::Legacy),
            1 => Ok(ItemstatesItemVersion::DataDriven),
            2 => Ok(ItemstatesItemVersion::None),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ItemstatesItemVersion),
                value: val as i64,
            }),
        }
    }
}
impl Default for ItemstatesItemVersion {
    fn default() -> Self {
        Self::Legacy
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemstatesItem {
    pub name: String,
    pub runtime_id: i16,
    pub component_based: bool,
    pub version: ItemstatesItemVersion,
    pub nbt: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for ItemstatesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I16LE(self.runtime_id).encode(buf)?;
        self.component_based.encode(buf)?;
        self.version.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let runtime_id =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let component_based = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version =
            <ItemstatesItemVersion as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt =
            <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            name,
            runtime_id,
            component_based,
            version,
            nbt,
        })
    }
}
pub type Itemstates = Vec<ItemstatesItem>;
pub type LatinString = String;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum LegacyEntityType {
    Chicken = 10,
    Cow = 11,
    Pig = 12,
    Sheep = 13,
    Wolf = 14,
    Villager = 15,
    Mooshroom = 16,
    Squid = 17,
    Rabbit = 18,
    Bat = 19,
    IronGolem = 20,
    SnowGolem = 21,
    Ocelot = 22,
    Horse = 23,
    Donkey = 24,
    Mule = 25,
    SkeletonHorse = 26,
    ZombieHorse = 27,
    PolarBear = 28,
    Llama = 29,
    Parrot = 30,
    Dolphin = 31,
    Zombie = 32,
    Creeper = 33,
    Skeleton = 34,
    Spider = 35,
    ZombiePigman = 36,
    Slime = 37,
    Enderman = 38,
    Silverfish = 39,
    CaveSpider = 40,
    Ghast = 41,
    MagmaCube = 42,
    Blaze = 43,
    ZombieVillager = 44,
    Witch = 45,
    Stray = 46,
    Husk = 47,
    WitherSkeleton = 48,
    Guardian = 49,
    ElderGuardian = 50,
    Npc = 51,
    Wither = 52,
    EnderDragon = 53,
    Shulker = 54,
    Endermite = 55,
    Agent = 56,
    Vindicator = 57,
    Phantom = 58,
    ArmorStand = 61,
    TripodCamera = 62,
    Player = 63,
    Item = 64,
    Tnt = 65,
    FallingBlock = 66,
    MovingBlock = 67,
    XpBottle = 68,
    XpOrb = 69,
    EyeOfEnderSignal = 70,
    EnderCrystal = 71,
    FireworksRocket = 72,
    ThrownTrident = 73,
    Turtle = 74,
    Cat = 75,
    ShulkerBullet = 76,
    FishingHook = 77,
    Chalkboard = 78,
    DragonFireball = 79,
    Arrow = 80,
    Snowball = 81,
    Egg = 82,
    Painting = 83,
    Minecart = 84,
    Fireball = 85,
    SplashPotion = 86,
    EnderPearl = 87,
    LeashKnot = 88,
    WitherSkull = 89,
    Boat = 90,
    WitherSkullDangerous = 91,
    LightningBolt = 93,
    SmallFireball = 94,
    AreaEffectCloud = 95,
    HopperMinecart = 96,
    TntMinecart = 97,
    ChestMinecart = 98,
    CommandBlockMinecart = 100,
    LingeringPotion = 101,
    LlamaSpit = 102,
    EvocationFang = 103,
    EvocationIllager = 104,
    Vex = 105,
    IceBomb = 106,
    Balloon = 107,
    Pufferfish = 108,
    Salmon = 109,
    Drowned = 110,
    Tropicalfish = 111,
    Cod = 112,
    Panda = 113,
}
impl crate::bedrock::codec::BedrockCodec for LegacyEntityType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            10 => Ok(LegacyEntityType::Chicken),
            11 => Ok(LegacyEntityType::Cow),
            12 => Ok(LegacyEntityType::Pig),
            13 => Ok(LegacyEntityType::Sheep),
            14 => Ok(LegacyEntityType::Wolf),
            15 => Ok(LegacyEntityType::Villager),
            16 => Ok(LegacyEntityType::Mooshroom),
            17 => Ok(LegacyEntityType::Squid),
            18 => Ok(LegacyEntityType::Rabbit),
            19 => Ok(LegacyEntityType::Bat),
            20 => Ok(LegacyEntityType::IronGolem),
            21 => Ok(LegacyEntityType::SnowGolem),
            22 => Ok(LegacyEntityType::Ocelot),
            23 => Ok(LegacyEntityType::Horse),
            24 => Ok(LegacyEntityType::Donkey),
            25 => Ok(LegacyEntityType::Mule),
            26 => Ok(LegacyEntityType::SkeletonHorse),
            27 => Ok(LegacyEntityType::ZombieHorse),
            28 => Ok(LegacyEntityType::PolarBear),
            29 => Ok(LegacyEntityType::Llama),
            30 => Ok(LegacyEntityType::Parrot),
            31 => Ok(LegacyEntityType::Dolphin),
            32 => Ok(LegacyEntityType::Zombie),
            33 => Ok(LegacyEntityType::Creeper),
            34 => Ok(LegacyEntityType::Skeleton),
            35 => Ok(LegacyEntityType::Spider),
            36 => Ok(LegacyEntityType::ZombiePigman),
            37 => Ok(LegacyEntityType::Slime),
            38 => Ok(LegacyEntityType::Enderman),
            39 => Ok(LegacyEntityType::Silverfish),
            40 => Ok(LegacyEntityType::CaveSpider),
            41 => Ok(LegacyEntityType::Ghast),
            42 => Ok(LegacyEntityType::MagmaCube),
            43 => Ok(LegacyEntityType::Blaze),
            44 => Ok(LegacyEntityType::ZombieVillager),
            45 => Ok(LegacyEntityType::Witch),
            46 => Ok(LegacyEntityType::Stray),
            47 => Ok(LegacyEntityType::Husk),
            48 => Ok(LegacyEntityType::WitherSkeleton),
            49 => Ok(LegacyEntityType::Guardian),
            50 => Ok(LegacyEntityType::ElderGuardian),
            51 => Ok(LegacyEntityType::Npc),
            52 => Ok(LegacyEntityType::Wither),
            53 => Ok(LegacyEntityType::EnderDragon),
            54 => Ok(LegacyEntityType::Shulker),
            55 => Ok(LegacyEntityType::Endermite),
            56 => Ok(LegacyEntityType::Agent),
            57 => Ok(LegacyEntityType::Vindicator),
            58 => Ok(LegacyEntityType::Phantom),
            61 => Ok(LegacyEntityType::ArmorStand),
            62 => Ok(LegacyEntityType::TripodCamera),
            63 => Ok(LegacyEntityType::Player),
            64 => Ok(LegacyEntityType::Item),
            65 => Ok(LegacyEntityType::Tnt),
            66 => Ok(LegacyEntityType::FallingBlock),
            67 => Ok(LegacyEntityType::MovingBlock),
            68 => Ok(LegacyEntityType::XpBottle),
            69 => Ok(LegacyEntityType::XpOrb),
            70 => Ok(LegacyEntityType::EyeOfEnderSignal),
            71 => Ok(LegacyEntityType::EnderCrystal),
            72 => Ok(LegacyEntityType::FireworksRocket),
            73 => Ok(LegacyEntityType::ThrownTrident),
            74 => Ok(LegacyEntityType::Turtle),
            75 => Ok(LegacyEntityType::Cat),
            76 => Ok(LegacyEntityType::ShulkerBullet),
            77 => Ok(LegacyEntityType::FishingHook),
            78 => Ok(LegacyEntityType::Chalkboard),
            79 => Ok(LegacyEntityType::DragonFireball),
            80 => Ok(LegacyEntityType::Arrow),
            81 => Ok(LegacyEntityType::Snowball),
            82 => Ok(LegacyEntityType::Egg),
            83 => Ok(LegacyEntityType::Painting),
            84 => Ok(LegacyEntityType::Minecart),
            85 => Ok(LegacyEntityType::Fireball),
            86 => Ok(LegacyEntityType::SplashPotion),
            87 => Ok(LegacyEntityType::EnderPearl),
            88 => Ok(LegacyEntityType::LeashKnot),
            89 => Ok(LegacyEntityType::WitherSkull),
            90 => Ok(LegacyEntityType::Boat),
            91 => Ok(LegacyEntityType::WitherSkullDangerous),
            93 => Ok(LegacyEntityType::LightningBolt),
            94 => Ok(LegacyEntityType::SmallFireball),
            95 => Ok(LegacyEntityType::AreaEffectCloud),
            96 => Ok(LegacyEntityType::HopperMinecart),
            97 => Ok(LegacyEntityType::TntMinecart),
            98 => Ok(LegacyEntityType::ChestMinecart),
            100 => Ok(LegacyEntityType::CommandBlockMinecart),
            101 => Ok(LegacyEntityType::LingeringPotion),
            102 => Ok(LegacyEntityType::LlamaSpit),
            103 => Ok(LegacyEntityType::EvocationFang),
            104 => Ok(LegacyEntityType::EvocationIllager),
            105 => Ok(LegacyEntityType::Vex),
            106 => Ok(LegacyEntityType::IceBomb),
            107 => Ok(LegacyEntityType::Balloon),
            108 => Ok(LegacyEntityType::Pufferfish),
            109 => Ok(LegacyEntityType::Salmon),
            110 => Ok(LegacyEntityType::Drowned),
            111 => Ok(LegacyEntityType::Tropicalfish),
            112 => Ok(LegacyEntityType::Cod),
            113 => Ok(LegacyEntityType::Panda),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(LegacyEntityType),
                value: val as i64,
            }),
        }
    }
}
impl Default for LegacyEntityType {
    fn default() -> Self {
        Self::Chicken
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Link {
    pub ridden_entity_id: i64,
    pub rider_entity_id: i64,
    pub type_: u8,
    pub immediate: bool,
    pub rider_initiated: bool,
    pub angular_velocity: f32,
}
impl crate::bedrock::codec::BedrockCodec for Link {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.ridden_entity_id).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.rider_entity_id).encode(buf)?;
        self.type_.encode(buf)?;
        self.immediate.encode(buf)?;
        self.rider_initiated.encode(buf)?;
        crate::bedrock::codec::F32LE(self.angular_velocity).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let ridden_entity_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let rider_entity_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let immediate = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rider_initiated = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let angular_velocity =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            ridden_entity_id,
            rider_entity_id,
            type_,
            immediate,
            rider_initiated,
            angular_velocity,
        })
    }
}
pub type Links = Vec<Link>;
#[derive(Debug, Clone, PartialEq)]
pub struct LittleString(pub String);
impl From<LittleString> for String {
    fn from(value: LittleString) -> Self {
        value.0
    }
}
impl std::ops::Deref for LittleString {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl AsRef<str> for LittleString {
    fn as_ref(&self) -> &str {
        &self.0
    }
}
impl AsRef<[u8]> for LittleString {
    fn as_ref(&self) -> &[u8] {
        self.0.as_bytes()
    }
}
impl crate::bedrock::codec::BedrockCodec for LittleString {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let bytes = self.0.as_bytes();
        let len = bytes.len() as u32;
        crate::bedrock::codec::U32LE(len).encode(buf)?;
        buf.put_slice(bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let len_raw =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let len = len_raw as usize;
        if buf.remaining() < len {
            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                declared: len,
                available: buf.remaining(),
            });
        }
        let mut v = vec![0u8; len];
        buf.copy_to_slice(&mut v);
        Ok(LittleString(String::from_utf8_lossy(&v).into_owned()))
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LoginTokens {
    pub identity: String,
    pub client: String,
}
impl crate::bedrock::codec::BedrockCodec for LoginTokens {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        LittleString((self.identity).clone()).encode(buf)?;
        LittleString((self.client).clone()).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let identity = {
            let tmp = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
            tmp.0
        };
        let client = {
            let tmp = <LittleString as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
            tmp.0
        };
        Ok(Self { identity, client })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum MapDecorationType {
    MarkerWhite = 0,
    MarkerGreen = 1,
    MarkerRed = 2,
    MarkerBlue = 3,
    CrossWhite = 4,
    TriangleRed = 5,
    SquareWhite = 6,
    MarkerSign = 7,
    MarkerPink = 8,
    MarkerOrange = 9,
    MarkerYellow = 10,
    MarkerTeal = 11,
    TriangleGreen = 12,
    SmallSquareWhite = 13,
    Mansion = 14,
    Monument = 15,
    NoDraw = 16,
    VillageDesert = 17,
    VillagePlains = 18,
    VillageSavanna = 19,
    VillageSnowy = 20,
    VillageTaiga = 21,
    JungleTemple = 22,
    WitchHut = 23,
    MarkerWhite24 = 24,
    MarkerGreen25 = 25,
    MarkerRed26 = 26,
    MarkerBlue27 = 27,
    CrossWhite28 = 28,
    TriangleRed29 = 29,
    SquareWhite30 = 30,
    MarkerSign31 = 31,
    MarkerPink32 = 32,
    MarkerOrange33 = 33,
    MarkerYellow34 = 34,
    MarkerTeal35 = 35,
    TriangleGreen36 = 36,
    SmallSquareWhite37 = 37,
    Mansion38 = 38,
    Monument39 = 39,
    NoDraw40 = 40,
    VillageDesert41 = 41,
    VillagePlains42 = 42,
    VillageSavanna43 = 43,
    VillageSnowy44 = 44,
    VillageTaiga45 = 45,
    JungleTemple46 = 46,
    WitchHut47 = 47,
}
impl crate::bedrock::codec::BedrockCodec for MapDecorationType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MapDecorationType::MarkerWhite),
            1 => Ok(MapDecorationType::MarkerGreen),
            2 => Ok(MapDecorationType::MarkerRed),
            3 => Ok(MapDecorationType::MarkerBlue),
            4 => Ok(MapDecorationType::CrossWhite),
            5 => Ok(MapDecorationType::TriangleRed),
            6 => Ok(MapDecorationType::SquareWhite),
            7 => Ok(MapDecorationType::MarkerSign),
            8 => Ok(MapDecorationType::MarkerPink),
            9 => Ok(MapDecorationType::MarkerOrange),
            10 => Ok(MapDecorationType::MarkerYellow),
            11 => Ok(MapDecorationType::MarkerTeal),
            12 => Ok(MapDecorationType::TriangleGreen),
            13 => Ok(MapDecorationType::SmallSquareWhite),
            14 => Ok(MapDecorationType::Mansion),
            15 => Ok(MapDecorationType::Monument),
            16 => Ok(MapDecorationType::NoDraw),
            17 => Ok(MapDecorationType::VillageDesert),
            18 => Ok(MapDecorationType::VillagePlains),
            19 => Ok(MapDecorationType::VillageSavanna),
            20 => Ok(MapDecorationType::VillageSnowy),
            21 => Ok(MapDecorationType::VillageTaiga),
            22 => Ok(MapDecorationType::JungleTemple),
            23 => Ok(MapDecorationType::WitchHut),
            24 => Ok(MapDecorationType::MarkerWhite),
            25 => Ok(MapDecorationType::MarkerGreen),
            26 => Ok(MapDecorationType::MarkerRed),
            27 => Ok(MapDecorationType::MarkerBlue),
            28 => Ok(MapDecorationType::CrossWhite),
            29 => Ok(MapDecorationType::TriangleRed),
            30 => Ok(MapDecorationType::SquareWhite),
            31 => Ok(MapDecorationType::MarkerSign),
            32 => Ok(MapDecorationType::MarkerPink),
            33 => Ok(MapDecorationType::MarkerOrange),
            34 => Ok(MapDecorationType::MarkerYellow),
            35 => Ok(MapDecorationType::MarkerTeal),
            36 => Ok(MapDecorationType::TriangleGreen),
            37 => Ok(MapDecorationType::SmallSquareWhite),
            38 => Ok(MapDecorationType::Mansion),
            39 => Ok(MapDecorationType::Monument),
            40 => Ok(MapDecorationType::NoDraw),
            41 => Ok(MapDecorationType::VillageDesert),
            42 => Ok(MapDecorationType::VillagePlains),
            43 => Ok(MapDecorationType::VillageSavanna),
            44 => Ok(MapDecorationType::VillageSnowy),
            45 => Ok(MapDecorationType::VillageTaiga),
            46 => Ok(MapDecorationType::JungleTemple),
            47 => Ok(MapDecorationType::WitchHut),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MapDecorationType),
                value: val as i64,
            }),
        }
    }
}
impl Default for MapDecorationType {
    fn default() -> Self {
        Self::MarkerWhite
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MapDecoration {
    pub type_: MapDecorationType,
    pub rotation: u8,
    pub x: u8,
    pub y: u8,
    pub label: String,
    pub color_abgr: i32,
}
impl crate::bedrock::codec::BedrockCodec for MapDecoration {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        self.rotation.encode(buf)?;
        self.x.encode(buf)?;
        self.y.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.label)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.label).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::VarInt(self.color_abgr).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <MapDecorationType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let x = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let y = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let label = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let color_abgr =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            type_,
            rotation,
            x,
            y,
            label,
            color_abgr,
        })
    }
}
pub type MapInfo = Vec<u8>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MaterialReducerItems {
    pub network_id: i32,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for MaterialReducerItems {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.network_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.count).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let network_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let count =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { network_id, count })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MaterialReducer {
    pub mix: i32,
    pub items: MaterialReducerItems,
}
impl crate::bedrock::codec::BedrockCodec for MaterialReducer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.mix).encode(buf)?;
        self.items.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let mix = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let items = <MaterialReducerItems as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { mix, items })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemKey {
    Flags = 0,
    Health = 1,
    Variant = 2,
    Color = 3,
    Nametag = 4,
    OwnerEid = 5,
    TargetEid = 6,
    Air = 7,
    PotionColor = 8,
    PotionAmbient = 9,
    JumpDuration = 10,
    HurtTime = 11,
    HurtDirection = 12,
    PaddleTimeLeft = 13,
    PaddleTimeRight = 14,
    ExperienceValue = 15,
    MinecartDisplayBlock = 16,
    MinecartDisplayOffset = 17,
    MinecartHasDisplay = 18,
    HorseType = 19,
    CreeperSwell = 20,
    CreeperSwellDirection = 21,
    ChargeAmount = 22,
    EndermanHeldRuntimeId = 23,
    EntityAge = 24,
    PlayerFlags = 26,
    PlayerIndex = 27,
    PlayerBedPosition = 28,
    FireballPowerX = 29,
    FireballPowerY = 30,
    FireballPowerZ = 31,
    AuxPower = 32,
    FishX = 33,
    FishZ = 34,
    FishAngle = 35,
    PotionAuxValue = 36,
    LeadHolderEid = 37,
    Scale = 38,
    InteractiveTag = 39,
    NpcSkinId = 40,
    UrlTag = 41,
    MaxAirdataMaxAir = 42,
    MarkVariant = 43,
    ContainerType = 44,
    ContainerBaseSize = 45,
    ContainerExtraSlotsPerStrength = 46,
    BlockTarget = 47,
    WitherInvulnerableTicks = 48,
    WitherTarget1 = 49,
    WitherTarget2 = 50,
    WitherTarget3 = 51,
    WitherAerialAttack = 52,
    BoundingboxWidth = 53,
    BoundingboxHeight = 54,
    FuseLength = 55,
    RiderSeatPosition = 56,
    RiderRotationLocked = 57,
    RiderMaxRotation = 58,
    RiderMinRotation = 59,
    RiderSeatRotationOffset = 60,
    AreaEffectCloudRadius = 61,
    AreaEffectCloudWaiting = 62,
    AreaEffectCloudParticleId = 63,
    ShulkerPeekId = 64,
    ShulkerAttachFace = 65,
    ShulkerAttached = 66,
    ShulkerAttachPos = 67,
    TradingPlayerEid = 68,
    TradingCareer = 69,
    HasCommandBlock = 70,
    CommandBlockCommand = 71,
    CommandBlockLastOutput = 72,
    CommandBlockTrackOutput = 73,
    ControllingRiderSeatNumber = 74,
    Strength = 75,
    MaxStrength = 76,
    EvokerSpellCastingColor = 77,
    LimitedLife = 78,
    ArmorStandPoseIndex = 79,
    EnderCrystalTimeOffset = 80,
    AlwaysShowNametag = 81,
    Color2 = 82,
    NameAuthor = 83,
    ScoreTag = 84,
    BalloonAttachedEntity = 85,
    PufferfishSize = 86,
    BubbleTime = 87,
    Agent = 88,
    SittingAmount = 89,
    SittingAmountPrevious = 90,
    EatingCounter = 91,
    FlagsExtended = 92,
    LayingAmount = 93,
    LayingAmountPrevious = 94,
    AreaEffectCloudDuration = 95,
    AreaEffectCloudSpawnTime = 96,
    AreaEffectCloudChangeRate = 97,
    AreaEffectCloudChangeOnPickup = 98,
    AreaEffectCloudPickupCount = 99,
    InteractText = 100,
    TradeTier = 101,
    MaxTradeTier = 102,
    TradeExperience = 103,
    SkinId = 104,
    SpawningFrames = 105,
    CommandBlockTickDelay = 106,
    CommandBlockExecuteOnFirstTick = 107,
    AmbientSoundInterval = 108,
    AmbientSoundIntervalRange = 109,
    AmbientSoundEventName = 110,
    FallDamageMultiplier = 111,
    NameRawText = 112,
    CanRideTarget = 113,
    LowTierCuredDiscount = 114,
    HighTierCuredDiscount = 115,
    NearbyCuredDiscount = 116,
    NearbyCuredDiscountTimestamp = 117,
    Hitbox = 118,
    IsBuoyant = 119,
    FreezingEffectStrength = 120,
    BuoyancyData = 121,
    GoatHornCount = 122,
    UpdateProperties = 123,
    MovementSoundDistanceOffset = 124,
    HeartbeatIntervalTicks = 125,
    HeartbeatSoundEvent = 126,
    PlayerLastDeathPosition = 127,
    PlayerLastDeathDimension = 128,
    PlayerHasDied = 129,
    CollisionBox = 130,
    VisibleMobEffects = 131,
    FilteredName = 132,
    BedEnterPosition = 133,
    SeatThirdPersonCameraRadius = 134,
    SeatCameraRelaxDistanceSmoothing = 135,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemKey {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(MetadataDictionaryItemKey::Flags),
            1 => Ok(MetadataDictionaryItemKey::Health),
            2 => Ok(MetadataDictionaryItemKey::Variant),
            3 => Ok(MetadataDictionaryItemKey::Color),
            4 => Ok(MetadataDictionaryItemKey::Nametag),
            5 => Ok(MetadataDictionaryItemKey::OwnerEid),
            6 => Ok(MetadataDictionaryItemKey::TargetEid),
            7 => Ok(MetadataDictionaryItemKey::Air),
            8 => Ok(MetadataDictionaryItemKey::PotionColor),
            9 => Ok(MetadataDictionaryItemKey::PotionAmbient),
            10 => Ok(MetadataDictionaryItemKey::JumpDuration),
            11 => Ok(MetadataDictionaryItemKey::HurtTime),
            12 => Ok(MetadataDictionaryItemKey::HurtDirection),
            13 => Ok(MetadataDictionaryItemKey::PaddleTimeLeft),
            14 => Ok(MetadataDictionaryItemKey::PaddleTimeRight),
            15 => Ok(MetadataDictionaryItemKey::ExperienceValue),
            16 => Ok(MetadataDictionaryItemKey::MinecartDisplayBlock),
            17 => Ok(MetadataDictionaryItemKey::MinecartDisplayOffset),
            18 => Ok(MetadataDictionaryItemKey::MinecartHasDisplay),
            19 => Ok(MetadataDictionaryItemKey::HorseType),
            20 => Ok(MetadataDictionaryItemKey::CreeperSwell),
            21 => Ok(MetadataDictionaryItemKey::CreeperSwellDirection),
            22 => Ok(MetadataDictionaryItemKey::ChargeAmount),
            23 => Ok(MetadataDictionaryItemKey::EndermanHeldRuntimeId),
            24 => Ok(MetadataDictionaryItemKey::EntityAge),
            26 => Ok(MetadataDictionaryItemKey::PlayerFlags),
            27 => Ok(MetadataDictionaryItemKey::PlayerIndex),
            28 => Ok(MetadataDictionaryItemKey::PlayerBedPosition),
            29 => Ok(MetadataDictionaryItemKey::FireballPowerX),
            30 => Ok(MetadataDictionaryItemKey::FireballPowerY),
            31 => Ok(MetadataDictionaryItemKey::FireballPowerZ),
            32 => Ok(MetadataDictionaryItemKey::AuxPower),
            33 => Ok(MetadataDictionaryItemKey::FishX),
            34 => Ok(MetadataDictionaryItemKey::FishZ),
            35 => Ok(MetadataDictionaryItemKey::FishAngle),
            36 => Ok(MetadataDictionaryItemKey::PotionAuxValue),
            37 => Ok(MetadataDictionaryItemKey::LeadHolderEid),
            38 => Ok(MetadataDictionaryItemKey::Scale),
            39 => Ok(MetadataDictionaryItemKey::InteractiveTag),
            40 => Ok(MetadataDictionaryItemKey::NpcSkinId),
            41 => Ok(MetadataDictionaryItemKey::UrlTag),
            42 => Ok(MetadataDictionaryItemKey::MaxAirdataMaxAir),
            43 => Ok(MetadataDictionaryItemKey::MarkVariant),
            44 => Ok(MetadataDictionaryItemKey::ContainerType),
            45 => Ok(MetadataDictionaryItemKey::ContainerBaseSize),
            46 => Ok(MetadataDictionaryItemKey::ContainerExtraSlotsPerStrength),
            47 => Ok(MetadataDictionaryItemKey::BlockTarget),
            48 => Ok(MetadataDictionaryItemKey::WitherInvulnerableTicks),
            49 => Ok(MetadataDictionaryItemKey::WitherTarget1),
            50 => Ok(MetadataDictionaryItemKey::WitherTarget2),
            51 => Ok(MetadataDictionaryItemKey::WitherTarget3),
            52 => Ok(MetadataDictionaryItemKey::WitherAerialAttack),
            53 => Ok(MetadataDictionaryItemKey::BoundingboxWidth),
            54 => Ok(MetadataDictionaryItemKey::BoundingboxHeight),
            55 => Ok(MetadataDictionaryItemKey::FuseLength),
            56 => Ok(MetadataDictionaryItemKey::RiderSeatPosition),
            57 => Ok(MetadataDictionaryItemKey::RiderRotationLocked),
            58 => Ok(MetadataDictionaryItemKey::RiderMaxRotation),
            59 => Ok(MetadataDictionaryItemKey::RiderMinRotation),
            60 => Ok(MetadataDictionaryItemKey::RiderSeatRotationOffset),
            61 => Ok(MetadataDictionaryItemKey::AreaEffectCloudRadius),
            62 => Ok(MetadataDictionaryItemKey::AreaEffectCloudWaiting),
            63 => Ok(MetadataDictionaryItemKey::AreaEffectCloudParticleId),
            64 => Ok(MetadataDictionaryItemKey::ShulkerPeekId),
            65 => Ok(MetadataDictionaryItemKey::ShulkerAttachFace),
            66 => Ok(MetadataDictionaryItemKey::ShulkerAttached),
            67 => Ok(MetadataDictionaryItemKey::ShulkerAttachPos),
            68 => Ok(MetadataDictionaryItemKey::TradingPlayerEid),
            69 => Ok(MetadataDictionaryItemKey::TradingCareer),
            70 => Ok(MetadataDictionaryItemKey::HasCommandBlock),
            71 => Ok(MetadataDictionaryItemKey::CommandBlockCommand),
            72 => Ok(MetadataDictionaryItemKey::CommandBlockLastOutput),
            73 => Ok(MetadataDictionaryItemKey::CommandBlockTrackOutput),
            74 => Ok(MetadataDictionaryItemKey::ControllingRiderSeatNumber),
            75 => Ok(MetadataDictionaryItemKey::Strength),
            76 => Ok(MetadataDictionaryItemKey::MaxStrength),
            77 => Ok(MetadataDictionaryItemKey::EvokerSpellCastingColor),
            78 => Ok(MetadataDictionaryItemKey::LimitedLife),
            79 => Ok(MetadataDictionaryItemKey::ArmorStandPoseIndex),
            80 => Ok(MetadataDictionaryItemKey::EnderCrystalTimeOffset),
            81 => Ok(MetadataDictionaryItemKey::AlwaysShowNametag),
            82 => Ok(MetadataDictionaryItemKey::Color2),
            83 => Ok(MetadataDictionaryItemKey::NameAuthor),
            84 => Ok(MetadataDictionaryItemKey::ScoreTag),
            85 => Ok(MetadataDictionaryItemKey::BalloonAttachedEntity),
            86 => Ok(MetadataDictionaryItemKey::PufferfishSize),
            87 => Ok(MetadataDictionaryItemKey::BubbleTime),
            88 => Ok(MetadataDictionaryItemKey::Agent),
            89 => Ok(MetadataDictionaryItemKey::SittingAmount),
            90 => Ok(MetadataDictionaryItemKey::SittingAmountPrevious),
            91 => Ok(MetadataDictionaryItemKey::EatingCounter),
            92 => Ok(MetadataDictionaryItemKey::FlagsExtended),
            93 => Ok(MetadataDictionaryItemKey::LayingAmount),
            94 => Ok(MetadataDictionaryItemKey::LayingAmountPrevious),
            95 => Ok(MetadataDictionaryItemKey::AreaEffectCloudDuration),
            96 => Ok(MetadataDictionaryItemKey::AreaEffectCloudSpawnTime),
            97 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeRate),
            98 => Ok(MetadataDictionaryItemKey::AreaEffectCloudChangeOnPickup),
            99 => Ok(MetadataDictionaryItemKey::AreaEffectCloudPickupCount),
            100 => Ok(MetadataDictionaryItemKey::InteractText),
            101 => Ok(MetadataDictionaryItemKey::TradeTier),
            102 => Ok(MetadataDictionaryItemKey::MaxTradeTier),
            103 => Ok(MetadataDictionaryItemKey::TradeExperience),
            104 => Ok(MetadataDictionaryItemKey::SkinId),
            105 => Ok(MetadataDictionaryItemKey::SpawningFrames),
            106 => Ok(MetadataDictionaryItemKey::CommandBlockTickDelay),
            107 => Ok(MetadataDictionaryItemKey::CommandBlockExecuteOnFirstTick),
            108 => Ok(MetadataDictionaryItemKey::AmbientSoundInterval),
            109 => Ok(MetadataDictionaryItemKey::AmbientSoundIntervalRange),
            110 => Ok(MetadataDictionaryItemKey::AmbientSoundEventName),
            111 => Ok(MetadataDictionaryItemKey::FallDamageMultiplier),
            112 => Ok(MetadataDictionaryItemKey::NameRawText),
            113 => Ok(MetadataDictionaryItemKey::CanRideTarget),
            114 => Ok(MetadataDictionaryItemKey::LowTierCuredDiscount),
            115 => Ok(MetadataDictionaryItemKey::HighTierCuredDiscount),
            116 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscount),
            117 => Ok(MetadataDictionaryItemKey::NearbyCuredDiscountTimestamp),
            118 => Ok(MetadataDictionaryItemKey::Hitbox),
            119 => Ok(MetadataDictionaryItemKey::IsBuoyant),
            120 => Ok(MetadataDictionaryItemKey::FreezingEffectStrength),
            121 => Ok(MetadataDictionaryItemKey::BuoyancyData),
            122 => Ok(MetadataDictionaryItemKey::GoatHornCount),
            123 => Ok(MetadataDictionaryItemKey::UpdateProperties),
            124 => Ok(MetadataDictionaryItemKey::MovementSoundDistanceOffset),
            125 => Ok(MetadataDictionaryItemKey::HeartbeatIntervalTicks),
            126 => Ok(MetadataDictionaryItemKey::HeartbeatSoundEvent),
            127 => Ok(MetadataDictionaryItemKey::PlayerLastDeathPosition),
            128 => Ok(MetadataDictionaryItemKey::PlayerLastDeathDimension),
            129 => Ok(MetadataDictionaryItemKey::PlayerHasDied),
            130 => Ok(MetadataDictionaryItemKey::CollisionBox),
            131 => Ok(MetadataDictionaryItemKey::VisibleMobEffects),
            132 => Ok(MetadataDictionaryItemKey::FilteredName),
            133 => Ok(MetadataDictionaryItemKey::BedEnterPosition),
            134 => Ok(MetadataDictionaryItemKey::SeatThirdPersonCameraRadius),
            135 => Ok(MetadataDictionaryItemKey::SeatCameraRelaxDistanceSmoothing),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MetadataDictionaryItemKey),
                value: val as i64,
            }),
        }
    }
}
impl Default for MetadataDictionaryItemKey {
    fn default() -> Self {
        Self::Flags
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MetadataDictionaryItemType {
    Byte = 0,
    Short = 1,
    Int = 2,
    Float = 3,
    String = 4,
    Compound = 5,
    Vec3I = 6,
    Long = 7,
    Vec3F = 8,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(MetadataDictionaryItemType::Byte),
            1 => Ok(MetadataDictionaryItemType::Short),
            2 => Ok(MetadataDictionaryItemType::Int),
            3 => Ok(MetadataDictionaryItemType::Float),
            4 => Ok(MetadataDictionaryItemType::String),
            5 => Ok(MetadataDictionaryItemType::Compound),
            6 => Ok(MetadataDictionaryItemType::Vec3I),
            7 => Ok(MetadataDictionaryItemType::Long),
            8 => Ok(MetadataDictionaryItemType::Vec3F),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MetadataDictionaryItemType),
                value: val as i64,
            }),
        }
    }
}
impl Default for MetadataDictionaryItemType {
    fn default() -> Self {
        Self::Byte
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3I {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3I {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValueDefault {
    Byte(i8),
    Compound(crate::bedrock::codec::Nbt),
    Float(f32),
    Int(i32),
    Long(i64),
    Short(i16),
    String(String),
    Vec3F(Vec3F),
    Vec3I(Vec3I),
}
impl Default for MetadataDictionaryItemValueDefault {
    fn default() -> Self {
        Self::Byte(Default::default())
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct MetadataFlags1
    : u64 { const ONFIRE = 1; const SNEAKING = 2; const RIDING = 4; const SPRINTING = 8;
    const ACTION = 16; const INVISIBLE = 32; const TEMPTED = 64; const INLOVE = 128;
    const SADDLED = 256; const POWERED = 512; const IGNITED = 1024; const BABY = 2048;
    const CONVERTING = 4096; const CRITICAL = 8192; const CAN_SHOW_NAMETAG = 16384; const
    ALWAYS_SHOW_NAMETAG = 32768; const NO_AI = 65536; const SILENT = 131072; const
    WALLCLIMBING = 262144; const CAN_CLIMB = 524288; const SWIMMER = 1048576; const
    CAN_FLY = 2097152; const WALKER = 4194304; const RESTING = 8388608; const SITTING =
    16777216; const ANGRY = 33554432; const INTERESTED = 67108864; const CHARGED =
    134217728; const TAMED = 268435456; const ORPHANED = 536870912; const LEASHED =
    1073741824; const SHEARED = 2147483648; const GLIDING = 4294967296; const ELDER =
    8589934592; const MOVING = 17179869184; const BREATHING = 34359738368; const CHESTED
    = 68719476736; const STACKABLE = 137438953472; const SHOWBASE = 274877906944; const
    REARING = 549755813888; const VIBRATING = 1099511627776; const IDLING =
    2199023255552; const EVOKER_SPELL = 4398046511104; const CHARGE_ATTACK =
    8796093022208; const WASD_CONTROLLED = 17592186044416; const CAN_POWER_JUMP =
    35184372088832; const CAN_DASH = 70368744177664; const LINGER = 140737488355328;
    const HAS_COLLISION = 281474976710656; const AFFECTED_BY_GRAVITY = 562949953421312;
    const FIRE_IMMUNE = 1125899906842624; const DANCING = 2251799813685248; const
    ENCHANTED = 4503599627370496; const SHOW_TRIDENT_ROPE = 9007199254740992; const
    CONTAINER_PRIVATE = 18014398509481984; const TRANSFORMING = 36028797018963968; const
    SPIN_ATTACK = 72057594037927936; const SWIMMING = 144115188075855872; const BRIBED =
    288230376151711744; const PREGNANT = 576460752303423488; const LAYING_EGG =
    1152921504606846976; const RIDER_CAN_PICK = 2305843009213693952; const
    TRANSITION_SITTING = 4611686018427387904; const EATING = 9223372036854775808; const
    LAYING_DOWN = 0; }
}
impl crate::bedrock::codec::BedrockCodec for MetadataFlags1 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::ZigZag64(val as i64).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u64;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct MetadataFlags2
    : u64 { const SNEEZING = 1; const TRUSTING = 2; const ROLLING = 4; const SCARED = 8;
    const IN_SCAFFOLDING = 16; const OVER_SCAFFOLDING = 32; const
    FALL_THROUGH_SCAFFOLDING = 64; const BLOCKING = 128; const TRANSITION_BLOCKING = 256;
    const BLOCKED_USING_SHIELD = 512; const BLOCKED_USING_DAMAGED_SHIELD = 1024; const
    SLEEPING = 2048; const WANTS_TO_WAKE = 4096; const TRADE_INTEREST = 8192; const
    DOOR_BREAKER = 16384; const BREAKING_OBSTRUCTION = 32768; const DOOR_OPENER = 65536;
    const ILLAGER_CAPTAIN = 131072; const STUNNED = 262144; const ROARING = 524288; const
    DELAYED_ATTACKING = 1048576; const AVOIDING_MOBS = 2097152; const AVOIDING_BLOCK =
    4194304; const FACING_TARGET_TO_RANGE_ATTACK = 8388608; const HIDDEN_WHEN_INVISIBLE =
    16777216; const IS_IN_UI = 33554432; const STALKING = 67108864; const EMOTING =
    134217728; const CELEBRATING = 268435456; const ADMIRING = 536870912; const
    CELEBRATING_SPECIAL = 1073741824; const UNKNOWN_95 = 2147483648; const RAM_ATTACK =
    4294967296; const PLAYING_DEAD = 8589934592; const IN_ASCENDABLE_BLOCK = 17179869184;
    const OVER_DESCENDABLE_BLOCK = 34359738368; const CROAKING = 68719476736; const
    EAT_MOB = 137438953472; const JUMP_GOAL_JUMP = 274877906944; const EMERGING =
    549755813888; const SNIFFING = 1099511627776; const DIGGING = 2199023255552; const
    SONIC_BOOM = 4398046511104; const HAS_DASH_COOLDOWN = 8796093022208; const
    PUSH_TOWARDS_CLOSEST_SPACE = 17592186044416; const SCENTING = 35184372088832; const
    RISING = 70368744177664; const FEELING_HAPPY = 140737488355328; const SEARCHING =
    281474976710656; const CRAWLING = 562949953421312; const TIMER_FLAG_1 =
    1125899906842624; const TIMER_FLAG_2 = 2251799813685248; const TIMER_FLAG_3 =
    4503599627370496; const BODY_ROTATION_BLOCKED = 9007199254740992; const
    RENDER_WHEN_INVISIBLE = 18014398509481984; const BODY_ROTATION_AXIS_ALIGNED =
    36028797018963968; const COLLIDABLE = 72057594037927936; const WASD_AIR_CONTROLLED =
    144115188075855872; const DOES_SERVER_AUTH_ONLY_DISMOUNT = 288230376151711744; const
    BODY_ROTATION_ALWAYS_FOLLOWS_HEAD = 576460752303423488; const
    CAN_USE_VERTICAL_MOVEMENT_ACTION = 1152921504606846976; const
    ROTATION_LOCKED_TO_VEHICLE = 2305843009213693952; }
}
impl crate::bedrock::codec::BedrockCodec for MetadataFlags2 {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::ZigZag64(val as i64).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u64;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum MetadataDictionaryItemValue {
    Default(Box<Option<MetadataDictionaryItemValueDefault>>),
    Flags(MetadataFlags1),
    FlagsExtended(MetadataFlags2),
    SeatCameraRelaxDistanceSmoothing(f32),
    SeatThirdPersonCameraRadius(f32),
}
impl Default for MetadataDictionaryItemValue {
    fn default() -> Self {
        Self::Default(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MetadataDictionaryItem {
    pub key: MetadataDictionaryItemKey,
    pub type_: MetadataDictionaryItemType,
    pub value: MetadataDictionaryItemValue,
}
impl crate::bedrock::codec::BedrockCodec for MetadataDictionaryItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.key.encode(buf)?;
        self.type_.encode(buf)?;
        match &self.value {
            MetadataDictionaryItemValue::Flags(v) => {
                v.encode(buf)?;
            }
            MetadataDictionaryItemValue::FlagsExtended(v) => {
                v.encode(buf)?;
            }
            MetadataDictionaryItemValue::SeatCameraRelaxDistanceSmoothing(v) => {
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            MetadataDictionaryItemValue::SeatThirdPersonCameraRadius(v) => {
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            MetadataDictionaryItemValue::Default(v) => {
                if let Some(v) = (&**v) {
                    match v {
                        MetadataDictionaryItemValueDefault::Byte(v) => {
                            (*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Compound(v) => {
                            (*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Float(v) => {
                            crate::bedrock::codec::F32LE(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Int(v) => {
                            crate::bedrock::codec::ZigZag32(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Long(v) => {
                            crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Short(v) => {
                            crate::bedrock::codec::I16LE(*v).encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::String(v) => {
                            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                                (v).chars()
                                    .map(|ch| {
                                        let code = ch as u32;
                                        if code <= 0xFF { code as u8 } else { b'?' }
                                    })
                                    .collect()
                            } else {
                                (v).as_bytes().to_vec()
                            };
                            let len = bytes.len();
                            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                            buf.put_slice(&bytes);
                        }
                        MetadataDictionaryItemValueDefault::Vec3F(v) => {
                            v.encode(buf)?;
                        }
                        MetadataDictionaryItemValueDefault::Vec3I(v) => {
                            v.encode(buf)?;
                        }
                    }
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let key =
            <MetadataDictionaryItemKey as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let type_ =
            <MetadataDictionaryItemType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let value = match key {
            MetadataDictionaryItemKey::Flags => {
                MetadataDictionaryItemValue::Flags(
                    <MetadataFlags1 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            MetadataDictionaryItemKey::FlagsExtended => {
                MetadataDictionaryItemValue::FlagsExtended(
                    <MetadataFlags2 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            MetadataDictionaryItemKey::SeatCameraRelaxDistanceSmoothing => {
                MetadataDictionaryItemValue::SeatCameraRelaxDistanceSmoothing(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            }
            MetadataDictionaryItemKey::SeatThirdPersonCameraRadius => {
                MetadataDictionaryItemValue::SeatThirdPersonCameraRadius(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            }
            _ => {
                MetadataDictionaryItemValue::Default(
                    Box::new(
                        match type_ {
                            MetadataDictionaryItemType::Byte => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Byte(
                                        <i8 as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Compound => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Compound(
                                        <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Float => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Float(
                                        <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Int => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Int(
                                        <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Long => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Long(
                                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Short => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Short(
                                        <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::String => {
                                Some(
                                    MetadataDictionaryItemValueDefault::String({
                                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?
                                            .0) as i64;
                                        if len_raw < 0 {
                                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                                value: len_raw,
                                            });
                                        }
                                        let len = len_raw as usize;
                                        if buf.remaining() < len {
                                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                                declared: len,
                                                available: buf.remaining(),
                                            });
                                        }
                                        let mut bytes = vec![0u8; len];
                                        buf.copy_to_slice(&mut bytes);
                                        let s = if "".eq_ignore_ascii_case("latin1") {
                                            bytes.into_iter().map(|b| b as char).collect::<String>()
                                        } else {
                                            String::from_utf8_lossy(&bytes).into_owned()
                                        };
                                        s
                                    }),
                                )
                            }
                            MetadataDictionaryItemType::Vec3F => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3F(
                                        <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                            MetadataDictionaryItemType::Vec3I => {
                                Some(
                                    MetadataDictionaryItemValueDefault::Vec3I(
                                        <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                        },
                    ),
                )
            }
        };
        Ok(Self { key, type_, value })
    }
}
pub type MetadataDictionary = Vec<MetadataDictionaryItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MovementEffectType {
    Invalid = -1,
    GlideBoost = 0,
}
impl crate::bedrock::codec::BedrockCodec for MovementEffectType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            -1 => Ok(MovementEffectType::Invalid),
            0 => Ok(MovementEffectType::GlideBoost),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MovementEffectType),
                value: val as i64,
            }),
        }
    }
}
impl Default for MovementEffectType {
    fn default() -> Self {
        Self::Invalid
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ParameterKeyframeValue {
    pub time: f32,
    pub value: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for ParameterKeyframeValue {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.time).encode(buf)?;
        self.value.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let time =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let value = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { time, value })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PermissionLevel {
    Visitor = 0,
    Member = 1,
    Operator = 2,
    Custom = 3,
}
impl crate::bedrock::codec::BedrockCodec for PermissionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PermissionLevel::Visitor),
            1 => Ok(PermissionLevel::Member),
            2 => Ok(PermissionLevel::Operator),
            3 => Ok(PermissionLevel::Custom),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PermissionLevel),
                value: val as i64,
            }),
        }
    }
}
impl Default for PermissionLevel {
    fn default() -> Self {
        Self::Visitor
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerAttributesItemModifiersItem {
    pub id: String,
    pub name: String,
    pub amount: f32,
    pub operation: i32,
    pub operand: i32,
    pub serializable: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItemModifiersItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::F32LE(self.amount).encode(buf)?;
        crate::bedrock::codec::I32LE(self.operation).encode(buf)?;
        crate::bedrock::codec::I32LE(self.operand).encode(buf)?;
        self.serializable.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let amount =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let operation =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let operand =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let serializable = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            id,
            name,
            amount,
            operation,
            operand,
            serializable,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerAttributesItem {
    pub min: f32,
    pub max: f32,
    pub current: f32,
    pub default_min: f32,
    pub default_max: f32,
    pub default: f32,
    pub name: String,
    pub modifiers: Vec<PlayerAttributesItemModifiersItem>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAttributesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.min).encode(buf)?;
        crate::bedrock::codec::F32LE(self.max).encode(buf)?;
        crate::bedrock::codec::F32LE(self.current).encode(buf)?;
        crate::bedrock::codec::F32LE(self.default_min).encode(buf)?;
        crate::bedrock::codec::F32LE(self.default_max).encode(buf)?;
        crate::bedrock::codec::F32LE(self.default).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.modifiers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.modifiers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let min =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let max =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let current =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let default_min =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let default_max =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let default =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let modifiers = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <PlayerAttributesItemModifiersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            min,
            max,
            current,
            default_min,
            default_max,
            default,
            name,
            modifiers,
        })
    }
}
pub type PlayerAttributes = Vec<PlayerAttributesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PlayerRecordsType {
    Add = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PlayerRecordsType::Add),
            1 => Ok(PlayerRecordsType::Remove),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayerRecordsType),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayerRecordsType {
    fn default() -> Self {
        Self::Add
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SkinImage {
    pub width: i32,
    pub height: i32,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for SkinImage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.width).encode(buf)?;
        crate::bedrock::codec::I32LE(self.height).encode(buf)?;
        let len = self.data.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.data {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let width =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let height =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let data = {
            let res: ByteArray = {
                let raw =
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec.push(<u8 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?);
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            width,
            height,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SkinAnimationsItem {
    pub skin_image: SkinImage,
    pub animation_type: i32,
    pub animation_frames: f32,
    pub expression_type: f32,
}
impl crate::bedrock::codec::BedrockCodec for SkinAnimationsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.skin_image.encode(buf)?;
        crate::bedrock::codec::I32LE(self.animation_type).encode(buf)?;
        crate::bedrock::codec::F32LE(self.animation_frames).encode(buf)?;
        crate::bedrock::codec::F32LE(self.expression_type).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let skin_image = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let animation_type =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let animation_frames =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let expression_type =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            skin_image,
            animation_type,
            animation_frames,
            expression_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SkinPersonalPiecesItem {
    pub piece_id: String,
    pub piece_type: String,
    pub pack_id: String,
    pub is_default_piece: bool,
    pub product_id: String,
}
impl crate::bedrock::codec::BedrockCodec for SkinPersonalPiecesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.piece_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.piece_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.piece_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.piece_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.pack_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.pack_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.is_default_piece.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.product_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.product_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let piece_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let piece_type = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let pack_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let is_default_piece = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let product_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            piece_id,
            piece_type,
            pack_id,
            is_default_piece,
            product_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SkinPieceTintColorsItem {
    pub piece_type: String,
    pub colors: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for SkinPieceTintColorsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.piece_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.piece_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.colors.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.colors {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let piece_type = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let colors = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self { piece_type, colors })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Skin {
    pub skin_id: String,
    pub play_fab_id: String,
    pub skin_resource_pack: String,
    pub skin_data: SkinImage,
    pub animations: Vec<SkinAnimationsItem>,
    pub cape_data: SkinImage,
    pub geometry_data: String,
    pub geometry_data_version: String,
    pub animation_data: String,
    pub cape_id: String,
    pub full_skin_id: String,
    pub arm_size: String,
    pub skin_color: String,
    pub personal_pieces: Vec<SkinPersonalPiecesItem>,
    pub piece_tint_colors: Vec<SkinPieceTintColorsItem>,
    pub premium: bool,
    pub persona: bool,
    pub cape_on_classic: bool,
    pub primary_user: bool,
    pub overriding_player_appearance: bool,
}
impl crate::bedrock::codec::BedrockCodec for Skin {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.skin_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.skin_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.play_fab_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.play_fab_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.skin_resource_pack)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.skin_resource_pack).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.skin_data.encode(buf)?;
        let len = self.animations.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.animations {
            item.encode(buf)?;
        }
        self.cape_data.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.geometry_data)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.geometry_data).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.geometry_data_version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.geometry_data_version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.animation_data)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.animation_data).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.cape_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.cape_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.full_skin_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.full_skin_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.arm_size)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.arm_size).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.skin_color)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.skin_color).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.personal_pieces.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.personal_pieces {
            item.encode(buf)?;
        }
        let len = self.piece_tint_colors.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.piece_tint_colors {
            item.encode(buf)?;
        }
        self.premium.encode(buf)?;
        self.persona.encode(buf)?;
        self.cape_on_classic.encode(buf)?;
        self.primary_user.encode(buf)?;
        self.overriding_player_appearance.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let skin_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let play_fab_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let skin_resource_pack = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let skin_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let animations = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <SkinAnimationsItem as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                );
            }
            tmp_vec
        };
        let cape_data = <SkinImage as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let geometry_data = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let geometry_data_version = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let animation_data = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let cape_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let full_skin_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let arm_size = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let skin_color = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let personal_pieces = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <SkinPersonalPiecesItem as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                );
            }
            tmp_vec
        };
        let piece_tint_colors = {
            let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <SkinPieceTintColorsItem as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                );
            }
            tmp_vec
        };
        let premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let persona = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let cape_on_classic = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let primary_user = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let overriding_player_appearance =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            skin_id,
            play_fab_id,
            skin_resource_pack,
            skin_data,
            animations,
            cape_data,
            geometry_data,
            geometry_data_version,
            animation_data,
            cape_id,
            full_skin_id,
            arm_size,
            skin_color,
            personal_pieces,
            piece_tint_colors,
            premium,
            persona,
            cape_on_classic,
            primary_user,
            overriding_player_appearance,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerRecordsRecordsItemAdd {
    pub uuid: uuid::Uuid,
    pub entity_unique_id: i64,
    pub username: String,
    pub xbox_user_id: String,
    pub platform_chat_id: String,
    pub build_platform: i32,
    pub skin_data: Skin,
    pub is_teacher: bool,
    pub is_host: bool,
    pub is_subclient: bool,
    pub player_color: i32,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemAdd {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.username)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.username).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.xbox_user_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.xbox_user_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.platform_chat_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.platform_chat_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I32LE(self.build_platform).encode(buf)?;
        self.skin_data.encode(buf)?;
        self.is_teacher.encode(buf)?;
        self.is_host.encode(buf)?;
        self.is_subclient.encode(buf)?;
        crate::bedrock::codec::I32LE(self.player_color).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_unique_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let username = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let xbox_user_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let platform_chat_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let build_platform =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let skin_data = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_teacher = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_host = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let is_subclient = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let player_color =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            uuid,
            entity_unique_id,
            username,
            xbox_user_id,
            platform_chat_id,
            build_platform,
            skin_data,
            is_teacher,
            is_host,
            is_subclient,
            player_color,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerRecordsRecordsItemRemove {
    pub uuid: uuid::Uuid,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecordsRecordsItemRemove {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { uuid })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerRecordsRecordsItem {
    Add(Box<PlayerRecordsRecordsItemAdd>),
    Remove(PlayerRecordsRecordsItemRemove),
}
impl Default for PlayerRecordsRecordsItem {
    fn default() -> Self {
        Self::Add(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerRecords {
    pub type_: PlayerRecordsType,
    pub records_count: i32,
    pub records: Vec<Option<PlayerRecordsRecordsItem>>,
    pub verified: Option<Vec<bool>>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerRecords {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        crate::bedrock::codec::VarInt(self.records_count).encode(buf)?;
        let len = self.records.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.records {
            if let Some(v) = item {
                match v {
                    PlayerRecordsRecordsItem::Add(v) => {
                        v.encode(buf)?;
                    }
                    PlayerRecordsRecordsItem::Remove(v) => {
                        v.encode(buf)?;
                    }
                }
            }
        }
        if let Some(v) = &self.verified {
            let len = v.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            for item in v {
                (*item).encode(buf)?;
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <PlayerRecordsType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let records_count =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let records = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        match type_ {
                            PlayerRecordsType::Add => {
                                Some(
                                    PlayerRecordsRecordsItem::Add(
                                        Box::new(
                                            <PlayerRecordsRecordsItemAdd as crate::bedrock::codec::BedrockCodec>::decode(
                                                buf,
                                                (),
                                            )?,
                                        ),
                                    ),
                                )
                            }
                            PlayerRecordsType::Remove => {
                                Some(
                                    PlayerRecordsRecordsItem::Remove(
                                        <PlayerRecordsRecordsItemRemove as crate::bedrock::codec::BedrockCodec>::decode(
                                            buf,
                                            (),
                                        )?,
                                    ),
                                )
                            }
                        },
                    );
            }
            tmp_vec
        };
        let verified = match type_ {
            PlayerRecordsType::Add => Some({
                let raw =
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec.push(<bool as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?);
                }
                tmp_vec
            }),
            _ => None,
        };
        Ok(Self {
            type_,
            records_count,
            records,
            verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PotionContainerChangeRecipesItem {
    pub input_item_id: i32,
    pub ingredient_id: i32,
    pub output_item_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PotionContainerChangeRecipesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.input_item_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let input_item_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let ingredient_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output_item_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            input_item_id,
            ingredient_id,
            output_item_id,
        })
    }
}
pub type PotionContainerChangeRecipes = Vec<PotionContainerChangeRecipesItem>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PotionTypeRecipesItem {
    pub input_item_id: i32,
    pub input_item_meta: i32,
    pub ingredient_id: i32,
    pub ingredient_meta: i32,
    pub output_item_id: i32,
    pub output_item_meta: i32,
}
impl crate::bedrock::codec::BedrockCodec for PotionTypeRecipesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.input_item_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.input_item_meta).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.ingredient_meta).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.output_item_meta).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let input_item_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let input_item_meta =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let ingredient_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let ingredient_meta =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output_item_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output_item_meta =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            input_item_id,
            input_item_meta,
            ingredient_id,
            ingredient_meta,
            output_item_id,
            output_item_meta,
        })
    }
}
pub type PotionTypeRecipes = Vec<PotionTypeRecipesItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum RecipeUnlockingRequirementContext {
    None = 0,
    AlwaysUnlocked = 1,
    PlayerInWater = 2,
    PlayerHasManyItems = 3,
}
impl crate::bedrock::codec::BedrockCodec for RecipeUnlockingRequirementContext {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(RecipeUnlockingRequirementContext::None),
            1 => Ok(RecipeUnlockingRequirementContext::AlwaysUnlocked),
            2 => Ok(RecipeUnlockingRequirementContext::PlayerInWater),
            3 => Ok(RecipeUnlockingRequirementContext::PlayerHasManyItems),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(RecipeUnlockingRequirementContext),
                value: val as i64,
            }),
        }
    }
}
impl Default for RecipeUnlockingRequirementContext {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipeUnlockingRequirement {
    pub context: RecipeUnlockingRequirementContext,
    pub ingredients: Option<Vec<RecipeIngredient>>,
}
impl crate::bedrock::codec::BedrockCodec for RecipeUnlockingRequirement {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.context.encode(buf)?;
        if let Some(v) = &self.ingredients {
            let len = v.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            for item in v {
                item.encode(buf)?;
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let context =
            <RecipeUnlockingRequirementContext as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let ingredients = match context {
            RecipeUnlockingRequirementContext::None => Some({
                let raw =
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec.push(
                        <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
                }
                tmp_vec
            }),
            _ => None,
        };
        Ok(Self {
            context,
            ingredients,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum RecipesItemType {
    Shapeless = 0,
    Shaped = 1,
    Furnace = 2,
    FurnaceWithMetadata = 3,
    Multi = 4,
    ShulkerBox = 5,
    ShapelessChemistry = 6,
    ShapedChemistry = 7,
    SmithingTransform = 8,
    SmithingTrim = 9,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(RecipesItemType::Shapeless),
            1 => Ok(RecipesItemType::Shaped),
            2 => Ok(RecipesItemType::Furnace),
            3 => Ok(RecipesItemType::FurnaceWithMetadata),
            4 => Ok(RecipesItemType::Multi),
            5 => Ok(RecipesItemType::ShulkerBox),
            6 => Ok(RecipesItemType::ShapelessChemistry),
            7 => Ok(RecipesItemType::ShapedChemistry),
            8 => Ok(RecipesItemType::SmithingTransform),
            9 => Ok(RecipesItemType::SmithingTrim),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(RecipesItemType),
                value: val as i64,
            }),
        }
    }
}
impl Default for RecipesItemType {
    fn default() -> Self {
        Self::Shapeless
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItemRecipeFurnace {
    pub input_id: i32,
    pub output: ItemLegacy,
    pub block: String,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeFurnaceArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for RecipesItemRecipeFurnaceArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnace {
    type Args = RecipesItemRecipeFurnaceArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.input_id).encode(buf)?;
        self.output.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.block)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.block).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let input_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let block = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            input_id,
            output,
            block,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItemRecipeFurnaceWithMetadata {
    pub input_id: i32,
    pub input_meta: i32,
    pub output: ItemLegacy,
    pub block: String,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeFurnaceWithMetadataArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
    for RecipesItemRecipeFurnaceWithMetadataArgs
{
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeFurnaceWithMetadata {
    type Args = RecipesItemRecipeFurnaceWithMetadataArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.input_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.input_meta).encode(buf)?;
        self.output.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.block)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.block).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let input_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let input_meta =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let block = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            input_id,
            input_meta,
            output,
            block,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItemRecipeMulti {
    pub uuid: uuid::Uuid,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeMulti {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { uuid, network_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItemRecipeShaped {
    pub recipe_id: LatinString,
    pub width: i32,
    pub height: i32,
    pub input: Vec<Vec<RecipeIngredient>>,
    pub output: Vec<ItemLegacy>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: i32,
    pub assume_symmetry: bool,
    pub unlocking_requirement: RecipeUnlockingRequirement,
    pub network_id: i32,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeShapedArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for RecipesItemRecipeShapedArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShaped {
    type Args = RecipesItemRecipeShapedArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "latin1".eq_ignore_ascii_case("latin1") {
            (&self.recipe_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.recipe_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.width).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.height).encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            let len = item.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            for item in item {
                item.encode(buf)?;
            }
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.block)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.block).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.priority).encode(buf)?;
        self.assume_symmetry.encode(buf)?;
        self.unlocking_requirement.encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_id = {
            let res: LatinString = {
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "latin1".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            };
            res
        };
        let width =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let height =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let input = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as i64;
                        if raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: raw,
                            });
                        }
                        let len = raw as usize;
                        let mut tmp_vec = Vec::with_capacity(len);
                        for _ in 0..len {
                            tmp_vec
                                .push(
                                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(
                                        buf,
                                        (),
                                    )?,
                                );
                        }
                        tmp_vec
                    });
            }
            tmp_vec
        };
        let output = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    ItemLegacyArgs {
                        shield_item_id: args.shield_item_id,
                    },
                )?);
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let priority =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let assume_symmetry = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let unlocking_requirement =
            <RecipeUnlockingRequirement as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_id,
            width,
            height,
            input,
            output,
            uuid,
            block,
            priority,
            assume_symmetry,
            unlocking_requirement,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItemRecipeShapeless {
    pub recipe_id: LatinString,
    pub input: Vec<RecipeIngredient>,
    pub output: Vec<ItemLegacy>,
    pub uuid: uuid::Uuid,
    pub block: String,
    pub priority: i32,
    pub unlocking_requirement: RecipeUnlockingRequirement,
    pub network_id: i32,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeShapelessArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for RecipesItemRecipeShapelessArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeShapeless {
    type Args = RecipesItemRecipeShapelessArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "latin1".eq_ignore_ascii_case("latin1") {
            (&self.recipe_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.recipe_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        self.uuid.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.block)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.block).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.priority).encode(buf)?;
        self.unlocking_requirement.encode(buf)?;
        crate::bedrock::codec::VarInt(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_id = {
            let res: LatinString = {
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "latin1".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            };
            res
        };
        let input = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                );
            }
            tmp_vec
        };
        let output = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(<ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    ItemLegacyArgs {
                        shield_item_id: args.shield_item_id,
                    },
                )?);
            }
            tmp_vec
        };
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let priority =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let unlocking_requirement =
            <RecipeUnlockingRequirement as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_id,
            input,
            output,
            uuid,
            block,
            priority,
            unlocking_requirement,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItemRecipeSmithingTransform {
    pub recipe_id: LatinString,
    pub template: RecipeIngredient,
    pub base: RecipeIngredient,
    pub addition: RecipeIngredient,
    pub result: ItemLegacy,
    pub tag: String,
    pub network_id: i32,
}
#[derive(Debug, Clone)]
pub struct RecipesItemRecipeSmithingTransformArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
    for RecipesItemRecipeSmithingTransformArgs
{
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeSmithingTransform {
    type Args = RecipesItemRecipeSmithingTransformArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "latin1".eq_ignore_ascii_case("latin1") {
            (&self.recipe_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.recipe_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.template.encode(buf)?;
        self.base.encode(buf)?;
        self.addition.encode(buf)?;
        self.result.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.tag)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.tag).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::VarInt(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_id = {
            let res: LatinString = {
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "latin1".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            };
            res
        };
        let template = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let base = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let addition = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let result = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let tag = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_id,
            template,
            base,
            addition,
            result,
            tag,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItemRecipeSmithingTrim {
    pub recipe_id: LatinString,
    pub template: RecipeIngredient,
    pub input: RecipeIngredient,
    pub addition: RecipeIngredient,
    pub block: String,
    pub network_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for RecipesItemRecipeSmithingTrim {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "latin1".eq_ignore_ascii_case("latin1") {
            (&self.recipe_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.recipe_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.template.encode(buf)?;
        self.input.encode(buf)?;
        self.addition.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.block)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.block).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::VarInt(self.network_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipe_id = {
            let res: LatinString = {
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "latin1".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            };
            res
        };
        let template = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let input = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let addition = <RecipeIngredient as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let network_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            recipe_id,
            template,
            input,
            addition,
            block,
            network_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RecipesItemRecipe {
    Furnace(Box<RecipesItemRecipeFurnace>),
    FurnaceWithMetadata(Box<RecipesItemRecipeFurnaceWithMetadata>),
    Multi(RecipesItemRecipeMulti),
    Shaped(Box<RecipesItemRecipeShaped>),
    ShapedChemistry(Box<RecipesItemRecipeShaped>),
    Shapeless(Box<RecipesItemRecipeShapeless>),
    ShapelessChemistry(Box<RecipesItemRecipeShapeless>),
    ShulkerBox(Box<RecipesItemRecipeShapeless>),
    SmithingTransform(Box<RecipesItemRecipeSmithingTransform>),
    SmithingTrim(Box<RecipesItemRecipeSmithingTrim>),
}
impl Default for RecipesItemRecipe {
    fn default() -> Self {
        Self::Furnace(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RecipesItem {
    pub type_: RecipesItemType,
    pub recipe: Option<RecipesItemRecipe>,
}
#[derive(Debug, Clone)]
pub struct RecipesItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for RecipesItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for RecipesItem {
    type Args = RecipesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        if let Some(v) = &self.recipe {
            match v {
                RecipesItemRecipe::Furnace(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::FurnaceWithMetadata(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::Multi(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::Shaped(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::ShapedChemistry(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::Shapeless(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::ShapelessChemistry(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::ShulkerBox(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::SmithingTransform(v) => {
                    v.encode(buf)?;
                }
                RecipesItemRecipe::SmithingTrim(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <RecipesItemType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let recipe = match type_ {
            RecipesItemType::Furnace => {
                Some(
                    RecipesItemRecipe::Furnace(
                        Box::new(
                            <RecipesItemRecipeFurnace as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeFurnaceArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::FurnaceWithMetadata => {
                Some(
                    RecipesItemRecipe::FurnaceWithMetadata(
                        Box::new(
                            <RecipesItemRecipeFurnaceWithMetadata as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeFurnaceWithMetadataArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Multi => {
                Some(
                    RecipesItemRecipe::Multi(
                        <RecipesItemRecipeMulti as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            RecipesItemType::Shaped => {
                Some(
                    RecipesItemRecipe::Shaped(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapedArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapedChemistry => {
                Some(
                    RecipesItemRecipe::ShapedChemistry(
                        Box::new(
                            <RecipesItemRecipeShaped as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapedArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::Shapeless => {
                Some(
                    RecipesItemRecipe::Shapeless(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapelessArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShapelessChemistry => {
                Some(
                    RecipesItemRecipe::ShapelessChemistry(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapelessArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::ShulkerBox => {
                Some(
                    RecipesItemRecipe::ShulkerBox(
                        Box::new(
                            <RecipesItemRecipeShapeless as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeShapelessArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::SmithingTransform => {
                Some(
                    RecipesItemRecipe::SmithingTransform(
                        Box::new(
                            <RecipesItemRecipeSmithingTransform as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemRecipeSmithingTransformArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            RecipesItemType::SmithingTrim => {
                Some(
                    RecipesItemRecipe::SmithingTrim(
                        Box::new(
                            <RecipesItemRecipeSmithingTrim as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
        };
        Ok(Self { type_, recipe })
    }
}
pub type Recipes = Vec<RecipesItem>;
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct
    RequestPermissions : u16 { const ATTACK_MOBS = 32; const ATTACK_PLAYERS = 16; const
    BUILD = 1; const DOORS_AND_SWITCHES = 4; const MINE = 2; const OPEN_CONTAINERS = 8;
    const OPERATOR = 64; const TELEPORT = 128; }
}
impl crate::bedrock::codec::BedrockCodec for RequestPermissions {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::U16LE(val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let bits = raw.0 as u16;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePackIdVersionsItem {
    pub uuid: String,
    pub version: String,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackIdVersionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.uuid)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.uuid).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let version = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            uuid,
            version,
            name,
        })
    }
}
pub type ResourcePackIdVersions = Vec<ResourcePackIdVersionsItem>;
pub type ResourcePackIds = Vec<String>;
pub type Byterot = Vec<u8>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Rotation {
    pub yaw: Byterot,
    pub pitch: Byterot,
    pub head_yaw: Byterot,
}
impl crate::bedrock::codec::BedrockCodec for Rotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.yaw.encode(buf)?;
        self.pitch.encode(buf)?;
        self.head_yaw.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let head_yaw = <Byterot as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            yaw,
            pitch,
            head_yaw,
        })
    }
}
pub type ShortArray = Vec<u8>;
pub type SignedByteArray = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SoundType {
    ItemUseOn = 0,
    Hit = 1,
    Step = 2,
    Fly = 3,
    Jump = 4,
    Break = 5,
    Place = 6,
    HeavyStep = 7,
    Gallop = 8,
    Fall = 9,
    Ambient = 10,
    AmbientBaby = 11,
    AmbientInWater = 12,
    Breathe = 13,
    Death = 14,
    DeathInWater = 15,
    DeathToZombie = 16,
    Hurt = 17,
    HurtInWater = 18,
    Mad = 19,
    Boost = 20,
    Bow = 21,
    SquishBig = 22,
    SquishSmall = 23,
    FallBig = 24,
    FallSmall = 25,
    Splash = 26,
    Fizz = 27,
    Flap = 28,
    Swim = 29,
    Drink = 30,
    Eat = 31,
    Takeoff = 32,
    Shake = 33,
    Plop = 34,
    Land = 35,
    Saddle = 36,
    Armor = 37,
    ArmorStandPlace = 38,
    AddChest = 39,
    Throw = 40,
    Attack = 41,
    AttackNoDamage = 42,
    AttackStrong = 43,
    Warn = 44,
    Shear = 45,
    Milk = 46,
    Thunder = 47,
    Explode = 48,
    Fire = 49,
    Ignite = 50,
    Fuse = 51,
    Stare = 52,
    Spawn = 53,
    Shoot = 54,
    BreakBlock = 55,
    Launch = 56,
    Blast = 57,
    LargeBlast = 58,
    Twinkle = 59,
    Remedy = 60,
    Unfect = 61,
    LevelUp = 62,
    BowHit = 63,
    BulletHit = 64,
    ExtinguishFire = 65,
    ItemFizz = 66,
    ChestOpen = 67,
    ChestClosed = 68,
    ShulkerBoxOpen = 69,
    ShulkerBoxClosed = 70,
    EnderChestOpen = 71,
    EnderChestClosed = 72,
    PowerOn = 73,
    PowerOff = 74,
    Attach = 75,
    Detach = 76,
    Deny = 77,
    Tripod = 78,
    Pop = 79,
    DropSlot = 80,
    Note = 81,
    Thorns = 82,
    PistonIn = 83,
    PistonOut = 84,
    Portal = 85,
    Water = 86,
    LavaPop = 87,
    Lava = 88,
    Burp = 89,
    BucketFillWater = 90,
    BucketFillLava = 91,
    BucketEmptyWater = 92,
    BucketEmptyLava = 93,
    ArmorEquipChain = 94,
    ArmorEquipDiamond = 95,
    ArmorEquipGeneric = 96,
    ArmorEquipGold = 97,
    ArmorEquipIron = 98,
    ArmorEquipLeather = 99,
    ArmorEquipElytra = 100,
    Record13 = 101,
    RecordCat = 102,
    RecordBlocks = 103,
    RecordChirp = 104,
    RecordFar = 105,
    RecordMall = 106,
    RecordMellohi = 107,
    RecordStal = 108,
    RecordStrad = 109,
    RecordWard = 110,
    Record11 = 111,
    RecordWait = 112,
    StopRecord = 113,
    Flop = 114,
    GuardianCurse = 115,
    MobWarning = 116,
    MobWarningBaby = 117,
    Teleport = 118,
    ShulkerOpen = 119,
    ShulkerClose = 120,
    Haggle = 121,
    HaggleYes = 122,
    HaggleNo = 123,
    HaggleIdle = 124,
    ChorusGrow = 125,
    ChorusDeath = 126,
    Glass = 127,
    PotionBrewed = 128,
    CastSpell = 129,
    PrepareAttackSpell = 130,
    PrepareSummon = 131,
    PrepareWololo = 132,
    Fang = 133,
    Charge = 134,
    CameraTakePicture = 135,
    LeashKnotPlace = 136,
    LeashKnotBreak = 137,
    AmbientGrowl = 138,
    AmbientWhine = 139,
    AmbientPant = 140,
    AmbientPurr = 141,
    AmbientPurreow = 142,
    DeathMinVolume = 143,
    DeathMidVolume = 144,
    ImitateBlaze = 145,
    ImitateCaveSpider = 146,
    ImitateCreeper = 147,
    ImitateElderGuardian = 148,
    ImitateEnderDragon = 149,
    ImitateEnderman = 150,
    ImitateEndermite = 151,
    ImitateEvocationIllager = 152,
    ImitateGhast = 153,
    ImitateHusk = 154,
    ImitateIllusionIllager = 155,
    ImitateMagmaCube = 156,
    ImitatePolarBear = 157,
    ImitateShulker = 158,
    ImitateSilverfish = 159,
    ImitateSkeleton = 160,
    ImitateSlime = 161,
    ImitateSpider = 162,
    ImitateStray = 163,
    ImitateVex = 164,
    ImitateVindicationIllager = 165,
    ImitateWitch = 166,
    ImitateWither = 167,
    ImitateWitherSkeleton = 168,
    ImitateWolf = 169,
    ImitateZombie = 170,
    ImitateZombiePigman = 171,
    ImitateZombieVillager = 172,
    EnderEyePlaced = 173,
    EndPortalCreated = 174,
    AnvilUse = 175,
    BottleDragonBreath = 176,
    PortalTravel = 177,
    TridentHit = 178,
    TridentReturn = 179,
    TridentRiptide1 = 180,
    TridentRiptide2 = 181,
    TridentRiptide3 = 182,
    TridentThrow = 183,
    TridentThunder = 184,
    TridentHitGround = 185,
    Default = 186,
    FletchingTableUse = 187,
    ElemConstructOpen = 188,
    IceBombHit = 189,
    BalloonPop = 190,
    LtReactionIceBomb = 191,
    LtReactionBleach = 192,
    LtReactionElephantToothpaste = 193,
    LtReactionElephantToothpaste2 = 194,
    LtReactionGlowStick = 195,
    LtReactionGlowStick2 = 196,
    LtReactionLuminol = 197,
    LtReactionSalt = 198,
    LtReactionFertilizer = 199,
    LtReactionFireball = 200,
    LtReactionMagnesiumSalt = 201,
    LtReactionMiscFire = 202,
    LtReactionFire = 203,
    LtReactionMiscExplosion = 204,
    LtReactionMiscMystical = 205,
    LtReactionMiscMystical2 = 206,
    LtReactionProduct = 207,
    SparklerUse = 208,
    GlowStickUse = 209,
    SparklerActive = 210,
    ConvertToDrowned = 211,
    BucketFillFish = 212,
    BucketEmptyFish = 213,
    BubbleColumnUpwards = 214,
    BubbleColumnDownwards = 215,
    BubblePop = 216,
    BubbleUpInside = 217,
    BubbleDownInside = 218,
    HurtBaby = 219,
    DeathBaby = 220,
    StepBaby = 221,
    SpawnBaby = 222,
    Born = 223,
    TurtleEggBreak = 224,
    TurtleEggCrack = 225,
    TurtleEggHatched = 226,
    LayEgg = 227,
    TurtleEggAttacked = 228,
    BeaconActivate = 229,
    BeaconAmbient = 230,
    BeaconDeactivate = 231,
    BeaconPower = 232,
    ConduitActivate = 233,
    ConduitAmbient = 234,
    ConduitAttack = 235,
    ConduitDeactivate = 236,
    ConduitShort = 237,
    Swoop = 238,
    BambooSaplingPlace = 239,
    PreSneeze = 240,
    Sneeze = 241,
    AmbientTame = 242,
    Scared = 243,
    ScaffoldingClimb = 244,
    CrossbowLoadingStart = 245,
    CrossbowLoadingMiddle = 246,
    CrossbowLoadingEnd = 247,
    CrossbowShoot = 248,
    CrossbowQuickChargeStart = 249,
    CrossbowQuickChargeMiddle = 250,
    CrossbowQuickChargeEnd = 251,
    AmbientAggressive = 252,
    AmbientWorried = 253,
    CantBreed = 254,
    ShieldBlock = 255,
    LecternBookPlace = 256,
    GrindstoneUse = 257,
    Bell = 258,
    CampfireCrackle = 259,
    Roar = 260,
    Stun = 261,
    SweetBerryBushHurt = 262,
    SweetBerryBushPick = 263,
    CartographyTableUse = 264,
    StonecutterUse = 265,
    ComposterEmpty = 266,
    ComposterFill = 267,
    ComposterFillLayer = 268,
    ComposterReady = 269,
    BarrelOpen = 270,
    BarrelClose = 271,
    RaidHorn = 272,
    LoomUse = 273,
    AmbientInRaid = 274,
    UicartographyTableUse = 275,
    UistonecutterUse = 276,
    UiloomUse = 277,
    SmokerUse = 278,
    BlastFurnaceUse = 279,
    SmithingTableUse = 280,
    Screech = 281,
    Sleep = 282,
    FurnaceUse = 283,
    MooshroomConvert = 284,
    MilkSuspiciously = 285,
    Celebrate = 286,
    JumpPrevent = 287,
    AmbientPollinate = 288,
    BeehiveDrip = 289,
    BeehiveEnter = 290,
    BeehiveExit = 291,
    BeehiveWork = 292,
    BeehiveShear = 293,
    HoneybottleDrink = 294,
    AmbientCave = 295,
    Retreat = 296,
    ConvertToZombified = 297,
    Admire = 298,
    StepLava = 299,
    Tempt = 300,
    Panic = 301,
    Angry = 302,
    AmbientMoodWarpedForest = 303,
    AmbientMoodSoulsandValley = 304,
    AmbientMoodNetherWastes = 305,
    AmbientMoodBasaltDeltas = 306,
    AmbientMoodCrimsonForest = 307,
    RespawnAnchorCharge = 308,
    RespawnAnchorDeplete = 309,
    RespawnAnchorSetSpawn = 310,
    RespawnAnchorAmbient = 311,
    SoulEscapeQuiet = 312,
    SoulEscapeLoud = 313,
    RecordPigstep = 314,
    LinkCompassToLodestone = 315,
    UseSmithingTable = 316,
    EquipNetherite = 317,
    AmbientLoopWarpedForest = 318,
    AmbientLoopSoulsandValley = 319,
    AmbientLoopNetherWastes = 320,
    AmbientLoopBasaltDeltas = 321,
    AmbientLoopCrimsonForest = 322,
    AmbientAdditionWarpedForest = 323,
    AmbientAdditionSoulsandValley = 324,
    AmbientAdditionNetherWastes = 325,
    AmbientAdditionBasaltDeltas = 326,
    AmbientAdditionCrimsonForest = 327,
    SculkSensorPowerOn = 328,
    SculkSensorPowerOff = 329,
    BucketFillPowderSnow = 330,
    BucketEmptyPowderSnow = 331,
    PointedDripstoneCauldronDripWater = 332,
    PointedDripstoneCauldronDripLava = 333,
    PointedDripstoneDripWater = 334,
    PointedDripstoneDripLava = 335,
    CaveVinesPickBerries = 336,
    BigDripleafTiltDown = 337,
    BigDripleafTiltUp = 338,
    CopperWaxOn = 339,
    CopperWaxOff = 340,
    Scrape = 341,
    PlayerHurtDrown = 342,
    PlayerHurtOnFire = 343,
    PlayerHurtFreeze = 344,
    UseSpyglass = 345,
    StopUsingSpyglass = 346,
    AmethystBlockChime = 347,
    AmbientScreamer = 348,
    HurtScreamer = 349,
    DeathScreamer = 350,
    MilkScreamer = 351,
    JumpToBlock = 352,
    PreRam = 353,
    PreRamScreamer = 354,
    RamImpact = 355,
    RamImpactScreamer = 356,
    SquidInkSquirt = 357,
    GlowSquidInkSquirt = 358,
    ConvertToStray = 359,
    CakeAddCandle = 360,
    ExtinguishCandle = 361,
    AmbientCandle = 362,
    BlockClick = 363,
    BlockClickFail = 364,
    SculkCatalystBloom = 365,
    SculkShriekerShriek = 366,
    WardenNearbyClose = 367,
    WardenNearbyCloser = 368,
    WardenNearbyClosest = 369,
    WardenSlightlyAngry = 370,
    RecordOtherside = 371,
    Tongue = 372,
    CrackIronGolem = 373,
    RepairIronGolem = 374,
    Listening = 375,
    Heartbeat = 376,
    HornBreak = 377,
    Unknown = 378,
    SculkSpread = 379,
    SculkCharge = 380,
    SculkSensorPlace = 381,
    SculkShriekerPlace = 382,
    GoatCall0 = 383,
    GoatCall1 = 384,
    GoatCall2 = 385,
    GoatCall3 = 386,
    GoatCall4 = 387,
    GoatCall5 = 388,
    GoatCall6 = 389,
    GoatCall7 = 390,
    GoatCall8 = 391,
    GoatCall9 = 392,
    GoatHarmony0 = 393,
    GoatHarmony1 = 394,
    GoatHarmony2 = 395,
    GoatHarmony3 = 396,
    GoatHarmony4 = 397,
    GoatHarmony5 = 398,
    GoatHarmony6 = 399,
    GoatHarmony7 = 400,
    GoatHarmony8 = 401,
    GoatHarmony9 = 402,
    GoatMelody0 = 403,
    GoatMelody1 = 404,
    GoatMelody2 = 405,
    GoatMelody3 = 406,
    GoatMelody4 = 407,
    GoatMelody5 = 408,
    GoatMelody6 = 409,
    GoatMelody7 = 410,
    GoatMelody8 = 411,
    GoatMelody9 = 412,
    GoatBass0 = 413,
    GoatBass1 = 414,
    GoatBass2 = 415,
    GoatBass3 = 416,
    GoatBass4 = 417,
    GoatBass5 = 418,
    GoatBass6 = 419,
    GoatBass7 = 420,
    GoatBass8 = 421,
    GoatBass9 = 422,
    Unknown423 = 423,
    Unknown424 = 424,
    Unknown425 = 425,
    ImitateWarden = 426,
    ListeningAngry = 427,
    ItemGiven = 428,
    ItemTaken = 429,
    Disappeared = 430,
    Reappeared = 431,
    DrinkMilk = 432,
    FrogspawnHatched = 433,
    LaySpawn = 434,
    FrogspawnBreak = 435,
    SonicBoom = 436,
    SonicCharge = 437,
    SoundeventItemThrown = 438,
    Record5 = 439,
    ConvertToFrog = 440,
    RecordPlaying = 441,
    EnchantingTableUse = 442,
    StepSand = 443,
    DashReady = 444,
    BundleDropContents = 445,
    BundleInsert = 446,
    BundleRemoveOne = 447,
    PressurePlateClickOff = 448,
    PressurePlateClickOn = 449,
    ButtonClickOff = 450,
    ButtonClickOn = 451,
    DoorOpen = 452,
    DoorClose = 453,
    TrapdoorOpen = 454,
    TrapdoorClose = 455,
    FenceGateOpen = 456,
    FenceGateClose = 457,
    Insert = 458,
    Pickup = 459,
    InsertEnchanted = 460,
    PickupEnchanted = 461,
    Brush = 462,
    BrushCompleted = 463,
    ShatterDecoratedPot = 464,
    BreakDecoratedPot = 465,
    SnifferEggCrack = 466,
    SnifferEggHatched = 467,
    WaxedSignInteractFail = 468,
    RecordRelic = 469,
    Bump = 470,
    PumpkinCarve = 471,
    ConvertHuskToZombie = 472,
    PigDeath = 473,
    HoglinZombified = 474,
    AmbientUnderwaterEnter = 475,
    AmbientUnderwaterExit = 476,
    BottleFill = 477,
    BottleEmpty = 478,
    CrafterCraft = 479,
    CrafterFail = 480,
    DecoratedPotInsert = 481,
    DecoratedPotInsertFail = 482,
    CrafterDisableSlot = 483,
    TrialSpawnerOpenShutter = 484,
    TrialSpawnerEjectItem = 485,
    TrialSpawnerDetectPlayer = 486,
    TrialSpawnerSpawnMob = 487,
    TrialSpawnerCloseShutter = 488,
    TrialSpawnerAmbient = 489,
    CopperBulbTurnOn = 490,
    CopperBulbTurnOff = 491,
    AmbientInAir = 492,
    BreezeWindChargeBurst = 493,
    ImitateBreeze = 494,
    ArmadilloBrush = 495,
    ArmadilloScuteDrop = 496,
    EquipWolf = 497,
    UnequipWolf = 498,
    Reflect = 499,
    VaultOpenShutter = 500,
    VaultCloseShutter = 501,
    VaultEjectItem = 502,
    VaultInsertItem = 503,
    VaultInsertItemFail = 504,
    VaultAmbient = 505,
    VaultActivate = 506,
    VaultDeactive = 507,
    HurtReduced = 508,
    WindChargeBurst = 509,
    ImitateBogged = 510,
    WolfArmourCrack = 511,
    WolfArmourBreak = 512,
    WolfArmourRepair = 513,
    MaceSmashAir = 514,
    MaceSmashGround = 515,
    TrialSpawnerChargeActivate = 516,
    TrialSpawnerAmbientOminous = 517,
    OminiousItemSpawnerSpawnItem = 518,
    OminousBottleEndUse = 519,
    MaceHeavySmashGround = 520,
    OminousItemSpawnerSpawnItemBegin = 521,
    Unknown522 = 522,
    ApplyEffectBadOmen = 523,
    ApplyEffectRaidOmen = 524,
    ApplyEffectTrialOmen = 525,
    OminousItemSpawnerAboutToSpawnItem = 526,
    RecordCreator = 527,
    RecordCreatorMusicBox = 528,
    RecordPrecipice = 529,
    VaultRejectRewardedPlayer = 530,
    ImitateDrowned = 531,
    ImitateCreaking = 532,
    BundleInsertFailed = 533,
    SpongeAbsorb = 534,
    Unknown535 = 535,
    BlockCreakingHeartTrail = 536,
    CreakingHeartSpawn = 537,
    Activate = 538,
    Deactivate = 539,
    Freeze = 540,
    Unfreeze = 541,
    Open = 542,
    OpenLong = 543,
    Close = 544,
    CloseLong = 545,
    ImitatePhantom = 546,
    ImitateZoglin = 547,
    ImitateGuardian = 548,
    ImitateRavager = 549,
    ImitatePillager = 550,
    PlaceInWater = 551,
    StateChange = 552,
    ImitateHappyGhast = 553,
    UniqueGeneric = 554,
    RecordTears = 555,
    TheEndLightFlash = 556,
    LeadLeash = 557,
    LeadUnleash = 558,
    LeadBreak = 559,
    Unsaddle = 560,
    EquipCopper = 561,
    RecordLavaChicken = 562,
    PlaceItem = 563,
    SingleItemSwap = 564,
    MultiItemSwap = 565,
    ItemEnchantLunge1 = 566,
    ItemEnchantLunge2 = 567,
    ItemEnchantLunge3 = 568,
    AttackCritical = 569,
    ItemSpearAttackHit = 570,
    ItemSpearAttackMiss = 571,
    ItemWoodenSpearAttackHit = 572,
    ItemWoodenSpearAttackMiss = 573,
    ImitateParched = 574,
    ImitateCamelHusk = 575,
    ItemSpearUse = 576,
    ItemWoodenSpearUse = 577,
}
impl crate::bedrock::codec::BedrockCodec for SoundType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SoundType::ItemUseOn),
            1 => Ok(SoundType::Hit),
            2 => Ok(SoundType::Step),
            3 => Ok(SoundType::Fly),
            4 => Ok(SoundType::Jump),
            5 => Ok(SoundType::Break),
            6 => Ok(SoundType::Place),
            7 => Ok(SoundType::HeavyStep),
            8 => Ok(SoundType::Gallop),
            9 => Ok(SoundType::Fall),
            10 => Ok(SoundType::Ambient),
            11 => Ok(SoundType::AmbientBaby),
            12 => Ok(SoundType::AmbientInWater),
            13 => Ok(SoundType::Breathe),
            14 => Ok(SoundType::Death),
            15 => Ok(SoundType::DeathInWater),
            16 => Ok(SoundType::DeathToZombie),
            17 => Ok(SoundType::Hurt),
            18 => Ok(SoundType::HurtInWater),
            19 => Ok(SoundType::Mad),
            20 => Ok(SoundType::Boost),
            21 => Ok(SoundType::Bow),
            22 => Ok(SoundType::SquishBig),
            23 => Ok(SoundType::SquishSmall),
            24 => Ok(SoundType::FallBig),
            25 => Ok(SoundType::FallSmall),
            26 => Ok(SoundType::Splash),
            27 => Ok(SoundType::Fizz),
            28 => Ok(SoundType::Flap),
            29 => Ok(SoundType::Swim),
            30 => Ok(SoundType::Drink),
            31 => Ok(SoundType::Eat),
            32 => Ok(SoundType::Takeoff),
            33 => Ok(SoundType::Shake),
            34 => Ok(SoundType::Plop),
            35 => Ok(SoundType::Land),
            36 => Ok(SoundType::Saddle),
            37 => Ok(SoundType::Armor),
            38 => Ok(SoundType::ArmorStandPlace),
            39 => Ok(SoundType::AddChest),
            40 => Ok(SoundType::Throw),
            41 => Ok(SoundType::Attack),
            42 => Ok(SoundType::AttackNoDamage),
            43 => Ok(SoundType::AttackStrong),
            44 => Ok(SoundType::Warn),
            45 => Ok(SoundType::Shear),
            46 => Ok(SoundType::Milk),
            47 => Ok(SoundType::Thunder),
            48 => Ok(SoundType::Explode),
            49 => Ok(SoundType::Fire),
            50 => Ok(SoundType::Ignite),
            51 => Ok(SoundType::Fuse),
            52 => Ok(SoundType::Stare),
            53 => Ok(SoundType::Spawn),
            54 => Ok(SoundType::Shoot),
            55 => Ok(SoundType::BreakBlock),
            56 => Ok(SoundType::Launch),
            57 => Ok(SoundType::Blast),
            58 => Ok(SoundType::LargeBlast),
            59 => Ok(SoundType::Twinkle),
            60 => Ok(SoundType::Remedy),
            61 => Ok(SoundType::Unfect),
            62 => Ok(SoundType::LevelUp),
            63 => Ok(SoundType::BowHit),
            64 => Ok(SoundType::BulletHit),
            65 => Ok(SoundType::ExtinguishFire),
            66 => Ok(SoundType::ItemFizz),
            67 => Ok(SoundType::ChestOpen),
            68 => Ok(SoundType::ChestClosed),
            69 => Ok(SoundType::ShulkerBoxOpen),
            70 => Ok(SoundType::ShulkerBoxClosed),
            71 => Ok(SoundType::EnderChestOpen),
            72 => Ok(SoundType::EnderChestClosed),
            73 => Ok(SoundType::PowerOn),
            74 => Ok(SoundType::PowerOff),
            75 => Ok(SoundType::Attach),
            76 => Ok(SoundType::Detach),
            77 => Ok(SoundType::Deny),
            78 => Ok(SoundType::Tripod),
            79 => Ok(SoundType::Pop),
            80 => Ok(SoundType::DropSlot),
            81 => Ok(SoundType::Note),
            82 => Ok(SoundType::Thorns),
            83 => Ok(SoundType::PistonIn),
            84 => Ok(SoundType::PistonOut),
            85 => Ok(SoundType::Portal),
            86 => Ok(SoundType::Water),
            87 => Ok(SoundType::LavaPop),
            88 => Ok(SoundType::Lava),
            89 => Ok(SoundType::Burp),
            90 => Ok(SoundType::BucketFillWater),
            91 => Ok(SoundType::BucketFillLava),
            92 => Ok(SoundType::BucketEmptyWater),
            93 => Ok(SoundType::BucketEmptyLava),
            94 => Ok(SoundType::ArmorEquipChain),
            95 => Ok(SoundType::ArmorEquipDiamond),
            96 => Ok(SoundType::ArmorEquipGeneric),
            97 => Ok(SoundType::ArmorEquipGold),
            98 => Ok(SoundType::ArmorEquipIron),
            99 => Ok(SoundType::ArmorEquipLeather),
            100 => Ok(SoundType::ArmorEquipElytra),
            101 => Ok(SoundType::Record13),
            102 => Ok(SoundType::RecordCat),
            103 => Ok(SoundType::RecordBlocks),
            104 => Ok(SoundType::RecordChirp),
            105 => Ok(SoundType::RecordFar),
            106 => Ok(SoundType::RecordMall),
            107 => Ok(SoundType::RecordMellohi),
            108 => Ok(SoundType::RecordStal),
            109 => Ok(SoundType::RecordStrad),
            110 => Ok(SoundType::RecordWard),
            111 => Ok(SoundType::Record11),
            112 => Ok(SoundType::RecordWait),
            113 => Ok(SoundType::StopRecord),
            114 => Ok(SoundType::Flop),
            115 => Ok(SoundType::GuardianCurse),
            116 => Ok(SoundType::MobWarning),
            117 => Ok(SoundType::MobWarningBaby),
            118 => Ok(SoundType::Teleport),
            119 => Ok(SoundType::ShulkerOpen),
            120 => Ok(SoundType::ShulkerClose),
            121 => Ok(SoundType::Haggle),
            122 => Ok(SoundType::HaggleYes),
            123 => Ok(SoundType::HaggleNo),
            124 => Ok(SoundType::HaggleIdle),
            125 => Ok(SoundType::ChorusGrow),
            126 => Ok(SoundType::ChorusDeath),
            127 => Ok(SoundType::Glass),
            128 => Ok(SoundType::PotionBrewed),
            129 => Ok(SoundType::CastSpell),
            130 => Ok(SoundType::PrepareAttackSpell),
            131 => Ok(SoundType::PrepareSummon),
            132 => Ok(SoundType::PrepareWololo),
            133 => Ok(SoundType::Fang),
            134 => Ok(SoundType::Charge),
            135 => Ok(SoundType::CameraTakePicture),
            136 => Ok(SoundType::LeashKnotPlace),
            137 => Ok(SoundType::LeashKnotBreak),
            138 => Ok(SoundType::AmbientGrowl),
            139 => Ok(SoundType::AmbientWhine),
            140 => Ok(SoundType::AmbientPant),
            141 => Ok(SoundType::AmbientPurr),
            142 => Ok(SoundType::AmbientPurreow),
            143 => Ok(SoundType::DeathMinVolume),
            144 => Ok(SoundType::DeathMidVolume),
            145 => Ok(SoundType::ImitateBlaze),
            146 => Ok(SoundType::ImitateCaveSpider),
            147 => Ok(SoundType::ImitateCreeper),
            148 => Ok(SoundType::ImitateElderGuardian),
            149 => Ok(SoundType::ImitateEnderDragon),
            150 => Ok(SoundType::ImitateEnderman),
            151 => Ok(SoundType::ImitateEndermite),
            152 => Ok(SoundType::ImitateEvocationIllager),
            153 => Ok(SoundType::ImitateGhast),
            154 => Ok(SoundType::ImitateHusk),
            155 => Ok(SoundType::ImitateIllusionIllager),
            156 => Ok(SoundType::ImitateMagmaCube),
            157 => Ok(SoundType::ImitatePolarBear),
            158 => Ok(SoundType::ImitateShulker),
            159 => Ok(SoundType::ImitateSilverfish),
            160 => Ok(SoundType::ImitateSkeleton),
            161 => Ok(SoundType::ImitateSlime),
            162 => Ok(SoundType::ImitateSpider),
            163 => Ok(SoundType::ImitateStray),
            164 => Ok(SoundType::ImitateVex),
            165 => Ok(SoundType::ImitateVindicationIllager),
            166 => Ok(SoundType::ImitateWitch),
            167 => Ok(SoundType::ImitateWither),
            168 => Ok(SoundType::ImitateWitherSkeleton),
            169 => Ok(SoundType::ImitateWolf),
            170 => Ok(SoundType::ImitateZombie),
            171 => Ok(SoundType::ImitateZombiePigman),
            172 => Ok(SoundType::ImitateZombieVillager),
            173 => Ok(SoundType::EnderEyePlaced),
            174 => Ok(SoundType::EndPortalCreated),
            175 => Ok(SoundType::AnvilUse),
            176 => Ok(SoundType::BottleDragonBreath),
            177 => Ok(SoundType::PortalTravel),
            178 => Ok(SoundType::TridentHit),
            179 => Ok(SoundType::TridentReturn),
            180 => Ok(SoundType::TridentRiptide1),
            181 => Ok(SoundType::TridentRiptide2),
            182 => Ok(SoundType::TridentRiptide3),
            183 => Ok(SoundType::TridentThrow),
            184 => Ok(SoundType::TridentThunder),
            185 => Ok(SoundType::TridentHitGround),
            186 => Ok(SoundType::Default),
            187 => Ok(SoundType::FletchingTableUse),
            188 => Ok(SoundType::ElemConstructOpen),
            189 => Ok(SoundType::IceBombHit),
            190 => Ok(SoundType::BalloonPop),
            191 => Ok(SoundType::LtReactionIceBomb),
            192 => Ok(SoundType::LtReactionBleach),
            193 => Ok(SoundType::LtReactionElephantToothpaste),
            194 => Ok(SoundType::LtReactionElephantToothpaste2),
            195 => Ok(SoundType::LtReactionGlowStick),
            196 => Ok(SoundType::LtReactionGlowStick2),
            197 => Ok(SoundType::LtReactionLuminol),
            198 => Ok(SoundType::LtReactionSalt),
            199 => Ok(SoundType::LtReactionFertilizer),
            200 => Ok(SoundType::LtReactionFireball),
            201 => Ok(SoundType::LtReactionMagnesiumSalt),
            202 => Ok(SoundType::LtReactionMiscFire),
            203 => Ok(SoundType::LtReactionFire),
            204 => Ok(SoundType::LtReactionMiscExplosion),
            205 => Ok(SoundType::LtReactionMiscMystical),
            206 => Ok(SoundType::LtReactionMiscMystical2),
            207 => Ok(SoundType::LtReactionProduct),
            208 => Ok(SoundType::SparklerUse),
            209 => Ok(SoundType::GlowStickUse),
            210 => Ok(SoundType::SparklerActive),
            211 => Ok(SoundType::ConvertToDrowned),
            212 => Ok(SoundType::BucketFillFish),
            213 => Ok(SoundType::BucketEmptyFish),
            214 => Ok(SoundType::BubbleColumnUpwards),
            215 => Ok(SoundType::BubbleColumnDownwards),
            216 => Ok(SoundType::BubblePop),
            217 => Ok(SoundType::BubbleUpInside),
            218 => Ok(SoundType::BubbleDownInside),
            219 => Ok(SoundType::HurtBaby),
            220 => Ok(SoundType::DeathBaby),
            221 => Ok(SoundType::StepBaby),
            222 => Ok(SoundType::SpawnBaby),
            223 => Ok(SoundType::Born),
            224 => Ok(SoundType::TurtleEggBreak),
            225 => Ok(SoundType::TurtleEggCrack),
            226 => Ok(SoundType::TurtleEggHatched),
            227 => Ok(SoundType::LayEgg),
            228 => Ok(SoundType::TurtleEggAttacked),
            229 => Ok(SoundType::BeaconActivate),
            230 => Ok(SoundType::BeaconAmbient),
            231 => Ok(SoundType::BeaconDeactivate),
            232 => Ok(SoundType::BeaconPower),
            233 => Ok(SoundType::ConduitActivate),
            234 => Ok(SoundType::ConduitAmbient),
            235 => Ok(SoundType::ConduitAttack),
            236 => Ok(SoundType::ConduitDeactivate),
            237 => Ok(SoundType::ConduitShort),
            238 => Ok(SoundType::Swoop),
            239 => Ok(SoundType::BambooSaplingPlace),
            240 => Ok(SoundType::PreSneeze),
            241 => Ok(SoundType::Sneeze),
            242 => Ok(SoundType::AmbientTame),
            243 => Ok(SoundType::Scared),
            244 => Ok(SoundType::ScaffoldingClimb),
            245 => Ok(SoundType::CrossbowLoadingStart),
            246 => Ok(SoundType::CrossbowLoadingMiddle),
            247 => Ok(SoundType::CrossbowLoadingEnd),
            248 => Ok(SoundType::CrossbowShoot),
            249 => Ok(SoundType::CrossbowQuickChargeStart),
            250 => Ok(SoundType::CrossbowQuickChargeMiddle),
            251 => Ok(SoundType::CrossbowQuickChargeEnd),
            252 => Ok(SoundType::AmbientAggressive),
            253 => Ok(SoundType::AmbientWorried),
            254 => Ok(SoundType::CantBreed),
            255 => Ok(SoundType::ShieldBlock),
            256 => Ok(SoundType::LecternBookPlace),
            257 => Ok(SoundType::GrindstoneUse),
            258 => Ok(SoundType::Bell),
            259 => Ok(SoundType::CampfireCrackle),
            260 => Ok(SoundType::Roar),
            261 => Ok(SoundType::Stun),
            262 => Ok(SoundType::SweetBerryBushHurt),
            263 => Ok(SoundType::SweetBerryBushPick),
            264 => Ok(SoundType::CartographyTableUse),
            265 => Ok(SoundType::StonecutterUse),
            266 => Ok(SoundType::ComposterEmpty),
            267 => Ok(SoundType::ComposterFill),
            268 => Ok(SoundType::ComposterFillLayer),
            269 => Ok(SoundType::ComposterReady),
            270 => Ok(SoundType::BarrelOpen),
            271 => Ok(SoundType::BarrelClose),
            272 => Ok(SoundType::RaidHorn),
            273 => Ok(SoundType::LoomUse),
            274 => Ok(SoundType::AmbientInRaid),
            275 => Ok(SoundType::UicartographyTableUse),
            276 => Ok(SoundType::UistonecutterUse),
            277 => Ok(SoundType::UiloomUse),
            278 => Ok(SoundType::SmokerUse),
            279 => Ok(SoundType::BlastFurnaceUse),
            280 => Ok(SoundType::SmithingTableUse),
            281 => Ok(SoundType::Screech),
            282 => Ok(SoundType::Sleep),
            283 => Ok(SoundType::FurnaceUse),
            284 => Ok(SoundType::MooshroomConvert),
            285 => Ok(SoundType::MilkSuspiciously),
            286 => Ok(SoundType::Celebrate),
            287 => Ok(SoundType::JumpPrevent),
            288 => Ok(SoundType::AmbientPollinate),
            289 => Ok(SoundType::BeehiveDrip),
            290 => Ok(SoundType::BeehiveEnter),
            291 => Ok(SoundType::BeehiveExit),
            292 => Ok(SoundType::BeehiveWork),
            293 => Ok(SoundType::BeehiveShear),
            294 => Ok(SoundType::HoneybottleDrink),
            295 => Ok(SoundType::AmbientCave),
            296 => Ok(SoundType::Retreat),
            297 => Ok(SoundType::ConvertToZombified),
            298 => Ok(SoundType::Admire),
            299 => Ok(SoundType::StepLava),
            300 => Ok(SoundType::Tempt),
            301 => Ok(SoundType::Panic),
            302 => Ok(SoundType::Angry),
            303 => Ok(SoundType::AmbientMoodWarpedForest),
            304 => Ok(SoundType::AmbientMoodSoulsandValley),
            305 => Ok(SoundType::AmbientMoodNetherWastes),
            306 => Ok(SoundType::AmbientMoodBasaltDeltas),
            307 => Ok(SoundType::AmbientMoodCrimsonForest),
            308 => Ok(SoundType::RespawnAnchorCharge),
            309 => Ok(SoundType::RespawnAnchorDeplete),
            310 => Ok(SoundType::RespawnAnchorSetSpawn),
            311 => Ok(SoundType::RespawnAnchorAmbient),
            312 => Ok(SoundType::SoulEscapeQuiet),
            313 => Ok(SoundType::SoulEscapeLoud),
            314 => Ok(SoundType::RecordPigstep),
            315 => Ok(SoundType::LinkCompassToLodestone),
            316 => Ok(SoundType::UseSmithingTable),
            317 => Ok(SoundType::EquipNetherite),
            318 => Ok(SoundType::AmbientLoopWarpedForest),
            319 => Ok(SoundType::AmbientLoopSoulsandValley),
            320 => Ok(SoundType::AmbientLoopNetherWastes),
            321 => Ok(SoundType::AmbientLoopBasaltDeltas),
            322 => Ok(SoundType::AmbientLoopCrimsonForest),
            323 => Ok(SoundType::AmbientAdditionWarpedForest),
            324 => Ok(SoundType::AmbientAdditionSoulsandValley),
            325 => Ok(SoundType::AmbientAdditionNetherWastes),
            326 => Ok(SoundType::AmbientAdditionBasaltDeltas),
            327 => Ok(SoundType::AmbientAdditionCrimsonForest),
            328 => Ok(SoundType::SculkSensorPowerOn),
            329 => Ok(SoundType::SculkSensorPowerOff),
            330 => Ok(SoundType::BucketFillPowderSnow),
            331 => Ok(SoundType::BucketEmptyPowderSnow),
            332 => Ok(SoundType::PointedDripstoneCauldronDripWater),
            333 => Ok(SoundType::PointedDripstoneCauldronDripLava),
            334 => Ok(SoundType::PointedDripstoneDripWater),
            335 => Ok(SoundType::PointedDripstoneDripLava),
            336 => Ok(SoundType::CaveVinesPickBerries),
            337 => Ok(SoundType::BigDripleafTiltDown),
            338 => Ok(SoundType::BigDripleafTiltUp),
            339 => Ok(SoundType::CopperWaxOn),
            340 => Ok(SoundType::CopperWaxOff),
            341 => Ok(SoundType::Scrape),
            342 => Ok(SoundType::PlayerHurtDrown),
            343 => Ok(SoundType::PlayerHurtOnFire),
            344 => Ok(SoundType::PlayerHurtFreeze),
            345 => Ok(SoundType::UseSpyglass),
            346 => Ok(SoundType::StopUsingSpyglass),
            347 => Ok(SoundType::AmethystBlockChime),
            348 => Ok(SoundType::AmbientScreamer),
            349 => Ok(SoundType::HurtScreamer),
            350 => Ok(SoundType::DeathScreamer),
            351 => Ok(SoundType::MilkScreamer),
            352 => Ok(SoundType::JumpToBlock),
            353 => Ok(SoundType::PreRam),
            354 => Ok(SoundType::PreRamScreamer),
            355 => Ok(SoundType::RamImpact),
            356 => Ok(SoundType::RamImpactScreamer),
            357 => Ok(SoundType::SquidInkSquirt),
            358 => Ok(SoundType::GlowSquidInkSquirt),
            359 => Ok(SoundType::ConvertToStray),
            360 => Ok(SoundType::CakeAddCandle),
            361 => Ok(SoundType::ExtinguishCandle),
            362 => Ok(SoundType::AmbientCandle),
            363 => Ok(SoundType::BlockClick),
            364 => Ok(SoundType::BlockClickFail),
            365 => Ok(SoundType::SculkCatalystBloom),
            366 => Ok(SoundType::SculkShriekerShriek),
            367 => Ok(SoundType::WardenNearbyClose),
            368 => Ok(SoundType::WardenNearbyCloser),
            369 => Ok(SoundType::WardenNearbyClosest),
            370 => Ok(SoundType::WardenSlightlyAngry),
            371 => Ok(SoundType::RecordOtherside),
            372 => Ok(SoundType::Tongue),
            373 => Ok(SoundType::CrackIronGolem),
            374 => Ok(SoundType::RepairIronGolem),
            375 => Ok(SoundType::Listening),
            376 => Ok(SoundType::Heartbeat),
            377 => Ok(SoundType::HornBreak),
            378 => Ok(SoundType::Unknown),
            379 => Ok(SoundType::SculkSpread),
            380 => Ok(SoundType::SculkCharge),
            381 => Ok(SoundType::SculkSensorPlace),
            382 => Ok(SoundType::SculkShriekerPlace),
            383 => Ok(SoundType::GoatCall0),
            384 => Ok(SoundType::GoatCall1),
            385 => Ok(SoundType::GoatCall2),
            386 => Ok(SoundType::GoatCall3),
            387 => Ok(SoundType::GoatCall4),
            388 => Ok(SoundType::GoatCall5),
            389 => Ok(SoundType::GoatCall6),
            390 => Ok(SoundType::GoatCall7),
            391 => Ok(SoundType::GoatCall8),
            392 => Ok(SoundType::GoatCall9),
            393 => Ok(SoundType::GoatHarmony0),
            394 => Ok(SoundType::GoatHarmony1),
            395 => Ok(SoundType::GoatHarmony2),
            396 => Ok(SoundType::GoatHarmony3),
            397 => Ok(SoundType::GoatHarmony4),
            398 => Ok(SoundType::GoatHarmony5),
            399 => Ok(SoundType::GoatHarmony6),
            400 => Ok(SoundType::GoatHarmony7),
            401 => Ok(SoundType::GoatHarmony8),
            402 => Ok(SoundType::GoatHarmony9),
            403 => Ok(SoundType::GoatMelody0),
            404 => Ok(SoundType::GoatMelody1),
            405 => Ok(SoundType::GoatMelody2),
            406 => Ok(SoundType::GoatMelody3),
            407 => Ok(SoundType::GoatMelody4),
            408 => Ok(SoundType::GoatMelody5),
            409 => Ok(SoundType::GoatMelody6),
            410 => Ok(SoundType::GoatMelody7),
            411 => Ok(SoundType::GoatMelody8),
            412 => Ok(SoundType::GoatMelody9),
            413 => Ok(SoundType::GoatBass0),
            414 => Ok(SoundType::GoatBass1),
            415 => Ok(SoundType::GoatBass2),
            416 => Ok(SoundType::GoatBass3),
            417 => Ok(SoundType::GoatBass4),
            418 => Ok(SoundType::GoatBass5),
            419 => Ok(SoundType::GoatBass6),
            420 => Ok(SoundType::GoatBass7),
            421 => Ok(SoundType::GoatBass8),
            422 => Ok(SoundType::GoatBass9),
            423 => Ok(SoundType::Unknown),
            424 => Ok(SoundType::Unknown),
            425 => Ok(SoundType::Unknown),
            426 => Ok(SoundType::ImitateWarden),
            427 => Ok(SoundType::ListeningAngry),
            428 => Ok(SoundType::ItemGiven),
            429 => Ok(SoundType::ItemTaken),
            430 => Ok(SoundType::Disappeared),
            431 => Ok(SoundType::Reappeared),
            432 => Ok(SoundType::DrinkMilk),
            433 => Ok(SoundType::FrogspawnHatched),
            434 => Ok(SoundType::LaySpawn),
            435 => Ok(SoundType::FrogspawnBreak),
            436 => Ok(SoundType::SonicBoom),
            437 => Ok(SoundType::SonicCharge),
            438 => Ok(SoundType::SoundeventItemThrown),
            439 => Ok(SoundType::Record5),
            440 => Ok(SoundType::ConvertToFrog),
            441 => Ok(SoundType::RecordPlaying),
            442 => Ok(SoundType::EnchantingTableUse),
            443 => Ok(SoundType::StepSand),
            444 => Ok(SoundType::DashReady),
            445 => Ok(SoundType::BundleDropContents),
            446 => Ok(SoundType::BundleInsert),
            447 => Ok(SoundType::BundleRemoveOne),
            448 => Ok(SoundType::PressurePlateClickOff),
            449 => Ok(SoundType::PressurePlateClickOn),
            450 => Ok(SoundType::ButtonClickOff),
            451 => Ok(SoundType::ButtonClickOn),
            452 => Ok(SoundType::DoorOpen),
            453 => Ok(SoundType::DoorClose),
            454 => Ok(SoundType::TrapdoorOpen),
            455 => Ok(SoundType::TrapdoorClose),
            456 => Ok(SoundType::FenceGateOpen),
            457 => Ok(SoundType::FenceGateClose),
            458 => Ok(SoundType::Insert),
            459 => Ok(SoundType::Pickup),
            460 => Ok(SoundType::InsertEnchanted),
            461 => Ok(SoundType::PickupEnchanted),
            462 => Ok(SoundType::Brush),
            463 => Ok(SoundType::BrushCompleted),
            464 => Ok(SoundType::ShatterDecoratedPot),
            465 => Ok(SoundType::BreakDecoratedPot),
            466 => Ok(SoundType::SnifferEggCrack),
            467 => Ok(SoundType::SnifferEggHatched),
            468 => Ok(SoundType::WaxedSignInteractFail),
            469 => Ok(SoundType::RecordRelic),
            470 => Ok(SoundType::Bump),
            471 => Ok(SoundType::PumpkinCarve),
            472 => Ok(SoundType::ConvertHuskToZombie),
            473 => Ok(SoundType::PigDeath),
            474 => Ok(SoundType::HoglinZombified),
            475 => Ok(SoundType::AmbientUnderwaterEnter),
            476 => Ok(SoundType::AmbientUnderwaterExit),
            477 => Ok(SoundType::BottleFill),
            478 => Ok(SoundType::BottleEmpty),
            479 => Ok(SoundType::CrafterCraft),
            480 => Ok(SoundType::CrafterFail),
            481 => Ok(SoundType::DecoratedPotInsert),
            482 => Ok(SoundType::DecoratedPotInsertFail),
            483 => Ok(SoundType::CrafterDisableSlot),
            484 => Ok(SoundType::TrialSpawnerOpenShutter),
            485 => Ok(SoundType::TrialSpawnerEjectItem),
            486 => Ok(SoundType::TrialSpawnerDetectPlayer),
            487 => Ok(SoundType::TrialSpawnerSpawnMob),
            488 => Ok(SoundType::TrialSpawnerCloseShutter),
            489 => Ok(SoundType::TrialSpawnerAmbient),
            490 => Ok(SoundType::CopperBulbTurnOn),
            491 => Ok(SoundType::CopperBulbTurnOff),
            492 => Ok(SoundType::AmbientInAir),
            493 => Ok(SoundType::BreezeWindChargeBurst),
            494 => Ok(SoundType::ImitateBreeze),
            495 => Ok(SoundType::ArmadilloBrush),
            496 => Ok(SoundType::ArmadilloScuteDrop),
            497 => Ok(SoundType::EquipWolf),
            498 => Ok(SoundType::UnequipWolf),
            499 => Ok(SoundType::Reflect),
            500 => Ok(SoundType::VaultOpenShutter),
            501 => Ok(SoundType::VaultCloseShutter),
            502 => Ok(SoundType::VaultEjectItem),
            503 => Ok(SoundType::VaultInsertItem),
            504 => Ok(SoundType::VaultInsertItemFail),
            505 => Ok(SoundType::VaultAmbient),
            506 => Ok(SoundType::VaultActivate),
            507 => Ok(SoundType::VaultDeactive),
            508 => Ok(SoundType::HurtReduced),
            509 => Ok(SoundType::WindChargeBurst),
            510 => Ok(SoundType::ImitateBogged),
            511 => Ok(SoundType::WolfArmourCrack),
            512 => Ok(SoundType::WolfArmourBreak),
            513 => Ok(SoundType::WolfArmourRepair),
            514 => Ok(SoundType::MaceSmashAir),
            515 => Ok(SoundType::MaceSmashGround),
            516 => Ok(SoundType::TrialSpawnerChargeActivate),
            517 => Ok(SoundType::TrialSpawnerAmbientOminous),
            518 => Ok(SoundType::OminiousItemSpawnerSpawnItem),
            519 => Ok(SoundType::OminousBottleEndUse),
            520 => Ok(SoundType::MaceHeavySmashGround),
            521 => Ok(SoundType::OminousItemSpawnerSpawnItemBegin),
            522 => Ok(SoundType::Unknown),
            523 => Ok(SoundType::ApplyEffectBadOmen),
            524 => Ok(SoundType::ApplyEffectRaidOmen),
            525 => Ok(SoundType::ApplyEffectTrialOmen),
            526 => Ok(SoundType::OminousItemSpawnerAboutToSpawnItem),
            527 => Ok(SoundType::RecordCreator),
            528 => Ok(SoundType::RecordCreatorMusicBox),
            529 => Ok(SoundType::RecordPrecipice),
            530 => Ok(SoundType::VaultRejectRewardedPlayer),
            531 => Ok(SoundType::ImitateDrowned),
            532 => Ok(SoundType::ImitateCreaking),
            533 => Ok(SoundType::BundleInsertFailed),
            534 => Ok(SoundType::SpongeAbsorb),
            535 => Ok(SoundType::Unknown),
            536 => Ok(SoundType::BlockCreakingHeartTrail),
            537 => Ok(SoundType::CreakingHeartSpawn),
            538 => Ok(SoundType::Activate),
            539 => Ok(SoundType::Deactivate),
            540 => Ok(SoundType::Freeze),
            541 => Ok(SoundType::Unfreeze),
            542 => Ok(SoundType::Open),
            543 => Ok(SoundType::OpenLong),
            544 => Ok(SoundType::Close),
            545 => Ok(SoundType::CloseLong),
            546 => Ok(SoundType::ImitatePhantom),
            547 => Ok(SoundType::ImitateZoglin),
            548 => Ok(SoundType::ImitateGuardian),
            549 => Ok(SoundType::ImitateRavager),
            550 => Ok(SoundType::ImitatePillager),
            551 => Ok(SoundType::PlaceInWater),
            552 => Ok(SoundType::StateChange),
            553 => Ok(SoundType::ImitateHappyGhast),
            554 => Ok(SoundType::UniqueGeneric),
            555 => Ok(SoundType::RecordTears),
            556 => Ok(SoundType::TheEndLightFlash),
            557 => Ok(SoundType::LeadLeash),
            558 => Ok(SoundType::LeadUnleash),
            559 => Ok(SoundType::LeadBreak),
            560 => Ok(SoundType::Unsaddle),
            561 => Ok(SoundType::EquipCopper),
            562 => Ok(SoundType::RecordLavaChicken),
            563 => Ok(SoundType::PlaceItem),
            564 => Ok(SoundType::SingleItemSwap),
            565 => Ok(SoundType::MultiItemSwap),
            566 => Ok(SoundType::ItemEnchantLunge1),
            567 => Ok(SoundType::ItemEnchantLunge2),
            568 => Ok(SoundType::ItemEnchantLunge3),
            569 => Ok(SoundType::AttackCritical),
            570 => Ok(SoundType::ItemSpearAttackHit),
            571 => Ok(SoundType::ItemSpearAttackMiss),
            572 => Ok(SoundType::ItemWoodenSpearAttackHit),
            573 => Ok(SoundType::ItemWoodenSpearAttackMiss),
            574 => Ok(SoundType::ImitateParched),
            575 => Ok(SoundType::ImitateCamelHusk),
            576 => Ok(SoundType::ItemSpearUse),
            577 => Ok(SoundType::ItemWoodenSpearUse),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SoundType),
                value: val as i64,
            }),
        }
    }
}
impl Default for SoundType {
    fn default() -> Self {
        Self::ItemUseOn
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureBlockSettingsRotation {
    None = 0,
    T90Deg = 1,
    T180Deg = 2,
    T270Deg = 3,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettingsRotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(StructureBlockSettingsRotation::None),
            1 => Ok(StructureBlockSettingsRotation::T90Deg),
            2 => Ok(StructureBlockSettingsRotation::T180Deg),
            3 => Ok(StructureBlockSettingsRotation::T270Deg),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StructureBlockSettingsRotation),
                value: val as i64,
            }),
        }
    }
}
impl Default for StructureBlockSettingsRotation {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureBlockSettingsMirror {
    None = 0,
    XAxis = 1,
    ZAxis = 2,
    BothAxes = 3,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettingsMirror {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(StructureBlockSettingsMirror::None),
            1 => Ok(StructureBlockSettingsMirror::XAxis),
            2 => Ok(StructureBlockSettingsMirror::ZAxis),
            3 => Ok(StructureBlockSettingsMirror::BothAxes),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StructureBlockSettingsMirror),
                value: val as i64,
            }),
        }
    }
}
impl Default for StructureBlockSettingsMirror {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureBlockSettingsAnimationMode {
    None = 0,
    Layers = 1,
    Blocks = 2,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettingsAnimationMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(StructureBlockSettingsAnimationMode::None),
            1 => Ok(StructureBlockSettingsAnimationMode::Layers),
            2 => Ok(StructureBlockSettingsAnimationMode::Blocks),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StructureBlockSettingsAnimationMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for StructureBlockSettingsAnimationMode {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StructureBlockSettings {
    pub palette_name: String,
    pub ignore_entities: bool,
    pub ignore_blocks: bool,
    pub non_ticking_players_and_ticking_areas: bool,
    pub size: BlockCoordinates,
    pub structure_offset: BlockCoordinates,
    pub last_editing_player_unique_id: i64,
    pub rotation: StructureBlockSettingsRotation,
    pub mirror: StructureBlockSettingsMirror,
    pub animation_mode: StructureBlockSettingsAnimationMode,
    pub animation_duration: f32,
    pub integrity: f32,
    pub seed: u32,
    pub pivot: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.palette_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.palette_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.ignore_entities.encode(buf)?;
        self.ignore_blocks.encode(buf)?;
        self.non_ticking_players_and_ticking_areas.encode(buf)?;
        self.size.encode(buf)?;
        self.structure_offset.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.last_editing_player_unique_id).encode(buf)?;
        self.rotation.encode(buf)?;
        self.mirror.encode(buf)?;
        self.animation_mode.encode(buf)?;
        crate::bedrock::codec::F32LE(self.animation_duration).encode(buf)?;
        crate::bedrock::codec::F32LE(self.integrity).encode(buf)?;
        crate::bedrock::codec::U32LE(self.seed).encode(buf)?;
        self.pivot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let palette_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let ignore_entities = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let ignore_blocks = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let non_ticking_players_and_ticking_areas =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let size = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let structure_offset =
            <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let last_editing_player_unique_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let rotation =
            <StructureBlockSettingsRotation as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let mirror =
            <StructureBlockSettingsMirror as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let animation_mode =
            <StructureBlockSettingsAnimationMode as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let animation_duration =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let integrity =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let seed =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let pivot = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            palette_name,
            ignore_entities,
            ignore_blocks,
            non_ticking_players_and_ticking_areas,
            size,
            structure_offset,
            last_editing_player_unique_id,
            rotation,
            mirror,
            animation_mode,
            animation_duration,
            integrity,
            seed,
            pivot,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithCachingItemResult {
    Undefined = 0,
    Success = 1,
    ChunkNotFound = 2,
    InvalidDimension = 3,
    PlayerNotFound = 4,
    YIndexOutOfBounds = 5,
    SuccessAllAir = 6,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItemResult {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SubChunkEntryWithCachingItemResult::Undefined),
            1 => Ok(SubChunkEntryWithCachingItemResult::Success),
            2 => Ok(SubChunkEntryWithCachingItemResult::ChunkNotFound),
            3 => Ok(SubChunkEntryWithCachingItemResult::InvalidDimension),
            4 => Ok(SubChunkEntryWithCachingItemResult::PlayerNotFound),
            5 => Ok(SubChunkEntryWithCachingItemResult::YIndexOutOfBounds),
            6 => Ok(SubChunkEntryWithCachingItemResult::SuccessAllAir),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SubChunkEntryWithCachingItemResult),
                value: val as i64,
            }),
        }
    }
}
impl Default for SubChunkEntryWithCachingItemResult {
    fn default() -> Self {
        Self::Undefined
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SubChunkEntryWithCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub result: SubChunkEntryWithCachingItemResult,
    pub payload: Option<ByteArray>,
    pub heightmap_type: HeightMapDataType,
    pub heightmap: Option<[u8; 256]>,
    pub render_heightmap_type: HeightMapDataType,
    pub render_heightmap: Option<[u8; 256]>,
    pub blob_id: u64,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithCachingItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        self.result.encode(buf)?;
        if let Some(v) = &self.payload {
            v.encode(buf)?;
        }
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            buf.put_slice(v);
        }
        self.render_heightmap_type.encode(buf)?;
        if let Some(v) = &self.render_heightmap {
            buf.put_slice(v);
        }
        crate::bedrock::codec::U64LE(self.blob_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let result =
            <SubChunkEntryWithCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let payload = match result {
            SubChunkEntryWithCachingItemResult::SuccessAllAir => None,
            _ => Some({
                let res: ByteArray = {
                    let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0 as i64;
                    if raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: raw,
                        });
                    }
                    let len = raw as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec.push(<u8 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?);
                    }
                    tmp_vec
                };
                res
            }),
        };
        let heightmap_type =
            <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let heightmap = match heightmap_type {
            HeightMapDataType::HasData => Some({
                if buf.remaining() < 256 {
                    return Err(crate::bedrock::error::DecodeError::UnexpectedEof {
                        needed: 256,
                        available: buf.remaining(),
                    });
                }
                let mut arr = [0u8; 256];
                buf.copy_to_slice(&mut arr);
                arr
            }),
            _ => None,
        };
        let render_heightmap_type =
            <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let render_heightmap = match render_heightmap_type {
            HeightMapDataType::HasData => Some({
                if buf.remaining() < 256 {
                    return Err(crate::bedrock::error::DecodeError::UnexpectedEof {
                        needed: 256,
                        available: buf.remaining(),
                    });
                }
                let mut arr = [0u8; 256];
                buf.copy_to_slice(&mut arr);
                arr
            }),
            _ => None,
        };
        let blob_id =
            <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            dx,
            dy,
            dz,
            result,
            payload,
            heightmap_type,
            heightmap,
            render_heightmap_type,
            render_heightmap,
            blob_id,
        })
    }
}
pub type SubChunkEntryWithCaching = Vec<SubChunkEntryWithCachingItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SubChunkEntryWithoutCachingItemResult {
    Undefined = 0,
    Success = 1,
    ChunkNotFound = 2,
    InvalidDimension = 3,
    PlayerNotFound = 4,
    YIndexOutOfBounds = 5,
    SuccessAllAir = 6,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithoutCachingItemResult {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SubChunkEntryWithoutCachingItemResult::Undefined),
            1 => Ok(SubChunkEntryWithoutCachingItemResult::Success),
            2 => Ok(SubChunkEntryWithoutCachingItemResult::ChunkNotFound),
            3 => Ok(SubChunkEntryWithoutCachingItemResult::InvalidDimension),
            4 => Ok(SubChunkEntryWithoutCachingItemResult::PlayerNotFound),
            5 => Ok(SubChunkEntryWithoutCachingItemResult::YIndexOutOfBounds),
            6 => Ok(SubChunkEntryWithoutCachingItemResult::SuccessAllAir),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SubChunkEntryWithoutCachingItemResult),
                value: val as i64,
            }),
        }
    }
}
impl Default for SubChunkEntryWithoutCachingItemResult {
    fn default() -> Self {
        Self::Undefined
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SubChunkEntryWithoutCachingItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
    pub result: SubChunkEntryWithoutCachingItemResult,
    pub payload: ByteArray,
    pub heightmap_type: HeightMapDataType,
    pub heightmap: Option<[u8; 256]>,
    pub render_heightmap_type: HeightMapDataType,
    pub render_heightmap: Option<[u8; 256]>,
}
impl crate::bedrock::codec::BedrockCodec for SubChunkEntryWithoutCachingItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        self.result.encode(buf)?;
        let len = self.payload.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.payload {
            (*item).encode(buf)?;
        }
        self.heightmap_type.encode(buf)?;
        if let Some(v) = &self.heightmap {
            buf.put_slice(v);
        }
        self.render_heightmap_type.encode(buf)?;
        if let Some(v) = &self.render_heightmap {
            buf.put_slice(v);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let result =
            <SubChunkEntryWithoutCachingItemResult as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let payload = {
            let res: ByteArray = {
                let raw =
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec.push(<u8 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?);
                }
                tmp_vec
            };
            res
        };
        let heightmap_type =
            <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let heightmap = match heightmap_type {
            HeightMapDataType::HasData => Some({
                if buf.remaining() < 256 {
                    return Err(crate::bedrock::error::DecodeError::UnexpectedEof {
                        needed: 256,
                        available: buf.remaining(),
                    });
                }
                let mut arr = [0u8; 256];
                buf.copy_to_slice(&mut arr);
                arr
            }),
            _ => None,
        };
        let render_heightmap_type =
            <HeightMapDataType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let render_heightmap = match render_heightmap_type {
            HeightMapDataType::HasData => Some({
                if buf.remaining() < 256 {
                    return Err(crate::bedrock::error::DecodeError::UnexpectedEof {
                        needed: 256,
                        available: buf.remaining(),
                    });
                }
                let mut arr = [0u8; 256];
                buf.copy_to_slice(&mut arr);
                arr
            }),
            _ => None,
        };
        Ok(Self {
            dx,
            dy,
            dz,
            result,
            payload,
            heightmap_type,
            heightmap,
            render_heightmap_type,
            render_heightmap,
        })
    }
}
pub type SubChunkEntryWithoutCaching = Vec<SubChunkEntryWithoutCachingItem>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TexturePackInfosItem {
    pub uuid: uuid::Uuid,
    pub version: String,
    pub size: u64,
    pub content_key: String,
    pub sub_pack_name: String,
    pub content_identity: String,
    pub has_scripts: bool,
    pub addon_pack: bool,
    pub rtx_enabled: bool,
    pub cdn_url: String,
}
impl crate::bedrock::codec::BedrockCodec for TexturePackInfosItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::U64LE(self.size).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.content_key)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.content_key).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.sub_pack_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.sub_pack_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.content_identity)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.content_identity).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.has_scripts.encode(buf)?;
        self.addon_pack.encode(buf)?;
        self.rtx_enabled.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.cdn_url)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.cdn_url).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let size =
            <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let content_key = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let sub_pack_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let content_identity = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let addon_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rtx_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let cdn_url = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            uuid,
            version,
            size,
            content_key,
            sub_pack_name,
            content_identity,
            has_scripts,
            addon_pack,
            rtx_enabled,
            cdn_url,
        })
    }
}
pub type TexturePackInfos = Vec<TexturePackInfosItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TrackedObjectType {
    Entity = 0,
    Block = 1,
}
impl crate::bedrock::codec::BedrockCodec for TrackedObjectType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TrackedObjectType::Entity),
            1 => Ok(TrackedObjectType::Block),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TrackedObjectType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TrackedObjectType {
    fn default() -> Self {
        Self::Entity
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrackedObject {
    pub type_: TrackedObjectType,
    pub entity_unique_id: Option<i64>,
    pub block_position: Option<BlockCoordinates>,
}
impl crate::bedrock::codec::BedrockCodec for TrackedObject {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
        }
        if let Some(v) = &self.block_position {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <TrackedObjectType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_unique_id = match type_ {
            TrackedObjectType::Entity => Some(
                <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            ),
            _ => None,
        };
        let block_position = match type_ {
            TrackedObjectType::Block => {
                Some(<BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        Ok(Self {
            type_,
            entity_unique_id,
            block_position,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionLegacyLegacyTransactionsItemChangedSlotsItem {
    pub slot_id: u8,
}
impl crate::bedrock::codec::BedrockCodec
    for TransactionLegacyLegacyTransactionsItemChangedSlotsItem
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.slot_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let slot_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { slot_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionLegacyLegacyTransactionsItem {
    pub container_id: u8,
    pub changed_slots: Vec<TransactionLegacyLegacyTransactionsItemChangedSlotsItem>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacyLegacyTransactionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.container_id.encode(buf)?;
        let len = self.changed_slots.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.changed_slots {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let container_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let changed_slots = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TransactionLegacyLegacyTransactionsItemChangedSlotsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            container_id,
            changed_slots,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionLegacy {
    pub legacy_request_id: i32,
    pub legacy_transactions: Option<Vec<TransactionLegacyLegacyTransactionsItem>>,
}
impl crate::bedrock::codec::BedrockCodec for TransactionLegacy {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.legacy_request_id).encode(buf)?;
        if let Some(v) = &self.legacy_transactions {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let legacy_request_id =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let legacy_transactions = if (legacy_request_id) != 0 {
            Some({
                let raw =
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TransactionLegacyLegacyTransactionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            })
        } else {
            None
        };
        Ok(Self {
            legacy_request_id,
            legacy_transactions,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionType {
    Normal = 0,
    InventoryMismatch = 1,
    ItemUse = 2,
    ItemUseOnEntity = 3,
    ItemRelease = 4,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TransactionTransactionType::Normal),
            1 => Ok(TransactionTransactionType::InventoryMismatch),
            2 => Ok(TransactionTransactionType::ItemUse),
            3 => Ok(TransactionTransactionType::ItemUseOnEntity),
            4 => Ok(TransactionTransactionType::ItemRelease),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TransactionTransactionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TransactionTransactionType {
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionActionsItemSourceType {
    Container = 0,
    Global = 1,
    WorldInteraction = 2,
    Creative = 3,
    // Manually added to fix crash (protocol update?)
    Creative2 = 248,
    CraftSlot = 100,
    Craft = 99999,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemSourceType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TransactionActionsItemSourceType::Container),
            1 => Ok(TransactionActionsItemSourceType::Global),
            2 => Ok(TransactionActionsItemSourceType::WorldInteraction),
            3 => Ok(TransactionActionsItemSourceType::Creative),
            248 => Ok(TransactionActionsItemSourceType::Creative2),
            100 => Ok(TransactionActionsItemSourceType::CraftSlot),
            99999 => Ok(TransactionActionsItemSourceType::Craft),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TransactionActionsItemSourceType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TransactionActionsItemSourceType {
    fn default() -> Self {
        Self::Container
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum WindowIdVarint {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Unknown3 = 3,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
    Creative2 = 248,
}
impl crate::bedrock::codec::BedrockCodec for WindowIdVarint {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            -100 => Ok(WindowIdVarint::DropContents),
            -24 => Ok(WindowIdVarint::Beacon),
            -23 => Ok(WindowIdVarint::TradingOutput),
            -22 => Ok(WindowIdVarint::TradingUseInputs),
            -21 => Ok(WindowIdVarint::TradingInput2),
            -20 => Ok(WindowIdVarint::TradingInput1),
            -17 => Ok(WindowIdVarint::EnchantOutput),
            -16 => Ok(WindowIdVarint::EnchantMaterial),
            -15 => Ok(WindowIdVarint::EnchantInput),
            -13 => Ok(WindowIdVarint::AnvilOutput),
            -12 => Ok(WindowIdVarint::AnvilResult),
            -11 => Ok(WindowIdVarint::AnvilMaterial),
            -10 => Ok(WindowIdVarint::ContainerInput),
            -5 => Ok(WindowIdVarint::CraftingUseIngredient),
            -4 => Ok(WindowIdVarint::CraftingResult),
            -3 => Ok(WindowIdVarint::CraftingRemoveIngredient),
            -2 => Ok(WindowIdVarint::CraftingAddIngredient),
            -1 => Ok(WindowIdVarint::None),
            0 => Ok(WindowIdVarint::Inventory),
            1 => Ok(WindowIdVarint::First),
            3 => Ok(WindowIdVarint::Unknown3),
            100 => Ok(WindowIdVarint::Last),
            119 => Ok(WindowIdVarint::Offhand),
            120 => Ok(WindowIdVarint::Armor),
            121 => Ok(WindowIdVarint::Creative),
            122 => Ok(WindowIdVarint::Hotbar),
            123 => Ok(WindowIdVarint::FixedInventory),
            124 => Ok(WindowIdVarint::Ui),
            248 => Ok(WindowIdVarint::Creative2),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(WindowIdVarint),
                value: val as i64,
            }),
        }
    }
}
impl Default for WindowIdVarint {
    fn default() -> Self {
        Self::DropContents
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionActionsItemContentContainer {
    pub inventory_id: WindowIdVarint,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemContentContainer {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.inventory_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let inventory_id =
            <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { inventory_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionActionsItemContentCraft {
    pub action: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemContentCraft {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.action).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { action })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionActionsItemContentWorldInteraction {
    pub flags: i32,
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItemContentWorldInteraction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.flags).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let flags = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        Ok(Self { flags })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionActionsItemContent {
    Container(TransactionActionsItemContentContainer),
    Craft(TransactionActionsItemContentCraft),
    CraftSlot(TransactionActionsItemContentCraft),
    WorldInteraction(TransactionActionsItemContentWorldInteraction),
}
impl Default for TransactionActionsItemContent {
    fn default() -> Self {
        Self::Container(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionActionsItem {
    pub source_type: TransactionActionsItemSourceType,
    pub content: Option<TransactionActionsItemContent>,
    pub slot: i32,
    pub old_item: Item,
    pub new_item: Item,
    pub stack_network_id: Option<i32>,
}
#[derive(Debug, Clone)]
pub struct TransactionActionsItemArgs {
    pub shield_item_id: i32,
    pub has_stack_net_ids: bool,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for TransactionActionsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
            has_stack_net_ids: false,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionActionsItem {
    type Args = TransactionActionsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        if let Some(id) = self.stack_network_id {
            crate::bedrock::codec::VarInt(id).encode(buf)?;
        }
        self.source_type.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                TransactionActionsItemContent::Container(v) => {
                    v.encode(buf)?;
                }
                TransactionActionsItemContent::Craft(v) => {
                    v.encode(buf)?;
                }
                TransactionActionsItemContent::CraftSlot(v) => {
                    v.encode(buf)?;
                }
                TransactionActionsItemContent::WorldInteraction(v) => {
                    v.encode(buf)?;
                }
            }
        }
        crate::bedrock::codec::VarInt(self.slot).encode(buf)?;
        self.old_item.encode(buf)?;
        self.new_item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let stack_network_id = if args.has_stack_net_ids {
            Some(
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            )
        } else {
            None
        };
        let source_type =
            <TransactionActionsItemSourceType as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        let content = match source_type {
            TransactionActionsItemSourceType::Container => {
                Some(
                    TransactionActionsItemContent::Container(
                        <TransactionActionsItemContentContainer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::Craft => {
                Some(
                    TransactionActionsItemContent::Craft(
                        <TransactionActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::CraftSlot => {
                Some(
                    TransactionActionsItemContent::CraftSlot(
                        <TransactionActionsItemContentCraft as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TransactionActionsItemSourceType::WorldInteraction => {
                Some(
                    TransactionActionsItemContent::WorldInteraction(
                        <TransactionActionsItemContentWorldInteraction as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        let slot = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let old_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let new_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            source_type,
            content,
            slot,
            old_item,
            new_item,
            stack_network_id,
        })
    }
}
pub type TransactionActions = Vec<TransactionActionsItem>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemReleaseActionType {
    Release = 0,
    Consume = 1,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemReleaseActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TransactionTransactionDataItemReleaseActionType::Release),
            1 => Ok(TransactionTransactionDataItemReleaseActionType::Consume),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TransactionTransactionDataItemReleaseActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TransactionTransactionDataItemReleaseActionType {
    fn default() -> Self {
        Self::Release
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionTransactionDataItemRelease {
    pub action_type: TransactionTransactionDataItemReleaseActionType,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub head_pos: Vec3F,
}
#[derive(Debug, Clone)]
pub struct TransactionTransactionDataItemReleaseArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
    for TransactionTransactionDataItemReleaseArgs
{
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemRelease {
    type Args = TransactionTransactionDataItemReleaseArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action_type.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot).encode(buf)?;
        self.held_item.encode(buf)?;
        self.head_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action_type = <TransactionTransactionDataItemReleaseActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hotbar_slot =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let head_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            action_type,
            hotbar_slot,
            held_item,
            head_pos,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionUseItemActionType {
    ClickBlock = 0,
    ClickAir = 1,
    BreakBlock = 2,
    Attack = 3,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItemActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TransactionUseItemActionType::ClickBlock),
            1 => Ok(TransactionUseItemActionType::ClickAir),
            2 => Ok(TransactionUseItemActionType::BreakBlock),
            3 => Ok(TransactionUseItemActionType::Attack),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TransactionUseItemActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TransactionUseItemActionType {
    fn default() -> Self {
        Self::ClickBlock
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionUseItemTriggerType {
    Unknown = 0,
    PlayerInput = 1,
    SimulationTick = 2,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItemTriggerType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TransactionUseItemTriggerType::Unknown),
            1 => Ok(TransactionUseItemTriggerType::PlayerInput),
            2 => Ok(TransactionUseItemTriggerType::SimulationTick),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TransactionUseItemTriggerType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TransactionUseItemTriggerType {
    fn default() -> Self {
        Self::Unknown
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionUseItemClientPrediction {
    Failure = 0,
    Success = 1,
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItemClientPrediction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TransactionUseItemClientPrediction::Failure),
            1 => Ok(TransactionUseItemClientPrediction::Success),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TransactionUseItemClientPrediction),
                value: val as i64,
            }),
        }
    }
}
impl Default for TransactionUseItemClientPrediction {
    fn default() -> Self {
        Self::Failure
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionUseItem {
    pub action_type: TransactionUseItemActionType,
    pub trigger_type: TransactionUseItemTriggerType,
    pub block_position: BlockCoordinates,
    pub face: i32,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
    pub block_runtime_id: i32,
    pub client_prediction: TransactionUseItemClientPrediction,
}
#[derive(Debug, Clone)]
pub struct TransactionUseItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for TransactionUseItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionUseItem {
    type Args = TransactionUseItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action_type.encode(buf)?;
        self.trigger_type.encode(buf)?;
        self.block_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.face).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot).encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id).encode(buf)?;
        self.client_prediction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        println!(
            "DEBUG: Decoding TransactionUseItem. Rem: {}",
            buf.remaining()
        );
        let action_type =
            <TransactionUseItemActionType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        println!(
            "DEBUG: action_type: {:?}. Rem: {}",
            action_type,
            buf.remaining()
        );
        let trigger_type =
            <TransactionUseItemTriggerType as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        println!(
            "DEBUG: trigger_type: {:?}. Rem: {}",
            trigger_type,
            buf.remaining()
        );
        let block_position =
            <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        println!(
            "DEBUG: block_position: {:?}. Rem: {}",
            block_position,
            buf.remaining()
        );
        let face =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        println!("DEBUG: face: {}. Rem: {}", face, buf.remaining());
        let hotbar_slot =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        println!(
            "DEBUG: hotbar_slot: {}. Rem: {}",
            hotbar_slot,
            buf.remaining()
        );
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        println!("DEBUG: held_item decoded. Rem: {}", buf.remaining());
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        println!(
            "DEBUG: player_pos: {:?}. Rem: {}",
            player_pos,
            buf.remaining()
        );
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        println!(
            "DEBUG: click_pos: {:?}. Rem: {}",
            click_pos,
            buf.remaining()
        );
        let block_runtime_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        println!(
            "DEBUG: block_runtime_id: {}. Rem: {}",
            block_runtime_id,
            buf.remaining()
        );
        let client_prediction =
            <TransactionUseItemClientPrediction as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?;
        println!(
            "DEBUG: client_prediction: {:?}. Rem: {}",
            client_prediction,
            buf.remaining()
        );
        Ok(Self {
            action_type,
            trigger_type,
            block_position,
            face,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
            block_runtime_id,
            client_prediction,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum TransactionTransactionDataItemUseOnEntityActionType {
    Interact = 0,
    Attack = 1,
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemUseOnEntityActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Interact),
            1 => Ok(TransactionTransactionDataItemUseOnEntityActionType::Attack),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TransactionTransactionDataItemUseOnEntityActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TransactionTransactionDataItemUseOnEntityActionType {
    fn default() -> Self {
        Self::Interact
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransactionTransactionDataItemUseOnEntity {
    pub entity_runtime_id: i64,
    pub action_type: TransactionTransactionDataItemUseOnEntityActionType,
    pub hotbar_slot: i32,
    pub held_item: Item,
    pub player_pos: Vec3F,
    pub click_pos: Vec3F,
}
#[derive(Debug, Clone)]
pub struct TransactionTransactionDataItemUseOnEntityArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
    for TransactionTransactionDataItemUseOnEntityArgs
{
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for TransactionTransactionDataItemUseOnEntity {
    type Args = TransactionTransactionDataItemUseOnEntityArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.entity_runtime_id).encode(buf)?;
        self.action_type.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.hotbar_slot).encode(buf)?;
        self.held_item.encode(buf)?;
        self.player_pos.encode(buf)?;
        self.click_pos.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_runtime_id =
            <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let action_type = <TransactionTransactionDataItemUseOnEntityActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hotbar_slot =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let player_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let click_pos = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_runtime_id,
            action_type,
            hotbar_slot,
            held_item,
            player_pos,
            click_pos,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionTransactionData {
    InventoryMismatch,
    ItemRelease(Box<TransactionTransactionDataItemRelease>),
    ItemUse(Box<TransactionUseItem>),
    ItemUseOnEntity(Box<TransactionTransactionDataItemUseOnEntity>),
    Normal,
}
impl Default for TransactionTransactionData {
    fn default() -> Self {
        Self::InventoryMismatch
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Transaction {
    pub legacy: TransactionLegacy,
    pub transaction_type: TransactionTransactionType,
    pub actions: TransactionActions,
    pub has_stack_net_ids: bool,
    pub transaction_data: Option<TransactionTransactionData>,
}
#[derive(Debug, Clone)]
pub struct TransactionArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for TransactionArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for Transaction {
    type Args = TransactionArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.legacy.encode(buf)?;
        self.transaction_type.encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        self.has_stack_net_ids.encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        if let Some(v) = &self.transaction_data {
            match v {
                TransactionTransactionData::InventoryMismatch => {}
                TransactionTransactionData::ItemRelease(v) => {
                    v.encode(buf)?;
                }
                TransactionTransactionData::ItemUse(v) => {
                    v.encode(buf)?;
                }
                TransactionTransactionData::ItemUseOnEntity(v) => {
                    v.encode(buf)?;
                }
                TransactionTransactionData::Normal => {}
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let legacy = <TransactionLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let transaction_type =
            <TransactionTransactionType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action_count =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_stack_net_ids = false;
        let actions = {
            let res: TransactionActions = {
                if action_count < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: action_count as i64,
                    });
                }
                let len = action_count as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec.push(
                        <TransactionActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            TransactionActionsItemArgs {
                                shield_item_id: args.shield_item_id,
                                has_stack_net_ids,
                            },
                        )?,
                    );
                }
                tmp_vec
            };
            res
        };
        let transaction_data = match transaction_type {
            TransactionTransactionType::InventoryMismatch => {
                Some(TransactionTransactionData::InventoryMismatch)
            }
            TransactionTransactionType::ItemRelease => {
                Some(
                    TransactionTransactionData::ItemRelease(
                        Box::new(
                            <TransactionTransactionDataItemRelease as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionTransactionDataItemReleaseArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUse => {
                Some(
                    TransactionTransactionData::ItemUse(
                        Box::new(
                            <TransactionUseItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionUseItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::ItemUseOnEntity => {
                Some(
                    TransactionTransactionData::ItemUseOnEntity(
                        Box::new(
                            <TransactionTransactionDataItemUseOnEntity as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                TransactionTransactionDataItemUseOnEntityArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        ),
                    ),
                )
            }
            TransactionTransactionType::Normal => Some(TransactionTransactionData::Normal),
        };
        Ok(Self {
            legacy,
            transaction_type,
            actions,
            has_stack_net_ids,
            transaction_data,
        })
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct
    UpdateBlockFlags : u32 { const NEIGHBORS = 1; const NETWORK = 2; const NO_GRAPHIC =
    4; const PRIORITY = 16; const UNUSED = 8; }
}
impl crate::bedrock::codec::BedrockCodec for UpdateBlockFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)] pub struct UpdateMapFlags
    : u32 { const VOID = 1; const TEXTURE = 2; const DECORATION = 4; const INITIALISATION
    = 8; }
}
impl crate::bedrock::codec::BedrockCodec for UpdateMapFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = self.bits();
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bits = raw.0 as u32;
        Ok(Self::from_bits_retain(bits))
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum WindowId {
    DropContents = -100,
    Beacon = -24,
    TradingOutput = -23,
    TradingUseInputs = -22,
    TradingInput2 = -21,
    TradingInput1 = -20,
    EnchantOutput = -17,
    EnchantMaterial = -16,
    EnchantInput = -15,
    AnvilOutput = -13,
    AnvilResult = -12,
    AnvilMaterial = -11,
    ContainerInput = -10,
    CraftingUseIngredient = -5,
    CraftingResult = -4,
    CraftingRemoveIngredient = -3,
    CraftingAddIngredient = -2,
    None = -1,
    Inventory = 0,
    First = 1,
    Last = 100,
    Offhand = 119,
    Armor = 120,
    Creative = 121,
    Hotbar = 122,
    FixedInventory = 123,
    Ui = 124,
}
impl crate::bedrock::codec::BedrockCodec for WindowId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            -100 => Ok(WindowId::DropContents),
            -24 => Ok(WindowId::Beacon),
            -23 => Ok(WindowId::TradingOutput),
            -22 => Ok(WindowId::TradingUseInputs),
            -21 => Ok(WindowId::TradingInput2),
            -20 => Ok(WindowId::TradingInput1),
            -17 => Ok(WindowId::EnchantOutput),
            -16 => Ok(WindowId::EnchantMaterial),
            -15 => Ok(WindowId::EnchantInput),
            -13 => Ok(WindowId::AnvilOutput),
            -12 => Ok(WindowId::AnvilResult),
            -11 => Ok(WindowId::AnvilMaterial),
            -10 => Ok(WindowId::ContainerInput),
            -5 => Ok(WindowId::CraftingUseIngredient),
            -4 => Ok(WindowId::CraftingResult),
            -3 => Ok(WindowId::CraftingRemoveIngredient),
            -2 => Ok(WindowId::CraftingAddIngredient),
            -1 => Ok(WindowId::None),
            0 => Ok(WindowId::Inventory),
            1 => Ok(WindowId::First),
            100 => Ok(WindowId::Last),
            119 => Ok(WindowId::Offhand),
            120 => Ok(WindowId::Armor),
            121 => Ok(WindowId::Creative),
            122 => Ok(WindowId::Hotbar),
            123 => Ok(WindowId::FixedInventory),
            124 => Ok(WindowId::Ui),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(WindowId),
                value: val as i64,
            }),
        }
    }
}
impl Default for WindowId {
    fn default() -> Self {
        Self::DropContents
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum WindowType {
    None = -9,
    Inventory = -1,
    Container = 0,
    Workbench = 1,
    Furnace = 2,
    Enchantment = 3,
    BrewingStand = 4,
    Anvil = 5,
    Dispenser = 6,
    Dropper = 7,
    Hopper = 8,
    Cauldron = 9,
    MinecartChest = 10,
    MinecartHopper = 11,
    Horse = 12,
    Beacon = 13,
    StructureEditor = 14,
    Trading = 15,
    CommandBlock = 16,
    Jukebox = 17,
    Armor = 18,
    Hand = 19,
    CompoundCreator = 20,
    ElementConstructor = 21,
    MaterialReducer = 22,
    LabTable = 23,
    Loom = 24,
    Lectern = 25,
    Grindstone = 26,
    BlastFurnace = 27,
    Smoker = 28,
    Stonecutter = 29,
    Cartography = 30,
    Hud = 31,
    JigsawEditor = 32,
    SmithingTable = 33,
    ChestBoat = 34,
    DecoratedPot = 35,
    Crafter = 36,
}
impl crate::bedrock::codec::BedrockCodec for WindowType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            -9 => Ok(WindowType::None),
            -1 => Ok(WindowType::Inventory),
            0 => Ok(WindowType::Container),
            1 => Ok(WindowType::Workbench),
            2 => Ok(WindowType::Furnace),
            3 => Ok(WindowType::Enchantment),
            4 => Ok(WindowType::BrewingStand),
            5 => Ok(WindowType::Anvil),
            6 => Ok(WindowType::Dispenser),
            7 => Ok(WindowType::Dropper),
            8 => Ok(WindowType::Hopper),
            9 => Ok(WindowType::Cauldron),
            10 => Ok(WindowType::MinecartChest),
            11 => Ok(WindowType::MinecartHopper),
            12 => Ok(WindowType::Horse),
            13 => Ok(WindowType::Beacon),
            14 => Ok(WindowType::StructureEditor),
            15 => Ok(WindowType::Trading),
            16 => Ok(WindowType::CommandBlock),
            17 => Ok(WindowType::Jukebox),
            18 => Ok(WindowType::Armor),
            19 => Ok(WindowType::Hand),
            20 => Ok(WindowType::CompoundCreator),
            21 => Ok(WindowType::ElementConstructor),
            22 => Ok(WindowType::MaterialReducer),
            23 => Ok(WindowType::LabTable),
            24 => Ok(WindowType::Loom),
            25 => Ok(WindowType::Lectern),
            26 => Ok(WindowType::Grindstone),
            27 => Ok(WindowType::BlastFurnace),
            28 => Ok(WindowType::Smoker),
            29 => Ok(WindowType::Stonecutter),
            30 => Ok(WindowType::Cartography),
            31 => Ok(WindowType::Hud),
            32 => Ok(WindowType::JigsawEditor),
            33 => Ok(WindowType::SmithingTable),
            34 => Ok(WindowType::ChestBoat),
            35 => Ok(WindowType::DecoratedPot),
            36 => Ok(WindowType::Crafter),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(WindowType),
                value: val as i64,
            }),
        }
    }
}
impl Default for WindowType {
    fn default() -> Self {
        Self::None
    }
}
pub type Bitflags = Vec<u8>;
pub type Encapsulated = Vec<u8>;
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum EnumSizeBasedOnValuesLen {
    Byte = 0,
    Short = 1,
    Int = 2,
}
impl crate::bedrock::codec::BedrockCodec for EnumSizeBasedOnValuesLen {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(EnumSizeBasedOnValuesLen::Byte),
            1 => Ok(EnumSizeBasedOnValuesLen::Short),
            2 => Ok(EnumSizeBasedOnValuesLen::Int),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(EnumSizeBasedOnValuesLen),
                value: val as i64,
            }),
        }
    }
}
impl Default for EnumSizeBasedOnValuesLen {
    fn default() -> Self {
        Self::Byte
    }
}
pub type Lnbt = crate::bedrock::codec::Nbt;
pub type Nbt = crate::bedrock::codec::Nbt;
pub type NbtLoop = crate::bedrock::codec::Nbt;
pub type RestBuffer = Vec<u8>;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3Li {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3Li {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.x).encode(buf)?;
        crate::bedrock::codec::I32LE(self.y).encode(buf)?;
        crate::bedrock::codec::I32LE(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let y =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let z =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3U {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for Vec3U {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.x).encode(buf)?;
        crate::bedrock::codec::VarInt(self.y).encode(buf)?;
        crate::bedrock::codec::VarInt(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let y = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let z = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        Ok(Self { x, y, z })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PlayStatusPacketStatus {
    LoginSuccess = 0,
    FailedClient = 1,
    FailedSpawn = 2,
    PlayerSpawn = 3,
    FailedInvalidTenant = 4,
    FailedVanillaEdu = 5,
    FailedEduVanilla = 6,
    FailedServerFull = 7,
    FailedEditorVanillaMismatch = 8,
    FailedVanillaEditorMismatch = 9,
}
impl crate::bedrock::codec::BedrockCodec for PlayStatusPacketStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <i32 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PlayStatusPacketStatus::LoginSuccess),
            1 => Ok(PlayStatusPacketStatus::FailedClient),
            2 => Ok(PlayStatusPacketStatus::FailedSpawn),
            3 => Ok(PlayStatusPacketStatus::PlayerSpawn),
            4 => Ok(PlayStatusPacketStatus::FailedInvalidTenant),
            5 => Ok(PlayStatusPacketStatus::FailedVanillaEdu),
            6 => Ok(PlayStatusPacketStatus::FailedEduVanilla),
            7 => Ok(PlayStatusPacketStatus::FailedServerFull),
            8 => Ok(PlayStatusPacketStatus::FailedEditorVanillaMismatch),
            9 => Ok(PlayStatusPacketStatus::FailedVanillaEditorMismatch),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayStatusPacketStatus),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayStatusPacketStatus {
    fn default() -> Self {
        Self::LoginSuccess
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DisconnectPacketContent {
    pub message: String,
    pub filtered_message: String,
}
impl crate::bedrock::codec::BedrockCodec for DisconnectPacketContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.filtered_message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.filtered_message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let message = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let filtered_message = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            message,
            filtered_message,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePacksInfoPacketWorldTemplate {
    pub uuid: uuid::Uuid,
    pub version: String,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePacksInfoPacketWorldTemplate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { uuid, version })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ResourcePackClientResponsePacketResponseStatus {
    None = 0,
    Refused = 1,
    SendPacks = 2,
    HaveAllPacks = 3,
    Completed = 4,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackClientResponsePacketResponseStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ResourcePackClientResponsePacketResponseStatus::None),
            1 => Ok(ResourcePackClientResponsePacketResponseStatus::Refused),
            2 => Ok(ResourcePackClientResponsePacketResponseStatus::SendPacks),
            3 => Ok(ResourcePackClientResponsePacketResponseStatus::HaveAllPacks),
            4 => Ok(ResourcePackClientResponsePacketResponseStatus::Completed),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ResourcePackClientResponsePacketResponseStatus),
                value: val as i64,
            }),
        }
    }
}
impl Default for ResourcePackClientResponsePacketResponseStatus {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum TextPacketCategory {
    MessageOnly = 0,
    Authored = 1,
    Parameters = 2,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketCategory {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TextPacketCategory::MessageOnly),
            1 => Ok(TextPacketCategory::Authored),
            2 => Ok(TextPacketCategory::Parameters),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TextPacketCategory),
                value: val as i64,
            }),
        }
    }
}
impl Default for TextPacketCategory {
    fn default() -> Self {
        Self::MessageOnly
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TextPacketContentAuthored {
    pub chat: String,
    pub whisper: String,
    pub announcement: String,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketContentAuthored {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.chat)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.chat).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.whisper)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.whisper).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.announcement)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.announcement).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let chat = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let whisper = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let announcement = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            chat,
            whisper,
            announcement,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TextPacketContentMessageOnly {
    pub raw: String,
    pub tip: String,
    pub system_message: String,
    pub text_object_whisper: String,
    pub text_object_announcement: String,
    pub text_object: String,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketContentMessageOnly {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.raw)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.raw).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.tip)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.tip).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.system_message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.system_message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.text_object_whisper)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.text_object_whisper).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.text_object_announcement)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.text_object_announcement).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.text_object)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.text_object).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let raw = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let tip = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let system_message = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let text_object_whisper = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let text_object_announcement = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let text_object = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            raw,
            tip,
            system_message,
            text_object_whisper,
            text_object_announcement,
            text_object,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TextPacketContentParameters {
    pub translate: String,
    pub popup: String,
    pub jukebox_popup: String,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketContentParameters {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.translate)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.translate).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.popup)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.popup).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.jukebox_popup)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.jukebox_popup).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let translate = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let popup = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let jukebox_popup = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            translate,
            popup,
            jukebox_popup,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TextPacketContent {
    Authored(TextPacketContentAuthored),
    MessageOnly(Box<TextPacketContentMessageOnly>),
    Parameters(TextPacketContentParameters),
}
impl Default for TextPacketContent {
    fn default() -> Self {
        Self::Authored(Default::default())
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum TextPacketType {
    Raw = 0,
    Chat = 1,
    Translation = 2,
    Popup = 3,
    JukeboxPopup = 4,
    Tip = 5,
    System = 6,
    Whisper = 7,
    Announcement = 8,
    JsonWhisper = 9,
    Json = 10,
    JsonAnnouncement = 11,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(TextPacketType::Raw),
            1 => Ok(TextPacketType::Chat),
            2 => Ok(TextPacketType::Translation),
            3 => Ok(TextPacketType::Popup),
            4 => Ok(TextPacketType::JukeboxPopup),
            5 => Ok(TextPacketType::Tip),
            6 => Ok(TextPacketType::System),
            7 => Ok(TextPacketType::Whisper),
            8 => Ok(TextPacketType::Announcement),
            9 => Ok(TextPacketType::JsonWhisper),
            10 => Ok(TextPacketType::Json),
            11 => Ok(TextPacketType::JsonAnnouncement),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(TextPacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for TextPacketType {
    fn default() -> Self {
        Self::Raw
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TextPacketExtraAnnouncement {
    pub source_name: String,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketExtraAnnouncement {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.source_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.source_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let source_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let message = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            source_name,
            message,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TextPacketExtraJson {
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketExtraJson {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let message = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { message })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TextPacketExtraJukeboxPopup {
    pub message: String,
    pub parameters: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for TextPacketExtraJukeboxPopup {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let message = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let parameters = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self {
            message,
            parameters,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum TextPacketExtra {
    Announcement(TextPacketExtraAnnouncement),
    Chat(TextPacketExtraAnnouncement),
    Json(TextPacketExtraJson),
    JsonAnnouncement(TextPacketExtraJson),
    JsonWhisper(TextPacketExtraJson),
    JukeboxPopup(TextPacketExtraJukeboxPopup),
    Popup(TextPacketExtraJukeboxPopup),
    Raw(TextPacketExtraJson),
    System(TextPacketExtraJson),
    Tip(TextPacketExtraJson),
    Translation(TextPacketExtraJukeboxPopup),
    Whisper(TextPacketExtraAnnouncement),
}
impl Default for TextPacketExtra {
    fn default() -> Self {
        Self::Announcement(Default::default())
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum StartGamePacketDimension {
    Overworld = 0,
    Nether = 1,
    End = 2,
}
impl crate::bedrock::codec::BedrockCodec for StartGamePacketDimension {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(StartGamePacketDimension::Overworld),
            1 => Ok(StartGamePacketDimension::Nether),
            2 => Ok(StartGamePacketDimension::End),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StartGamePacketDimension),
                value: val as i64,
            }),
        }
    }
}
impl Default for StartGamePacketDimension {
    fn default() -> Self {
        Self::Overworld
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum StartGamePacketEditorWorldType {
    NotEditor = 0,
    Project = 1,
    TestLevel = 2,
    RealmsUpload = 3,
}
impl crate::bedrock::codec::BedrockCodec for StartGamePacketEditorWorldType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(StartGamePacketEditorWorldType::NotEditor),
            1 => Ok(StartGamePacketEditorWorldType::Project),
            2 => Ok(StartGamePacketEditorWorldType::TestLevel),
            3 => Ok(StartGamePacketEditorWorldType::RealmsUpload),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StartGamePacketEditorWorldType),
                value: val as i64,
            }),
        }
    }
}
impl Default for StartGamePacketEditorWorldType {
    fn default() -> Self {
        Self::NotEditor
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StartGamePacketChatRestrictionLevel {
    None = 0,
    Dropped = 1,
    Disabled = 2,
}
impl crate::bedrock::codec::BedrockCodec for StartGamePacketChatRestrictionLevel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(StartGamePacketChatRestrictionLevel::None),
            1 => Ok(StartGamePacketChatRestrictionLevel::Dropped),
            2 => Ok(StartGamePacketChatRestrictionLevel::Disabled),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StartGamePacketChatRestrictionLevel),
                value: val as i64,
            }),
        }
    }
}
impl Default for StartGamePacketChatRestrictionLevel {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum MovePlayerPacketMode {
    Normal = 0,
    Reset = 1,
    Teleport = 2,
    Rotation = 3,
}
impl crate::bedrock::codec::BedrockCodec for MovePlayerPacketMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(MovePlayerPacketMode::Normal),
            1 => Ok(MovePlayerPacketMode::Reset),
            2 => Ok(MovePlayerPacketMode::Teleport),
            3 => Ok(MovePlayerPacketMode::Rotation),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MovePlayerPacketMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for MovePlayerPacketMode {
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MovePlayerPacketTeleportCause {
    Unknown = 0,
    Projectile = 1,
    ChorusFruit = 2,
    Command = 3,
    Behavior = 4,
}
impl crate::bedrock::codec::BedrockCodec for MovePlayerPacketTeleportCause {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(MovePlayerPacketTeleportCause::Unknown),
            1 => Ok(MovePlayerPacketTeleportCause::Projectile),
            2 => Ok(MovePlayerPacketTeleportCause::ChorusFruit),
            3 => Ok(MovePlayerPacketTeleportCause::Command),
            4 => Ok(MovePlayerPacketTeleportCause::Behavior),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MovePlayerPacketTeleportCause),
                value: val as i64,
            }),
        }
    }
}
impl Default for MovePlayerPacketTeleportCause {
    fn default() -> Self {
        Self::Unknown
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MovePlayerPacketTeleport {
    pub cause: MovePlayerPacketTeleportCause,
    pub source_entity_type: LegacyEntityType,
}
impl crate::bedrock::codec::BedrockCodec for MovePlayerPacketTeleport {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.cause.encode(buf)?;
        self.source_entity_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let cause = <MovePlayerPacketTeleportCause as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let source_entity_type =
            <LegacyEntityType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            cause,
            source_entity_type,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum LevelEventPacketEvent {
    SoundClick = 1000,
    SoundClickFail = 1001,
    SoundShoot = 1002,
    SoundDoor = 1003,
    SoundFizz = 1004,
    SoundIgnite = 1005,
    SoundGhast = 1007,
    SoundGhastShoot = 1008,
    SoundBlazeShoot = 1009,
    SoundDoorBump = 1010,
    SoundDoorCrash = 1012,
    SoundEndermanTeleport = 1018,
    SoundAnvilBreak = 1020,
    SoundAnvilUse = 1021,
    SoundAnvilFall = 1022,
    SoundPop = 1030,
    SoundPortal = 1032,
    SoundItemframeAddItem = 1040,
    SoundItemframeRemove = 1041,
    SoundItemframePlace = 1042,
    SoundItemframeRemoveItem = 1043,
    SoundItemframeRotateItem = 1044,
    SoundCamera = 1050,
    SoundOrb = 1051,
    SoundTotem = 1052,
    SoundArmorStandBreak = 1060,
    SoundArmorStandHit = 1061,
    SoundArmorStandFall = 1062,
    SoundArmorStandPlace = 1063,
    PointedDripstoneLand = 1064,
    DyeUsed = 1065,
    InkSackUsed = 1066,
    ParticleShoot = 2000,
    ParticleDestroy = 2001,
    ParticleSplash = 2002,
    ParticleEyeDespawn = 2003,
    ParticleSpawn = 2004,
    ParticleCropGrowth = 2005,
    ParticleGuardianCurse = 2006,
    ParticleDeathSmoke = 2007,
    ParticleBlockForceField = 2008,
    ParticleProjectileHit = 2009,
    ParticleDragonEggTeleport = 2010,
    ParticleCropEaten = 2011,
    ParticleCritical = 2012,
    ParticleEndermanTeleport = 2013,
    ParticlePunchBlock = 2014,
    ParticleBubble = 2015,
    ParticleEvaporate = 2016,
    ParticleDestroyArmorStand = 2017,
    ParticleBreakingEgg = 2018,
    ParticleDestroyEgg = 2019,
    ParticleEvaporateWater = 2020,
    ParticleDestroyBlockNoSound = 2021,
    ParticleKnockbackRoar = 2022,
    ParticleTeleportTrail = 2023,
    ParticlePointCloud = 2024,
    ParticleExplosion = 2025,
    ParticleBlockExplosion = 2026,
    ParticleVibrationSignal = 2027,
    ParticleDripstoneDrip = 2028,
    ParticleFizzEffect = 2029,
    ParticleWaxOn = 2030,
    ParticleWaxOff = 2031,
    ParticleScrape = 2032,
    ParticleElectricSpark = 2033,
    ParticleTurtleEgg = 2034,
    ParticleSculkShriek = 2035,
    SculkCatalystBloom = 2036,
    SculkCharge = 2037,
    SculkChargePop = 2038,
    SonicExplosion = 2039,
    DustPlume = 2040,
    StartRain = 3001,
    StartThunder = 3002,
    StopRain = 3003,
    StopThunder = 3004,
    PauseGame = 3005,
    PauseGameNoScreen = 3006,
    SetGameSpeed = 3007,
    RedstoneTrigger = 3500,
    CauldronExplode = 3501,
    CauldronDyeArmor = 3502,
    CauldronCleanArmor = 3503,
    CauldronFillPotion = 3504,
    CauldronTakePotion = 3505,
    CauldronFillWater = 3506,
    CauldronTakeWater = 3507,
    CauldronAddDye = 3508,
    CauldronCleanBanner = 3509,
    BlockStartBreak = 3600,
    BlockStopBreak = 3601,
    BlockBreakSpeed = 3602,
    ParticlePunchBlockDown = 3603,
    ParticlePunchBlockUp = 3604,
    ParticlePunchBlockNorth = 3605,
    ParticlePunchBlockSouth = 3606,
    ParticlePunchBlockWest = 3607,
    ParticlePunchBlockEast = 3608,
    ParticleShootWhiteSmoke = 3609,
    ParticleBreezeWindExplosion = 3610,
    ParticleTrialSpawnerDetection = 3611,
    ParticleTrialSpawnerSpawning = 3612,
    ParticleTrialSpawnerEjecting = 3613,
    ParticleWindExplosion = 3614,
    ParticleWolfArmorBreak = 3615,
    OminousItemSpawner = 3616,
    CreakingCrumble = 3617,
    PaleOakLeaves = 3618,
    EyeblossomOpen = 3619,
    EyeblossomClose = 3620,
    GreenFlame = 3621,
    SetData = 4000,
    PlayersSleeping = 9800,
    SleepingPlayers = 9801,
    JumpPrevented = 9810,
    AnimationVaultActivate = 9811,
    AnimationVaultDeactivate = 9812,
    AnimationVaultEjectItem = 9813,
    AnimationSpawnCobweb = 9814,
    AddParticleSmashAttackGroundDust = 9815,
    AddParticleCreakingHeartTrail = 9816,
    AddParticleMask = 16384,
    AddParticleBubble = 16385,
    AddParticleBubbleManual = 16386,
    AddParticleCritical = 16387,
    AddParticleBlockForceField = 16388,
    AddParticleSmoke = 16389,
    AddParticleExplode = 16390,
    AddParticleEvaporation = 16391,
    AddParticleFlame = 16392,
    AddParticleCandleFlame = 16393,
    AddParticleLava = 16394,
    AddParticleLargeSmoke = 16395,
    AddParticleRedstone = 16396,
    AddParticleRisingRedDust = 16397,
    AddParticleItemBreak = 16398,
    AddParticleSnowballPoof = 16399,
    AddParticleHugeExplode = 16400,
    AddParticleHugeExplodeSeed = 16401,
    AddParticleMobFlame = 16402,
    AddParticleHeart = 16403,
    AddParticleTerrain = 16404,
    AddParticleTownAura = 16405,
    AddParticlePortal = 16406,
    AddParticleWaterSplash = 16408,
    AddParticleWaterSplashManual = 16409,
    AddParticleWaterWake = 16410,
    AddParticleDripWater = 16411,
    AddParticleDripLava = 16412,
    AddParticleDripHoney = 16413,
    AddParticleStalactiteDripWater = 16414,
    AddParticleStalactiteDripLava = 16415,
    AddParticleFallingDust = 16416,
    AddParticleMobSpell = 16417,
    AddParticleMobSpellAmbient = 16418,
    AddParticleMobSpellInstantaneous = 16419,
    AddParticleInk = 16420,
    AddParticleSlime = 16421,
    AddParticleRainSplash = 16422,
    AddParticleVillagerAngry = 16423,
    AddParticleVillagerHappy = 16424,
    AddParticleEnchantmentTable = 16425,
    AddParticleTrackingEmitter = 16426,
    AddParticleNote = 16427,
    AddParticleWitchSpell = 16428,
    AddParticleCarrot = 16429,
    AddParticleMobAppearance = 16430,
    AddParticleEndRod = 16431,
    AddParticleDragonsBreath = 16432,
    AddParticleSpit = 16433,
    AddParticleTotem = 16434,
    AddParticleFood = 16435,
    AddParticleFireworksStarter = 16436,
    AddParticleFireworksSpark = 16437,
    AddParticleFireworksOverlay = 16438,
    AddParticleBalloonGas = 16439,
    AddParticleColoredFlame = 16440,
    AddParticleSparkler = 16441,
    AddParticleConduit = 16442,
    AddParticleBubbleColumnUp = 16443,
    AddParticleBubbleColumnDown = 16444,
    AddParticleSneeze = 16445,
    AddParticleShulkerBullet = 16446,
    AddParticleBleach = 16447,
    AddParticleDragonDestroyBlock = 16448,
    AddParticleMyceliumDust = 16449,
    AddParticleFallingRedDust = 16450,
    AddParticleCampfireSmoke = 16451,
    AddParticleTallCampfireSmoke = 16452,
    AddParticleDragonBreathFire = 16453,
    AddParticleDragonBreathTrail = 16454,
    AddParticleBlueFlame = 16455,
    AddParticleSoul = 16456,
    AddParticleObsidianTear = 16457,
    AddParticlePortalReverse = 16458,
    AddParticleSnowflake = 16459,
    AddParticleVibrationSignal = 16460,
    AddParticleSculkSensorRedstone = 16461,
    AddParticleSporeBlossomShower = 16462,
    AddParticleSporeBlossomAmbient = 16463,
    AddParticleWax = 16464,
    AddParticleElectricSpark = 16465,
}
impl crate::bedrock::codec::BedrockCodec for LevelEventPacketEvent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            1000 => Ok(LevelEventPacketEvent::SoundClick),
            1001 => Ok(LevelEventPacketEvent::SoundClickFail),
            1002 => Ok(LevelEventPacketEvent::SoundShoot),
            1003 => Ok(LevelEventPacketEvent::SoundDoor),
            1004 => Ok(LevelEventPacketEvent::SoundFizz),
            1005 => Ok(LevelEventPacketEvent::SoundIgnite),
            1007 => Ok(LevelEventPacketEvent::SoundGhast),
            1008 => Ok(LevelEventPacketEvent::SoundGhastShoot),
            1009 => Ok(LevelEventPacketEvent::SoundBlazeShoot),
            1010 => Ok(LevelEventPacketEvent::SoundDoorBump),
            1012 => Ok(LevelEventPacketEvent::SoundDoorCrash),
            1018 => Ok(LevelEventPacketEvent::SoundEndermanTeleport),
            1020 => Ok(LevelEventPacketEvent::SoundAnvilBreak),
            1021 => Ok(LevelEventPacketEvent::SoundAnvilUse),
            1022 => Ok(LevelEventPacketEvent::SoundAnvilFall),
            1030 => Ok(LevelEventPacketEvent::SoundPop),
            1032 => Ok(LevelEventPacketEvent::SoundPortal),
            1040 => Ok(LevelEventPacketEvent::SoundItemframeAddItem),
            1041 => Ok(LevelEventPacketEvent::SoundItemframeRemove),
            1042 => Ok(LevelEventPacketEvent::SoundItemframePlace),
            1043 => Ok(LevelEventPacketEvent::SoundItemframeRemoveItem),
            1044 => Ok(LevelEventPacketEvent::SoundItemframeRotateItem),
            1050 => Ok(LevelEventPacketEvent::SoundCamera),
            1051 => Ok(LevelEventPacketEvent::SoundOrb),
            1052 => Ok(LevelEventPacketEvent::SoundTotem),
            1060 => Ok(LevelEventPacketEvent::SoundArmorStandBreak),
            1061 => Ok(LevelEventPacketEvent::SoundArmorStandHit),
            1062 => Ok(LevelEventPacketEvent::SoundArmorStandFall),
            1063 => Ok(LevelEventPacketEvent::SoundArmorStandPlace),
            1064 => Ok(LevelEventPacketEvent::PointedDripstoneLand),
            1065 => Ok(LevelEventPacketEvent::DyeUsed),
            1066 => Ok(LevelEventPacketEvent::InkSackUsed),
            2000 => Ok(LevelEventPacketEvent::ParticleShoot),
            2001 => Ok(LevelEventPacketEvent::ParticleDestroy),
            2002 => Ok(LevelEventPacketEvent::ParticleSplash),
            2003 => Ok(LevelEventPacketEvent::ParticleEyeDespawn),
            2004 => Ok(LevelEventPacketEvent::ParticleSpawn),
            2005 => Ok(LevelEventPacketEvent::ParticleCropGrowth),
            2006 => Ok(LevelEventPacketEvent::ParticleGuardianCurse),
            2007 => Ok(LevelEventPacketEvent::ParticleDeathSmoke),
            2008 => Ok(LevelEventPacketEvent::ParticleBlockForceField),
            2009 => Ok(LevelEventPacketEvent::ParticleProjectileHit),
            2010 => Ok(LevelEventPacketEvent::ParticleDragonEggTeleport),
            2011 => Ok(LevelEventPacketEvent::ParticleCropEaten),
            2012 => Ok(LevelEventPacketEvent::ParticleCritical),
            2013 => Ok(LevelEventPacketEvent::ParticleEndermanTeleport),
            2014 => Ok(LevelEventPacketEvent::ParticlePunchBlock),
            2015 => Ok(LevelEventPacketEvent::ParticleBubble),
            2016 => Ok(LevelEventPacketEvent::ParticleEvaporate),
            2017 => Ok(LevelEventPacketEvent::ParticleDestroyArmorStand),
            2018 => Ok(LevelEventPacketEvent::ParticleBreakingEgg),
            2019 => Ok(LevelEventPacketEvent::ParticleDestroyEgg),
            2020 => Ok(LevelEventPacketEvent::ParticleEvaporateWater),
            2021 => Ok(LevelEventPacketEvent::ParticleDestroyBlockNoSound),
            2022 => Ok(LevelEventPacketEvent::ParticleKnockbackRoar),
            2023 => Ok(LevelEventPacketEvent::ParticleTeleportTrail),
            2024 => Ok(LevelEventPacketEvent::ParticlePointCloud),
            2025 => Ok(LevelEventPacketEvent::ParticleExplosion),
            2026 => Ok(LevelEventPacketEvent::ParticleBlockExplosion),
            2027 => Ok(LevelEventPacketEvent::ParticleVibrationSignal),
            2028 => Ok(LevelEventPacketEvent::ParticleDripstoneDrip),
            2029 => Ok(LevelEventPacketEvent::ParticleFizzEffect),
            2030 => Ok(LevelEventPacketEvent::ParticleWaxOn),
            2031 => Ok(LevelEventPacketEvent::ParticleWaxOff),
            2032 => Ok(LevelEventPacketEvent::ParticleScrape),
            2033 => Ok(LevelEventPacketEvent::ParticleElectricSpark),
            2034 => Ok(LevelEventPacketEvent::ParticleTurtleEgg),
            2035 => Ok(LevelEventPacketEvent::ParticleSculkShriek),
            2036 => Ok(LevelEventPacketEvent::SculkCatalystBloom),
            2037 => Ok(LevelEventPacketEvent::SculkCharge),
            2038 => Ok(LevelEventPacketEvent::SculkChargePop),
            2039 => Ok(LevelEventPacketEvent::SonicExplosion),
            2040 => Ok(LevelEventPacketEvent::DustPlume),
            3001 => Ok(LevelEventPacketEvent::StartRain),
            3002 => Ok(LevelEventPacketEvent::StartThunder),
            3003 => Ok(LevelEventPacketEvent::StopRain),
            3004 => Ok(LevelEventPacketEvent::StopThunder),
            3005 => Ok(LevelEventPacketEvent::PauseGame),
            3006 => Ok(LevelEventPacketEvent::PauseGameNoScreen),
            3007 => Ok(LevelEventPacketEvent::SetGameSpeed),
            3500 => Ok(LevelEventPacketEvent::RedstoneTrigger),
            3501 => Ok(LevelEventPacketEvent::CauldronExplode),
            3502 => Ok(LevelEventPacketEvent::CauldronDyeArmor),
            3503 => Ok(LevelEventPacketEvent::CauldronCleanArmor),
            3504 => Ok(LevelEventPacketEvent::CauldronFillPotion),
            3505 => Ok(LevelEventPacketEvent::CauldronTakePotion),
            3506 => Ok(LevelEventPacketEvent::CauldronFillWater),
            3507 => Ok(LevelEventPacketEvent::CauldronTakeWater),
            3508 => Ok(LevelEventPacketEvent::CauldronAddDye),
            3509 => Ok(LevelEventPacketEvent::CauldronCleanBanner),
            3600 => Ok(LevelEventPacketEvent::BlockStartBreak),
            3601 => Ok(LevelEventPacketEvent::BlockStopBreak),
            3602 => Ok(LevelEventPacketEvent::BlockBreakSpeed),
            3603 => Ok(LevelEventPacketEvent::ParticlePunchBlockDown),
            3604 => Ok(LevelEventPacketEvent::ParticlePunchBlockUp),
            3605 => Ok(LevelEventPacketEvent::ParticlePunchBlockNorth),
            3606 => Ok(LevelEventPacketEvent::ParticlePunchBlockSouth),
            3607 => Ok(LevelEventPacketEvent::ParticlePunchBlockWest),
            3608 => Ok(LevelEventPacketEvent::ParticlePunchBlockEast),
            3609 => Ok(LevelEventPacketEvent::ParticleShootWhiteSmoke),
            3610 => Ok(LevelEventPacketEvent::ParticleBreezeWindExplosion),
            3611 => Ok(LevelEventPacketEvent::ParticleTrialSpawnerDetection),
            3612 => Ok(LevelEventPacketEvent::ParticleTrialSpawnerSpawning),
            3613 => Ok(LevelEventPacketEvent::ParticleTrialSpawnerEjecting),
            3614 => Ok(LevelEventPacketEvent::ParticleWindExplosion),
            3615 => Ok(LevelEventPacketEvent::ParticleWolfArmorBreak),
            3616 => Ok(LevelEventPacketEvent::OminousItemSpawner),
            3617 => Ok(LevelEventPacketEvent::CreakingCrumble),
            3618 => Ok(LevelEventPacketEvent::PaleOakLeaves),
            3619 => Ok(LevelEventPacketEvent::EyeblossomOpen),
            3620 => Ok(LevelEventPacketEvent::EyeblossomClose),
            3621 => Ok(LevelEventPacketEvent::GreenFlame),
            4000 => Ok(LevelEventPacketEvent::SetData),
            9800 => Ok(LevelEventPacketEvent::PlayersSleeping),
            9801 => Ok(LevelEventPacketEvent::SleepingPlayers),
            9810 => Ok(LevelEventPacketEvent::JumpPrevented),
            9811 => Ok(LevelEventPacketEvent::AnimationVaultActivate),
            9812 => Ok(LevelEventPacketEvent::AnimationVaultDeactivate),
            9813 => Ok(LevelEventPacketEvent::AnimationVaultEjectItem),
            9814 => Ok(LevelEventPacketEvent::AnimationSpawnCobweb),
            9815 => Ok(LevelEventPacketEvent::AddParticleSmashAttackGroundDust),
            9816 => Ok(LevelEventPacketEvent::AddParticleCreakingHeartTrail),
            16384 => Ok(LevelEventPacketEvent::AddParticleMask),
            16385 => Ok(LevelEventPacketEvent::AddParticleBubble),
            16386 => Ok(LevelEventPacketEvent::AddParticleBubbleManual),
            16387 => Ok(LevelEventPacketEvent::AddParticleCritical),
            16388 => Ok(LevelEventPacketEvent::AddParticleBlockForceField),
            16389 => Ok(LevelEventPacketEvent::AddParticleSmoke),
            16390 => Ok(LevelEventPacketEvent::AddParticleExplode),
            16391 => Ok(LevelEventPacketEvent::AddParticleEvaporation),
            16392 => Ok(LevelEventPacketEvent::AddParticleFlame),
            16393 => Ok(LevelEventPacketEvent::AddParticleCandleFlame),
            16394 => Ok(LevelEventPacketEvent::AddParticleLava),
            16395 => Ok(LevelEventPacketEvent::AddParticleLargeSmoke),
            16396 => Ok(LevelEventPacketEvent::AddParticleRedstone),
            16397 => Ok(LevelEventPacketEvent::AddParticleRisingRedDust),
            16398 => Ok(LevelEventPacketEvent::AddParticleItemBreak),
            16399 => Ok(LevelEventPacketEvent::AddParticleSnowballPoof),
            16400 => Ok(LevelEventPacketEvent::AddParticleHugeExplode),
            16401 => Ok(LevelEventPacketEvent::AddParticleHugeExplodeSeed),
            16402 => Ok(LevelEventPacketEvent::AddParticleMobFlame),
            16403 => Ok(LevelEventPacketEvent::AddParticleHeart),
            16404 => Ok(LevelEventPacketEvent::AddParticleTerrain),
            16405 => Ok(LevelEventPacketEvent::AddParticleTownAura),
            16406 => Ok(LevelEventPacketEvent::AddParticlePortal),
            16408 => Ok(LevelEventPacketEvent::AddParticleWaterSplash),
            16409 => Ok(LevelEventPacketEvent::AddParticleWaterSplashManual),
            16410 => Ok(LevelEventPacketEvent::AddParticleWaterWake),
            16411 => Ok(LevelEventPacketEvent::AddParticleDripWater),
            16412 => Ok(LevelEventPacketEvent::AddParticleDripLava),
            16413 => Ok(LevelEventPacketEvent::AddParticleDripHoney),
            16414 => Ok(LevelEventPacketEvent::AddParticleStalactiteDripWater),
            16415 => Ok(LevelEventPacketEvent::AddParticleStalactiteDripLava),
            16416 => Ok(LevelEventPacketEvent::AddParticleFallingDust),
            16417 => Ok(LevelEventPacketEvent::AddParticleMobSpell),
            16418 => Ok(LevelEventPacketEvent::AddParticleMobSpellAmbient),
            16419 => Ok(LevelEventPacketEvent::AddParticleMobSpellInstantaneous),
            16420 => Ok(LevelEventPacketEvent::AddParticleInk),
            16421 => Ok(LevelEventPacketEvent::AddParticleSlime),
            16422 => Ok(LevelEventPacketEvent::AddParticleRainSplash),
            16423 => Ok(LevelEventPacketEvent::AddParticleVillagerAngry),
            16424 => Ok(LevelEventPacketEvent::AddParticleVillagerHappy),
            16425 => Ok(LevelEventPacketEvent::AddParticleEnchantmentTable),
            16426 => Ok(LevelEventPacketEvent::AddParticleTrackingEmitter),
            16427 => Ok(LevelEventPacketEvent::AddParticleNote),
            16428 => Ok(LevelEventPacketEvent::AddParticleWitchSpell),
            16429 => Ok(LevelEventPacketEvent::AddParticleCarrot),
            16430 => Ok(LevelEventPacketEvent::AddParticleMobAppearance),
            16431 => Ok(LevelEventPacketEvent::AddParticleEndRod),
            16432 => Ok(LevelEventPacketEvent::AddParticleDragonsBreath),
            16433 => Ok(LevelEventPacketEvent::AddParticleSpit),
            16434 => Ok(LevelEventPacketEvent::AddParticleTotem),
            16435 => Ok(LevelEventPacketEvent::AddParticleFood),
            16436 => Ok(LevelEventPacketEvent::AddParticleFireworksStarter),
            16437 => Ok(LevelEventPacketEvent::AddParticleFireworksSpark),
            16438 => Ok(LevelEventPacketEvent::AddParticleFireworksOverlay),
            16439 => Ok(LevelEventPacketEvent::AddParticleBalloonGas),
            16440 => Ok(LevelEventPacketEvent::AddParticleColoredFlame),
            16441 => Ok(LevelEventPacketEvent::AddParticleSparkler),
            16442 => Ok(LevelEventPacketEvent::AddParticleConduit),
            16443 => Ok(LevelEventPacketEvent::AddParticleBubbleColumnUp),
            16444 => Ok(LevelEventPacketEvent::AddParticleBubbleColumnDown),
            16445 => Ok(LevelEventPacketEvent::AddParticleSneeze),
            16446 => Ok(LevelEventPacketEvent::AddParticleShulkerBullet),
            16447 => Ok(LevelEventPacketEvent::AddParticleBleach),
            16448 => Ok(LevelEventPacketEvent::AddParticleDragonDestroyBlock),
            16449 => Ok(LevelEventPacketEvent::AddParticleMyceliumDust),
            16450 => Ok(LevelEventPacketEvent::AddParticleFallingRedDust),
            16451 => Ok(LevelEventPacketEvent::AddParticleCampfireSmoke),
            16452 => Ok(LevelEventPacketEvent::AddParticleTallCampfireSmoke),
            16453 => Ok(LevelEventPacketEvent::AddParticleDragonBreathFire),
            16454 => Ok(LevelEventPacketEvent::AddParticleDragonBreathTrail),
            16455 => Ok(LevelEventPacketEvent::AddParticleBlueFlame),
            16456 => Ok(LevelEventPacketEvent::AddParticleSoul),
            16457 => Ok(LevelEventPacketEvent::AddParticleObsidianTear),
            16458 => Ok(LevelEventPacketEvent::AddParticlePortalReverse),
            16459 => Ok(LevelEventPacketEvent::AddParticleSnowflake),
            16460 => Ok(LevelEventPacketEvent::AddParticleVibrationSignal),
            16461 => Ok(LevelEventPacketEvent::AddParticleSculkSensorRedstone),
            16462 => Ok(LevelEventPacketEvent::AddParticleSporeBlossomShower),
            16463 => Ok(LevelEventPacketEvent::AddParticleSporeBlossomAmbient),
            16464 => Ok(LevelEventPacketEvent::AddParticleWax),
            16465 => Ok(LevelEventPacketEvent::AddParticleElectricSpark),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(LevelEventPacketEvent),
                value: val as i64,
            }),
        }
    }
}
impl Default for LevelEventPacketEvent {
    fn default() -> Self {
        Self::SoundClick
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BlockEventPacketType {
    Sound = 0,
    ChangeState = 1,
}
impl crate::bedrock::codec::BedrockCodec for BlockEventPacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(BlockEventPacketType::Sound),
            1 => Ok(BlockEventPacketType::ChangeState),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(BlockEventPacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for BlockEventPacketType {
    fn default() -> Self {
        Self::Sound
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum EntityEventPacketEventId {
    Jump = 1,
    HurtAnimation = 2,
    DeathAnimation = 3,
    ArmSwing = 4,
    StopAttack = 5,
    TameFail = 6,
    TameSuccess = 7,
    ShakeWet = 8,
    UseItem = 9,
    EatGrassAnimation = 10,
    FishHookBubble = 11,
    FishHookPosition = 12,
    FishHookHook = 13,
    FishHookTease = 14,
    SquidInkCloud = 15,
    ZombieVillagerCure = 16,
    Respawn = 18,
    IronGolemOfferFlower = 19,
    IronGolemWithdrawFlower = 20,
    LoveParticles = 21,
    VillagerAngry = 22,
    VillagerHappy = 23,
    WitchSpellParticles = 24,
    FireworkParticles = 25,
    InLoveParticles = 26,
    SilverfishSpawnAnimation = 27,
    GuardianAttack = 28,
    WitchDrinkPotion = 29,
    WitchThrowPotion = 30,
    MinecartTntPrimeFuse = 31,
    CreeperPrimeFuse = 32,
    AirSupplyExpired = 33,
    PlayerAddXpLevels = 34,
    ElderGuardianCurse = 35,
    AgentArmSwing = 36,
    EnderDragonDeath = 37,
    DustParticles = 38,
    ArrowShake = 39,
    EatingItem = 57,
    BabyAnimalFeed = 60,
    DeathSmokeCloud = 61,
    CompleteTrade = 62,
    RemoveLeash = 63,
    Caravan = 64,
    ConsumeTotem = 65,
    PlayerCheckTreasureHunterAchievement = 66,
    EntitySpawn = 67,
    DragonPuke = 68,
    ItemEntityMerge = 69,
    StartSwim = 70,
    BalloonPop = 71,
    TreasureHunt = 72,
    AgentSummon = 73,
    ChargedItem = 74,
    Fall = 75,
    GrowUp = 76,
    VibrationDetected = 77,
    DrinkMilk = 78,
    WetnessStop = 79,
}
impl crate::bedrock::codec::BedrockCodec for EntityEventPacketEventId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(EntityEventPacketEventId::Jump),
            2 => Ok(EntityEventPacketEventId::HurtAnimation),
            3 => Ok(EntityEventPacketEventId::DeathAnimation),
            4 => Ok(EntityEventPacketEventId::ArmSwing),
            5 => Ok(EntityEventPacketEventId::StopAttack),
            6 => Ok(EntityEventPacketEventId::TameFail),
            7 => Ok(EntityEventPacketEventId::TameSuccess),
            8 => Ok(EntityEventPacketEventId::ShakeWet),
            9 => Ok(EntityEventPacketEventId::UseItem),
            10 => Ok(EntityEventPacketEventId::EatGrassAnimation),
            11 => Ok(EntityEventPacketEventId::FishHookBubble),
            12 => Ok(EntityEventPacketEventId::FishHookPosition),
            13 => Ok(EntityEventPacketEventId::FishHookHook),
            14 => Ok(EntityEventPacketEventId::FishHookTease),
            15 => Ok(EntityEventPacketEventId::SquidInkCloud),
            16 => Ok(EntityEventPacketEventId::ZombieVillagerCure),
            18 => Ok(EntityEventPacketEventId::Respawn),
            19 => Ok(EntityEventPacketEventId::IronGolemOfferFlower),
            20 => Ok(EntityEventPacketEventId::IronGolemWithdrawFlower),
            21 => Ok(EntityEventPacketEventId::LoveParticles),
            22 => Ok(EntityEventPacketEventId::VillagerAngry),
            23 => Ok(EntityEventPacketEventId::VillagerHappy),
            24 => Ok(EntityEventPacketEventId::WitchSpellParticles),
            25 => Ok(EntityEventPacketEventId::FireworkParticles),
            26 => Ok(EntityEventPacketEventId::InLoveParticles),
            27 => Ok(EntityEventPacketEventId::SilverfishSpawnAnimation),
            28 => Ok(EntityEventPacketEventId::GuardianAttack),
            29 => Ok(EntityEventPacketEventId::WitchDrinkPotion),
            30 => Ok(EntityEventPacketEventId::WitchThrowPotion),
            31 => Ok(EntityEventPacketEventId::MinecartTntPrimeFuse),
            32 => Ok(EntityEventPacketEventId::CreeperPrimeFuse),
            33 => Ok(EntityEventPacketEventId::AirSupplyExpired),
            34 => Ok(EntityEventPacketEventId::PlayerAddXpLevels),
            35 => Ok(EntityEventPacketEventId::ElderGuardianCurse),
            36 => Ok(EntityEventPacketEventId::AgentArmSwing),
            37 => Ok(EntityEventPacketEventId::EnderDragonDeath),
            38 => Ok(EntityEventPacketEventId::DustParticles),
            39 => Ok(EntityEventPacketEventId::ArrowShake),
            57 => Ok(EntityEventPacketEventId::EatingItem),
            60 => Ok(EntityEventPacketEventId::BabyAnimalFeed),
            61 => Ok(EntityEventPacketEventId::DeathSmokeCloud),
            62 => Ok(EntityEventPacketEventId::CompleteTrade),
            63 => Ok(EntityEventPacketEventId::RemoveLeash),
            64 => Ok(EntityEventPacketEventId::Caravan),
            65 => Ok(EntityEventPacketEventId::ConsumeTotem),
            66 => Ok(EntityEventPacketEventId::PlayerCheckTreasureHunterAchievement),
            67 => Ok(EntityEventPacketEventId::EntitySpawn),
            68 => Ok(EntityEventPacketEventId::DragonPuke),
            69 => Ok(EntityEventPacketEventId::ItemEntityMerge),
            70 => Ok(EntityEventPacketEventId::StartSwim),
            71 => Ok(EntityEventPacketEventId::BalloonPop),
            72 => Ok(EntityEventPacketEventId::TreasureHunt),
            73 => Ok(EntityEventPacketEventId::AgentSummon),
            74 => Ok(EntityEventPacketEventId::ChargedItem),
            75 => Ok(EntityEventPacketEventId::Fall),
            76 => Ok(EntityEventPacketEventId::GrowUp),
            77 => Ok(EntityEventPacketEventId::VibrationDetected),
            78 => Ok(EntityEventPacketEventId::DrinkMilk),
            79 => Ok(EntityEventPacketEventId::WetnessStop),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(EntityEventPacketEventId),
                value: val as i64,
            }),
        }
    }
}
impl Default for EntityEventPacketEventId {
    fn default() -> Self {
        Self::Jump
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum MobEffectPacketEventId {
    Add = 1,
    Update = 2,
    Remove = 3,
}
impl crate::bedrock::codec::BedrockCodec for MobEffectPacketEventId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(MobEffectPacketEventId::Add),
            2 => Ok(MobEffectPacketEventId::Update),
            3 => Ok(MobEffectPacketEventId::Remove),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MobEffectPacketEventId),
                value: val as i64,
            }),
        }
    }
}
impl Default for MobEffectPacketEventId {
    fn default() -> Self {
        Self::Add
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum InteractPacketActionId {
    LeaveVehicle = 3,
    MouseOverEntity = 4,
    NpcOpen = 5,
    OpenInventory = 6,
}
impl crate::bedrock::codec::BedrockCodec for InteractPacketActionId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            3 => Ok(InteractPacketActionId::LeaveVehicle),
            4 => Ok(InteractPacketActionId::MouseOverEntity),
            5 => Ok(InteractPacketActionId::NpcOpen),
            6 => Ok(InteractPacketActionId::OpenInventory),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(InteractPacketActionId),
                value: val as i64,
            }),
        }
    }
}
impl Default for InteractPacketActionId {
    fn default() -> Self {
        Self::LeaveVehicle
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SetSpawnPositionPacketSpawnType {
    Player = 0,
    World = 1,
}
impl crate::bedrock::codec::BedrockCodec for SetSpawnPositionPacketSpawnType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SetSpawnPositionPacketSpawnType::Player),
            1 => Ok(SetSpawnPositionPacketSpawnType::World),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetSpawnPositionPacketSpawnType),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetSpawnPositionPacketSpawnType {
    fn default() -> Self {
        Self::Player
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum AnimatePacketActionId {
    None = 0,
    SwingArm = 1,
    Unknown = 2,
    WakeUp = 3,
    CriticalHit = 4,
    MagicCriticalHit = 5,
}
impl crate::bedrock::codec::BedrockCodec for AnimatePacketActionId {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(AnimatePacketActionId::None),
            1 => Ok(AnimatePacketActionId::SwingArm),
            2 => Ok(AnimatePacketActionId::Unknown),
            3 => Ok(AnimatePacketActionId::WakeUp),
            4 => Ok(AnimatePacketActionId::CriticalHit),
            5 => Ok(AnimatePacketActionId::MagicCriticalHit),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(AnimatePacketActionId),
                value: val as i64,
            }),
        }
    }
}
impl Default for AnimatePacketActionId {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CraftingEventPacketRecipeType {
    Inventory = 0,
    Crafting = 1,
    Workbench = 2,
}
impl crate::bedrock::codec::BedrockCodec for CraftingEventPacketRecipeType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(CraftingEventPacketRecipeType::Inventory),
            1 => Ok(CraftingEventPacketRecipeType::Crafting),
            2 => Ok(CraftingEventPacketRecipeType::Workbench),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CraftingEventPacketRecipeType),
                value: val as i64,
            }),
        }
    }
}
impl Default for CraftingEventPacketRecipeType {
    fn default() -> Self {
        Self::Inventory
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LevelChunkPacketBlobs {
    pub hashes: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for LevelChunkPacketBlobs {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.hashes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.hashes {
            crate::bedrock::codec::U64LE(*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let hashes = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        Ok(Self { hashes })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum SimpleEventPacketEventType {
    UninitializedSubtype = 0,
    EnableCommands = 1,
    DisableCommands = 2,
    UnlockWorldTemplateSettings = 3,
}
impl crate::bedrock::codec::BedrockCodec for SimpleEventPacketEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        crate::bedrock::codec::U16LE(val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as u16;
        match val {
            0 => Ok(SimpleEventPacketEventType::UninitializedSubtype),
            1 => Ok(SimpleEventPacketEventType::EnableCommands),
            2 => Ok(SimpleEventPacketEventType::DisableCommands),
            3 => Ok(SimpleEventPacketEventType::UnlockWorldTemplateSettings),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SimpleEventPacketEventType),
                value: val as i64,
            }),
        }
    }
}
impl Default for SimpleEventPacketEventType {
    fn default() -> Self {
        Self::UninitializedSubtype
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum EventPacketEventType {
    AchievementAwarded = 0,
    EntityInteract = 1,
    PortalBuilt = 2,
    PortalUsed = 3,
    MobKilled = 4,
    CauldronUsed = 5,
    PlayerDeath = 6,
    BossKilled = 7,
    AgentCommand = 8,
    AgentCreated = 9,
    BannerPatternRemoved = 10,
    CommandExecuted = 11,
    FishBucketed = 12,
    MobBorn = 13,
    PetDied = 14,
    CauldronBlockUsed = 15,
    ComposterBlockUsed = 16,
    BellBlockUsed = 17,
    ActorDefinition = 18,
    RaidUpdate = 19,
    PlayerMovementAnomaly = 20,
    PlayerMovementCorrected = 21,
    HoneyHarvested = 22,
    TargetBlockHit = 23,
    PiglinBarter = 24,
    WaxedOrUnwaxedCopper = 25,
    CodeBuilderRuntimeAction = 26,
    CodeBuilderScoreboard = 27,
    StriderRiddenInLavaInOverworld = 28,
    SneakCloseToSculkSensor = 29,
    CarefulRestoration = 30,
    ItemUsed = 31,
}
impl crate::bedrock::codec::BedrockCodec for EventPacketEventType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(EventPacketEventType::AchievementAwarded),
            1 => Ok(EventPacketEventType::EntityInteract),
            2 => Ok(EventPacketEventType::PortalBuilt),
            3 => Ok(EventPacketEventType::PortalUsed),
            4 => Ok(EventPacketEventType::MobKilled),
            5 => Ok(EventPacketEventType::CauldronUsed),
            6 => Ok(EventPacketEventType::PlayerDeath),
            7 => Ok(EventPacketEventType::BossKilled),
            8 => Ok(EventPacketEventType::AgentCommand),
            9 => Ok(EventPacketEventType::AgentCreated),
            10 => Ok(EventPacketEventType::BannerPatternRemoved),
            11 => Ok(EventPacketEventType::CommandExecuted),
            12 => Ok(EventPacketEventType::FishBucketed),
            13 => Ok(EventPacketEventType::MobBorn),
            14 => Ok(EventPacketEventType::PetDied),
            15 => Ok(EventPacketEventType::CauldronBlockUsed),
            16 => Ok(EventPacketEventType::ComposterBlockUsed),
            17 => Ok(EventPacketEventType::BellBlockUsed),
            18 => Ok(EventPacketEventType::ActorDefinition),
            19 => Ok(EventPacketEventType::RaidUpdate),
            20 => Ok(EventPacketEventType::PlayerMovementAnomaly),
            21 => Ok(EventPacketEventType::PlayerMovementCorrected),
            22 => Ok(EventPacketEventType::HoneyHarvested),
            23 => Ok(EventPacketEventType::TargetBlockHit),
            24 => Ok(EventPacketEventType::PiglinBarter),
            25 => Ok(EventPacketEventType::WaxedOrUnwaxedCopper),
            26 => Ok(EventPacketEventType::CodeBuilderRuntimeAction),
            27 => Ok(EventPacketEventType::CodeBuilderScoreboard),
            28 => Ok(EventPacketEventType::StriderRiddenInLavaInOverworld),
            29 => Ok(EventPacketEventType::SneakCloseToSculkSensor),
            30 => Ok(EventPacketEventType::CarefulRestoration),
            31 => Ok(EventPacketEventType::ItemUsed),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(EventPacketEventType),
                value: val as i64,
            }),
        }
    }
}
impl Default for EventPacketEventType {
    fn default() -> Self {
        Self::AchievementAwarded
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundMapItemDataPacketTracked {
    pub objects: Vec<TrackedObject>,
    pub decorations: Vec<MapDecoration>,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundMapItemDataPacketTracked {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.objects.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.objects {
            item.encode(buf)?;
        }
        let len = self.decorations.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.decorations {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let objects = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<TrackedObject as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?);
            }
            tmp_vec
        };
        let decorations = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(<MapDecoration as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?);
            }
            tmp_vec
        };
        Ok(Self {
            objects,
            decorations,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundMapItemDataPacketTexture {
    pub width: i32,
    pub height: i32,
    pub x_offset: i32,
    pub y_offset: i32,
    pub pixels: Vec<i32>,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundMapItemDataPacketTexture {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.width).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.height).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.x_offset).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y_offset).encode(buf)?;
        let len = self.pixels.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.pixels {
            crate::bedrock::codec::VarInt(*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let width =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let height =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let x_offset =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let y_offset =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let pixels = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        Ok(Self {
            width,
            height,
            x_offset,
            y_offset,
            pixels,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MapInfoRequestPacketClientPixelsItem {
    pub rgba: i32,
    pub index: u16,
}
impl crate::bedrock::codec::BedrockCodec for MapInfoRequestPacketClientPixelsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.rgba).encode(buf)?;
        crate::bedrock::codec::U16LE(self.index).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let rgba =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let index =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { rgba, index })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum BossEventPacketType {
    ShowBar = 0,
    RegisterPlayer = 1,
    HideBar = 2,
    UnregisterPlayer = 3,
    SetBarProgress = 4,
    SetBarTitle = 5,
    UpdateProperties = 6,
    Texture = 7,
    Query = 8,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(BossEventPacketType::ShowBar),
            1 => Ok(BossEventPacketType::RegisterPlayer),
            2 => Ok(BossEventPacketType::HideBar),
            3 => Ok(BossEventPacketType::UnregisterPlayer),
            4 => Ok(BossEventPacketType::SetBarProgress),
            5 => Ok(BossEventPacketType::SetBarTitle),
            6 => Ok(BossEventPacketType::UpdateProperties),
            7 => Ok(BossEventPacketType::Texture),
            8 => Ok(BossEventPacketType::Query),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(BossEventPacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for BossEventPacketType {
    fn default() -> Self {
        Self::ShowBar
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BossEventPacketContentQuery {
    pub player_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacketContentQuery {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.player_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let player_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { player_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BossEventPacketContentSetBarProgress {
    pub progress: f32,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacketContentSetBarProgress {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.progress).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let progress =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { progress })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BossEventPacketContentSetBarTitle {
    pub title: String,
    pub filtered_title: String,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacketContentSetBarTitle {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.filtered_title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.filtered_title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let title = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let filtered_title = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            title,
            filtered_title,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BossEventPacketContentShowBar {
    pub title: String,
    pub filtered_title: String,
    pub progress: f32,
    pub screen_darkening: i16,
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacketContentShowBar {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.filtered_title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.filtered_title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::F32LE(self.progress).encode(buf)?;
        crate::bedrock::codec::I16LE(self.screen_darkening).encode(buf)?;
        crate::bedrock::codec::VarInt(self.color).encode(buf)?;
        crate::bedrock::codec::VarInt(self.overlay).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let title = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let filtered_title = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let progress =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let screen_darkening =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let color = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let overlay =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            title,
            filtered_title,
            progress,
            screen_darkening,
            color,
            overlay,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BossEventPacketContentTexture {
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacketContentTexture {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.color).encode(buf)?;
        crate::bedrock::codec::VarInt(self.overlay).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let color = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let overlay =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { color, overlay })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BossEventPacketContentUpdateProperties {
    pub screen_darkening: i16,
    pub color: i32,
    pub overlay: i32,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacketContentUpdateProperties {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I16LE(self.screen_darkening).encode(buf)?;
        crate::bedrock::codec::VarInt(self.color).encode(buf)?;
        crate::bedrock::codec::VarInt(self.overlay).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let screen_darkening =
            <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let color = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let overlay =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            screen_darkening,
            color,
            overlay,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum BossEventPacketContent {
    Query(BossEventPacketContentQuery),
    RegisterPlayer(BossEventPacketContentQuery),
    SetBarProgress(BossEventPacketContentSetBarProgress),
    SetBarTitle(BossEventPacketContentSetBarTitle),
    ShowBar(Box<BossEventPacketContentShowBar>),
    Texture(BossEventPacketContentTexture),
    UnregisterPlayer(BossEventPacketContentQuery),
    UpdateProperties(BossEventPacketContentUpdateProperties),
}
impl Default for BossEventPacketContent {
    fn default() -> Self {
        Self::Query(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketEnumsItem {
    pub name: String,
    pub values: Vec<u32>,
}
impl crate::bedrock::codec::BedrockCodec for AvailableCommandsPacketEnumsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            crate::bedrock::codec::U32LE(*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let values = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketChainedSubcommandsItemValuesItem {
    pub index: i32,
    pub value: i32,
}
impl crate::bedrock::codec::BedrockCodec
    for AvailableCommandsPacketChainedSubcommandsItemValuesItem
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.index).encode(buf)?;
        crate::bedrock::codec::VarInt(self.value).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let index = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let value = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        Ok(Self { index, value })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketChainedSubcommandsItem {
    pub name: String,
    pub values: Vec<AvailableCommandsPacketChainedSubcommandsItemValuesItem>,
}
impl crate::bedrock::codec::BedrockCodec for AvailableCommandsPacketChainedSubcommandsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let values = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketChainedSubcommandsItemValuesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType {
    Int = 1,
    Float = 3,
    Value = 4,
    WildcardInt = 5,
    Operator = 6,
    CommandOperator = 7,
    Target = 8,
    WildcardTarget = 10,
    FilePath = 17,
    IntegerRange = 23,
    EquipmentSlots = 43,
    String = 44,
    BlockPosition = 52,
    Position = 53,
    Message = 55,
    RawText = 58,
    Json = 62,
    BlockStates = 71,
    Command = 74,
}
impl crate::bedrock::codec::BedrockCodec
    for AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        crate::bedrock::codec::U16LE(val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as u16;
        match val {
            1 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Int,
                )
            }
            3 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Float,
                )
            }
            4 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Value,
                )
            }
            5 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::WildcardInt,
                )
            }
            6 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Operator,
                )
            }
            7 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::CommandOperator,
                )
            }
            8 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Target,
                )
            }
            10 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::WildcardTarget,
                )
            }
            17 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::FilePath,
                )
            }
            23 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::IntegerRange,
                )
            }
            43 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::EquipmentSlots,
                )
            }
            44 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::String,
                )
            }
            52 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::BlockPosition,
                )
            }
            53 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Position,
                )
            }
            55 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Message,
                )
            }
            58 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::RawText,
                )
            }
            62 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Json,
                )
            }
            71 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::BlockStates,
                )
            }
            74 => {
                Ok(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType::Command,
                )
            }
            _ => {
                Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                    enum_name: stringify!(
                        AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType
                    ),
                    value: val as i64,
                })
            }
        }
    }
}
impl Default for AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType {
    fn default() -> Self {
        Self::Int
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType {
    Valid = 16,
    Enum = 48,
    Suffixed = 256,
    SoftEnum = 1040,
}
impl crate::bedrock::codec::BedrockCodec
    for AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        crate::bedrock::codec::U16LE(val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as u16;
        match val {
            16 => Ok(
                AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType::Valid,
            ),
            48 => {
                Ok(AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType::Enum)
            }
            256 => Ok(
                AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType::Suffixed,
            ),
            1040 => Ok(
                AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType::SoftEnum,
            ),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(
                    AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType
                ),
                value: val as i64,
            }),
        }
    }
}
impl Default for AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType {
    fn default() -> Self {
        Self::Valid
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketCommandDataItemOverloadsItemParametersItem {
    pub parameter_name: String,
    pub value_type: AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType,
    pub enum_type: AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType,
    pub optional: bool,
    pub options: CommandFlags,
}
impl crate::bedrock::codec::BedrockCodec
    for AvailableCommandsPacketCommandDataItemOverloadsItemParametersItem
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.parameter_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.parameter_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.value_type.encode(buf)?;
        self.enum_type.encode(buf)?;
        self.optional.encode(buf)?;
        self.options.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let parameter_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let value_type = <AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let enum_type = <AvailableCommandsPacketCommandDataItemOverloadsItemParametersItemEnumType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let optional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let options = <CommandFlags as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            parameter_name,
            value_type,
            enum_type,
            optional,
            options,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketCommandDataItemOverloadsItem {
    pub chaining: bool,
    pub parameters: Vec<AvailableCommandsPacketCommandDataItemOverloadsItemParametersItem>,
}
impl crate::bedrock::codec::BedrockCodec for AvailableCommandsPacketCommandDataItemOverloadsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.chaining.encode(buf)?;
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let chaining = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let parameters = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketCommandDataItemOverloadsItemParametersItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            chaining,
            parameters,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketCommandDataItem {
    pub name: String,
    pub description: String,
    pub flags: u16,
    pub permission_level: String,
    pub alias: i32,
    pub chained_subcommand_offsets: Vec<u32>,
    pub overloads: Vec<AvailableCommandsPacketCommandDataItemOverloadsItem>,
}
impl crate::bedrock::codec::BedrockCodec for AvailableCommandsPacketCommandDataItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.description)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.description).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::U16LE(self.flags).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.permission_level)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.permission_level).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I32LE(self.alias).encode(buf)?;
        let len = self.chained_subcommand_offsets.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.chained_subcommand_offsets {
            crate::bedrock::codec::U32LE(*item).encode(buf)?;
        }
        let len = self.overloads.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.overloads {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let description = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let flags =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let permission_level = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let alias =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let chained_subcommand_offsets = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        let overloads = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketCommandDataItemOverloadsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            name,
            description,
            flags,
            permission_level,
            alias,
            chained_subcommand_offsets,
            overloads,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketDynamicEnumsItem {
    pub name: String,
    pub values: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for AvailableCommandsPacketDynamicEnumsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let values = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self { name, values })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint {
    CheatsEnabled = 0,
    OperatorPermissions = 1,
    HostPermissions = 2,
}
impl crate::bedrock::codec::BedrockCodec
    for AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => {
                Ok(
                    AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint::CheatsEnabled,
                )
            }
            1 => {
                Ok(
                    AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint::OperatorPermissions,
                )
            }
            2 => {
                Ok(
                    AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint::HostPermissions,
                )
            }
            _ => {
                Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                    enum_name: stringify!(
                        AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint
                    ),
                    value: val as i64,
                })
            }
        }
    }
}
impl Default for AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint {
    fn default() -> Self {
        Self::CheatsEnabled
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketEnumConstraintsItemConstraintsItem {
    pub constraint: AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint,
}
impl crate::bedrock::codec::BedrockCodec
    for AvailableCommandsPacketEnumConstraintsItemConstraintsItem
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.constraint.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let constraint = <AvailableCommandsPacketEnumConstraintsItemConstraintsItemConstraint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { constraint })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacketEnumConstraintsItem {
    pub value_index: i32,
    pub enum_index: i32,
    pub constraints: Vec<AvailableCommandsPacketEnumConstraintsItemConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for AvailableCommandsPacketEnumConstraintsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.value_index).encode(buf)?;
        crate::bedrock::codec::I32LE(self.enum_index).encode(buf)?;
        let len = self.constraints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let value_index =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let enum_index =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let constraints = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketEnumConstraintsItemConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            value_index,
            enum_index,
            constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandBlockUpdatePacketContentFalse {
    pub minecart_entity_runtime_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for CommandBlockUpdatePacketContentFalse {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.minecart_entity_runtime_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let minecart_entity_runtime_id =
            <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            minecart_entity_runtime_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CommandBlockUpdatePacketContentTrueMode {
    Impulse = 0,
    Repeat = 1,
    Chain = 2,
}
impl crate::bedrock::codec::BedrockCodec for CommandBlockUpdatePacketContentTrueMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(CommandBlockUpdatePacketContentTrueMode::Impulse),
            1 => Ok(CommandBlockUpdatePacketContentTrueMode::Repeat),
            2 => Ok(CommandBlockUpdatePacketContentTrueMode::Chain),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CommandBlockUpdatePacketContentTrueMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for CommandBlockUpdatePacketContentTrueMode {
    fn default() -> Self {
        Self::Impulse
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandBlockUpdatePacketContentTrue {
    pub position: BlockCoordinates,
    pub mode: CommandBlockUpdatePacketContentTrueMode,
    pub needs_redstone: bool,
    pub conditional: bool,
}
impl crate::bedrock::codec::BedrockCodec for CommandBlockUpdatePacketContentTrue {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        self.mode.encode(buf)?;
        self.needs_redstone.encode(buf)?;
        self.conditional.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let mode = <CommandBlockUpdatePacketContentTrueMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let needs_redstone = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let conditional = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            position,
            mode,
            needs_redstone,
            conditional,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum CommandBlockUpdatePacketContent {
    False(CommandBlockUpdatePacketContentFalse),
    True(Box<CommandBlockUpdatePacketContentTrue>),
}
impl Default for CommandBlockUpdatePacketContent {
    fn default() -> Self {
        Self::False(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandOutputPacketOutputItem {
    pub message_id: String,
    pub success: bool,
    pub parameters: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for CommandOutputPacketOutputItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.message_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.message_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.success.encode(buf)?;
        let len = self.parameters.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.parameters {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let message_id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let success = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let parameters = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self {
            message_id,
            success,
            parameters,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ResourcePackDataInfoPacketPackType {
    Addon = 1,
    Cached = 2,
    CopyProtected = 3,
    Behavior = 4,
    PersonaPiece = 5,
    Resources = 6,
    Skins = 7,
    WorldTemplate = 8,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackDataInfoPacketPackType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(ResourcePackDataInfoPacketPackType::Addon),
            2 => Ok(ResourcePackDataInfoPacketPackType::Cached),
            3 => Ok(ResourcePackDataInfoPacketPackType::CopyProtected),
            4 => Ok(ResourcePackDataInfoPacketPackType::Behavior),
            5 => Ok(ResourcePackDataInfoPacketPackType::PersonaPiece),
            6 => Ok(ResourcePackDataInfoPacketPackType::Resources),
            7 => Ok(ResourcePackDataInfoPacketPackType::Skins),
            8 => Ok(ResourcePackDataInfoPacketPackType::WorldTemplate),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ResourcePackDataInfoPacketPackType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ResourcePackDataInfoPacketPackType {
    fn default() -> Self {
        Self::Addon
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SetTitlePacketType {
    Clear = 0,
    Reset = 1,
    SetTitle = 2,
    SetSubtitle = 3,
    ActionBarMessage = 4,
    SetDurations = 5,
    SetTitleJson = 6,
    SetSubtitleJson = 7,
    ActionBarMessageJson = 8,
}
impl crate::bedrock::codec::BedrockCodec for SetTitlePacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SetTitlePacketType::Clear),
            1 => Ok(SetTitlePacketType::Reset),
            2 => Ok(SetTitlePacketType::SetTitle),
            3 => Ok(SetTitlePacketType::SetSubtitle),
            4 => Ok(SetTitlePacketType::ActionBarMessage),
            5 => Ok(SetTitlePacketType::SetDurations),
            6 => Ok(SetTitlePacketType::SetTitleJson),
            7 => Ok(SetTitlePacketType::SetSubtitleJson),
            8 => Ok(SetTitlePacketType::ActionBarMessageJson),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetTitlePacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetTitlePacketType {
    fn default() -> Self {
        Self::Clear
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ShowStoreOfferPacketRedirectType {
    Marketplace = 0,
    DressingRoom = 1,
    ThirdPartyServerPage = 2,
}
impl crate::bedrock::codec::BedrockCodec for ShowStoreOfferPacketRedirectType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ShowStoreOfferPacketRedirectType::Marketplace),
            1 => Ok(ShowStoreOfferPacketRedirectType::DressingRoom),
            2 => Ok(ShowStoreOfferPacketRedirectType::ThirdPartyServerPage),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ShowStoreOfferPacketRedirectType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ShowStoreOfferPacketRedirectType {
    fn default() -> Self {
        Self::Marketplace
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum BookEditPacketType {
    ReplacePage = 0,
    AddPage = 1,
    DeletePage = 2,
    SwapPages = 3,
    Sign = 4,
}
impl crate::bedrock::codec::BedrockCodec for BookEditPacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(BookEditPacketType::ReplacePage),
            1 => Ok(BookEditPacketType::AddPage),
            2 => Ok(BookEditPacketType::DeletePage),
            3 => Ok(BookEditPacketType::SwapPages),
            4 => Ok(BookEditPacketType::Sign),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(BookEditPacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for BookEditPacketType {
    fn default() -> Self {
        Self::ReplacePage
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BookEditPacketContentAddPage {
    pub page_number: u8,
    pub text: String,
    pub photo_name: String,
}
impl crate::bedrock::codec::BedrockCodec for BookEditPacketContentAddPage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.page_number.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.text)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.text).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.photo_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.photo_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let text = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let photo_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            page_number,
            text,
            photo_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BookEditPacketContentDeletePage {
    pub page_number: u8,
}
impl crate::bedrock::codec::BedrockCodec for BookEditPacketContentDeletePage {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.page_number.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let page_number = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { page_number })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BookEditPacketContentSign {
    pub title: String,
    pub author: String,
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for BookEditPacketContentSign {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.author)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.author).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.xuid)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.xuid).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let title = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let author = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let xuid = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            title,
            author,
            xuid,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BookEditPacketContentSwapPages {
    pub page_1: u8,
    pub page_2: u8,
}
impl crate::bedrock::codec::BedrockCodec for BookEditPacketContentSwapPages {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.page_1.encode(buf)?;
        self.page_2.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let page_1 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let page_2 = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { page_1, page_2 })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum BookEditPacketContent {
    AddPage(BookEditPacketContentAddPage),
    DeletePage(BookEditPacketContentDeletePage),
    ReplacePage(BookEditPacketContentAddPage),
    Sign(BookEditPacketContentSign),
    SwapPages(BookEditPacketContentSwapPages),
}
impl Default for BookEditPacketContent {
    fn default() -> Self {
        Self::AddPage(Default::default())
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum NpcRequestPacketRequestType {
    SetActions = 0,
    ExecuteAction = 1,
    ExecuteClosingCommands = 2,
    SetName = 3,
    SetSkin = 4,
    SetInteractionText = 5,
    ExecuteOpeningCommands = 6,
}
impl crate::bedrock::codec::BedrockCodec for NpcRequestPacketRequestType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(NpcRequestPacketRequestType::SetActions),
            1 => Ok(NpcRequestPacketRequestType::ExecuteAction),
            2 => Ok(NpcRequestPacketRequestType::ExecuteClosingCommands),
            3 => Ok(NpcRequestPacketRequestType::SetName),
            4 => Ok(NpcRequestPacketRequestType::SetSkin),
            5 => Ok(NpcRequestPacketRequestType::SetInteractionText),
            6 => Ok(NpcRequestPacketRequestType::ExecuteOpeningCommands),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(NpcRequestPacketRequestType),
                value: val as i64,
            }),
        }
    }
}
impl Default for NpcRequestPacketRequestType {
    fn default() -> Self {
        Self::SetActions
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum NpcRequestPacketActionType {
    SetActions = 0,
    ExecuteAction = 1,
    ExecuteClosingCommands = 2,
    SetName = 3,
    SetSkin = 4,
    SetInteractText = 5,
    ExecuteOpeningCommands = 6,
}
impl crate::bedrock::codec::BedrockCodec for NpcRequestPacketActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(NpcRequestPacketActionType::SetActions),
            1 => Ok(NpcRequestPacketActionType::ExecuteAction),
            2 => Ok(NpcRequestPacketActionType::ExecuteClosingCommands),
            3 => Ok(NpcRequestPacketActionType::SetName),
            4 => Ok(NpcRequestPacketActionType::SetSkin),
            5 => Ok(NpcRequestPacketActionType::SetInteractText),
            6 => Ok(NpcRequestPacketActionType::ExecuteOpeningCommands),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(NpcRequestPacketActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for NpcRequestPacketActionType {
    fn default() -> Self {
        Self::SetActions
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ModalFormResponsePacketContentCancelReason {
    Closed = 0,
    Busy = 1,
}
impl crate::bedrock::codec::BedrockCodec for ModalFormResponsePacketContentCancelReason {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ModalFormResponsePacketContentCancelReason::Closed),
            1 => Ok(ModalFormResponsePacketContentCancelReason::Busy),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ModalFormResponsePacketContentCancelReason),
                value: val as i64,
            }),
        }
    }
}
impl Default for ModalFormResponsePacketContentCancelReason {
    fn default() -> Self {
        Self::Closed
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ModalFormResponsePacketContent {
    pub cancel_reason: ModalFormResponsePacketContentCancelReason,
}
impl crate::bedrock::codec::BedrockCodec for ModalFormResponsePacketContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.cancel_reason.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let cancel_reason = <ModalFormResponsePacketContentCancelReason as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { cancel_reason })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SetScorePacketAction {
    Change = 0,
    Remove = 1,
}
impl crate::bedrock::codec::BedrockCodec for SetScorePacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SetScorePacketAction::Change),
            1 => Ok(SetScorePacketAction::Remove),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetScorePacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetScorePacketAction {
    fn default() -> Self {
        Self::Change
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum SetScorePacketEntriesItemContentEntryType {
    Player = 1,
    Entity = 2,
    FakePlayer = 3,
}
impl crate::bedrock::codec::BedrockCodec for SetScorePacketEntriesItemContentEntryType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(SetScorePacketEntriesItemContentEntryType::Player),
            2 => Ok(SetScorePacketEntriesItemContentEntryType::Entity),
            3 => Ok(SetScorePacketEntriesItemContentEntryType::FakePlayer),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetScorePacketEntriesItemContentEntryType),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetScorePacketEntriesItemContentEntryType {
    fn default() -> Self {
        Self::Player
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum SetScorePacketEntriesItemContentEntityUniqueId {
    Entity(i64),
    Player(i64),
}
impl Default for SetScorePacketEntriesItemContentEntityUniqueId {
    fn default() -> Self {
        Self::Entity(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetScorePacketEntriesItemContent {
    pub entry_type: SetScorePacketEntriesItemContentEntryType,
    pub entity_unique_id: Option<SetScorePacketEntriesItemContentEntityUniqueId>,
    pub custom_name: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for SetScorePacketEntriesItemContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.entry_type.encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            match v {
                SetScorePacketEntriesItemContentEntityUniqueId::Entity(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
                SetScorePacketEntriesItemContentEntityUniqueId::Player(v) => {
                    crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
                }
            }
        }
        if let Some(v) = &self.custom_name {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (v).chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (v).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entry_type = <SetScorePacketEntriesItemContentEntryType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_unique_id = match entry_type {
            SetScorePacketEntriesItemContentEntryType::Entity => {
                Some(
                    SetScorePacketEntriesItemContentEntityUniqueId::Entity(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            SetScorePacketEntriesItemContentEntryType::Player => {
                Some(
                    SetScorePacketEntriesItemContentEntityUniqueId::Player(
                        <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            _ => None,
        };
        let custom_name = match entry_type {
            SetScorePacketEntriesItemContentEntryType::FakePlayer => Some({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            }),
            _ => None,
        };
        Ok(Self {
            entry_type,
            entity_unique_id,
            custom_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetScorePacketEntriesItem {
    pub scoreboard_id: i64,
    pub objective_name: String,
    pub score: i32,
    pub content: Option<Box<SetScorePacketEntriesItemContent>>,
}
#[derive(Debug, Clone)]
pub struct SetScorePacketEntriesItemArgs {
    pub action: SetScorePacketAction,
}
impl crate::bedrock::codec::BedrockCodec for SetScorePacketEntriesItem {
    type Args = SetScorePacketEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.scoreboard_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.objective_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.objective_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I32LE(self.score).encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let scoreboard_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let objective_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let score =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let content = match args.action {
            SetScorePacketAction::Change => Some(Box::new(
                <SetScorePacketEntriesItemContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )),
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            objective_name,
            score,
            content,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum LabTablePacketActionType {
    Combine = 0,
    React = 1,
    Reset = 2,
}
impl crate::bedrock::codec::BedrockCodec for LabTablePacketActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(LabTablePacketActionType::Combine),
            1 => Ok(LabTablePacketActionType::React),
            2 => Ok(LabTablePacketActionType::Reset),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(LabTablePacketActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for LabTablePacketActionType {
    fn default() -> Self {
        Self::Combine
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum UpdateBlockSyncedPacketTransitionType {
    Entity = 0,
    Create = 1,
    Destroy = 2,
}
impl crate::bedrock::codec::BedrockCodec for UpdateBlockSyncedPacketTransitionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(UpdateBlockSyncedPacketTransitionType::Entity),
            1 => Ok(UpdateBlockSyncedPacketTransitionType::Create),
            2 => Ok(UpdateBlockSyncedPacketTransitionType::Destroy),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(UpdateBlockSyncedPacketTransitionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for UpdateBlockSyncedPacketTransitionType {
    fn default() -> Self {
        Self::Entity
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i8)]
pub enum SetScoreboardIdentityPacketAction {
    RegisterIdentity = 0,
    ClearIdentity = 1,
}
impl crate::bedrock::codec::BedrockCodec for SetScoreboardIdentityPacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SetScoreboardIdentityPacketAction::RegisterIdentity),
            1 => Ok(SetScoreboardIdentityPacketAction::ClearIdentity),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetScoreboardIdentityPacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetScoreboardIdentityPacketAction {
    fn default() -> Self {
        Self::RegisterIdentity
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetScoreboardIdentityPacketEntriesItem {
    pub scoreboard_id: i64,
    pub entity_unique_id: Option<i64>,
}
#[derive(Debug, Clone)]
pub struct SetScoreboardIdentityPacketEntriesItemArgs {
    pub action: SetScoreboardIdentityPacketAction,
}
impl crate::bedrock::codec::BedrockCodec for SetScoreboardIdentityPacketEntriesItem {
    type Args = SetScoreboardIdentityPacketEntriesItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.scoreboard_id).encode(buf)?;
        if let Some(v) = &self.entity_unique_id {
            crate::bedrock::codec::ZigZag64(*v).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let scoreboard_id =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_unique_id = match args.action {
            SetScoreboardIdentityPacketAction::RegisterIdentity => Some(
                <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0,
            ),
            _ => None,
        };
        Ok(Self {
            scoreboard_id,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum UpdateSoftEnumPacketActionType {
    Add = 0,
    Remove = 1,
    Update = 2,
}
impl crate::bedrock::codec::BedrockCodec for UpdateSoftEnumPacketActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(UpdateSoftEnumPacketActionType::Add),
            1 => Ok(UpdateSoftEnumPacketActionType::Remove),
            2 => Ok(UpdateSoftEnumPacketActionType::Update),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(UpdateSoftEnumPacketActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for UpdateSoftEnumPacketActionType {
    fn default() -> Self {
        Self::Add
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct NetworkChunkPublisherUpdatePacketSavedChunksItem {
    pub x: i32,
    pub z: i32,
}
impl crate::bedrock::codec::BedrockCodec for NetworkChunkPublisherUpdatePacketSavedChunksItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?
        .0;
        Ok(Self { x, z })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum VideoStreamConnectPacketAction {
    None = 1,
    Close = 2,
}
impl crate::bedrock::codec::BedrockCodec for VideoStreamConnectPacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(VideoStreamConnectPacketAction::None),
            2 => Ok(VideoStreamConnectPacketAction::Close),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(VideoStreamConnectPacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for VideoStreamConnectPacketAction {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureTemplateDataExportRequestPacketRequestType {
    ExportFromSave = 1,
    ExportFromLoad = 2,
    QuerySavedStructure = 3,
    ImportFromSave = 4,
}
impl crate::bedrock::codec::BedrockCodec for StructureTemplateDataExportRequestPacketRequestType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(StructureTemplateDataExportRequestPacketRequestType::ExportFromSave),
            2 => Ok(StructureTemplateDataExportRequestPacketRequestType::ExportFromLoad),
            3 => Ok(StructureTemplateDataExportRequestPacketRequestType::QuerySavedStructure),
            4 => Ok(StructureTemplateDataExportRequestPacketRequestType::ImportFromSave),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StructureTemplateDataExportRequestPacketRequestType),
                value: val as i64,
            }),
        }
    }
}
impl Default for StructureTemplateDataExportRequestPacketRequestType {
    fn default() -> Self {
        Self::ExportFromSave
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum StructureTemplateDataExportResponsePacketResponseType {
    Export = 1,
    Query = 2,
    Import = 3,
}
impl crate::bedrock::codec::BedrockCodec for StructureTemplateDataExportResponsePacketResponseType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(StructureTemplateDataExportResponsePacketResponseType::Export),
            2 => Ok(StructureTemplateDataExportResponsePacketResponseType::Query),
            3 => Ok(StructureTemplateDataExportResponsePacketResponseType::Import),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(StructureTemplateDataExportResponsePacketResponseType),
                value: val as i64,
            }),
        }
    }
}
impl Default for StructureTemplateDataExportResponsePacketResponseType {
    fn default() -> Self {
        Self::Export
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EducationSettingsPacketAgentCapabilities {
    pub has: bool,
    pub can_modify_blocks: bool,
}
impl crate::bedrock::codec::BedrockCodec for EducationSettingsPacketAgentCapabilities {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.has.encode(buf)?;
        self.can_modify_blocks.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let has = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let can_modify_blocks = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            has,
            can_modify_blocks,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EducationSettingsPacketExternalLinkSettings {
    pub has: bool,
    pub url: String,
    pub display_name: String,
}
impl crate::bedrock::codec::BedrockCodec for EducationSettingsPacketExternalLinkSettings {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.has.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.url)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.url).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.display_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.display_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let has = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let url = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let display_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            has,
            url,
            display_name,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum EmotePacketFlags {
    ServerSide = 1,
    MuteChat = 2,
}
impl crate::bedrock::codec::BedrockCodec for EmotePacketFlags {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(EmotePacketFlags::ServerSide),
            2 => Ok(EmotePacketFlags::MuteChat),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(EmotePacketFlags),
                value: val as i64,
            }),
        }
    }
}
impl Default for EmotePacketFlags {
    fn default() -> Self {
        Self::ServerSide
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum MultiplayerSettingsPacketActionType {
    EnableMultiplayer = 0,
    DisableMultiplayer = 1,
    RefreshJoinCode = 2,
}
impl crate::bedrock::codec::BedrockCodec for MultiplayerSettingsPacketActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(MultiplayerSettingsPacketActionType::EnableMultiplayer),
            1 => Ok(MultiplayerSettingsPacketActionType::DisableMultiplayer),
            2 => Ok(MultiplayerSettingsPacketActionType::RefreshJoinCode),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(MultiplayerSettingsPacketActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for MultiplayerSettingsPacketActionType {
    fn default() -> Self {
        Self::EnableMultiplayer
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CompletedUsingItemPacketUseMethod {
    EquipArmor = 0,
    Eat = 1,
    Attack = 2,
    Consume = 3,
    Throw = 4,
    Shoot = 5,
    Place = 6,
    FillBottle = 7,
    FillBucket = 8,
    PourBucket = 9,
    UseTool = 10,
    Interact = 11,
    Retrieved = 12,
    Dyed = 13,
    Traded = 14,
    BrushingCompleted = 15,
    OpenedVault = 16,
}
impl crate::bedrock::codec::BedrockCodec for CompletedUsingItemPacketUseMethod {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(CompletedUsingItemPacketUseMethod::EquipArmor),
            1 => Ok(CompletedUsingItemPacketUseMethod::Eat),
            2 => Ok(CompletedUsingItemPacketUseMethod::Attack),
            3 => Ok(CompletedUsingItemPacketUseMethod::Consume),
            4 => Ok(CompletedUsingItemPacketUseMethod::Throw),
            5 => Ok(CompletedUsingItemPacketUseMethod::Shoot),
            6 => Ok(CompletedUsingItemPacketUseMethod::Place),
            7 => Ok(CompletedUsingItemPacketUseMethod::FillBottle),
            8 => Ok(CompletedUsingItemPacketUseMethod::FillBucket),
            9 => Ok(CompletedUsingItemPacketUseMethod::PourBucket),
            10 => Ok(CompletedUsingItemPacketUseMethod::UseTool),
            11 => Ok(CompletedUsingItemPacketUseMethod::Interact),
            12 => Ok(CompletedUsingItemPacketUseMethod::Retrieved),
            13 => Ok(CompletedUsingItemPacketUseMethod::Dyed),
            14 => Ok(CompletedUsingItemPacketUseMethod::Traded),
            15 => Ok(CompletedUsingItemPacketUseMethod::BrushingCompleted),
            16 => Ok(CompletedUsingItemPacketUseMethod::OpenedVault),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CompletedUsingItemPacketUseMethod),
                value: val as i64,
            }),
        }
    }
}
impl Default for CompletedUsingItemPacketUseMethod {
    fn default() -> Self {
        Self::EquipArmor
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u16)]
pub enum NetworkSettingsPacketCompressionAlgorithm {
    Deflate = 0,
    Snappy = 1,
}
impl crate::bedrock::codec::BedrockCodec for NetworkSettingsPacketCompressionAlgorithm {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u16;
        crate::bedrock::codec::U16LE(val as u16).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as u16;
        match val {
            0 => Ok(NetworkSettingsPacketCompressionAlgorithm::Deflate),
            1 => Ok(NetworkSettingsPacketCompressionAlgorithm::Snappy),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(NetworkSettingsPacketCompressionAlgorithm),
                value: val as i64,
            }),
        }
    }
}
impl Default for NetworkSettingsPacketCompressionAlgorithm {
    fn default() -> Self {
        Self::Deflate
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PlayerAuthInputPacketInputMode {
    Unknown = 0,
    Mouse = 1,
    Touch = 2,
    GamePad = 3,
    MotionController = 4,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacketInputMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(PlayerAuthInputPacketInputMode::Unknown),
            1 => Ok(PlayerAuthInputPacketInputMode::Mouse),
            2 => Ok(PlayerAuthInputPacketInputMode::Touch),
            3 => Ok(PlayerAuthInputPacketInputMode::GamePad),
            4 => Ok(PlayerAuthInputPacketInputMode::MotionController),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayerAuthInputPacketInputMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayerAuthInputPacketInputMode {
    fn default() -> Self {
        Self::Unknown
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PlayerAuthInputPacketPlayMode {
    Normal = 0,
    Teaser = 1,
    Screen = 2,
    Viewer = 3,
    Reality = 4,
    Placement = 5,
    LivingRoom = 6,
    ExitLevel = 7,
    ExitLevelLivingRoom = 8,
    NumModes = 9,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacketPlayMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(PlayerAuthInputPacketPlayMode::Normal),
            1 => Ok(PlayerAuthInputPacketPlayMode::Teaser),
            2 => Ok(PlayerAuthInputPacketPlayMode::Screen),
            3 => Ok(PlayerAuthInputPacketPlayMode::Viewer),
            4 => Ok(PlayerAuthInputPacketPlayMode::Reality),
            5 => Ok(PlayerAuthInputPacketPlayMode::Placement),
            6 => Ok(PlayerAuthInputPacketPlayMode::LivingRoom),
            7 => Ok(PlayerAuthInputPacketPlayMode::ExitLevel),
            8 => Ok(PlayerAuthInputPacketPlayMode::ExitLevelLivingRoom),
            9 => Ok(PlayerAuthInputPacketPlayMode::NumModes),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayerAuthInputPacketPlayMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayerAuthInputPacketPlayMode {
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PlayerAuthInputPacketInteractionModel {
    Touch = 0,
    Crosshair = 1,
    Classic = 2,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacketInteractionModel {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(PlayerAuthInputPacketInteractionModel::Touch),
            1 => Ok(PlayerAuthInputPacketInteractionModel::Crosshair),
            2 => Ok(PlayerAuthInputPacketInteractionModel::Classic),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayerAuthInputPacketInteractionModel),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayerAuthInputPacketInteractionModel {
    fn default() -> Self {
        Self::Touch
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerAuthInputPacketTransaction {
    pub legacy: TransactionLegacy,
    pub actions: TransactionActions,
    pub data: TransactionUseItem,
}
#[derive(Debug, Clone)]
pub struct PlayerAuthInputPacketTransactionArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
    for PlayerAuthInputPacketTransactionArgs
{
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacketTransaction {
    type Args = PlayerAuthInputPacketTransactionArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.legacy.encode(buf)?;
        let len = self.actions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.actions {
            item.encode(buf)?;
        }
        self.data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let legacy = <TransactionLegacy as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let actions = {
            let res: TransactionActions = {
                let raw =
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec.push(
                        <TransactionActionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            TransactionActionsItemArgs {
                                shield_item_id: args.shield_item_id,
                                has_stack_net_ids: false,
                            },
                        )?,
                    );
                }
                tmp_vec
            };
            res
        };
        let data = <TransactionUseItem as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            TransactionUseItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            legacy,
            actions,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerAuthInputPacketContent {
    pub vehicle_rotation: Vec2F,
    pub predicted_vehicle: i64,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacketContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.vehicle_rotation.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.predicted_vehicle).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let vehicle_rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let predicted_vehicle =
            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            vehicle_rotation,
            predicted_vehicle,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerAuthInputPacketBlockActionItemContentAbortBreak {
    pub position: Vec3I,
    pub face: i32,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacketBlockActionItemContentAbortBreak {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.face).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let face =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { position, face })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerAuthInputPacketBlockActionItemContent {
    AbortBreak(PlayerAuthInputPacketBlockActionItemContentAbortBreak),
    ContinueBreak(PlayerAuthInputPacketBlockActionItemContentAbortBreak),
    CrackBreak(PlayerAuthInputPacketBlockActionItemContentAbortBreak),
    PredictBreak(PlayerAuthInputPacketBlockActionItemContentAbortBreak),
    StartBreak(PlayerAuthInputPacketBlockActionItemContentAbortBreak),
}
impl Default for PlayerAuthInputPacketBlockActionItemContent {
    fn default() -> Self {
        Self::AbortBreak(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerAuthInputPacketBlockActionItem {
    pub action: Action,
    pub content: Option<PlayerAuthInputPacketBlockActionItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacketBlockActionItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                PlayerAuthInputPacketBlockActionItemContent::AbortBreak(v) => {
                    v.encode(buf)?;
                }
                PlayerAuthInputPacketBlockActionItemContent::ContinueBreak(v) => {
                    v.encode(buf)?;
                }
                PlayerAuthInputPacketBlockActionItemContent::CrackBreak(v) => {
                    v.encode(buf)?;
                }
                PlayerAuthInputPacketBlockActionItemContent::PredictBreak(v) => {
                    v.encode(buf)?;
                }
                PlayerAuthInputPacketBlockActionItemContent::StartBreak(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action = <Action as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match action {
            Action::AbortBreak => {
                Some(
                    PlayerAuthInputPacketBlockActionItemContent::AbortBreak(
                        <PlayerAuthInputPacketBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::ContinueBreak => {
                Some(
                    PlayerAuthInputPacketBlockActionItemContent::ContinueBreak(
                        <PlayerAuthInputPacketBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::CrackBreak => {
                Some(
                    PlayerAuthInputPacketBlockActionItemContent::CrackBreak(
                        <PlayerAuthInputPacketBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::PredictBreak => {
                Some(
                    PlayerAuthInputPacketBlockActionItemContent::PredictBreak(
                        <PlayerAuthInputPacketBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            Action::StartBreak => {
                Some(
                    PlayerAuthInputPacketBlockActionItemContent::StartBreak(
                        <PlayerAuthInputPacketBlockActionItemContentAbortBreak as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self { action, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum CreativeContentPacketGroupsItemCategory {
    All = 0,
    Construction = 1,
    Nature = 2,
    Equipment = 3,
    Items = 4,
    ItemCommandOnly = 5,
}
impl crate::bedrock::codec::BedrockCodec for CreativeContentPacketGroupsItemCategory {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(CreativeContentPacketGroupsItemCategory::All),
            1 => Ok(CreativeContentPacketGroupsItemCategory::Construction),
            2 => Ok(CreativeContentPacketGroupsItemCategory::Nature),
            3 => Ok(CreativeContentPacketGroupsItemCategory::Equipment),
            4 => Ok(CreativeContentPacketGroupsItemCategory::Items),
            5 => Ok(CreativeContentPacketGroupsItemCategory::ItemCommandOnly),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CreativeContentPacketGroupsItemCategory),
                value: val as i64,
            }),
        }
    }
}
impl Default for CreativeContentPacketGroupsItemCategory {
    fn default() -> Self {
        Self::All
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CreativeContentPacketGroupsItem {
    pub category: CreativeContentPacketGroupsItemCategory,
    pub name: String,
    pub icon_item: ItemLegacy,
}
#[derive(Debug, Clone)]
pub struct CreativeContentPacketGroupsItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for CreativeContentPacketGroupsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for CreativeContentPacketGroupsItem {
    type Args = CreativeContentPacketGroupsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.category.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.icon_item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let category = <CreativeContentPacketGroupsItemCategory as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let icon_item = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            category,
            name,
            icon_item,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CreativeContentPacketItemsItem {
    pub entry_id: i32,
    pub item: ItemLegacy,
    pub group_index: i32,
}
#[derive(Debug, Clone)]
pub struct CreativeContentPacketItemsItemArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for CreativeContentPacketItemsItemArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for CreativeContentPacketItemsItem {
    type Args = CreativeContentPacketItemsItemArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.entry_id).encode(buf)?;
        self.item.encode(buf)?;
        crate::bedrock::codec::VarInt(self.group_index).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entry_id =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <ItemLegacy as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemLegacyArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let group_index =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            entry_id,
            item,
            group_index,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PositionTrackingDbBroadcastPacketBroadcastAction {
    Update = 0,
    Destory = 1,
    NotFound = 2,
}
impl crate::bedrock::codec::BedrockCodec for PositionTrackingDbBroadcastPacketBroadcastAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PositionTrackingDbBroadcastPacketBroadcastAction::Update),
            1 => Ok(PositionTrackingDbBroadcastPacketBroadcastAction::Destory),
            2 => Ok(PositionTrackingDbBroadcastPacketBroadcastAction::NotFound),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PositionTrackingDbBroadcastPacketBroadcastAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for PositionTrackingDbBroadcastPacketBroadcastAction {
    fn default() -> Self {
        Self::Update
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PositionTrackingDbRequestPacketAction {
    Query = 0,
}
impl crate::bedrock::codec::BedrockCodec for PositionTrackingDbRequestPacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PositionTrackingDbRequestPacketAction::Query),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PositionTrackingDbRequestPacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for PositionTrackingDbRequestPacketAction {
    fn default() -> Self {
        Self::Query
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ViolationWarningPacketViolationType {
    Malformed = 0,
}
impl crate::bedrock::codec::BedrockCodec for ViolationWarningPacketViolationType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ViolationWarningPacketViolationType::Malformed),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ViolationWarningPacketViolationType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ViolationWarningPacketViolationType {
    fn default() -> Self {
        Self::Malformed
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ViolationWarningPacketSeverity {
    Warning = 0,
    FinalWarning = 1,
    Terminating = 2,
}
impl crate::bedrock::codec::BedrockCodec for ViolationWarningPacketSeverity {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ViolationWarningPacketSeverity::Warning),
            1 => Ok(ViolationWarningPacketSeverity::FinalWarning),
            2 => Ok(ViolationWarningPacketSeverity::Terminating),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ViolationWarningPacketSeverity),
                value: val as i64,
            }),
        }
    }
}
impl Default for ViolationWarningPacketSeverity {
    fn default() -> Self {
        Self::Warning
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraShakePacketAction {
    Add = 0,
    Stop = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraShakePacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CameraShakePacketAction::Add),
            1 => Ok(CameraShakePacketAction::Stop),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CameraShakePacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for CameraShakePacketAction {
    fn default() -> Self {
        Self::Add
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CorrectPlayerMovePredictionPacketPredictionType {
    Player = 0,
    Vehicle = 1,
}
impl crate::bedrock::codec::BedrockCodec for CorrectPlayerMovePredictionPacketPredictionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CorrectPlayerMovePredictionPacketPredictionType::Player),
            1 => Ok(CorrectPlayerMovePredictionPacketPredictionType::Vehicle),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CorrectPlayerMovePredictionPacketPredictionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for CorrectPlayerMovePredictionPacketPredictionType {
    fn default() -> Self {
        Self::Player
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AddVolumeEntityPacketBounds {
    pub min: BlockCoordinates,
    pub max: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for AddVolumeEntityPacketBounds {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.min.encode(buf)?;
        self.max.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let min = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let max = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { min, max })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SimulationTypePacketType {
    Game = 0,
    Editor = 1,
    Test = 2,
    Invalid = 3,
}
impl crate::bedrock::codec::BedrockCodec for SimulationTypePacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SimulationTypePacketType::Game),
            1 => Ok(SimulationTypePacketType::Editor),
            2 => Ok(SimulationTypePacketType::Test),
            3 => Ok(SimulationTypePacketType::Invalid),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SimulationTypePacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for SimulationTypePacketType {
    fn default() -> Self {
        Self::Game
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum NpcDialoguePacketActionType {
    Open = 0,
    Close = 1,
}
impl crate::bedrock::codec::BedrockCodec for NpcDialoguePacketActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(NpcDialoguePacketActionType::Open),
            1 => Ok(NpcDialoguePacketActionType::Close),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(NpcDialoguePacketActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for NpcDialoguePacketActionType {
    fn default() -> Self {
        Self::Open
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum SubchunkPacketEntries {
    SubChunkEntryWithoutCaching(SubChunkEntryWithoutCaching),
    SubChunkEntryWithCaching(SubChunkEntryWithCaching),
}
impl Default for SubchunkPacketEntries {
    fn default() -> Self {
        Self::SubChunkEntryWithoutCaching(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SubchunkRequestPacketRequestsItem {
    pub dx: i8,
    pub dy: i8,
    pub dz: i8,
}
impl crate::bedrock::codec::BedrockCodec for SubchunkRequestPacketRequestsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.dx.encode(buf)?;
        self.dy.encode(buf)?;
        self.dz.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let dx = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dy = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let dz = <i8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { dx, dy, dz })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CodeBuilderSourcePacketOperation {
    None = 0,
    Get = 1,
    Set = 2,
    Reset = 3,
}
impl crate::bedrock::codec::BedrockCodec for CodeBuilderSourcePacketOperation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CodeBuilderSourcePacketOperation::None),
            1 => Ok(CodeBuilderSourcePacketOperation::Get),
            2 => Ok(CodeBuilderSourcePacketOperation::Set),
            3 => Ok(CodeBuilderSourcePacketOperation::Reset),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CodeBuilderSourcePacketOperation),
                value: val as i64,
            }),
        }
    }
}
impl Default for CodeBuilderSourcePacketOperation {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CodeBuilderSourcePacketCategory {
    None = 0,
    CodeStatus = 1,
    Instantiation = 2,
}
impl crate::bedrock::codec::BedrockCodec for CodeBuilderSourcePacketCategory {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CodeBuilderSourcePacketCategory::None),
            1 => Ok(CodeBuilderSourcePacketCategory::CodeStatus),
            2 => Ok(CodeBuilderSourcePacketCategory::Instantiation),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CodeBuilderSourcePacketCategory),
                value: val as i64,
            }),
        }
    }
}
impl Default for CodeBuilderSourcePacketCategory {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CodeBuilderSourcePacketCodeStatus {
    None = 0,
    NotStarted = 1,
    InProgress = 2,
    Paused = 3,
    Error = 4,
    Succeeded = 5,
}
impl crate::bedrock::codec::BedrockCodec for CodeBuilderSourcePacketCodeStatus {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CodeBuilderSourcePacketCodeStatus::None),
            1 => Ok(CodeBuilderSourcePacketCodeStatus::NotStarted),
            2 => Ok(CodeBuilderSourcePacketCodeStatus::InProgress),
            3 => Ok(CodeBuilderSourcePacketCodeStatus::Paused),
            4 => Ok(CodeBuilderSourcePacketCodeStatus::Error),
            5 => Ok(CodeBuilderSourcePacketCodeStatus::Succeeded),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CodeBuilderSourcePacketCodeStatus),
                value: val as i64,
            }),
        }
    }
}
impl Default for CodeBuilderSourcePacketCodeStatus {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum DimensionDataPacketDefinitionsItemGenerator {
    Legacy = 0,
    Overworld = 1,
    Flat = 2,
    Nether = 3,
    End = 4,
    Void = 5,
}
impl crate::bedrock::codec::BedrockCodec for DimensionDataPacketDefinitionsItemGenerator {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(DimensionDataPacketDefinitionsItemGenerator::Legacy),
            1 => Ok(DimensionDataPacketDefinitionsItemGenerator::Overworld),
            2 => Ok(DimensionDataPacketDefinitionsItemGenerator::Flat),
            3 => Ok(DimensionDataPacketDefinitionsItemGenerator::Nether),
            4 => Ok(DimensionDataPacketDefinitionsItemGenerator::End),
            5 => Ok(DimensionDataPacketDefinitionsItemGenerator::Void),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(DimensionDataPacketDefinitionsItemGenerator),
                value: val as i64,
            }),
        }
    }
}
impl Default for DimensionDataPacketDefinitionsItemGenerator {
    fn default() -> Self {
        Self::Legacy
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DimensionDataPacketDefinitionsItem {
    pub id: String,
    pub max_height: i32,
    pub min_height: i32,
    pub generator: DimensionDataPacketDefinitionsItemGenerator,
}
impl crate::bedrock::codec::BedrockCodec for DimensionDataPacketDefinitionsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.max_height).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.min_height).encode(buf)?;
        self.generator.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let max_height =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let min_height =
            <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let generator = <DimensionDataPacketDefinitionsItemGenerator as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            id,
            max_height,
            min_height,
            generator,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum AgentActionPacketActionType {
    None = 0,
    Attack = 1,
    Collect = 2,
    Destroy = 3,
    DetectRedstone = 4,
    DetectObstacle = 5,
    Drop = 6,
    DropAll = 7,
    Inspect = 8,
    InspectData = 9,
    InspectItemCount = 10,
    InspectItemDetail = 11,
    InspectItemSpace = 12,
    Interact = 13,
    Move = 14,
    PlaceBlock = 15,
    Till = 16,
    TransferItemTo = 17,
    Turn = 18,
}
impl crate::bedrock::codec::BedrockCodec for AgentActionPacketActionType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(AgentActionPacketActionType::None),
            1 => Ok(AgentActionPacketActionType::Attack),
            2 => Ok(AgentActionPacketActionType::Collect),
            3 => Ok(AgentActionPacketActionType::Destroy),
            4 => Ok(AgentActionPacketActionType::DetectRedstone),
            5 => Ok(AgentActionPacketActionType::DetectObstacle),
            6 => Ok(AgentActionPacketActionType::Drop),
            7 => Ok(AgentActionPacketActionType::DropAll),
            8 => Ok(AgentActionPacketActionType::Inspect),
            9 => Ok(AgentActionPacketActionType::InspectData),
            10 => Ok(AgentActionPacketActionType::InspectItemCount),
            11 => Ok(AgentActionPacketActionType::InspectItemDetail),
            12 => Ok(AgentActionPacketActionType::InspectItemSpace),
            13 => Ok(AgentActionPacketActionType::Interact),
            14 => Ok(AgentActionPacketActionType::Move),
            15 => Ok(AgentActionPacketActionType::PlaceBlock),
            16 => Ok(AgentActionPacketActionType::Till),
            17 => Ok(AgentActionPacketActionType::TransferItemTo),
            18 => Ok(AgentActionPacketActionType::Turn),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(AgentActionPacketActionType),
                value: val as i64,
            }),
        }
    }
}
impl Default for AgentActionPacketActionType {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum RequestAbilityPacketAbility {
    Build = 0,
    Mine = 1,
    DoorsAndSwitches = 2,
    OpenContainers = 3,
    AttackPlayers = 4,
    AttackMobs = 5,
    OperatorCommands = 6,
    Teleport = 7,
    Invulnerable = 8,
    Flying = 9,
    MayFly = 10,
    InstantBuild = 11,
    Lightning = 12,
    FlySpeed = 13,
    WalkSpeed = 14,
    Muted = 15,
    WorldBuilder = 16,
    NoClip = 17,
    AbilityCount = 18,
}
impl crate::bedrock::codec::BedrockCodec for RequestAbilityPacketAbility {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(RequestAbilityPacketAbility::Build),
            1 => Ok(RequestAbilityPacketAbility::Mine),
            2 => Ok(RequestAbilityPacketAbility::DoorsAndSwitches),
            3 => Ok(RequestAbilityPacketAbility::OpenContainers),
            4 => Ok(RequestAbilityPacketAbility::AttackPlayers),
            5 => Ok(RequestAbilityPacketAbility::AttackMobs),
            6 => Ok(RequestAbilityPacketAbility::OperatorCommands),
            7 => Ok(RequestAbilityPacketAbility::Teleport),
            8 => Ok(RequestAbilityPacketAbility::Invulnerable),
            9 => Ok(RequestAbilityPacketAbility::Flying),
            10 => Ok(RequestAbilityPacketAbility::MayFly),
            11 => Ok(RequestAbilityPacketAbility::InstantBuild),
            12 => Ok(RequestAbilityPacketAbility::Lightning),
            13 => Ok(RequestAbilityPacketAbility::FlySpeed),
            14 => Ok(RequestAbilityPacketAbility::WalkSpeed),
            15 => Ok(RequestAbilityPacketAbility::Muted),
            16 => Ok(RequestAbilityPacketAbility::WorldBuilder),
            17 => Ok(RequestAbilityPacketAbility::NoClip),
            18 => Ok(RequestAbilityPacketAbility::AbilityCount),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(RequestAbilityPacketAbility),
                value: val as i64,
            }),
        }
    }
}
impl Default for RequestAbilityPacketAbility {
    fn default() -> Self {
        Self::Build
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum RequestAbilityPacketValueType {
    Bool = 1,
    Float = 2,
}
impl crate::bedrock::codec::BedrockCodec for RequestAbilityPacketValueType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            1 => Ok(RequestAbilityPacketValueType::Bool),
            2 => Ok(RequestAbilityPacketValueType::Float),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(RequestAbilityPacketValueType),
                value: val as i64,
            }),
        }
    }
}
impl Default for RequestAbilityPacketValueType {
    fn default() -> Self {
        Self::Bool
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct FeatureRegistryPacketFeaturesItem {
    pub name: String,
    pub options: String,
}
impl crate::bedrock::codec::BedrockCodec for FeatureRegistryPacketFeaturesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.options)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.options).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let options = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { name, options })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum GameTestRequestPacketRotation {
    T0Deg = 0,
    T90Deg = 1,
    T180Deg = 2,
    T270Deg = 3,
    T360Deg = 4,
}
impl crate::bedrock::codec::BedrockCodec for GameTestRequestPacketRotation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(GameTestRequestPacketRotation::T0Deg),
            1 => Ok(GameTestRequestPacketRotation::T90Deg),
            2 => Ok(GameTestRequestPacketRotation::T180Deg),
            3 => Ok(GameTestRequestPacketRotation::T270Deg),
            4 => Ok(GameTestRequestPacketRotation::T360Deg),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(GameTestRequestPacketRotation),
                value: val as i64,
            }),
        }
    }
}
impl Default for GameTestRequestPacketRotation {
    fn default() -> Self {
        Self::T0Deg
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum UnlockedRecipesPacketUnlockType {
    Empty = 0,
    InitiallyUnlocked = 1,
    NewlyUnlocked = 2,
    RemoveUnlocked = 3,
    RemoveAllUnlocked = 4,
}
impl crate::bedrock::codec::BedrockCodec for UnlockedRecipesPacketUnlockType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u32;
        crate::bedrock::codec::U32LE(val as u32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as u32;
        match val {
            0 => Ok(UnlockedRecipesPacketUnlockType::Empty),
            1 => Ok(UnlockedRecipesPacketUnlockType::InitiallyUnlocked),
            2 => Ok(UnlockedRecipesPacketUnlockType::NewlyUnlocked),
            3 => Ok(UnlockedRecipesPacketUnlockType::RemoveUnlocked),
            4 => Ok(UnlockedRecipesPacketUnlockType::RemoveAllUnlocked),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(UnlockedRecipesPacketUnlockType),
                value: val as i64,
            }),
        }
    }
}
impl Default for UnlockedRecipesPacketUnlockType {
    fn default() -> Self {
        Self::Empty
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraInstructionPacketInstructionSetEaseData {
    pub type_: EaseType,
    pub duration: f32,
}
impl crate::bedrock::codec::BedrockCodec for CameraInstructionPacketInstructionSetEaseData {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        crate::bedrock::codec::F32LE(self.duration).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <EaseType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { type_, duration })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraInstructionPacketInstructionSet {
    pub runtime_id: i32,
    pub ease_data: Option<CameraInstructionPacketInstructionSetEaseData>,
    pub position: Option<Vec3F>,
    pub rotation: Option<Vec2F>,
    pub facing: Option<Vec3F>,
    pub offset: Option<Vec2F>,
    pub entity_offset: Option<Vec3F>,
    pub default: Option<bool>,
    pub remove_ignore_starting_values: bool,
}
impl crate::bedrock::codec::BedrockCodec for CameraInstructionPacketInstructionSet {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.runtime_id).encode(buf)?;
        match &self.ease_data {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.position {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.rotation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.facing {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.entity_offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.default {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.remove_ignore_starting_values.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_id =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let ease_data = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraInstructionPacketInstructionSetEaseData as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let position = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let rotation = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let facing = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let offset = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let entity_offset = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let default = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let remove_ignore_starting_values =
            <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_id,
            ease_data,
            position,
            rotation,
            facing,
            offset,
            entity_offset,
            default,
            remove_ignore_starting_values,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraInstructionPacketFade {
    pub fade_in_duration: f32,
    pub wait_duration: f32,
    pub fade_out_duration: f32,
    pub color_rgb: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for CameraInstructionPacketFade {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.fade_in_duration).encode(buf)?;
        crate::bedrock::codec::F32LE(self.wait_duration).encode(buf)?;
        crate::bedrock::codec::F32LE(self.fade_out_duration).encode(buf)?;
        self.color_rgb.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let fade_in_duration =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let wait_duration =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let fade_out_duration =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let color_rgb = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            fade_in_duration,
            wait_duration,
            fade_out_duration,
            color_rgb,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraInstructionPacketTarget {
    pub offset: Option<Vec3F>,
    pub entity_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for CameraInstructionPacketTarget {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        match &self.offset {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        crate::bedrock::codec::I64LE(self.entity_unique_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let offset = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let entity_unique_id =
            <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            offset,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraInstructionPacketFov {
    pub field_of_view: f32,
    pub ease_time: f32,
    pub ease_type: EaseType,
    pub clear: bool,
}
impl crate::bedrock::codec::BedrockCodec for CameraInstructionPacketFov {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.field_of_view).encode(buf)?;
        crate::bedrock::codec::F32LE(self.ease_time).encode(buf)?;
        self.ease_type.encode(buf)?;
        self.clear.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let field_of_view =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let ease_time =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let ease_type = <EaseType as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let clear = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            field_of_view,
            ease_time,
            ease_type,
            clear,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrimDataPacketPatternsItem {
    pub item_name: String,
    pub pattern: String,
}
impl crate::bedrock::codec::BedrockCodec for TrimDataPacketPatternsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.item_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.item_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.pattern)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.pattern).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let item_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let pattern = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { item_name, pattern })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrimDataPacketMaterialsItem {
    pub material: String,
    pub color: String,
    pub item_name: String,
}
impl crate::bedrock::codec::BedrockCodec for TrimDataPacketMaterialsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.material)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.material).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.color)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.color).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.item_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.item_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let material = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let color = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let item_name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            material,
            color,
            item_name,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum AgentAnimationPacketAnimation {
    ArmSwing = 0,
    Shrug = 1,
}
impl crate::bedrock::codec::BedrockCodec for AgentAnimationPacketAnimation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(AgentAnimationPacketAnimation::ArmSwing),
            1 => Ok(AgentAnimationPacketAnimation::Shrug),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(AgentAnimationPacketAnimation),
                value: val as i64,
            }),
        }
    }
}
impl Default for AgentAnimationPacketAnimation {
    fn default() -> Self {
        Self::ArmSwing
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SetPlayerInventoryOptionsPacketLeftTab {
    None = 0,
    Construction = 1,
    Equipment = 2,
    Items = 3,
    Nature = 4,
    Search = 5,
    Survival = 6,
}
impl crate::bedrock::codec::BedrockCodec for SetPlayerInventoryOptionsPacketLeftTab {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SetPlayerInventoryOptionsPacketLeftTab::None),
            1 => Ok(SetPlayerInventoryOptionsPacketLeftTab::Construction),
            2 => Ok(SetPlayerInventoryOptionsPacketLeftTab::Equipment),
            3 => Ok(SetPlayerInventoryOptionsPacketLeftTab::Items),
            4 => Ok(SetPlayerInventoryOptionsPacketLeftTab::Nature),
            5 => Ok(SetPlayerInventoryOptionsPacketLeftTab::Search),
            6 => Ok(SetPlayerInventoryOptionsPacketLeftTab::Survival),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetPlayerInventoryOptionsPacketLeftTab),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetPlayerInventoryOptionsPacketLeftTab {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SetPlayerInventoryOptionsPacketRightTab {
    None = 0,
    Fullscreen = 1,
    Crafting = 2,
    Armor = 3,
}
impl crate::bedrock::codec::BedrockCodec for SetPlayerInventoryOptionsPacketRightTab {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SetPlayerInventoryOptionsPacketRightTab::None),
            1 => Ok(SetPlayerInventoryOptionsPacketRightTab::Fullscreen),
            2 => Ok(SetPlayerInventoryOptionsPacketRightTab::Crafting),
            3 => Ok(SetPlayerInventoryOptionsPacketRightTab::Armor),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetPlayerInventoryOptionsPacketRightTab),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetPlayerInventoryOptionsPacketRightTab {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SetPlayerInventoryOptionsPacketLayout {
    None = 0,
    Survival = 1,
    RecipeBook = 2,
    Creative = 3,
}
impl crate::bedrock::codec::BedrockCodec for SetPlayerInventoryOptionsPacketLayout {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SetPlayerInventoryOptionsPacketLayout::None),
            1 => Ok(SetPlayerInventoryOptionsPacketLayout::Survival),
            2 => Ok(SetPlayerInventoryOptionsPacketLayout::RecipeBook),
            3 => Ok(SetPlayerInventoryOptionsPacketLayout::Creative),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetPlayerInventoryOptionsPacketLayout),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetPlayerInventoryOptionsPacketLayout {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SetPlayerInventoryOptionsPacketCraftingLayout {
    None = 0,
    Survival = 1,
    RecipeBook = 2,
    Creative = 3,
}
impl crate::bedrock::codec::BedrockCodec for SetPlayerInventoryOptionsPacketCraftingLayout {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::ZigZag32(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SetPlayerInventoryOptionsPacketCraftingLayout::None),
            1 => Ok(SetPlayerInventoryOptionsPacketCraftingLayout::Survival),
            2 => Ok(SetPlayerInventoryOptionsPacketCraftingLayout::RecipeBook),
            3 => Ok(SetPlayerInventoryOptionsPacketCraftingLayout::Creative),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetPlayerInventoryOptionsPacketCraftingLayout),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetPlayerInventoryOptionsPacketCraftingLayout {
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum SetHudPacketVisibility {
    Hide = 0,
    Reset = 1,
}
impl crate::bedrock::codec::BedrockCodec for SetHudPacketVisibility {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(SetHudPacketVisibility::Hide),
            1 => Ok(SetHudPacketVisibility::Reset),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetHudPacketVisibility),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetHudPacketVisibility {
    fn default() -> Self {
        Self::Hide
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraAimAssistPacketTargetMode {
    Angle = 0,
    Distance = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraAimAssistPacketTargetMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CameraAimAssistPacketTargetMode::Angle),
            1 => Ok(CameraAimAssistPacketTargetMode::Distance),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CameraAimAssistPacketTargetMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for CameraAimAssistPacketTargetMode {
    fn default() -> Self {
        Self::Angle
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraAimAssistPacketAction {
    Set = 0,
    Clear = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraAimAssistPacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CameraAimAssistPacketAction::Set),
            1 => Ok(CameraAimAssistPacketAction::Clear),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CameraAimAssistPacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for CameraAimAssistPacketAction {
    fn default() -> Self {
        Self::Set
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum SetMovementAuthorityPacketMovementAuthority {
    Client = 0,
    Server = 1,
    ServerWithRewind = 2,
}
impl crate::bedrock::codec::BedrockCodec for SetMovementAuthorityPacketMovementAuthority {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(SetMovementAuthorityPacketMovementAuthority::Client),
            1 => Ok(SetMovementAuthorityPacketMovementAuthority::Server),
            2 => Ok(SetMovementAuthorityPacketMovementAuthority::ServerWithRewind),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(SetMovementAuthorityPacketMovementAuthority),
                value: val as i64,
            }),
        }
    }
}
impl Default for SetMovementAuthorityPacketMovementAuthority {
    fn default() -> Self {
        Self::Client
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraAimAssistPresetsPacketCategoriesItemEntityPrioritiesItem {
    pub id: String,
    pub priority: i32,
}
impl crate::bedrock::codec::BedrockCodec
    for CameraAimAssistPresetsPacketCategoriesItemEntityPrioritiesItem
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I32LE(self.priority).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let priority =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self { id, priority })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraAimAssistPresetsPacketCategoriesItem {
    pub name: String,
    pub entity_priorities: Vec<CameraAimAssistPresetsPacketCategoriesItemEntityPrioritiesItem>,
    pub block_priorities: Vec<CameraAimAssistPresetsPacketCategoriesItemEntityPrioritiesItem>,
    pub block_tags: Vec<i32>,
    pub entity_default: Option<i32>,
    pub block_default: Option<i32>,
}
impl crate::bedrock::codec::BedrockCodec for CameraAimAssistPresetsPacketCategoriesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.entity_priorities.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entity_priorities {
            item.encode(buf)?;
        }
        let len = self.block_priorities.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.block_priorities {
            item.encode(buf)?;
        }
        let len = self.block_tags.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.block_tags {
            crate::bedrock::codec::VarInt(*item).encode(buf)?;
        }
        match &self.entity_default {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::I32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.block_default {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::I32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let entity_priorities = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraAimAssistPresetsPacketCategoriesItemEntityPrioritiesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let block_priorities = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraAimAssistPresetsPacketCategoriesItemEntityPrioritiesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let block_tags = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec.push(
                    <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                );
            }
            tmp_vec
        };
        let entity_default = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let block_default = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        Ok(Self {
            name,
            entity_priorities,
            block_priorities,
            block_tags,
            entity_default,
            block_default,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraAimAssistPresetsPacketPresetsItemExclusionSettings {
    pub blocks: Vec<String>,
    pub entities: Vec<String>,
    pub block_tags: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec
    for CameraAimAssistPresetsPacketPresetsItemExclusionSettings
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.blocks.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.blocks {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.entities.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entities {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.block_tags.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.block_tags {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let blocks = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let entities = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let block_tags = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self {
            blocks,
            entities,
            block_tags,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraAimAssistPresetsPacketPresetsItemItemSettingsItem {
    pub id: String,
    pub category: String,
}
impl crate::bedrock::codec::BedrockCodec
    for CameraAimAssistPresetsPacketPresetsItemItemSettingsItem
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.category)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.category).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let category = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { id, category })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraAimAssistPresetsPacketPresetsItem {
    pub id: String,
    pub exclusion_settings: CameraAimAssistPresetsPacketPresetsItemExclusionSettings,
    pub target_liquids: Vec<String>,
    pub item_settings: Vec<CameraAimAssistPresetsPacketPresetsItemItemSettingsItem>,
    pub default_item_settings: Option<String>,
    pub hand_settings: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for CameraAimAssistPresetsPacketPresetsItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.exclusion_settings.encode(buf)?;
        let len = self.target_liquids.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.target_liquids {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.item_settings.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.item_settings {
            item.encode(buf)?;
        }
        match &self.default_item_settings {
            Some(v) => {
                buf.put_u8(1);
                let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                    (v).chars()
                        .map(|ch| {
                            let code = ch as u32;
                            if code <= 0xFF { code as u8 } else { b'?' }
                        })
                        .collect()
                } else {
                    (v).as_bytes().to_vec()
                };
                let len = bytes.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&bytes);
            }
            None => buf.put_u8(0),
        }
        match &self.hand_settings {
            Some(v) => {
                buf.put_u8(1);
                let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                    (v).chars()
                        .map(|ch| {
                            let code = ch as u32;
                            if code <= 0xFF { code as u8 } else { b'?' }
                        })
                        .collect()
                } else {
                    (v).as_bytes().to_vec()
                };
                let len = bytes.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&bytes);
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let id = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let exclusion_settings = <CameraAimAssistPresetsPacketPresetsItemExclusionSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let target_liquids = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let item_settings = {
            let raw =
                <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: raw });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraAimAssistPresetsPacketPresetsItemItemSettingsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let default_item_settings = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                })
            } else {
                None
            }
        };
        let hand_settings = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                })
            } else {
                None
            }
        };
        Ok(Self {
            id,
            exclusion_settings,
            target_liquids,
            item_settings,
            default_item_settings,
            hand_settings,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum CameraAimAssistPresetsPacketOperation {
    Set = 0,
    AddToExisting = 1,
}
impl crate::bedrock::codec::BedrockCodec for CameraAimAssistPresetsPacketOperation {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(CameraAimAssistPresetsPacketOperation::Set),
            1 => Ok(CameraAimAssistPresetsPacketOperation::AddToExisting),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(CameraAimAssistPresetsPacketOperation),
                value: val as i64,
            }),
        }
    }
}
impl Default for CameraAimAssistPresetsPacketOperation {
    fn default() -> Self {
        Self::Set
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ClientCameraAimAssistPacketAction {
    SetFromCameraPreset = 0,
    Clear = 1,
}
impl crate::bedrock::codec::BedrockCodec for ClientCameraAimAssistPacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ClientCameraAimAssistPacketAction::SetFromCameraPreset),
            1 => Ok(ClientCameraAimAssistPacketAction::Clear),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ClientCameraAimAssistPacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for ClientCameraAimAssistPacketAction {
    fn default() -> Self {
        Self::SetFromCameraPreset
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientMovementPredictionSyncPacketBoundingBox {
    pub scale: f32,
    pub width: f32,
    pub height: f32,
}
impl crate::bedrock::codec::BedrockCodec for ClientMovementPredictionSyncPacketBoundingBox {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.scale).encode(buf)?;
        crate::bedrock::codec::F32LE(self.width).encode(buf)?;
        crate::bedrock::codec::F32LE(self.height).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let scale =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let width =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let height =
            <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        Ok(Self {
            scale,
            width,
            height,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum UpdateClientOptionsPacketGraphicsMode {
    Simple = 0,
    Fancy = 1,
    Advanced = 2,
    RayTraced = 3,
}
impl crate::bedrock::codec::BedrockCodec for UpdateClientOptionsPacketGraphicsMode {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(UpdateClientOptionsPacketGraphicsMode::Simple),
            1 => Ok(UpdateClientOptionsPacketGraphicsMode::Fancy),
            2 => Ok(UpdateClientOptionsPacketGraphicsMode::Advanced),
            3 => Ok(UpdateClientOptionsPacketGraphicsMode::RayTraced),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(UpdateClientOptionsPacketGraphicsMode),
                value: val as i64,
            }),
        }
    }
}
impl Default for UpdateClientOptionsPacketGraphicsMode {
    fn default() -> Self {
        Self::Simple
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PlayerVideoCapturePacketAction {
    Stop = 0,
    Start = 1,
}
impl crate::bedrock::codec::BedrockCodec for PlayerVideoCapturePacketAction {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PlayerVideoCapturePacketAction::Stop),
            1 => Ok(PlayerVideoCapturePacketAction::Start),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayerVideoCapturePacketAction),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayerVideoCapturePacketAction {
    fn default() -> Self {
        Self::Stop
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerVideoCapturePacketContent {
    pub frame_rate: i32,
    pub file_prefix: String,
}
impl crate::bedrock::codec::BedrockCodec for PlayerVideoCapturePacketContent {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.frame_rate).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.file_prefix)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.file_prefix).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let frame_rate =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
                .0;
        let file_prefix = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            frame_rate,
            file_prefix,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum PlayerUpdateEntityOverridesPacketType {
    ClearAll = 0,
    Remove = 1,
    SetInt = 2,
    SetFloat = 3,
}
impl crate::bedrock::codec::BedrockCodec for PlayerUpdateEntityOverridesPacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(PlayerUpdateEntityOverridesPacketType::ClearAll),
            1 => Ok(PlayerUpdateEntityOverridesPacketType::Remove),
            2 => Ok(PlayerUpdateEntityOverridesPacketType::SetInt),
            3 => Ok(PlayerUpdateEntityOverridesPacketType::SetFloat),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayerUpdateEntityOverridesPacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayerUpdateEntityOverridesPacketType {
    fn default() -> Self {
        Self::ClearAll
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum PlayerUpdateEntityOverridesPacketValue {
    SetFloat(f32),
    SetInt(i32),
}
impl Default for PlayerUpdateEntityOverridesPacketValue {
    fn default() -> Self {
        Self::SetFloat(Default::default())
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum PlayerLocationPacketType {
    Coordinates = 0,
    TypeHide = 1,
}
impl crate::bedrock::codec::BedrockCodec for PlayerLocationPacketType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::I32LE(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw =
            <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(PlayerLocationPacketType::Coordinates),
            1 => Ok(PlayerLocationPacketType::TypeHide),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(PlayerLocationPacketType),
                value: val as i64,
            }),
        }
    }
}
impl Default for PlayerLocationPacketType {
    fn default() -> Self {
        Self::Coordinates
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ClientboundControlsSchemePacketScheme {
    LockedPlayerRelativeStrafe = 0,
    CameraRelative = 1,
    CameraRelativeStrafe = 2,
    PlayerRelative = 3,
    PlayerRelativeStrafe = 4,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundControlsSchemePacketScheme {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ClientboundControlsSchemePacketScheme::LockedPlayerRelativeStrafe),
            1 => Ok(ClientboundControlsSchemePacketScheme::CameraRelative),
            2 => Ok(ClientboundControlsSchemePacketScheme::CameraRelativeStrafe),
            3 => Ok(ClientboundControlsSchemePacketScheme::PlayerRelative),
            4 => Ok(ClientboundControlsSchemePacketScheme::PlayerRelativeStrafe),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ClientboundControlsSchemePacketScheme),
                value: val as i64,
            }),
        }
    }
}
impl Default for ClientboundControlsSchemePacketScheme {
    fn default() -> Self {
        Self::LockedPlayerRelativeStrafe
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum ServerScriptDebugDrawerPacketShapesItemShapeType {
    Line = 0,
    Box = 1,
    Sphere = 2,
    Circle = 3,
    Text = 4,
    Arrow = 5,
}
impl crate::bedrock::codec::BedrockCodec for ServerScriptDebugDrawerPacketShapesItemShapeType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as u8;
        val.encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let val = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        match val {
            0 => Ok(ServerScriptDebugDrawerPacketShapesItemShapeType::Line),
            1 => Ok(ServerScriptDebugDrawerPacketShapesItemShapeType::Box),
            2 => Ok(ServerScriptDebugDrawerPacketShapesItemShapeType::Sphere),
            3 => Ok(ServerScriptDebugDrawerPacketShapesItemShapeType::Circle),
            4 => Ok(ServerScriptDebugDrawerPacketShapesItemShapeType::Text),
            5 => Ok(ServerScriptDebugDrawerPacketShapesItemShapeType::Arrow),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ServerScriptDebugDrawerPacketShapesItemShapeType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ServerScriptDebugDrawerPacketShapesItemShapeType {
    fn default() -> Self {
        Self::Line
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerScriptDebugDrawerPacketShapesItem {
    pub network_id: i64,
    pub shape_type: Option<ServerScriptDebugDrawerPacketShapesItemShapeType>,
    pub location: Option<Vec3F>,
    pub scale: Option<f32>,
    pub rotation: Option<Vec3F>,
    pub time_left: Option<f32>,
    pub color: Option<i32>,
    pub text: Option<String>,
    pub box_bound: Option<Vec3F>,
    pub line_end_location: Option<Vec3F>,
    pub arrow_head_length: Option<f32>,
    pub arrow_head_radius: Option<f32>,
    pub segment_count: Option<u8>,
}
impl crate::bedrock::codec::BedrockCodec for ServerScriptDebugDrawerPacketShapesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.network_id).encode(buf)?;
        match &self.shape_type {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.location {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.scale {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.rotation {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.time_left {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.color {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::I32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.text {
            Some(v) => {
                buf.put_u8(1);
                let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                    (v).chars()
                        .map(|ch| {
                            let code = ch as u32;
                            if code <= 0xFF { code as u8 } else { b'?' }
                        })
                        .collect()
                } else {
                    (v).as_bytes().to_vec()
                };
                let len = bytes.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&bytes);
            }
            None => buf.put_u8(0),
        }
        match &self.box_bound {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.line_end_location {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.arrow_head_length {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.arrow_head_radius {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.segment_count {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let network_id =
            <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let shape_type = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <ServerScriptDebugDrawerPacketShapesItemShapeType as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let location = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let scale = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let rotation = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let time_left = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let color = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let text = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                })
            } else {
                None
            }
        };
        let box_bound = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let line_end_location = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        let arrow_head_length = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let arrow_head_radius = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                )
            } else {
                None
            }
        };
        let segment_count = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?)
            } else {
                None
            }
        };
        Ok(Self {
            network_id,
            shape_type,
            location,
            scale,
            rotation,
            time_left,
            color,
            text,
            box_bound,
            line_end_location,
            arrow_head_length,
            arrow_head_radius,
            segment_count,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ServerboundPackSettingChangePacketPackSettingType {
    Float = 0,
    Bool = 1,
    String = 2,
}
impl crate::bedrock::codec::BedrockCodec for ServerboundPackSettingChangePacketPackSettingType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ServerboundPackSettingChangePacketPackSettingType::Float),
            1 => Ok(ServerboundPackSettingChangePacketPackSettingType::Bool),
            2 => Ok(ServerboundPackSettingChangePacketPackSettingType::String),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ServerboundPackSettingChangePacketPackSettingType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ServerboundPackSettingChangePacketPackSettingType {
    fn default() -> Self {
        Self::Float
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ServerboundPackSettingChangePacketPackSettingValue {
    Bool(bool),
    Float(f32),
    String(String),
}
impl Default for ServerboundPackSettingChangePacketPackSettingValue {
    fn default() -> Self {
        Self::Bool(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerboundPackSettingChangePacketPackSetting {
    pub name: String,
    pub type_: ServerboundPackSettingChangePacketPackSettingType,
    pub value: Option<ServerboundPackSettingChangePacketPackSettingValue>,
}
impl crate::bedrock::codec::BedrockCodec for ServerboundPackSettingChangePacketPackSetting {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                ServerboundPackSettingChangePacketPackSettingValue::Bool(v) => {
                    (*v).encode(buf)?;
                }
                ServerboundPackSettingChangePacketPackSettingValue::Float(v) => {
                    crate::bedrock::codec::F32LE(*v).encode(buf)?;
                }
                ServerboundPackSettingChangePacketPackSettingValue::String(v) => {
                    let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                        (v).chars()
                            .map(|ch| {
                                let code = ch as u32;
                                if code <= 0xFF { code as u8 } else { b'?' }
                            })
                            .collect()
                    } else {
                        (v).as_bytes().to_vec()
                    };
                    let len = bytes.len();
                    crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                    buf.put_slice(&bytes);
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let type_ = <ServerboundPackSettingChangePacketPackSettingType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match type_ {
            ServerboundPackSettingChangePacketPackSettingType::Bool => {
                Some(ServerboundPackSettingChangePacketPackSettingValue::Bool(
                    <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                ))
            }
            ServerboundPackSettingChangePacketPackSettingType::Float => {
                Some(ServerboundPackSettingChangePacketPackSettingValue::Float(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                ))
            }
            ServerboundPackSettingChangePacketPackSettingType::String => Some(
                ServerboundPackSettingChangePacketPackSettingValue::String({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                }),
            ),
        };
        Ok(Self { name, type_, value })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ClientboundDataStorePacketEntriesItemType {
    Update = 0,
    Change = 1,
    Removal = 2,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundDataStorePacketEntriesItemType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ClientboundDataStorePacketEntriesItemType::Update),
            1 => Ok(ClientboundDataStorePacketEntriesItemType::Change),
            2 => Ok(ClientboundDataStorePacketEntriesItemType::Removal),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ClientboundDataStorePacketEntriesItemType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ClientboundDataStorePacketEntriesItemType {
    fn default() -> Self {
        Self::Update
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ClientboundDataStorePacketEntriesItemContentChangeDataType {
    Double = 0,
    Bool = 1,
    String = 2,
}
impl crate::bedrock::codec::BedrockCodec
    for ClientboundDataStorePacketEntriesItemContentChangeDataType
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ClientboundDataStorePacketEntriesItemContentChangeDataType::Double),
            1 => Ok(ClientboundDataStorePacketEntriesItemContentChangeDataType::Bool),
            2 => Ok(ClientboundDataStorePacketEntriesItemContentChangeDataType::String),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ClientboundDataStorePacketEntriesItemContentChangeDataType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ClientboundDataStorePacketEntriesItemContentChangeDataType {
    fn default() -> Self {
        Self::Double
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ClientboundDataStorePacketEntriesItemContentChangeData {
    Bool(bool),
    Double(f64),
    String(String),
}
impl Default for ClientboundDataStorePacketEntriesItemContentChangeData {
    fn default() -> Self {
        Self::Bool(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundDataStorePacketEntriesItemContentChange {
    pub name: String,
    pub property: String,
    pub update_count: i32,
    pub data_type: ClientboundDataStorePacketEntriesItemContentChangeDataType,
    pub data: Option<ClientboundDataStorePacketEntriesItemContentChangeData>,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundDataStorePacketEntriesItemContentChange {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.property)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.property).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::VarInt(self.update_count).encode(buf)?;
        self.data_type.encode(buf)?;
        if let Some(v) = &self.data {
            match v {
                ClientboundDataStorePacketEntriesItemContentChangeData::Bool(v) => {
                    (*v).encode(buf)?;
                }
                ClientboundDataStorePacketEntriesItemContentChangeData::Double(v) => {
                    crate::bedrock::codec::F64LE(*v).encode(buf)?;
                }
                ClientboundDataStorePacketEntriesItemContentChangeData::String(v) => {
                    let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                        (v).chars()
                            .map(|ch| {
                                let code = ch as u32;
                                if code <= 0xFF { code as u8 } else { b'?' }
                            })
                            .collect()
                    } else {
                        (v).as_bytes().to_vec()
                    };
                    let len = bytes.len();
                    crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                    buf.put_slice(&bytes);
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let property = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let update_count =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data_type = <ClientboundDataStorePacketEntriesItemContentChangeDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = match data_type {
            ClientboundDataStorePacketEntriesItemContentChangeDataType::Bool => Some(
                ClientboundDataStorePacketEntriesItemContentChangeData::Bool(
                    <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                ),
            ),
            ClientboundDataStorePacketEntriesItemContentChangeDataType::Double => Some(
                ClientboundDataStorePacketEntriesItemContentChangeData::Double(
                    <crate::bedrock::codec::F64LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                ),
            ),
            ClientboundDataStorePacketEntriesItemContentChangeDataType::String => Some(
                ClientboundDataStorePacketEntriesItemContentChangeData::String({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                }),
            ),
        };
        Ok(Self {
            name,
            property,
            update_count,
            data_type,
            data,
        })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ClientboundDataStorePacketEntriesItemContentUpdateDataType {
    Double = 0,
    Bool = 1,
    String = 2,
}
impl crate::bedrock::codec::BedrockCodec
    for ClientboundDataStorePacketEntriesItemContentUpdateDataType
{
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ClientboundDataStorePacketEntriesItemContentUpdateDataType::Double),
            1 => Ok(ClientboundDataStorePacketEntriesItemContentUpdateDataType::Bool),
            2 => Ok(ClientboundDataStorePacketEntriesItemContentUpdateDataType::String),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ClientboundDataStorePacketEntriesItemContentUpdateDataType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ClientboundDataStorePacketEntriesItemContentUpdateDataType {
    fn default() -> Self {
        Self::Double
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ClientboundDataStorePacketEntriesItemContentUpdateData {
    Bool(bool),
    Double(f64),
    String(String),
}
impl Default for ClientboundDataStorePacketEntriesItemContentUpdateData {
    fn default() -> Self {
        Self::Bool(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundDataStorePacketEntriesItemContentUpdate {
    pub name: String,
    pub property: String,
    pub path: String,
    pub data_type: ClientboundDataStorePacketEntriesItemContentUpdateDataType,
    pub data: Option<ClientboundDataStorePacketEntriesItemContentUpdateData>,
    pub update_count: i32,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundDataStorePacketEntriesItemContentUpdate {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.property)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.property).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.path)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.path).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.data_type.encode(buf)?;
        if let Some(v) = &self.data {
            match v {
                ClientboundDataStorePacketEntriesItemContentUpdateData::Bool(v) => {
                    (*v).encode(buf)?;
                }
                ClientboundDataStorePacketEntriesItemContentUpdateData::Double(v) => {
                    crate::bedrock::codec::F64LE(*v).encode(buf)?;
                }
                ClientboundDataStorePacketEntriesItemContentUpdateData::String(v) => {
                    let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                        (v).chars()
                            .map(|ch| {
                                let code = ch as u32;
                                if code <= 0xFF { code as u8 } else { b'?' }
                            })
                            .collect()
                    } else {
                        (v).as_bytes().to_vec()
                    };
                    let len = bytes.len();
                    crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                    buf.put_slice(&bytes);
                }
            }
        }
        crate::bedrock::codec::VarInt(self.update_count).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let property = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let path = {
            let len_raw =
                (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength { value: len_raw });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let data_type = <ClientboundDataStorePacketEntriesItemContentUpdateDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = match data_type {
            ClientboundDataStorePacketEntriesItemContentUpdateDataType::Bool => Some(
                ClientboundDataStorePacketEntriesItemContentUpdateData::Bool(
                    <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                ),
            ),
            ClientboundDataStorePacketEntriesItemContentUpdateDataType::Double => Some(
                ClientboundDataStorePacketEntriesItemContentUpdateData::Double(
                    <crate::bedrock::codec::F64LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
                ),
            ),
            ClientboundDataStorePacketEntriesItemContentUpdateDataType::String => Some(
                ClientboundDataStorePacketEntriesItemContentUpdateData::String({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                }),
            ),
        };
        let update_count =
            <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            name,
            property,
            path,
            data_type,
            data,
            update_count,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ClientboundDataStorePacketEntriesItemContent {
    Change(Box<ClientboundDataStorePacketEntriesItemContentChange>),
    Removal(RecipeIngredientContentComplexAlias),
    Update(Box<ClientboundDataStorePacketEntriesItemContentUpdate>),
}
impl Default for ClientboundDataStorePacketEntriesItemContent {
    fn default() -> Self {
        Self::Change(Default::default())
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundDataStorePacketEntriesItem {
    pub type_: ClientboundDataStorePacketEntriesItemType,
    pub content: Option<ClientboundDataStorePacketEntriesItemContent>,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundDataStorePacketEntriesItem {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                ClientboundDataStorePacketEntriesItemContent::Change(v) => {
                    v.encode(buf)?;
                }
                ClientboundDataStorePacketEntriesItemContent::Removal(v) => {
                    v.encode(buf)?;
                }
                ClientboundDataStorePacketEntriesItemContent::Update(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <ClientboundDataStorePacketEntriesItemType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            ClientboundDataStorePacketEntriesItemType::Change => {
                Some(
                    ClientboundDataStorePacketEntriesItemContent::Change(
                        Box::new(
                            <ClientboundDataStorePacketEntriesItemContentChange as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            ClientboundDataStorePacketEntriesItemType::Removal => {
                Some(
                    ClientboundDataStorePacketEntriesItemContent::Removal(
                        <RecipeIngredientContentComplexAlias as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            ClientboundDataStorePacketEntriesItemType::Update => {
                Some(
                    ClientboundDataStorePacketEntriesItemContent::Update(
                        Box::new(
                            <ClientboundDataStorePacketEntriesItemContentUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
        };
        Ok(Self { type_, content })
    }
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum ServerboundDataStorePacketDataType {
    Double = 0,
    Bool = 1,
    String = 2,
}
impl crate::bedrock::codec::BedrockCodec for ServerboundDataStorePacketDataType {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let val = *self as i32;
        crate::bedrock::codec::VarInt(val as i32).encode(buf)
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let val = raw.0 as i32;
        match val {
            0 => Ok(ServerboundDataStorePacketDataType::Double),
            1 => Ok(ServerboundDataStorePacketDataType::Bool),
            2 => Ok(ServerboundDataStorePacketDataType::String),
            _ => Err(crate::bedrock::error::DecodeError::InvalidEnumValue {
                enum_name: stringify!(ServerboundDataStorePacketDataType),
                value: val as i64,
            }),
        }
    }
}
impl Default for ServerboundDataStorePacketDataType {
    fn default() -> Self {
        Self::Double
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ServerboundDataStorePacketData {
    Bool(bool),
    Double(f64),
    String(String),
}
impl Default for ServerboundDataStorePacketData {
    fn default() -> Self {
        Self::Bool(Default::default())
    }
}
