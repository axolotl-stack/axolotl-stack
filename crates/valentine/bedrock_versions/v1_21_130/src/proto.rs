// Generated by valentine_gen. Do not edit.

//! Generated protocol packet definitions.
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_parens)]
#![allow(clippy::all)]
use ::bitflags::bitflags;
use bytes::{Buf, BufMut};
use crate::types::*;
use crate::bedrock::codec::BedrockCodec;
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LoginPacket {
    pub protocol_version: i32,
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for LoginPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.protocol_version.encode(buf)?;
        let mut __encap_tmp = bytes::BytesMut::new();
        {
            let buf = &mut __encap_tmp;
            self.tokens.encode(buf)?;
        }
        let len = __encap_tmp.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&__encap_tmp);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let protocol_version = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tokens = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::ArrayLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut slice = bytes::Buf::take(&mut *buf, len);
            let value = {
                let buf = &mut slice;
                <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
            };
            let _ = slice.remaining();
            value
        };
        Ok(Self { protocol_version, tokens })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayStatusPacket {
    pub status: PlayStatusPacketStatus,
}
impl crate::bedrock::codec::BedrockCodec for PlayStatusPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.status.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let status = <PlayStatusPacketStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { status })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerToClientHandshakePacket {
    pub token: String,
}
impl crate::bedrock::codec::BedrockCodec for ServerToClientHandshakePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.token)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.token).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let token = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { token })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientToServerHandshakePacket {}
impl crate::bedrock::codec::BedrockCodec for ClientToServerHandshakePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DisconnectPacket {
    pub reason: DisconnectFailReason,
    pub hide_disconnect_reason: bool,
    pub content: Option<DisconnectPacketContent>,
}
impl crate::bedrock::codec::BedrockCodec for DisconnectPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.reason.encode(buf)?;
        self.hide_disconnect_reason.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let reason = <DisconnectFailReason as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hide_disconnect_reason = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = if hide_disconnect_reason {
            None
        } else {
            Some(
                <DisconnectPacketContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        };
        Ok(Self {
            reason,
            hide_disconnect_reason,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePacksInfoPacket {
    pub must_accept: bool,
    pub has_addons: bool,
    pub has_scripts: bool,
    pub disable_vibrant_visuals: bool,
    pub world_template: ResourcePacksInfoPacketWorldTemplate,
    pub texture_packs: TexturePackInfos,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePacksInfoPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.must_accept.encode(buf)?;
        self.has_addons.encode(buf)?;
        self.has_scripts.encode(buf)?;
        self.disable_vibrant_visuals.encode(buf)?;
        self.world_template.encode(buf)?;
        let len = self.texture_packs.len();
        crate::bedrock::codec::I16LE(len as i16).encode(buf)?;
        for item in &self.texture_packs {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_addons = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let has_scripts = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let disable_vibrant_visuals = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let world_template = <ResourcePacksInfoPacketWorldTemplate as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let texture_packs = {
            let res: TexturePackInfos = {
                let raw = <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <TexturePackInfosItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            must_accept,
            has_addons,
            has_scripts,
            disable_vibrant_visuals,
            world_template,
            texture_packs,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePackStackPacket {
    pub must_accept: bool,
    pub resource_packs: ResourcePackIdVersions,
    pub game_version: String,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
    pub has_editor_packs: bool,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackStackPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.must_accept.encode(buf)?;
        let len = self.resource_packs.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.resource_packs {
            item.encode(buf)?;
        }
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.game_version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.game_version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.experiments.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.experiments {
            item.encode(buf)?;
        }
        self.experiments_previously_used.encode(buf)?;
        self.has_editor_packs.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let must_accept = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resource_packs = {
            let res: ResourcePackIdVersions = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ResourcePackIdVersionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let game_version = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let experiments = {
            let res: Experiments = {
                let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Experiment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments_previously_used = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_editor_packs = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            must_accept,
            resource_packs,
            game_version,
            experiments,
            experiments_previously_used,
            has_editor_packs,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePackClientResponsePacket {
    pub response_status: ResourcePackClientResponsePacketResponseStatus,
    pub resourcepackids: ResourcePackIds,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackClientResponsePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.response_status.encode(buf)?;
        let len = self.resourcepackids.len();
        crate::bedrock::codec::I16LE(len as i16).encode(buf)?;
        for item in &self.resourcepackids {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let response_status = <ResourcePackClientResponsePacketResponseStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resourcepackids = {
            let res: ResourcePackIds = {
                let raw = <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push({
                            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?
                                .0) as i64;
                            if len_raw < 0 {
                                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                    value: len_raw,
                                });
                            }
                            let len = len_raw as usize;
                            if buf.remaining() < len {
                                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                    declared: len,
                                    available: buf.remaining(),
                                });
                            }
                            let mut bytes = vec![0u8; len];
                            buf.copy_to_slice(&mut bytes);
                            let s = if "".eq_ignore_ascii_case("latin1") {
                                bytes.into_iter().map(|b| b as char).collect::<String>()
                            } else {
                                String::from_utf8_lossy(&bytes).into_owned()
                            };
                            s
                        });
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            response_status,
            resourcepackids,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TextPacket {
    pub needs_translation: bool,
    pub category: TextPacketCategory,
    pub content: Option<TextPacketContent>,
    pub type_: TextPacketType,
    pub extra: Option<TextPacketExtra>,
    pub xuid: String,
    pub platform_chat_id: String,
    pub filtered_message: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for TextPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.needs_translation.encode(buf)?;
        self.category.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                TextPacketContent::Authored(v) => {
                    v.encode(buf)?;
                }
                TextPacketContent::MessageOnly(v) => {
                    v.encode(buf)?;
                }
                TextPacketContent::Parameters(v) => {
                    v.encode(buf)?;
                }
            }
        }
        self.type_.encode(buf)?;
        if let Some(v) = &self.extra {
            match v {
                TextPacketExtra::Announcement(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::Chat(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::Json(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::JsonAnnouncement(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::JsonWhisper(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::JukeboxPopup(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::Popup(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::Raw(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::System(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::Tip(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::Translation(v) => {
                    v.encode(buf)?;
                }
                TextPacketExtra::Whisper(v) => {
                    v.encode(buf)?;
                }
            }
        }
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.xuid)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.xuid).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.platform_chat_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.platform_chat_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let val = self.filtered_message.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.filtered_message {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (v)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (v).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let needs_translation = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let category = <TextPacketCategory as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match category {
            TextPacketCategory::Authored => {
                Some(
                    TextPacketContent::Authored(
                        <TextPacketContentAuthored as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketCategory::MessageOnly => {
                Some(
                    TextPacketContent::MessageOnly(
                        Box::new(
                            <TextPacketContentMessageOnly as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            TextPacketCategory::Parameters => {
                Some(
                    TextPacketContent::Parameters(
                        <TextPacketContentParameters as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
        };
        let type_ = <TextPacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let extra = match type_ {
            TextPacketType::Announcement => {
                Some(
                    TextPacketExtra::Announcement(
                        <TextPacketExtraAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::Chat => {
                Some(
                    TextPacketExtra::Chat(
                        <TextPacketExtraAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::Json => {
                Some(
                    TextPacketExtra::Json(
                        <TextPacketExtraJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::JsonAnnouncement => {
                Some(
                    TextPacketExtra::JsonAnnouncement(
                        <TextPacketExtraJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::JsonWhisper => {
                Some(
                    TextPacketExtra::JsonWhisper(
                        <TextPacketExtraJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::JukeboxPopup => {
                Some(
                    TextPacketExtra::JukeboxPopup(
                        <TextPacketExtraJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::Popup => {
                Some(
                    TextPacketExtra::Popup(
                        <TextPacketExtraJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::Raw => {
                Some(
                    TextPacketExtra::Raw(
                        <TextPacketExtraJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::System => {
                Some(
                    TextPacketExtra::System(
                        <TextPacketExtraJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::Tip => {
                Some(
                    TextPacketExtra::Tip(
                        <TextPacketExtraJson as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::Translation => {
                Some(
                    TextPacketExtra::Translation(
                        <TextPacketExtraJukeboxPopup as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            TextPacketType::Whisper => {
                Some(
                    TextPacketExtra::Whisper(
                        <TextPacketExtraAnnouncement as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
        };
        let xuid = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let platform_chat_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let has_filtered_message = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let filtered_message = if has_filtered_message {
            Some({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            })
        } else {
            None
        };
        Ok(Self {
            needs_translation,
            category,
            content,
            type_,
            extra,
            xuid,
            platform_chat_id,
            filtered_message,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetTimePacket {
    pub time: i32,
}
impl crate::bedrock::codec::BedrockCodec for SetTimePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.time).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { time })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StartGamePacket {
    pub entity_id: i64,
    pub runtime_entity_id: i64,
    pub player_gamemode: GameMode,
    pub player_position: Vec3F,
    pub rotation: Vec2F,
    pub seed: u64,
    pub biome_type: i16,
    pub biome_name: String,
    pub dimension: StartGamePacketDimension,
    pub generator: i32,
    pub world_gamemode: GameMode,
    pub hardcore: bool,
    pub difficulty: i32,
    pub spawn_position: BlockCoordinates,
    pub achievements_disabled: bool,
    pub editor_world_type: StartGamePacketEditorWorldType,
    pub created_in_editor: bool,
    pub exported_from_editor: bool,
    pub day_cycle_stop_time: i32,
    pub edu_offer: i32,
    pub edu_features_enabled: bool,
    pub edu_product_uuid: String,
    pub rain_level: f32,
    pub lightning_level: f32,
    pub has_confirmed_platform_locked_content: bool,
    pub is_multiplayer: bool,
    pub broadcast_to_lan: bool,
    pub xbox_live_broadcast_mode: i32,
    pub platform_broadcast_mode: i32,
    pub enable_commands: bool,
    pub is_texturepacks_required: bool,
    pub gamerules: Vec<GameRuleVarint>,
    pub experiments: Experiments,
    pub experiments_previously_used: bool,
    pub bonus_chest: bool,
    pub map_enabled: bool,
    pub permission_level: PermissionLevel,
    pub server_chunk_tick_range: i32,
    pub has_locked_behavior_pack: bool,
    pub has_locked_resource_pack: bool,
    pub is_from_locked_world_template: bool,
    pub msa_gamertags_only: bool,
    pub is_from_world_template: bool,
    pub is_world_template_option_locked: bool,
    pub only_spawn_v_1_villagers: bool,
    pub persona_disabled: bool,
    pub custom_skins_disabled: bool,
    pub emote_chat_muted: bool,
    pub game_version: String,
    pub limited_world_width: i32,
    pub limited_world_length: i32,
    pub is_new_nether: bool,
    pub edu_resource_uri: EducationSharedResourceUri,
    pub experimental_gameplay_override: bool,
    pub chat_restriction_level: StartGamePacketChatRestrictionLevel,
    pub disable_player_interactions: bool,
    pub server_identifier: String,
    pub world_identifier: String,
    pub scenario_identifier: String,
    pub owner_identifier: String,
    pub level_id: String,
    pub world_name: String,
    pub premium_world_template_id: String,
    pub is_trial: bool,
    pub rewind_history_size: i32,
    pub server_authoritative_block_breaking: bool,
    pub current_tick: i64,
    pub enchantment_seed: i32,
    pub block_properties: BlockProperties,
    pub multiplayer_correlation_id: String,
    pub server_authoritative_inventory: bool,
    pub engine: String,
    pub property_data: crate::bedrock::codec::Nbt,
    pub block_pallette_checksum: u64,
    pub world_template_id: uuid::Uuid,
    pub client_side_generation: bool,
    pub block_network_ids_are_hashes: bool,
    pub server_controlled_sound: bool,
}
impl crate::bedrock::codec::BedrockCodec for StartGamePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.entity_id).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.player_gamemode.encode(buf)?;
        self.player_position.encode(buf)?;
        self.rotation.encode(buf)?;
        crate::bedrock::codec::U64LE(self.seed).encode(buf)?;
        crate::bedrock::codec::I16LE(self.biome_type).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.biome_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.biome_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.dimension.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.generator).encode(buf)?;
        self.world_gamemode.encode(buf)?;
        self.hardcore.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.difficulty).encode(buf)?;
        self.spawn_position.encode(buf)?;
        self.achievements_disabled.encode(buf)?;
        self.editor_world_type.encode(buf)?;
        self.created_in_editor.encode(buf)?;
        self.exported_from_editor.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.day_cycle_stop_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.edu_offer).encode(buf)?;
        self.edu_features_enabled.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.edu_product_uuid)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.edu_product_uuid).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::F32LE(self.rain_level).encode(buf)?;
        crate::bedrock::codec::F32LE(self.lightning_level).encode(buf)?;
        self.has_confirmed_platform_locked_content.encode(buf)?;
        self.is_multiplayer.encode(buf)?;
        self.broadcast_to_lan.encode(buf)?;
        crate::bedrock::codec::VarInt(self.xbox_live_broadcast_mode).encode(buf)?;
        crate::bedrock::codec::VarInt(self.platform_broadcast_mode).encode(buf)?;
        self.enable_commands.encode(buf)?;
        self.is_texturepacks_required.encode(buf)?;
        let len = self.gamerules.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.gamerules {
            item.encode(buf)?;
        }
        let len = self.experiments.len();
        crate::bedrock::codec::I32LE(len as i32).encode(buf)?;
        for item in &self.experiments {
            item.encode(buf)?;
        }
        self.experiments_previously_used.encode(buf)?;
        self.bonus_chest.encode(buf)?;
        self.map_enabled.encode(buf)?;
        self.permission_level.encode(buf)?;
        crate::bedrock::codec::I32LE(self.server_chunk_tick_range).encode(buf)?;
        self.has_locked_behavior_pack.encode(buf)?;
        self.has_locked_resource_pack.encode(buf)?;
        self.is_from_locked_world_template.encode(buf)?;
        self.msa_gamertags_only.encode(buf)?;
        self.is_from_world_template.encode(buf)?;
        self.is_world_template_option_locked.encode(buf)?;
        self.only_spawn_v_1_villagers.encode(buf)?;
        self.persona_disabled.encode(buf)?;
        self.custom_skins_disabled.encode(buf)?;
        self.emote_chat_muted.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.game_version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.game_version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I32LE(self.limited_world_width).encode(buf)?;
        crate::bedrock::codec::I32LE(self.limited_world_length).encode(buf)?;
        self.is_new_nether.encode(buf)?;
        self.edu_resource_uri.encode(buf)?;
        self.experimental_gameplay_override.encode(buf)?;
        self.chat_restriction_level.encode(buf)?;
        self.disable_player_interactions.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.server_identifier)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.server_identifier).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.world_identifier)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.world_identifier).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.scenario_identifier)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.scenario_identifier).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.owner_identifier)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.owner_identifier).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.level_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.level_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.world_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.world_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.premium_world_template_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.premium_world_template_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.is_trial.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.rewind_history_size).encode(buf)?;
        self.server_authoritative_block_breaking.encode(buf)?;
        crate::bedrock::codec::I64LE(self.current_tick).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.enchantment_seed).encode(buf)?;
        let len = self.block_properties.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.block_properties {
            item.encode(buf)?;
        }
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.multiplayer_correlation_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.multiplayer_correlation_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.server_authoritative_inventory.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.engine)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.engine).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.property_data.encode(buf)?;
        crate::bedrock::codec::U64LE(self.block_pallette_checksum).encode(buf)?;
        self.world_template_id.encode(buf)?;
        self.client_side_generation.encode(buf)?;
        self.block_network_ids_are_hashes.encode(buf)?;
        self.server_controlled_sound.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let player_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let seed = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let biome_type = <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let biome_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let dimension = <StartGamePacketDimension as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let generator = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let world_gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let hardcore = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let difficulty = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let spawn_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let achievements_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let editor_world_type = <StartGamePacketEditorWorldType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let created_in_editor = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let exported_from_editor = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let day_cycle_stop_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let edu_offer = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let edu_features_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let edu_product_uuid = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let rain_level = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let lightning_level = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_confirmed_platform_locked_content = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_multiplayer = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let broadcast_to_lan = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let xbox_live_broadcast_mode = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let platform_broadcast_mode = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let enable_commands = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_texturepacks_required = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let gamerules = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <GameRuleVarint as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let experiments = {
            let res: Experiments = {
                let raw = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Experiment as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let experiments_previously_used = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bonus_chest = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let map_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server_chunk_tick_range = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_locked_behavior_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let has_locked_resource_pack = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_from_locked_world_template = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let msa_gamertags_only = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_from_world_template = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_world_template_option_locked = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let only_spawn_v_1_villagers = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let persona_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let custom_skins_disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let emote_chat_muted = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let game_version = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let limited_world_width = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let limited_world_length = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let is_new_nether = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let edu_resource_uri = <EducationSharedResourceUri as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let experimental_gameplay_override = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let chat_restriction_level = <StartGamePacketChatRestrictionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let disable_player_interactions = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server_identifier = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let world_identifier = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let scenario_identifier = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let owner_identifier = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let level_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let world_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let premium_world_template_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let is_trial = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rewind_history_size = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let server_authoritative_block_breaking = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let current_tick = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let enchantment_seed = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let block_properties = {
            let res: BlockProperties = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <BlockPropertiesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let multiplayer_correlation_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let server_authoritative_inventory = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let engine = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let property_data = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_pallette_checksum = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let world_template_id = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_side_generation = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_network_ids_are_hashes = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server_controlled_sound = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id,
            runtime_entity_id,
            player_gamemode,
            player_position,
            rotation,
            seed,
            biome_type,
            biome_name,
            dimension,
            generator,
            world_gamemode,
            hardcore,
            difficulty,
            spawn_position,
            achievements_disabled,
            editor_world_type,
            created_in_editor,
            exported_from_editor,
            day_cycle_stop_time,
            edu_offer,
            edu_features_enabled,
            edu_product_uuid,
            rain_level,
            lightning_level,
            has_confirmed_platform_locked_content,
            is_multiplayer,
            broadcast_to_lan,
            xbox_live_broadcast_mode,
            platform_broadcast_mode,
            enable_commands,
            is_texturepacks_required,
            gamerules,
            experiments,
            experiments_previously_used,
            bonus_chest,
            map_enabled,
            permission_level,
            server_chunk_tick_range,
            has_locked_behavior_pack,
            has_locked_resource_pack,
            is_from_locked_world_template,
            msa_gamertags_only,
            is_from_world_template,
            is_world_template_option_locked,
            only_spawn_v_1_villagers,
            persona_disabled,
            custom_skins_disabled,
            emote_chat_muted,
            game_version,
            limited_world_width,
            limited_world_length,
            is_new_nether,
            edu_resource_uri,
            experimental_gameplay_override,
            chat_restriction_level,
            disable_player_interactions,
            server_identifier,
            world_identifier,
            scenario_identifier,
            owner_identifier,
            level_id,
            world_name,
            premium_world_template_id,
            is_trial,
            rewind_history_size,
            server_authoritative_block_breaking,
            current_tick,
            enchantment_seed,
            block_properties,
            multiplayer_correlation_id,
            server_authoritative_inventory,
            engine,
            property_data,
            block_pallette_checksum,
            world_template_id,
            client_side_generation,
            block_network_ids_are_hashes,
            server_controlled_sound,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AddPlayerPacket {
    pub uuid: uuid::Uuid,
    pub username: String,
    pub runtime_id: i64,
    pub platform_chat_id: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub held_item: Item,
    pub gamemode: GameMode,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
    pub links: Links,
    pub device_id: String,
    pub device_os: DeviceOs,
}
#[derive(Debug, Clone)]
pub struct AddPlayerPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for AddPlayerPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for AddPlayerPacket {
    type Args = AddPlayerPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.username)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.username).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.platform_chat_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.platform_chat_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        crate::bedrock::codec::F32LE(self.pitch).encode(buf)?;
        crate::bedrock::codec::F32LE(self.yaw).encode(buf)?;
        crate::bedrock::codec::F32LE(self.head_yaw).encode(buf)?;
        self.held_item.encode(buf)?;
        self.gamemode.encode(buf)?;
        let len = self.metadata.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.metadata {
            item.encode(buf)?;
        }
        self.properties.encode(buf)?;
        crate::bedrock::codec::I64LE(self.unique_id).encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        let len = self.links.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.links {
            item.encode(buf)?;
        }
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.device_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.device_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.device_os.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let username = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let platform_chat_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let head_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let held_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let metadata = {
            let res: MetadataDictionary = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = (<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let links = {
            let res: Links = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let device_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let device_os = <DeviceOs as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            username,
            runtime_id,
            platform_chat_id,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            held_item,
            gamemode,
            metadata,
            properties,
            unique_id,
            permission_level,
            command_permission,
            abilities,
            links,
            device_id,
            device_os,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AddEntityPacket {
    pub unique_id: i64,
    pub runtime_id: i64,
    pub entity_type: String,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub body_yaw: f32,
    pub attributes: EntityAttributes,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub links: Links,
}
impl crate::bedrock::codec::BedrockCodec for AddEntityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.unique_id).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.entity_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.entity_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        crate::bedrock::codec::F32LE(self.pitch).encode(buf)?;
        crate::bedrock::codec::F32LE(self.yaw).encode(buf)?;
        crate::bedrock::codec::F32LE(self.head_yaw).encode(buf)?;
        crate::bedrock::codec::F32LE(self.body_yaw).encode(buf)?;
        let len = self.attributes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.attributes {
            item.encode(buf)?;
        }
        let len = self.metadata.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.metadata {
            item.encode(buf)?;
        }
        self.properties.encode(buf)?;
        let len = self.links.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.links {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let head_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let body_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let attributes = {
            let res: EntityAttributes = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <EntityAttributesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let metadata = {
            let res: MetadataDictionary = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let links = {
            let res: Links = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Link as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            unique_id,
            runtime_id,
            entity_type,
            position,
            velocity,
            pitch,
            yaw,
            head_yaw,
            body_yaw,
            attributes,
            metadata,
            properties,
            links,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RemoveEntityPacket {
    pub entity_id_self: i64,
}
impl crate::bedrock::codec::BedrockCodec for RemoveEntityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { entity_id_self })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AddItemEntityPacket {
    pub entity_id_self: i64,
    pub runtime_entity_id: i64,
    pub item: Item,
    pub position: Vec3F,
    pub velocity: Vec3F,
    pub metadata: MetadataDictionary,
    pub is_from_fishing: bool,
}
#[derive(Debug, Clone)]
pub struct AddItemEntityPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for AddItemEntityPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for AddItemEntityPacket {
    type Args = AddItemEntityPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.item.encode(buf)?;
        self.position.encode(buf)?;
        self.velocity.encode(buf)?;
        let len = self.metadata.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.metadata {
            item.encode(buf)?;
        }
        self.is_from_fishing.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let metadata = {
            let res: MetadataDictionary = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let is_from_fishing = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            item,
            position,
            velocity,
            metadata,
            is_from_fishing,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerPostMovePacket {
    pub position: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for ServerPostMovePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { position })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TakeItemEntityPacket {
    pub runtime_entity_id: i64,
    pub target: i32,
}
impl crate::bedrock::codec::BedrockCodec for TakeItemEntityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        crate::bedrock::codec::VarInt(self.target).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let target = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { runtime_entity_id, target })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MoveEntityPacket {
    pub runtime_entity_id: i64,
    pub flags: u8,
    pub position: Vec3F,
    pub rotation: Rotation,
}
impl crate::bedrock::codec::BedrockCodec for MoveEntityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.flags.encode(buf)?;
        self.position.encode(buf)?;
        self.rotation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let flags = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation = <Rotation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            flags,
            position,
            rotation,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MovePlayerPacket {
    pub runtime_id: i32,
    pub position: Vec3F,
    pub pitch: f32,
    pub yaw: f32,
    pub head_yaw: f32,
    pub mode: MovePlayerPacketMode,
    pub on_ground: bool,
    pub ridden_runtime_id: i32,
    pub teleport: Option<MovePlayerPacketTeleport>,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for MovePlayerPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.runtime_id).encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::F32LE(self.pitch).encode(buf)?;
        crate::bedrock::codec::F32LE(self.yaw).encode(buf)?;
        crate::bedrock::codec::F32LE(self.head_yaw).encode(buf)?;
        self.mode.encode(buf)?;
        self.on_ground.encode(buf)?;
        crate::bedrock::codec::VarInt(self.ridden_runtime_id).encode(buf)?;
        if let Some(v) = &self.teleport {
            v.encode(buf)?;
        }
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pitch = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let head_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let mode = <MovePlayerPacketMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let ridden_runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let teleport = match mode {
            MovePlayerPacketMode::Teleport => {
                Some(
                    <MovePlayerPacketTeleport as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => None,
        };
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_id,
            position,
            pitch,
            yaw,
            head_yaw,
            mode,
            on_ground,
            ridden_runtime_id,
            teleport,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RiderJumpPacket {
    pub jump_strength: i32,
}
impl crate::bedrock::codec::BedrockCodec for RiderJumpPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.jump_strength).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let jump_strength = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { jump_strength })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateBlockPacket {
    pub position: BlockCoordinates,
    pub block_runtime_id: i32,
    pub flags: UpdateBlockFlags,
    pub layer: i32,
}
impl crate::bedrock::codec::BedrockCodec for UpdateBlockPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id).encode(buf)?;
        self.flags.encode(buf)?;
        crate::bedrock::codec::VarInt(self.layer).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let flags = <UpdateBlockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let layer = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            position,
            block_runtime_id,
            flags,
            layer,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AddPaintingPacket {
    pub entity_id_self: i64,
    pub runtime_entity_id: i64,
    pub coordinates: Vec3F,
    pub direction: i32,
    pub title: String,
}
impl crate::bedrock::codec::BedrockCodec for AddPaintingPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.entity_id_self).encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.direction).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_id_self = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let coordinates = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let direction = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let title = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            entity_id_self,
            runtime_entity_id,
            coordinates,
            direction,
            title,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TickSyncPacket {
    pub request_time: i64,
    pub response_time: i64,
}
impl crate::bedrock::codec::BedrockCodec for TickSyncPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I64LE(self.request_time).encode(buf)?;
        crate::bedrock::codec::I64LE(self.response_time).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let request_time = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let response_time = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            request_time,
            response_time,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LevelSoundEventOldPacket {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: i32,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for LevelSoundEventOldPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.entity_type).encode(buf)?;
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LevelEventPacket {
    pub event: LevelEventPacketEvent,
    pub position: Vec3F,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for LevelEventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.event.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let event = <LevelEventPacketEvent as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { event, position, data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BlockEventPacket {
    pub position: BlockCoordinates,
    pub type_: BlockEventPacketType,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for BlockEventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        self.type_.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let type_ = <BlockEventPacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { position, type_, data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EntityEventPacket {
    pub runtime_entity_id: i64,
    pub event_id: EntityEventPacketEventId,
    pub data: i32,
}
impl crate::bedrock::codec::BedrockCodec for EntityEventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.event_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.data).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let event_id = <EntityEventPacketEventId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            event_id,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MobEffectPacket {
    pub runtime_entity_id: i64,
    pub event_id: MobEffectPacketEventId,
    pub effect_id: i32,
    pub amplifier: i32,
    pub particles: bool,
    pub duration: i32,
    pub tick: i64,
    pub ambient: bool,
}
impl crate::bedrock::codec::BedrockCodec for MobEffectPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.event_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.effect_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.amplifier).encode(buf)?;
        self.particles.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.duration).encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        self.ambient.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let event_id = <MobEffectPacketEventId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let effect_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let amplifier = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let particles = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let ambient = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            event_id,
            effect_id,
            amplifier,
            particles,
            duration,
            tick,
            ambient,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateAttributesPacket {
    pub runtime_entity_id: i64,
    pub attributes: PlayerAttributes,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for UpdateAttributesPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        let len = self.attributes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.attributes {
            item.encode(buf)?;
        }
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let attributes = {
            let res: PlayerAttributes = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PlayerAttributesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            attributes,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct InventoryTransactionPacket {
    pub transaction: Transaction,
}
#[derive(Debug, Clone)]
pub struct InventoryTransactionPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for InventoryTransactionPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for InventoryTransactionPacket {
    type Args = InventoryTransactionPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.transaction.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let transaction = <Transaction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            TransactionArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self { transaction })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MobEquipmentPacket {
    pub runtime_entity_id: i64,
    pub item: Item,
    pub slot: u8,
    pub selected_slot: u8,
    pub window_id: WindowId,
}
#[derive(Debug, Clone)]
pub struct MobEquipmentPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for MobEquipmentPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for MobEquipmentPacket {
    type Args = MobEquipmentPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.item.encode(buf)?;
        self.slot.encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.window_id.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            runtime_entity_id,
            item,
            slot,
            selected_slot,
            window_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MobArmorEquipmentPacket {
    pub runtime_entity_id: i64,
    pub helmet: Item,
    pub chestplate: Item,
    pub leggings: Item,
    pub boots: Item,
    pub body: Item,
}
#[derive(Debug, Clone)]
pub struct MobArmorEquipmentPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for MobArmorEquipmentPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for MobArmorEquipmentPacket {
    type Args = MobArmorEquipmentPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.helmet.encode(buf)?;
        self.chestplate.encode(buf)?;
        self.leggings.encode(buf)?;
        self.boots.encode(buf)?;
        self.body.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let helmet = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let chestplate = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let leggings = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let boots = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let body = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            runtime_entity_id,
            helmet,
            chestplate,
            leggings,
            boots,
            body,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct InteractPacket {
    pub action_id: InteractPacketActionId,
    pub target_entity_id: i64,
    pub position: Option<Vec3F>,
}
impl crate::bedrock::codec::BedrockCodec for InteractPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action_id.encode(buf)?;
        crate::bedrock::codec::VarLong(self.target_entity_id).encode(buf)?;
        let val = self.position.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.position {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action_id = <InteractPacketActionId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let target_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_position = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = if has_position {
            Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        Ok(Self {
            action_id,
            target_entity_id,
            position,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BlockPickRequestPacket {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub add_user_data: bool,
    pub selected_slot: u8,
}
impl crate::bedrock::codec::BedrockCodec for BlockPickRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        self.add_user_data.encode(buf)?;
        self.selected_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let add_user_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            x,
            y,
            z,
            add_user_data,
            selected_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EntityPickRequestPacket {
    pub runtime_entity_id: u64,
    pub selected_slot: u8,
    pub with_data: bool,
}
impl crate::bedrock::codec::BedrockCodec for EntityPickRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U64LE(self.runtime_entity_id).encode(buf)?;
        self.selected_slot.encode(buf)?;
        self.with_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let selected_slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let with_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_entity_id,
            selected_slot,
            with_data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerActionPacket {
    pub runtime_entity_id: i64,
    pub action: Action,
    pub position: BlockCoordinates,
    pub result_position: BlockCoordinates,
    pub face: i32,
}
impl crate::bedrock::codec::BedrockCodec for PlayerActionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.action.encode(buf)?;
        self.position.encode(buf)?;
        self.result_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.face).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let action = <Action as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let result_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let face = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            action,
            position,
            result_position,
            face,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HurtArmorPacket {
    pub cause: i32,
    pub damage: i32,
    pub armor_slots: i64,
}
impl crate::bedrock::codec::BedrockCodec for HurtArmorPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.cause).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.damage).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.armor_slots).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let cause = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let damage = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let armor_slots = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { cause, damage, armor_slots })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetEntityDataPacket {
    pub runtime_entity_id: i64,
    pub metadata: MetadataDictionary,
    pub properties: EntityProperties,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for SetEntityDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        let len = self.metadata.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.metadata {
            item.encode(buf)?;
        }
        self.properties.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let metadata = {
            let res: MetadataDictionary = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <MetadataDictionaryItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let properties = <EntityProperties as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            metadata,
            properties,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetEntityMotionPacket {
    pub runtime_entity_id: i64,
    pub velocity: Vec3F,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for SetEntityMotionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.velocity.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_entity_id,
            velocity,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetEntityLinkPacket {
    pub link: Link,
}
impl crate::bedrock::codec::BedrockCodec for SetEntityLinkPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.link.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let link = <Link as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { link })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetHealthPacket {
    pub health: i32,
}
impl crate::bedrock::codec::BedrockCodec for SetHealthPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.health).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let health = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { health })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetSpawnPositionPacket {
    pub spawn_type: SetSpawnPositionPacketSpawnType,
    pub player_position: BlockCoordinates,
    pub dimension: i32,
    pub world_position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for SetSpawnPositionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.spawn_type.encode(buf)?;
        self.player_position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.world_position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let spawn_type = <SetSpawnPositionPacketSpawnType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let world_position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            spawn_type,
            player_position,
            dimension,
            world_position,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AnimatePacket {
    pub action_id: AnimatePacketActionId,
    pub runtime_entity_id: i64,
    pub data: f32,
    pub swing_source: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for AnimatePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action_id.encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        crate::bedrock::codec::F32LE(self.data).encode(buf)?;
        let val = self.swing_source.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.swing_source {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (v)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (v).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action_id = <AnimatePacketActionId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_swing_source = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let swing_source = if has_swing_source {
            Some({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            })
        } else {
            None
        };
        Ok(Self {
            action_id,
            runtime_entity_id,
            data,
            swing_source,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RespawnPacket {
    pub position: Vec3F,
    pub state: u8,
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for RespawnPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        self.state.encode(buf)?;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let state = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            position,
            state,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ContainerOpenPacket {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub coordinates: BlockCoordinates,
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for ContainerOpenPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.runtime_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let runtime_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            window_id,
            window_type,
            coordinates,
            runtime_entity_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ContainerClosePacket {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub server: bool,
}
impl crate::bedrock::codec::BedrockCodec for ContainerClosePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let server = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            window_id,
            window_type,
            server,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerHotbarPacket {
    pub selected_slot: i32,
    pub window_id: WindowId,
    pub select_slot: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerHotbarPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.selected_slot).encode(buf)?;
        self.window_id.encode(buf)?;
        self.select_slot.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let selected_slot = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let select_slot = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            selected_slot,
            window_id,
            select_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct InventoryContentPacket {
    pub window_id: WindowIdVarint,
    pub input: ItemStacks,
    pub container: FullContainerName,
    pub storage_item: Item,
}
#[derive(Debug, Clone)]
pub struct InventoryContentPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for InventoryContentPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for InventoryContentPacket {
    type Args = InventoryContentPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        self.container.encode(buf)?;
        self.storage_item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let res: ItemStacks = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <Item as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                ItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let container = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let storage_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            window_id,
            input,
            container,
            storage_item,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct InventorySlotPacket {
    pub window_id: WindowIdVarint,
    pub slot: i32,
    pub container: FullContainerName,
    pub storage_item: Item,
    pub item: Item,
}
#[derive(Debug, Clone)]
pub struct InventorySlotPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for InventorySlotPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for InventorySlotPacket {
    type Args = InventorySlotPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        crate::bedrock::codec::VarInt(self.slot).encode(buf)?;
        self.container.encode(buf)?;
        self.storage_item.encode(buf)?;
        self.item.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowIdVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slot = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let container = <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let storage_item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        let item = <Item as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            ItemArgs {
                shield_item_id: args.shield_item_id,
            },
        )?;
        Ok(Self {
            window_id,
            slot,
            container,
            storage_item,
            item,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ContainerSetDataPacket {
    pub window_id: WindowId,
    pub property: i32,
    pub value: i32,
}
impl crate::bedrock::codec::BedrockCodec for ContainerSetDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.property).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.value).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let property = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { window_id, property, value })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CraftingDataPacket {
    pub recipes: Recipes,
    pub potion_type_recipes: PotionTypeRecipes,
    pub potion_container_recipes: PotionContainerChangeRecipes,
    pub material_reducers: Vec<MaterialReducer>,
    pub clear_recipes: bool,
}
#[derive(Debug, Clone)]
pub struct CraftingDataPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for CraftingDataPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for CraftingDataPacket {
    type Args = CraftingDataPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.recipes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.recipes {
            item.encode(buf)?;
        }
        let len = self.potion_type_recipes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.potion_type_recipes {
            item.encode(buf)?;
        }
        let len = self.potion_container_recipes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.potion_container_recipes {
            item.encode(buf)?;
        }
        let len = self.material_reducers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.material_reducers {
            item.encode(buf)?;
        }
        self.clear_recipes.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let recipes = {
            let res: Recipes = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <RecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                RecipesItemArgs {
                                    shield_item_id: args.shield_item_id,
                                },
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let potion_type_recipes = {
            let res: PotionTypeRecipes = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PotionTypeRecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let potion_container_recipes = {
            let res: PotionContainerChangeRecipes = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PotionContainerChangeRecipesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        let material_reducers = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <MaterialReducer as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let clear_recipes = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            recipes,
            potion_type_recipes,
            potion_container_recipes,
            material_reducers,
            clear_recipes,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CraftingEventPacket {
    pub window_id: WindowId,
    pub recipe_type: CraftingEventPacketRecipeType,
    pub recipe_id: uuid::Uuid,
    pub input: Vec<Item>,
    pub result: Vec<Item>,
}
#[derive(Debug, Clone)]
pub struct CraftingEventPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession> for CraftingEventPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for CraftingEventPacket {
    type Args = CraftingEventPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        self.recipe_type.encode(buf)?;
        self.recipe_id.encode(buf)?;
        let len = self.input.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.input {
            item.encode(buf)?;
        }
        let len = self.result.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.result {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe_type = <CraftingEventPacketRecipeType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipe_id = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let result = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Item as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            window_id,
            recipe_type,
            recipe_id,
            input,
            result,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GuiDataPickItemPacket {
    pub item_name: String,
    pub item_effects: String,
    pub hotbar_slot: i32,
}
impl crate::bedrock::codec::BedrockCodec for GuiDataPickItemPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.item_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.item_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.item_effects)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.item_effects).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I32LE(self.hotbar_slot).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let item_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let item_effects = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let hotbar_slot = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            item_name,
            item_effects,
            hotbar_slot,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AdventureSettingsPacket {
    pub flags: AdventureFlags,
    pub command_permission: CommandPermissionLevelVarint,
    pub action_permissions: ActionPermissions,
    pub permission_level: PermissionLevel,
    pub custom_stored_permissions: i32,
    pub user_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for AdventureSettingsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.flags.encode(buf)?;
        self.command_permission.encode(buf)?;
        self.action_permissions.encode(buf)?;
        self.permission_level.encode(buf)?;
        crate::bedrock::codec::VarInt(self.custom_stored_permissions).encode(buf)?;
        crate::bedrock::codec::I64LE(self.user_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let flags = <AdventureFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevelVarint as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let action_permissions = <ActionPermissions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let custom_stored_permissions = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let user_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            flags,
            command_permission,
            action_permissions,
            permission_level,
            custom_stored_permissions,
            user_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BlockEntityDataPacket {
    pub position: BlockCoordinates,
    pub nbt: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for BlockEntityDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let nbt = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { position, nbt })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerInputPacket {
    pub motion_x: f32,
    pub motion_z: f32,
    pub jumping: bool,
    pub sneaking: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerInputPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.motion_x).encode(buf)?;
        crate::bedrock::codec::F32LE(self.motion_z).encode(buf)?;
        self.jumping.encode(buf)?;
        self.sneaking.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let motion_x = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let motion_z = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let jumping = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let sneaking = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            motion_x,
            motion_z,
            jumping,
            sneaking,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LevelChunkPacket {
    pub x: i32,
    pub z: i32,
    pub dimension: i32,
    pub sub_chunk_count: i32,
    pub highest_subchunk_count: Option<u16>,
    pub blobs: Option<LevelChunkPacketBlobs>,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for LevelChunkPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        crate::bedrock::codec::VarInt(self.sub_chunk_count).encode(buf)?;
        if let Some(v) = &self.highest_subchunk_count {
            crate::bedrock::codec::U16LE(*v).encode(buf)?;
        }
        let val = self.blobs.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.blobs {
            v.encode(buf)?;
        }
        let len = self.payload.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.payload {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let sub_chunk_count = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let highest_subchunk_count = match sub_chunk_count {
            -2 => {
                Some(
                    <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            }
            _ => None,
        };
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let blobs = if cache_enabled {
            Some(
                <LevelChunkPacketBlobs as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let payload = {
            let res: ByteArray = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            x,
            z,
            dimension,
            sub_chunk_count,
            highest_subchunk_count,
            blobs,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetCommandsEnabledPacket {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for SetCommandsEnabledPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetDifficultyPacket {
    pub difficulty: i32,
}
impl crate::bedrock::codec::BedrockCodec for SetDifficultyPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.difficulty).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let difficulty = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { difficulty })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ChangeDimensionPacket {
    pub dimension: i32,
    pub position: Vec3F,
    pub respawn: bool,
    pub loading_screen_id: Option<u32>,
}
impl crate::bedrock::codec::BedrockCodec for ChangeDimensionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.position.encode(buf)?;
        self.respawn.encode(buf)?;
        match &self.loading_screen_id {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::U32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let respawn = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let loading_screen_id = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            } else {
                None
            }
        };
        Ok(Self {
            dimension,
            position,
            respawn,
            loading_screen_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetPlayerGameTypePacket {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for SetPlayerGameTypePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerListPacket {
    pub records: PlayerRecords,
}
impl crate::bedrock::codec::BedrockCodec for PlayerListPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.records.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let records = <PlayerRecords as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { records })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SimpleEventPacket {
    pub event_type: SimpleEventPacketEventType,
}
impl crate::bedrock::codec::BedrockCodec for SimpleEventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.event_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let event_type = <SimpleEventPacketEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { event_type })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EventPacket {
    pub runtime_id: i64,
    pub event_type: EventPacketEventType,
    pub use_player_id: u8,
    pub event_data: Vec<u8>,
}
impl crate::bedrock::codec::BedrockCodec for EventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        self.event_type.encode(buf)?;
        self.use_player_id.encode(buf)?;
        self.event_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let event_type = <EventPacketEventType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let use_player_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let event_data = <Vec<
            u8,
        > as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            runtime_id,
            event_type,
            use_player_id,
            event_data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SpawnExperienceOrbPacket {
    pub position: Vec3F,
    pub count: i32,
}
impl crate::bedrock::codec::BedrockCodec for SpawnExperienceOrbPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.count).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let count = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { position, count })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundMapItemDataPacket {
    pub map_id: i64,
    pub update_flags: UpdateMapFlags,
    pub dimension: u8,
    pub locked: bool,
    pub origin: Vec3I,
    pub included_in: Option<Vec<i64>>,
    pub scale: Option<u8>,
    pub tracked: Option<ClientboundMapItemDataPacketTracked>,
    pub texture: Option<Box<ClientboundMapItemDataPacketTexture>>,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundMapItemDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.map_id).encode(buf)?;
        self.update_flags.encode(buf)?;
        self.dimension.encode(buf)?;
        self.locked.encode(buf)?;
        self.origin.encode(buf)?;
        if let Some(v) = &self.included_in {
            let len = v.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            for item in v {
                crate::bedrock::codec::ZigZag64(*item).encode(buf)?;
            }
        }
        if let Some(v) = &self.scale {
            (*v).encode(buf)?;
        }
        if let Some(v) = &self.tracked {
            v.encode(buf)?;
        }
        if let Some(v) = &self.texture {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let update_flags = <UpdateMapFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let locked = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let included_in = if update_flags.contains(UpdateMapFlags::INITIALISATION) {
            Some({
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?
                                .0,
                        );
                }
                tmp_vec
            })
        } else {
            None
        };
        let scale = if (update_flags.contains(UpdateMapFlags::INITIALISATION)
            || update_flags.contains(UpdateMapFlags::DECORATION)
            || update_flags.contains(UpdateMapFlags::TEXTURE))
        {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let tracked = if update_flags.contains(UpdateMapFlags::DECORATION) {
            Some(
                <ClientboundMapItemDataPacketTracked as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let texture = if update_flags.contains(UpdateMapFlags::TEXTURE) {
            Some(
                Box::new(
                    <ClientboundMapItemDataPacketTexture as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                ),
            )
        } else {
            None
        };
        Ok(Self {
            map_id,
            update_flags,
            dimension,
            locked,
            origin,
            included_in,
            scale,
            tracked,
            texture,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MapInfoRequestPacket {
    pub map_id: i64,
    pub client_pixels: Vec<MapInfoRequestPacketClientPixelsItem>,
}
impl crate::bedrock::codec::BedrockCodec for MapInfoRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.map_id).encode(buf)?;
        let len = self.client_pixels.len();
        crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
        for item in &self.client_pixels {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let client_pixels = {
            let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <MapInfoRequestPacketClientPixelsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { map_id, client_pixels })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RequestChunkRadiusPacket {
    pub chunk_radius: i32,
    pub max_radius: u8,
}
impl crate::bedrock::codec::BedrockCodec for RequestChunkRadiusPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.chunk_radius).encode(buf)?;
        self.max_radius.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let max_radius = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { chunk_radius, max_radius })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ChunkRadiusUpdatePacket {
    pub chunk_radius: i32,
}
impl crate::bedrock::codec::BedrockCodec for ChunkRadiusUpdatePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.chunk_radius).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let chunk_radius = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { chunk_radius })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GameRulesChangedPacket {
    pub rules: Vec<GameRuleI32>,
}
impl crate::bedrock::codec::BedrockCodec for GameRulesChangedPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.rules.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.rules {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let rules = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <GameRuleI32 as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { rules })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraPacket {
    pub camera_entity_unique_id: i64,
    pub target_player_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for CameraPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.camera_entity_unique_id).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.target_player_unique_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let camera_entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let target_player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            camera_entity_unique_id,
            target_player_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BossEventPacket {
    pub boss_entity_id: i64,
    pub type_: BossEventPacketType,
    pub content: Option<BossEventPacketContent>,
}
impl crate::bedrock::codec::BedrockCodec for BossEventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.boss_entity_id).encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                BossEventPacketContent::Query(v) => {
                    v.encode(buf)?;
                }
                BossEventPacketContent::RegisterPlayer(v) => {
                    v.encode(buf)?;
                }
                BossEventPacketContent::SetBarProgress(v) => {
                    v.encode(buf)?;
                }
                BossEventPacketContent::SetBarTitle(v) => {
                    v.encode(buf)?;
                }
                BossEventPacketContent::ShowBar(v) => {
                    v.encode(buf)?;
                }
                BossEventPacketContent::Texture(v) => {
                    v.encode(buf)?;
                }
                BossEventPacketContent::UnregisterPlayer(v) => {
                    v.encode(buf)?;
                }
                BossEventPacketContent::UpdateProperties(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let boss_entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let type_ = <BossEventPacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match type_ {
            BossEventPacketType::Query => {
                Some(
                    BossEventPacketContent::Query(
                        <BossEventPacketContentQuery as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BossEventPacketType::RegisterPlayer => {
                Some(
                    BossEventPacketContent::RegisterPlayer(
                        <BossEventPacketContentQuery as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BossEventPacketType::SetBarProgress => {
                Some(
                    BossEventPacketContent::SetBarProgress(
                        <BossEventPacketContentSetBarProgress as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BossEventPacketType::SetBarTitle => {
                Some(
                    BossEventPacketContent::SetBarTitle(
                        <BossEventPacketContentSetBarTitle as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BossEventPacketType::ShowBar => {
                Some(
                    BossEventPacketContent::ShowBar(
                        Box::new(
                            <BossEventPacketContentShowBar as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        ),
                    ),
                )
            }
            BossEventPacketType::Texture => {
                Some(
                    BossEventPacketContent::Texture(
                        <BossEventPacketContentTexture as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BossEventPacketType::UnregisterPlayer => {
                Some(
                    BossEventPacketContent::UnregisterPlayer(
                        <BossEventPacketContentQuery as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BossEventPacketType::UpdateProperties => {
                Some(
                    BossEventPacketContent::UpdateProperties(
                        <BossEventPacketContentUpdateProperties as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            boss_entity_id,
            type_,
            content,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ShowCreditsPacket {
    pub runtime_entity_id: i64,
    pub status: i32,
}
impl crate::bedrock::codec::BedrockCodec for ShowCreditsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.status).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let status = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { runtime_entity_id, status })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableCommandsPacket {
    pub values_len: i32,
    pub enum_values: Vec<String>,
    pub chained_subcommand_values: Vec<String>,
    pub suffixes: Vec<String>,
    pub enums: Vec<AvailableCommandsPacketEnumsItem>,
    pub chained_subcommands: Vec<AvailableCommandsPacketChainedSubcommandsItem>,
    pub command_data: Vec<AvailableCommandsPacketCommandDataItem>,
    pub dynamic_enums: Vec<AvailableCommandsPacketDynamicEnumsItem>,
    pub enum_constraints: Vec<AvailableCommandsPacketEnumConstraintsItem>,
}
impl crate::bedrock::codec::BedrockCodec for AvailableCommandsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.values_len).encode(buf)?;
        let len = self.enum_values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enum_values {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.chained_subcommand_values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.chained_subcommand_values {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.suffixes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.suffixes {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let len = self.enums.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enums {
            item.encode(buf)?;
        }
        let len = self.chained_subcommands.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.chained_subcommands {
            item.encode(buf)?;
        }
        let len = self.command_data.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.command_data {
            item.encode(buf)?;
        }
        let len = self.dynamic_enums.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.dynamic_enums {
            item.encode(buf)?;
        }
        let len = self.enum_constraints.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.enum_constraints {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let values_len = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let enum_values = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let chained_subcommand_values = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let suffixes = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let enums = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let chained_subcommands = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketChainedSubcommandsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let command_data = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketCommandDataItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let dynamic_enums = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketDynamicEnumsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let enum_constraints = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AvailableCommandsPacketEnumConstraintsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            values_len,
            enum_values,
            chained_subcommand_values,
            suffixes,
            enums,
            chained_subcommands,
            command_data,
            dynamic_enums,
            enum_constraints,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandRequestPacket {
    pub command: String,
    pub origin: CommandOrigin,
    pub internal: bool,
    pub version: String,
}
impl crate::bedrock::codec::BedrockCodec for CommandRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.command)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.command).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.origin.encode(buf)?;
        self.internal.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let command = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let internal = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let version = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            command,
            origin,
            internal,
            version,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandBlockUpdatePacket {
    pub content: CommandBlockUpdatePacketContent,
    pub command: String,
    pub last_output: String,
    pub name: String,
    pub filtered_name: String,
    pub should_track_output: bool,
    pub tick_delay: i32,
    pub execute_on_first_tick: bool,
}
impl crate::bedrock::codec::BedrockCodec for CommandBlockUpdatePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = matches!(self.content, CommandBlockUpdatePacketContent::True(_));
        val.encode(buf)?;
        match &self.content {
            CommandBlockUpdatePacketContent::False(v) => {
                v.encode(buf)?;
            }
            CommandBlockUpdatePacketContent::True(v) => {
                v.encode(buf)?;
            }
        }
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.command)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.command).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.last_output)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.last_output).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.filtered_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.filtered_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.should_track_output.encode(buf)?;
        crate::bedrock::codec::I32LE(self.tick_delay).encode(buf)?;
        self.execute_on_first_tick.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let is_block = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = if is_block {
            CommandBlockUpdatePacketContent::True(
                Box::new(
                    <CommandBlockUpdatePacketContentTrue as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                ),
            )
        } else {
            CommandBlockUpdatePacketContent::False(
                <CommandBlockUpdatePacketContentFalse as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        };
        let command = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let last_output = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let filtered_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let should_track_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tick_delay = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let execute_on_first_tick = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            content,
            command,
            last_output,
            name,
            filtered_name,
            should_track_output,
            tick_delay,
            execute_on_first_tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CommandOutputPacket {
    pub origin: CommandOrigin,
    pub output_type: String,
    pub success_count: u32,
    pub output: Vec<CommandOutputPacketOutputItem>,
    pub data: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for CommandOutputPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.origin.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.output_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.output_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::U32LE(self.success_count).encode(buf)?;
        let len = self.output.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.output {
            item.encode(buf)?;
        }
        let val = self.data.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.data {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (v)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (v).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let origin = <CommandOrigin as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let output_type = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let success_count = <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let output = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CommandOutputPacketOutputItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let has_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = if has_data {
            Some({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            })
        } else {
            None
        };
        Ok(Self {
            origin,
            output_type,
            success_count,
            output,
            data,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateTradePacket {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub size: i32,
    pub trade_tier: i32,
    pub villager_unique_id: i64,
    pub entity_unique_id: i64,
    pub display_name: String,
    pub new_trading_ui: bool,
    pub economic_trades: bool,
    pub offers: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for UpdateTradePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        crate::bedrock::codec::VarInt(self.size).encode(buf)?;
        crate::bedrock::codec::VarInt(self.trade_tier).encode(buf)?;
        crate::bedrock::codec::VarLong(self.villager_unique_id).encode(buf)?;
        crate::bedrock::codec::VarLong(self.entity_unique_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.display_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.display_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.new_trading_ui.encode(buf)?;
        self.economic_trades.encode(buf)?;
        self.offers.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let size = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let trade_tier = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let villager_unique_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_unique_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let display_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let new_trading_ui = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let economic_trades = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let offers = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            window_id,
            window_type,
            size,
            trade_tier,
            villager_unique_id,
            entity_unique_id,
            display_name,
            new_trading_ui,
            economic_trades,
            offers,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateEquipmentPacket {
    pub window_id: WindowId,
    pub window_type: WindowType,
    pub size: u8,
    pub entity_id: i64,
    pub inventory: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for UpdateEquipmentPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.window_id.encode(buf)?;
        self.window_type.encode(buf)?;
        self.size.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_id).encode(buf)?;
        self.inventory.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let window_id = <WindowId as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let window_type = <WindowType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let size = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let inventory = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            window_id,
            window_type,
            size,
            entity_id,
            inventory,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePackDataInfoPacket {
    pub pack_id: String,
    pub max_chunk_size: u32,
    pub chunk_count: u32,
    pub size: u64,
    pub hash: ByteArray,
    pub is_premium: bool,
    pub pack_type: ResourcePackDataInfoPacketPackType,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackDataInfoPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.pack_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.pack_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::U32LE(self.max_chunk_size).encode(buf)?;
        crate::bedrock::codec::U32LE(self.chunk_count).encode(buf)?;
        crate::bedrock::codec::U64LE(self.size).encode(buf)?;
        let len = self.hash.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.hash {
            (*item).encode(buf)?;
        }
        self.is_premium.encode(buf)?;
        self.pack_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let pack_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let max_chunk_size = <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let chunk_count = <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let size = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let hash = {
            let res: ByteArray = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                        );
                }
                tmp_vec
            };
            res
        };
        let is_premium = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let pack_type = <ResourcePackDataInfoPacketPackType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            pack_id,
            max_chunk_size,
            chunk_count,
            size,
            hash,
            is_premium,
            pack_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePackChunkDataPacket {
    pub pack_id: String,
    pub chunk_index: u32,
    pub progress: u64,
    pub payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackChunkDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.pack_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.pack_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::U32LE(self.chunk_index).encode(buf)?;
        crate::bedrock::codec::U64LE(self.progress).encode(buf)?;
        let len = self.payload.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.payload {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let pack_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let chunk_index = <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let progress = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let payload = {
            let res: ByteArray = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self {
            pack_id,
            chunk_index,
            progress,
            payload,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ResourcePackChunkRequestPacket {
    pub pack_id: String,
    pub chunk_index: u32,
}
impl crate::bedrock::codec::BedrockCodec for ResourcePackChunkRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.pack_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.pack_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::U32LE(self.chunk_index).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let pack_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let chunk_index = <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { pack_id, chunk_index })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransferPacket {
    pub server_address: String,
    pub port: u16,
    pub reload_world: bool,
}
impl crate::bedrock::codec::BedrockCodec for TransferPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.server_address)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.server_address).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::U16LE(self.port).encode(buf)?;
        self.reload_world.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let server_address = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let port = <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let reload_world = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            server_address,
            port,
            reload_world,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlaySoundPacket {
    pub name: String,
    pub coordinates: BlockCoordinates,
    pub volume: f32,
    pub pitch: f32,
}
impl crate::bedrock::codec::BedrockCodec for PlaySoundPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::F32LE(self.volume).encode(buf)?;
        crate::bedrock::codec::F32LE(self.pitch).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let volume = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let pitch = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            name,
            coordinates,
            volume,
            pitch,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StopSoundPacket {
    pub name: String,
    pub stop_all: bool,
    pub stop_music_legacy: bool,
}
impl crate::bedrock::codec::BedrockCodec for StopSoundPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.stop_all.encode(buf)?;
        self.stop_music_legacy.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let stop_all = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let stop_music_legacy = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            name,
            stop_all,
            stop_music_legacy,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetTitlePacket {
    pub type_: SetTitlePacketType,
    pub text: String,
    pub fade_in_time: i32,
    pub stay_time: i32,
    pub fade_out_time: i32,
    pub xuid: String,
    pub platform_online_id: String,
    pub filtered_message: String,
}
impl crate::bedrock::codec::BedrockCodec for SetTitlePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.text)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.text).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.fade_in_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.stay_time).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.fade_out_time).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.xuid)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.xuid).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.platform_online_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.platform_online_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.filtered_message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.filtered_message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <SetTitlePacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let text = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let fade_in_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let stay_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let fade_out_time = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let xuid = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let platform_online_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let filtered_message = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            type_,
            text,
            fade_in_time,
            stay_time,
            fade_out_time,
            xuid,
            platform_online_id,
            filtered_message,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AddBehaviorTreePacket {
    pub behaviortree: String,
}
impl crate::bedrock::codec::BedrockCodec for AddBehaviorTreePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.behaviortree)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.behaviortree).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let behaviortree = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { behaviortree })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StructureBlockUpdatePacket {
    pub position: BlockCoordinates,
    pub structure_name: String,
    pub filtered_structure_name: String,
    pub data_field: String,
    pub include_players: bool,
    pub show_bounding_box: bool,
    pub structure_block_type: i32,
    pub settings: StructureBlockSettings,
    pub redstone_save_mode: i32,
    pub should_trigger: bool,
    pub water_logged: bool,
}
impl crate::bedrock::codec::BedrockCodec for StructureBlockUpdatePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.structure_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.structure_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.filtered_structure_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.filtered_structure_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.data_field)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.data_field).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.include_players.encode(buf)?;
        self.show_bounding_box.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.structure_block_type).encode(buf)?;
        self.settings.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.redstone_save_mode).encode(buf)?;
        self.should_trigger.encode(buf)?;
        self.water_logged.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let structure_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let filtered_structure_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let data_field = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let include_players = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let show_bounding_box = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let structure_block_type = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let settings = <StructureBlockSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let redstone_save_mode = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let should_trigger = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let water_logged = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            position,
            structure_name,
            filtered_structure_name,
            data_field,
            include_players,
            show_bounding_box,
            structure_block_type,
            settings,
            redstone_save_mode,
            should_trigger,
            water_logged,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ShowStoreOfferPacket {
    pub offer_uuid: uuid::Uuid,
    pub redirect_type: ShowStoreOfferPacketRedirectType,
}
impl crate::bedrock::codec::BedrockCodec for ShowStoreOfferPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.offer_uuid.encode(buf)?;
        self.redirect_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let offer_uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let redirect_type = <ShowStoreOfferPacketRedirectType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { offer_uuid, redirect_type })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PurchaseReceiptPacket {
    pub receipts: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PurchaseReceiptPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.receipts.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.receipts {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let receipts = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self { receipts })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerSkinPacket {
    pub uuid: uuid::Uuid,
    pub skin: Skin,
    pub skin_name: String,
    pub old_skin_name: String,
    pub is_verified: bool,
}
impl crate::bedrock::codec::BedrockCodec for PlayerSkinPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.uuid.encode(buf)?;
        self.skin.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.skin_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.skin_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.old_skin_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.old_skin_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.is_verified.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let uuid = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin = <Skin as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let skin_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let old_skin_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let is_verified = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            uuid,
            skin,
            skin_name,
            old_skin_name,
            is_verified,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SubClientLoginPacket {
    pub tokens: LoginTokens,
}
impl crate::bedrock::codec::BedrockCodec for SubClientLoginPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let mut __encap_tmp = bytes::BytesMut::new();
        {
            let buf = &mut __encap_tmp;
            self.tokens.encode(buf)?;
        }
        let len = __encap_tmp.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&__encap_tmp);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let tokens = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::ArrayLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut slice = bytes::Buf::take(&mut *buf, len);
            let value = {
                let buf = &mut slice;
                <LoginTokens as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?
            };
            let _ = slice.remaining();
            value
        };
        Ok(Self { tokens })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct InitiateWebSocketConnectionPacket {
    pub server: String,
}
impl crate::bedrock::codec::BedrockCodec for InitiateWebSocketConnectionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.server)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.server).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let server = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { server })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetLastHurtByPacket {
    pub entity_type: i32,
}
impl crate::bedrock::codec::BedrockCodec for SetLastHurtByPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.entity_type).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_type = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { entity_type })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BookEditPacket {
    pub type_: BookEditPacketType,
    pub slot: u8,
    pub content: Option<BookEditPacketContent>,
}
impl crate::bedrock::codec::BedrockCodec for BookEditPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        self.slot.encode(buf)?;
        if let Some(v) = &self.content {
            match v {
                BookEditPacketContent::AddPage(v) => {
                    v.encode(buf)?;
                }
                BookEditPacketContent::DeletePage(v) => {
                    v.encode(buf)?;
                }
                BookEditPacketContent::ReplacePage(v) => {
                    v.encode(buf)?;
                }
                BookEditPacketContent::Sign(v) => {
                    v.encode(buf)?;
                }
                BookEditPacketContent::SwapPages(v) => {
                    v.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <BookEditPacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let content = match type_ {
            BookEditPacketType::AddPage => {
                Some(
                    BookEditPacketContent::AddPage(
                        <BookEditPacketContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BookEditPacketType::DeletePage => {
                Some(
                    BookEditPacketContent::DeletePage(
                        <BookEditPacketContentDeletePage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BookEditPacketType::ReplacePage => {
                Some(
                    BookEditPacketContent::ReplacePage(
                        <BookEditPacketContentAddPage as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BookEditPacketType::Sign => {
                Some(
                    BookEditPacketContent::Sign(
                        <BookEditPacketContentSign as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
            BookEditPacketType::SwapPages => {
                Some(
                    BookEditPacketContent::SwapPages(
                        <BookEditPacketContentSwapPages as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    ),
                )
            }
        };
        Ok(Self { type_, slot, content })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct NpcRequestPacket {
    pub runtime_entity_id: i64,
    pub request_type: NpcRequestPacketRequestType,
    pub command: String,
    pub action_type: NpcRequestPacketActionType,
    pub scene_name: String,
}
impl crate::bedrock::codec::BedrockCodec for NpcRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.request_type.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.command)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.command).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.action_type.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.scene_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.scene_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let request_type = <NpcRequestPacketRequestType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let action_type = <NpcRequestPacketActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let scene_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            runtime_entity_id,
            request_type,
            command,
            action_type,
            scene_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PhotoTransferPacket {
    pub image_name: String,
    pub image_data: String,
    pub book_id: String,
    pub photo_type: u8,
    pub source_type: u8,
    pub owner_entity_unique_id: i64,
    pub new_photo_name: String,
}
impl crate::bedrock::codec::BedrockCodec for PhotoTransferPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.image_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.image_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.image_data)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.image_data).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.book_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.book_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.photo_type.encode(buf)?;
        self.source_type.encode(buf)?;
        crate::bedrock::codec::I64LE(self.owner_entity_unique_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.new_photo_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.new_photo_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let image_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let image_data = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let book_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let photo_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let source_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let owner_entity_unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let new_photo_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            image_name,
            image_data,
            book_id,
            photo_type,
            source_type,
            owner_entity_unique_id,
            new_photo_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ModalFormRequestPacket {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for ModalFormRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.form_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.data)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.data).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let form_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ModalFormResponsePacket {
    pub form_id: i32,
    pub data: Option<String>,
    pub content: Option<ModalFormResponsePacketContent>,
}
impl crate::bedrock::codec::BedrockCodec for ModalFormResponsePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.form_id).encode(buf)?;
        let val = self.data.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.data {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (v)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (v).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        let val = self.content.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let form_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let has_response_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = if has_response_data {
            Some({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            })
        } else {
            None
        };
        let has_cancel_reason = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = if has_cancel_reason {
            Some(
                <ModalFormResponsePacketContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        Ok(Self { form_id, data, content })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerSettingsRequestPacket {}
impl crate::bedrock::codec::BedrockCodec for ServerSettingsRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerSettingsResponsePacket {
    pub form_id: i32,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for ServerSettingsResponsePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.form_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.data)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.data).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let form_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { form_id, data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ShowProfilePacket {
    pub xuid: String,
}
impl crate::bedrock::codec::BedrockCodec for ShowProfilePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.xuid)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.xuid).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let xuid = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { xuid })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetDefaultGameTypePacket {
    pub gamemode: GameMode,
}
impl crate::bedrock::codec::BedrockCodec for SetDefaultGameTypePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.gamemode.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { gamemode })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RemoveObjectivePacket {
    pub objective_name: String,
}
impl crate::bedrock::codec::BedrockCodec for RemoveObjectivePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.objective_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.objective_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let objective_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { objective_name })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetDisplayObjectivePacket {
    pub display_slot: String,
    pub objective_name: String,
    pub display_name: String,
    pub criteria_name: String,
    pub sort_order: i32,
}
impl crate::bedrock::codec::BedrockCodec for SetDisplayObjectivePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.display_slot)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.display_slot).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.objective_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.objective_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.display_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.display_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.criteria_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.criteria_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.sort_order).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let display_slot = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let objective_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let display_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let criteria_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let sort_order = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            display_slot,
            objective_name,
            display_name,
            criteria_name,
            sort_order,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetScorePacket {
    pub action: SetScorePacketAction,
    pub entries: Vec<SetScorePacketEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for SetScorePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action = <SetScorePacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SetScorePacketEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            SetScorePacketEntriesItemArgs {
                                action: action,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { action, entries })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LabTablePacket {
    pub action_type: LabTablePacketActionType,
    pub position: Vec3I,
    pub reaction_type: u8,
}
impl crate::bedrock::codec::BedrockCodec for LabTablePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action_type.encode(buf)?;
        self.position.encode(buf)?;
        self.reaction_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action_type = <LabTablePacketActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let reaction_type = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            action_type,
            position,
            reaction_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateBlockSyncedPacket {
    pub position: BlockCoordinates,
    pub block_runtime_id: i32,
    pub flags: UpdateBlockFlags,
    pub layer: i32,
    pub entity_unique_id: i64,
    pub transition_type: UpdateBlockSyncedPacketTransitionType,
}
impl crate::bedrock::codec::BedrockCodec for UpdateBlockSyncedPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.block_runtime_id).encode(buf)?;
        self.flags.encode(buf)?;
        crate::bedrock::codec::VarInt(self.layer).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id).encode(buf)?;
        self.transition_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let block_runtime_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let flags = <UpdateBlockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let layer = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let transition_type = <UpdateBlockSyncedPacketTransitionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            position,
            block_runtime_id,
            flags,
            layer,
            entity_unique_id,
            transition_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MoveEntityDeltaPacket {
    pub runtime_entity_id: i64,
    pub flags: DeltaMoveFlags,
    pub x: Option<f32>,
    pub y: Option<f32>,
    pub z: Option<f32>,
    pub rot_x: Option<u8>,
    pub rot_y: Option<u8>,
    pub rot_z: Option<u8>,
}
impl crate::bedrock::codec::BedrockCodec for MoveEntityDeltaPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        self.flags.encode(buf)?;
        if let Some(v) = &self.x {
            crate::bedrock::codec::F32LE(*v).encode(buf)?;
        }
        if let Some(v) = &self.y {
            crate::bedrock::codec::F32LE(*v).encode(buf)?;
        }
        if let Some(v) = &self.z {
            crate::bedrock::codec::F32LE(*v).encode(buf)?;
        }
        if let Some(v) = &self.rot_x {
            (*v).encode(buf)?;
        }
        if let Some(v) = &self.rot_y {
            (*v).encode(buf)?;
        }
        if let Some(v) = &self.rot_z {
            (*v).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let flags = <DeltaMoveFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let x = if flags.contains(DeltaMoveFlags::HAS_X) {
            Some(
                <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        let y = if flags.contains(DeltaMoveFlags::HAS_Y) {
            Some(
                <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        let z = if flags.contains(DeltaMoveFlags::HAS_Z) {
            Some(
                <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0,
            )
        } else {
            None
        };
        let rot_x = if flags.contains(DeltaMoveFlags::HAS_ROT_X) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_y = if flags.contains(DeltaMoveFlags::HAS_ROT_Y) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        let rot_z = if flags.contains(DeltaMoveFlags::HAS_ROT_Z) {
            Some(<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
        } else {
            None
        };
        Ok(Self {
            runtime_entity_id,
            flags,
            x,
            y,
            z,
            rot_x,
            rot_y,
            rot_z,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetScoreboardIdentityPacket {
    pub action: SetScoreboardIdentityPacketAction,
    pub entries: Vec<SetScoreboardIdentityPacketEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for SetScoreboardIdentityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action = <SetScoreboardIdentityPacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entries = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SetScoreboardIdentityPacketEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            SetScoreboardIdentityPacketEntriesItemArgs {
                                action: action,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { action, entries })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetLocalPlayerAsInitializedPacket {
    pub runtime_entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for SetLocalPlayerAsInitializedPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { runtime_entity_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateSoftEnumPacket {
    pub enum_type: String,
    pub options: Vec<String>,
    pub action_type: UpdateSoftEnumPacketActionType,
}
impl crate::bedrock::codec::BedrockCodec for UpdateSoftEnumPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.enum_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.enum_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.options.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.options {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let enum_type = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let options = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        let action_type = <UpdateSoftEnumPacketActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            enum_type,
            options,
            action_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct NetworkStackLatencyPacket {
    pub timestamp: u64,
    pub needs_response: u8,
}
impl crate::bedrock::codec::BedrockCodec for NetworkStackLatencyPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U64LE(self.timestamp).encode(buf)?;
        self.needs_response.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let timestamp = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let needs_response = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { timestamp, needs_response })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ScriptCustomEventPacket {
    pub event_name: String,
    pub event_data: String,
}
impl crate::bedrock::codec::BedrockCodec for ScriptCustomEventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.event_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.event_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.event_data)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.event_data).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let event_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let event_data = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { event_name, event_data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SpawnParticleEffectPacket {
    pub dimension: u8,
    pub entity_id: i64,
    pub position: Vec3F,
    pub particle_name: String,
    pub molang_variables: Option<String>,
}
impl crate::bedrock::codec::BedrockCodec for SpawnParticleEffectPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.dimension.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.entity_id).encode(buf)?;
        self.position.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.particle_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.particle_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        match &self.molang_variables {
            Some(v) => {
                buf.put_u8(1);
                let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                    (v)
                        .chars()
                        .map(|ch| {
                            let code = ch as u32;
                            if code <= 0xFF { code as u8 } else { b'?' }
                        })
                        .collect()
                } else {
                    (v).as_bytes().to_vec()
                };
                let len = bytes.len();
                crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                buf.put_slice(&bytes);
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let dimension = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let particle_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let molang_variables = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some({
                    let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as i64;
                    if len_raw < 0 {
                        return Err(crate::bedrock::error::DecodeError::NegativeLength {
                            value: len_raw,
                        });
                    }
                    let len = len_raw as usize;
                    if buf.remaining() < len {
                        return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                            declared: len,
                            available: buf.remaining(),
                        });
                    }
                    let mut bytes = vec![0u8; len];
                    buf.copy_to_slice(&mut bytes);
                    let s = if "".eq_ignore_ascii_case("latin1") {
                        bytes.into_iter().map(|b| b as char).collect::<String>()
                    } else {
                        String::from_utf8_lossy(&bytes).into_owned()
                    };
                    s
                })
            } else {
                None
            }
        };
        Ok(Self {
            dimension,
            entity_id,
            position,
            particle_name,
            molang_variables,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AvailableEntityIdentifiersPacket {
    pub nbt: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for AvailableEntityIdentifiersPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let nbt = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LevelSoundEventV2Packet {
    pub sound_id: u8,
    pub position: Vec3F,
    pub block_id: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
}
impl crate::bedrock::codec::BedrockCodec for LevelSoundEventV2Packet {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.block_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.entity_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.entity_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let sound_id = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let block_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            sound_id,
            position,
            block_id,
            entity_type,
            is_baby_mob,
            is_global,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct NetworkChunkPublisherUpdatePacket {
    pub coordinates: BlockCoordinates,
    pub radius: i32,
    pub saved_chunks: Vec<NetworkChunkPublisherUpdatePacketSavedChunksItem>,
}
impl crate::bedrock::codec::BedrockCodec for NetworkChunkPublisherUpdatePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.coordinates.encode(buf)?;
        crate::bedrock::codec::VarInt(self.radius).encode(buf)?;
        let len = self.saved_chunks.len();
        crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
        for item in &self.saved_chunks {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let coordinates = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let radius = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let saved_chunks = {
            let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <NetworkChunkPublisherUpdatePacketSavedChunksItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            coordinates,
            radius,
            saved_chunks,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BiomeDefinitionListPacket {
    pub biome_definitions: Vec<BiomeDefinition>,
    pub string_list: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for BiomeDefinitionListPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.biome_definitions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.biome_definitions {
            item.encode(buf)?;
        }
        let len = self.string_list.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.string_list {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let biome_definitions = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BiomeDefinition as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let string_list = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self {
            biome_definitions,
            string_list,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LevelSoundEventPacket {
    pub sound_id: SoundType,
    pub position: Vec3F,
    pub extra_data: i32,
    pub entity_type: String,
    pub is_baby_mob: bool,
    pub is_global: bool,
    pub entity_unique_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for LevelSoundEventPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.sound_id.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.extra_data).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.entity_type)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.entity_type).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.is_baby_mob.encode(buf)?;
        self.is_global.encode(buf)?;
        crate::bedrock::codec::I64LE(self.entity_unique_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let sound_id = <SoundType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let extra_data = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_type = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let is_baby_mob = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_global = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entity_unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            sound_id,
            position,
            extra_data,
            entity_type,
            is_baby_mob,
            is_global,
            entity_unique_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LevelEventGenericPacket {
    pub event_id: i32,
    pub nbt: NbtLoop,
}
impl crate::bedrock::codec::BedrockCodec for LevelEventGenericPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.event_id).encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let event_id = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let nbt = <NbtLoop as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { event_id, nbt })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LecternUpdatePacket {
    pub page: u8,
    pub page_count: u8,
    pub position: Vec3I,
}
impl crate::bedrock::codec::BedrockCodec for LecternUpdatePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.page.encode(buf)?;
        self.page_count.encode(buf)?;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let page = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let page_count = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { page, page_count, position })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VideoStreamConnectPacket {
    pub server_uri: String,
    pub frame_send_frequency: f32,
    pub action: VideoStreamConnectPacketAction,
    pub resolution_x: i32,
    pub resolution_y: i32,
}
impl crate::bedrock::codec::BedrockCodec for VideoStreamConnectPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.server_uri)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.server_uri).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::F32LE(self.frame_send_frequency).encode(buf)?;
        self.action.encode(buf)?;
        crate::bedrock::codec::I32LE(self.resolution_x).encode(buf)?;
        crate::bedrock::codec::I32LE(self.resolution_y).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let server_uri = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let frame_send_frequency = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let action = <VideoStreamConnectPacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let resolution_x = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let resolution_y = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            server_uri,
            frame_send_frequency,
            action,
            resolution_x,
            resolution_y,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientCacheStatusPacket {
    pub enabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for ClientCacheStatusPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.enabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { enabled })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct OnScreenTextureAnimationPacket {
    pub animation_type: u32,
}
impl crate::bedrock::codec::BedrockCodec for OnScreenTextureAnimationPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U32LE(self.animation_type).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let animation_type = <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { animation_type })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MapCreateLockedCopyPacket {
    pub original_map_id: i64,
    pub new_map_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for MapCreateLockedCopyPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.original_map_id).encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.new_map_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let original_map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let new_map_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            original_map_id,
            new_map_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StructureTemplateDataExportRequestPacket {
    pub name: String,
    pub position: BlockCoordinates,
    pub settings: StructureBlockSettings,
    pub request_type: StructureTemplateDataExportRequestPacketRequestType,
}
impl crate::bedrock::codec::BedrockCodec for StructureTemplateDataExportRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.position.encode(buf)?;
        self.settings.encode(buf)?;
        self.request_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let settings = <StructureBlockSettings as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let request_type = <StructureTemplateDataExportRequestPacketRequestType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            name,
            position,
            settings,
            request_type,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StructureTemplateDataExportResponsePacket {
    pub name: String,
    pub nbt: Option<crate::bedrock::codec::Nbt>,
    pub response_type: StructureTemplateDataExportResponsePacketResponseType,
}
impl crate::bedrock::codec::BedrockCodec for StructureTemplateDataExportResponsePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let val = self.nbt.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.nbt {
            (*v).encode(buf)?;
        }
        self.response_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let success = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let nbt = if success {
            Some(
                <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let response_type = <StructureTemplateDataExportResponsePacketResponseType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { name, nbt, response_type })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateBlockPropertiesPacket {
    pub nbt: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for UpdateBlockPropertiesPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let nbt = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientCacheBlobStatusPacket {
    pub misses: i32,
    pub haves: i32,
    pub missing: Vec<u64>,
    pub have: Vec<u64>,
}
impl crate::bedrock::codec::BedrockCodec for ClientCacheBlobStatusPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.misses).encode(buf)?;
        crate::bedrock::codec::VarInt(self.haves).encode(buf)?;
        let len = self.missing.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.missing {
            crate::bedrock::codec::U64LE(*item).encode(buf)?;
        }
        let len = self.have.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.have {
            crate::bedrock::codec::U64LE(*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let misses = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let haves = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let missing = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    );
            }
            tmp_vec
        };
        let have = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            misses,
            haves,
            missing,
            have,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientCacheMissResponsePacket {
    pub blobs: Vec<Blob>,
}
impl crate::bedrock::codec::BedrockCodec for ClientCacheMissResponsePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.blobs.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.blobs {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let blobs = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Blob as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    );
            }
            tmp_vec
        };
        Ok(Self { blobs })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EducationSettingsPacket {
    pub code_builder_default_uri: String,
    pub code_builder_title: String,
    pub can_resize_code_builder: bool,
    pub disable_legacy_title_bar: bool,
    pub post_process_filter: String,
    pub screenshot_border_path: String,
    pub agent_capabilities: Option<EducationSettingsPacketAgentCapabilities>,
    pub has_override_uri: bool,
    pub override_uri: Option<String>,
    pub has_quiz: bool,
    pub external_link_settings: Option<EducationSettingsPacketExternalLinkSettings>,
}
impl crate::bedrock::codec::BedrockCodec for EducationSettingsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.code_builder_default_uri)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.code_builder_default_uri).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.code_builder_title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.code_builder_title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.can_resize_code_builder.encode(buf)?;
        self.disable_legacy_title_bar.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.post_process_filter)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.post_process_filter).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.screenshot_border_path)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.screenshot_border_path).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let val = self.agent_capabilities.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.agent_capabilities {
            v.encode(buf)?;
        }
        self.has_override_uri.encode(buf)?;
        if let Some(v) = &self.override_uri {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (v)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (v).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        self.has_quiz.encode(buf)?;
        let val = self.external_link_settings.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.external_link_settings {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let code_builder_default_uri = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let code_builder_title = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let can_resize_code_builder = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let disable_legacy_title_bar = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let post_process_filter = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let screenshot_border_path = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let has_agent_capabilities = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let agent_capabilities = if has_agent_capabilities {
            Some(
                <EducationSettingsPacketAgentCapabilities as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let has_override_uri = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let override_uri = if has_override_uri {
            Some({
                let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0) as i64;
                if len_raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: len_raw,
                    });
                }
                let len = len_raw as usize;
                if buf.remaining() < len {
                    return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                        declared: len,
                        available: buf.remaining(),
                    });
                }
                let mut bytes = vec![0u8; len];
                buf.copy_to_slice(&mut bytes);
                let s = if "".eq_ignore_ascii_case("latin1") {
                    bytes.into_iter().map(|b| b as char).collect::<String>()
                } else {
                    String::from_utf8_lossy(&bytes).into_owned()
                };
                s
            })
        } else {
            None
        };
        let has_quiz = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let has_external_link_settings = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let external_link_settings = if has_external_link_settings {
            Some(
                <EducationSettingsPacketExternalLinkSettings as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        Ok(Self {
            code_builder_default_uri,
            code_builder_title,
            can_resize_code_builder,
            disable_legacy_title_bar,
            post_process_filter,
            screenshot_border_path,
            agent_capabilities,
            has_override_uri,
            override_uri,
            has_quiz,
            external_link_settings,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EmotePacket {
    pub entity_id: i64,
    pub emote_id: String,
    pub emote_length_ticks: i32,
    pub xuid: String,
    pub platform_id: String,
    pub flags: EmotePacketFlags,
}
impl crate::bedrock::codec::BedrockCodec for EmotePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.entity_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.emote_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.emote_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::VarInt(self.emote_length_ticks).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.xuid)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.xuid).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.platform_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.platform_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.flags.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let emote_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let emote_length_ticks = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let xuid = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let platform_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let flags = <EmotePacketFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_id,
            emote_id,
            emote_length_ticks,
            xuid,
            platform_id,
            flags,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MultiplayerSettingsPacket {
    pub action_type: MultiplayerSettingsPacketActionType,
}
impl crate::bedrock::codec::BedrockCodec for MultiplayerSettingsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action_type.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action_type = <MultiplayerSettingsPacketActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { action_type })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SettingsCommandPacket {
    pub command_line: String,
    pub suppress_output: bool,
}
impl crate::bedrock::codec::BedrockCodec for SettingsCommandPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.command_line)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.command_line).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.suppress_output.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let command_line = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let suppress_output = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            command_line,
            suppress_output,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AnvilDamagePacket {
    pub damage: u8,
    pub position: BlockCoordinates,
}
impl crate::bedrock::codec::BedrockCodec for AnvilDamagePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.damage.encode(buf)?;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let damage = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { damage, position })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CompletedUsingItemPacket {
    pub used_item_id: i16,
    pub use_method: CompletedUsingItemPacketUseMethod,
}
impl crate::bedrock::codec::BedrockCodec for CompletedUsingItemPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I16LE(self.used_item_id).encode(buf)?;
        self.use_method.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let used_item_id = <crate::bedrock::codec::I16LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let use_method = <CompletedUsingItemPacketUseMethod as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { used_item_id, use_method })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct NetworkSettingsPacket {
    pub compression_threshold: u16,
    pub compression_algorithm: NetworkSettingsPacketCompressionAlgorithm,
    pub client_throttle: bool,
    pub client_throttle_threshold: u8,
    pub client_throttle_scalar: f32,
}
impl crate::bedrock::codec::BedrockCodec for NetworkSettingsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U16LE(self.compression_threshold).encode(buf)?;
        self.compression_algorithm.encode(buf)?;
        self.client_throttle.encode(buf)?;
        self.client_throttle_threshold.encode(buf)?;
        crate::bedrock::codec::F32LE(self.client_throttle_scalar).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let compression_threshold = <crate::bedrock::codec::U16LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let compression_algorithm = <NetworkSettingsPacketCompressionAlgorithm as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_throttle = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_throttle_threshold = <u8 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let client_throttle_scalar = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            compression_threshold,
            compression_algorithm,
            client_throttle,
            client_throttle_threshold,
            client_throttle_scalar,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerAuthInputPacket {
    pub pitch: f32,
    pub yaw: f32,
    pub position: Vec3F,
    pub move_vector: Vec2F,
    pub head_yaw: f32,
    pub input_data: InputFlag,
    pub input_mode: PlayerAuthInputPacketInputMode,
    pub play_mode: PlayerAuthInputPacketPlayMode,
    pub interaction_model: PlayerAuthInputPacketInteractionModel,
    pub interact_rotation: Vec2F,
    pub tick: i64,
    pub delta: Vec3F,
    pub transaction: Option<Box<PlayerAuthInputPacketTransaction>>,
    pub item_stack_request: Option<Box<ItemStackRequest>>,
    pub content: Option<PlayerAuthInputPacketContent>,
    pub block_action: Option<Vec<PlayerAuthInputPacketBlockActionItem>>,
    pub analogue_move_vector: Vec2F,
    pub camera_orientation: Vec3F,
    pub raw_move_vector: Vec2F,
}
#[derive(Debug, Clone)]
pub struct PlayerAuthInputPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for PlayerAuthInputPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for PlayerAuthInputPacket {
    type Args = PlayerAuthInputPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.pitch).encode(buf)?;
        crate::bedrock::codec::F32LE(self.yaw).encode(buf)?;
        self.position.encode(buf)?;
        self.move_vector.encode(buf)?;
        crate::bedrock::codec::F32LE(self.head_yaw).encode(buf)?;
        self.input_data.encode(buf)?;
        self.input_mode.encode(buf)?;
        self.play_mode.encode(buf)?;
        self.interaction_model.encode(buf)?;
        self.interact_rotation.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        self.delta.encode(buf)?;
        if let Some(v) = &self.transaction {
            v.encode(buf)?;
        }
        if let Some(v) = &self.item_stack_request {
            v.encode(buf)?;
        }
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        if let Some(v) = &self.block_action {
            let len = v.len();
            crate::bedrock::codec::ZigZag32(len as i32).encode(buf)?;
            for item in v {
                item.encode(buf)?;
            }
        }
        self.analogue_move_vector.encode(buf)?;
        self.camera_orientation.encode(buf)?;
        self.raw_move_vector.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let pitch = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let head_yaw = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let input_data = <InputFlag as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let input_mode = <PlayerAuthInputPacketInputMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let play_mode = <PlayerAuthInputPacketPlayMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let interaction_model = <PlayerAuthInputPacketInteractionModel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let interact_rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let transaction = if input_data.contains(InputFlag::ITEM_INTERACT) {
            Some(
                Box::new(
                    <PlayerAuthInputPacketTransaction as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        PlayerAuthInputPacketTransactionArgs {
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        let item_stack_request = if input_data.contains(InputFlag::ITEM_STACK_REQUEST) {
            Some(
                Box::new(
                    <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        ItemStackRequestArgs {
                            shield_item_id: args.shield_item_id,
                        },
                    )?,
                ),
            )
        } else {
            None
        };
        let content = if input_data.contains(InputFlag::CLIENT_PREDICTED_VEHICLE) {
            Some(
                <PlayerAuthInputPacketContent as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?,
            )
        } else {
            None
        };
        let block_action = if input_data.contains(InputFlag::BLOCK_ACTION) {
            Some({
                let raw = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <PlayerAuthInputPacketBlockActionItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            })
        } else {
            None
        };
        let analogue_move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let camera_orientation = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let raw_move_vector = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            pitch,
            yaw,
            position,
            move_vector,
            head_yaw,
            input_data,
            input_mode,
            play_mode,
            interaction_model,
            interact_rotation,
            tick,
            delta,
            transaction,
            item_stack_request,
            content,
            block_action,
            analogue_move_vector,
            camera_orientation,
            raw_move_vector,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CreativeContentPacket {
    pub groups: Vec<CreativeContentPacketGroupsItem>,
    pub items: Vec<CreativeContentPacketItemsItem>,
}
#[derive(Debug, Clone)]
pub struct CreativeContentPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for CreativeContentPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for CreativeContentPacket {
    type Args = CreativeContentPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.groups.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.groups {
            item.encode(buf)?;
        }
        let len = self.items.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.items {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let groups = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CreativeContentPacketGroupsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            CreativeContentPacketGroupsItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        let items = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CreativeContentPacketItemsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            CreativeContentPacketItemsItemArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { groups, items })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerEnchantOptionsPacket {
    pub options: Vec<EnchantOption>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerEnchantOptionsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.options.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.options {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let options = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <EnchantOption as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { options })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackRequestPacket {
    pub requests: Vec<ItemStackRequest>,
}
#[derive(Debug, Clone)]
pub struct ItemStackRequestPacketArgs {
    pub shield_item_id: i32,
}
impl<'a> From<&'a crate::bedrock::context::BedrockSession>
for ItemStackRequestPacketArgs {
    fn from(source: &'a crate::bedrock::context::BedrockSession) -> Self {
        Self {
            shield_item_id: source.shield_item_id,
        }
    }
}
impl crate::bedrock::codec::BedrockCodec for ItemStackRequestPacket {
    type Args = ItemStackRequestPacketArgs;
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.requests.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let requests = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ItemStackRequest as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            ItemStackRequestArgs {
                                shield_item_id: args.shield_item_id,
                            },
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { requests })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemStackResponsePacket {
    pub responses: ItemStackResponses,
}
impl crate::bedrock::codec::BedrockCodec for ItemStackResponsePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.responses.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.responses {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let responses = {
            let res: ItemStackResponses = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemStackResponsesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { responses })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerArmorDamagePacket {
    pub entries: Vec<ArmorDamageEntry>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerArmorDamagePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entries = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ArmorDamageEntry as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CodeBuilderPacket {
    pub url: String,
    pub should_open_code_builder: bool,
}
impl crate::bedrock::codec::BedrockCodec for CodeBuilderPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.url)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.url).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.should_open_code_builder.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let url = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let should_open_code_builder = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            url,
            should_open_code_builder,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdatePlayerGameTypePacket {
    pub gamemode: GameMode,
    pub player_unique_id: i64,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for UpdatePlayerGameTypePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.gamemode.encode(buf)?;
        crate::bedrock::codec::ZigZag64(self.player_unique_id).encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let gamemode = <GameMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            gamemode,
            player_unique_id,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EmoteListPacket {
    pub player_id: i64,
    pub emote_pieces: Vec<uuid::Uuid>,
}
impl crate::bedrock::codec::BedrockCodec for EmoteListPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.player_id).encode(buf)?;
        let len = self.emote_pieces.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.emote_pieces {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let player_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let emote_pieces = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { player_id, emote_pieces })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PositionTrackingDbBroadcastPacket {
    pub broadcast_action: PositionTrackingDbBroadcastPacketBroadcastAction,
    pub tracking_id: i32,
    pub nbt: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for PositionTrackingDbBroadcastPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.broadcast_action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.tracking_id).encode(buf)?;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let broadcast_action = <PositionTrackingDbBroadcastPacketBroadcastAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let nbt = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            broadcast_action,
            tracking_id,
            nbt,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PositionTrackingDbRequestPacket {
    pub action: PositionTrackingDbRequestPacketAction,
    pub tracking_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for PositionTrackingDbRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.tracking_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action = <PositionTrackingDbRequestPacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tracking_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { action, tracking_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DebugInfoPacket {
    pub player_unique_id: i64,
    pub data: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for DebugInfoPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.player_unique_id).encode(buf)?;
        let len = self.data.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.data {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let player_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let data = {
            let res: ByteArray = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { player_unique_id, data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ViolationWarningPacket {
    pub violation_type: ViolationWarningPacketViolationType,
    pub severity: ViolationWarningPacketSeverity,
    pub packet_id: i32,
    pub reason: String,
}
impl crate::bedrock::codec::BedrockCodec for ViolationWarningPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.violation_type.encode(buf)?;
        self.severity.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.packet_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.reason)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.reason).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let violation_type = <ViolationWarningPacketViolationType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let severity = <ViolationWarningPacketSeverity as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let packet_id = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let reason = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            violation_type,
            severity,
            packet_id,
            reason,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MotionPredictionHintsPacket {
    pub entity_runtime_id: i64,
    pub velocity: Vec3F,
    pub on_ground: bool,
}
impl crate::bedrock::codec::BedrockCodec for MotionPredictionHintsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.entity_runtime_id).encode(buf)?;
        self.velocity.encode(buf)?;
        self.on_ground.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let velocity = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            entity_runtime_id,
            velocity,
            on_ground,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AnimateEntityPacket {
    pub animation: String,
    pub next_state: String,
    pub stop_condition: String,
    pub stop_condition_version: i32,
    pub controller: String,
    pub blend_out_time: f32,
    pub runtime_entity_ids: Vec<i64>,
}
impl crate::bedrock::codec::BedrockCodec for AnimateEntityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.animation)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.animation).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.next_state)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.next_state).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.stop_condition)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.stop_condition).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::I32LE(self.stop_condition_version).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.controller)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.controller).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::F32LE(self.blend_out_time).encode(buf)?;
        let len = self.runtime_entity_ids.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.runtime_entity_ids {
            crate::bedrock::codec::VarLong(*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let animation = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let next_state = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let stop_condition = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let stop_condition_version = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let controller = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let blend_out_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let runtime_entity_ids = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            animation,
            next_state,
            stop_condition,
            stop_condition_version,
            controller,
            blend_out_time,
            runtime_entity_ids,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraShakePacket {
    pub intensity: f32,
    pub duration: f32,
    pub type_: u8,
    pub action: CameraShakePacketAction,
}
impl crate::bedrock::codec::BedrockCodec for CameraShakePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.intensity).encode(buf)?;
        crate::bedrock::codec::F32LE(self.duration).encode(buf)?;
        self.type_.encode(buf)?;
        self.action.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let intensity = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let duration = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let type_ = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let action = <CameraShakePacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            intensity,
            duration,
            type_,
            action,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerFogPacket {
    pub stack: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerFogPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.stack.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.stack {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let stack = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self { stack })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CorrectPlayerMovePredictionPacket {
    pub prediction_type: CorrectPlayerMovePredictionPacketPredictionType,
    pub position: Vec3F,
    pub delta: Vec3F,
    pub rotation: Vec2F,
    pub angular_velocity: Option<f32>,
    pub on_ground: bool,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for CorrectPlayerMovePredictionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.prediction_type.encode(buf)?;
        self.position.encode(buf)?;
        self.delta.encode(buf)?;
        self.rotation.encode(buf)?;
        match &self.angular_velocity {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::F32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        self.on_ground.encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let prediction_type = <CorrectPlayerMovePredictionPacketPredictionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let delta = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let rotation = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let angular_velocity = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            } else {
                None
            }
        };
        let on_ground = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            prediction_type,
            position,
            delta,
            rotation,
            angular_velocity,
            on_ground,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ItemRegistryPacket {
    pub itemstates: Itemstates,
}
impl crate::bedrock::codec::BedrockCodec for ItemRegistryPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.itemstates.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.itemstates {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let itemstates = {
            let res: Itemstates = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <ItemstatesItem as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { itemstates })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PacketFilterTextPacket {
    pub text: String,
    pub from_server: bool,
}
impl crate::bedrock::codec::BedrockCodec for PacketFilterTextPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.text)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.text).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.from_server.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let text = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let from_server = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { text, from_server })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DebugRendererPacket {
    pub type_: String,
    pub data: Option<Box<DebugMarkerData>>,
}
impl crate::bedrock::codec::BedrockCodec for DebugRendererPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.type_)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.type_).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let val = self.data.is_some();
        val.encode(buf)?;
        if let Some(v) = &self.data {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let has_data = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let data = if has_data {
            Some(
                Box::new(
                    <DebugMarkerData as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                ),
            )
        } else {
            None
        };
        Ok(Self { type_, data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SyncEntityPropertyPacket {
    pub nbt: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for SyncEntityPropertyPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.nbt.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let nbt = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { nbt })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AddVolumeEntityPacket {
    pub runtime_id: i64,
    pub nbt: crate::bedrock::codec::Nbt,
    pub encoding_identifier: String,
    pub instance_name: String,
    pub bounds: AddVolumeEntityPacketBounds,
    pub dimension: i32,
    pub engine_version: String,
}
impl crate::bedrock::codec::BedrockCodec for AddVolumeEntityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        self.nbt.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.encoding_identifier)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.encoding_identifier).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.instance_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.instance_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.bounds.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.engine_version)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.engine_version).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let nbt = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let encoding_identifier = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let instance_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let bounds = <AddVolumeEntityPacketBounds as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let engine_version = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            runtime_id,
            nbt,
            encoding_identifier,
            instance_name,
            bounds,
            dimension,
            engine_version,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RemoveVolumeEntityPacket {
    pub entity_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for RemoveVolumeEntityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.entity_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { entity_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SimulationTypePacket {
    pub type_: SimulationTypePacketType,
}
impl crate::bedrock::codec::BedrockCodec for SimulationTypePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <SimulationTypePacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { type_ })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct NpcDialoguePacket {
    pub entity_id: u64,
    pub action_type: NpcDialoguePacketActionType,
    pub dialogue: String,
    pub screen_name: String,
    pub npc_name: String,
    pub action_json: String,
}
impl crate::bedrock::codec::BedrockCodec for NpcDialoguePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::U64LE(self.entity_id).encode(buf)?;
        self.action_type.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.dialogue)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.dialogue).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.screen_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.screen_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.npc_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.npc_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.action_json)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.action_json).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_id = <crate::bedrock::codec::U64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let action_type = <NpcDialoguePacketActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dialogue = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let screen_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let npc_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let action_json = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            entity_id,
            action_type,
            dialogue,
            screen_name,
            npc_name,
            action_json,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PacketEduUriResourcePacket {
    pub resource: EducationSharedResourceUri,
}
impl crate::bedrock::codec::BedrockCodec for PacketEduUriResourcePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.resource.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let resource = <EducationSharedResourceUri as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { resource })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CreatePhotoPacket {
    pub entity_unique_id: i64,
    pub photo_name: String,
    pub item_name: String,
}
impl crate::bedrock::codec::BedrockCodec for CreatePhotoPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I64LE(self.entity_unique_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.photo_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.photo_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.item_name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.item_name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let photo_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let item_name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            entity_unique_id,
            photo_name,
            item_name,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateSubchunkBlocksPacket {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub blocks: Vec<BlockUpdate>,
    pub extra: Vec<BlockUpdate>,
}
impl crate::bedrock::codec::BedrockCodec for UpdateSubchunkBlocksPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.x).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.y).encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.z).encode(buf)?;
        let len = self.blocks.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.blocks {
            item.encode(buf)?;
        }
        let len = self.extra.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.extra {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let x = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let y = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let z = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let blocks = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let extra = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <BlockUpdate as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { x, y, z, blocks, extra })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PhotoInfoRequestPacket {
    pub photo_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for PhotoInfoRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.photo_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let photo_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { photo_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SubchunkPacket {
    pub dimension: i32,
    pub origin: Vec3I,
    pub entries: SubchunkPacketEntries,
}
impl crate::bedrock::codec::BedrockCodec for SubchunkPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let val = matches!(
            self.entries, SubchunkPacketEntries::SubChunkEntryWithCaching(_)
        );
        val.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.origin.encode(buf)?;
        match &self.entries {
            SubchunkPacketEntries::SubChunkEntryWithoutCaching(v) => {
                let len = v.len();
                crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
            SubchunkPacketEntries::SubChunkEntryWithCaching(v) => {
                let len = v.len();
                crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
                for item in v {
                    item.encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let cache_enabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let entries = if cache_enabled {
            SubchunkPacketEntries::SubChunkEntryWithCaching({
                let res: SubChunkEntryWithCaching = {
                    let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <SubChunkEntryWithCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                };
                res
            })
        } else {
            SubchunkPacketEntries::SubChunkEntryWithoutCaching({
                let res: SubChunkEntryWithoutCaching = {
                    let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0) as usize;
                    let mut tmp_vec = Vec::with_capacity(len);
                    for _ in 0..len {
                        tmp_vec
                            .push(
                                <SubChunkEntryWithoutCachingItem as crate::bedrock::codec::BedrockCodec>::decode(
                                    buf,
                                    (),
                                )?,
                            );
                    }
                    tmp_vec
                };
                res
            })
        };
        Ok(Self { dimension, origin, entries })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SubchunkRequestPacket {
    pub dimension: i32,
    pub origin: Vec3I,
    pub requests: Vec<SubchunkRequestPacketRequestsItem>,
}
impl crate::bedrock::codec::BedrockCodec for SubchunkRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.dimension).encode(buf)?;
        self.origin.encode(buf)?;
        let len = self.requests.len();
        crate::bedrock::codec::U32LE(len as u32).encode(buf)?;
        for item in &self.requests {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let dimension = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let origin = <Vec3I as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let requests = {
            let len = (<crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <SubchunkRequestPacketRequestsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            dimension,
            origin,
            requests,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientStartItemCooldownPacket {
    pub category: String,
    pub duration: i32,
}
impl crate::bedrock::codec::BedrockCodec for ClientStartItemCooldownPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.category)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.category).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.duration).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let category = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let duration = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { category, duration })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ScriptMessagePacket {
    pub message_id: String,
    pub data: String,
}
impl crate::bedrock::codec::BedrockCodec for ScriptMessagePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.message_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.message_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.data)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.data).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let message_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let data = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { message_id, data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CodeBuilderSourcePacket {
    pub operation: CodeBuilderSourcePacketOperation,
    pub category: CodeBuilderSourcePacketCategory,
    pub code_status: CodeBuilderSourcePacketCodeStatus,
}
impl crate::bedrock::codec::BedrockCodec for CodeBuilderSourcePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.operation.encode(buf)?;
        self.category.encode(buf)?;
        self.code_status.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let operation = <CodeBuilderSourcePacketOperation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let category = <CodeBuilderSourcePacketCategory as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let code_status = <CodeBuilderSourcePacketCodeStatus as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            operation,
            category,
            code_status,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TickingAreasLoadStatusPacket {
    pub preload: bool,
}
impl crate::bedrock::codec::BedrockCodec for TickingAreasLoadStatusPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.preload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let preload = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { preload })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DimensionDataPacket {
    pub definitions: Vec<DimensionDataPacketDefinitionsItem>,
}
impl crate::bedrock::codec::BedrockCodec for DimensionDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.definitions.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.definitions {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let definitions = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <DimensionDataPacketDefinitionsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { definitions })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AgentActionPacket {
    pub request_id: String,
    pub action_type: AgentActionPacketActionType,
    pub body: String,
}
impl crate::bedrock::codec::BedrockCodec for AgentActionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.request_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.request_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.action_type.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.body)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.body).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let request_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let action_type = <AgentActionPacketActionType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let body = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            request_id,
            action_type,
            body,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ChangeMobPropertyPacket {
    pub entity_unique_id: i64,
    pub property: String,
    pub bool_value: bool,
    pub string_value: String,
    pub int_value: i32,
    pub float_value: f32,
}
impl crate::bedrock::codec::BedrockCodec for ChangeMobPropertyPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag64(self.entity_unique_id).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.property)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.property).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.bool_value.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.string_value)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.string_value).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        crate::bedrock::codec::ZigZag32(self.int_value).encode(buf)?;
        crate::bedrock::codec::F32LE(self.float_value).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_unique_id = <crate::bedrock::codec::ZigZag64 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let property = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let bool_value = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let string_value = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let int_value = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let float_value = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            entity_unique_id,
            property,
            bool_value,
            string_value,
            int_value,
            float_value,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LessonProgressPacket {
    pub action: u8,
    pub score: i32,
    pub identifier: String,
}
impl crate::bedrock::codec::BedrockCodec for LessonProgressPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        crate::bedrock::codec::ZigZag32(self.score).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.identifier)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.identifier).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let score = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let identifier = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { action, score, identifier })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RequestAbilityPacket {
    pub ability: RequestAbilityPacketAbility,
    pub value_type: RequestAbilityPacketValueType,
    pub bool_value: bool,
    pub float_val: f32,
}
impl crate::bedrock::codec::BedrockCodec for RequestAbilityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.ability.encode(buf)?;
        self.value_type.encode(buf)?;
        self.bool_value.encode(buf)?;
        crate::bedrock::codec::F32LE(self.float_val).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let ability = <RequestAbilityPacketAbility as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value_type = <RequestAbilityPacketValueType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let bool_value = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let float_val = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            ability,
            value_type,
            bool_value,
            float_val,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RequestPermissionsPacket {
    pub entity_unique_id: i64,
    pub permission_level: PermissionLevel,
    pub requested_permissions: RequestPermissions,
}
impl crate::bedrock::codec::BedrockCodec for RequestPermissionsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I64LE(self.entity_unique_id).encode(buf)?;
        self.permission_level.encode(buf)?;
        self.requested_permissions.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let requested_permissions = <RequestPermissions as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            entity_unique_id,
            permission_level,
            requested_permissions,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ToastRequestPacket {
    pub title: String,
    pub message: String,
}
impl crate::bedrock::codec::BedrockCodec for ToastRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.title)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.title).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.message)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.message).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let title = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let message = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { title, message })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateAbilitiesPacket {
    pub entity_unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
}
impl crate::bedrock::codec::BedrockCodec for UpdateAbilitiesPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I64LE(self.entity_unique_id).encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = (<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            entity_unique_id,
            permission_level,
            command_permission,
            abilities,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateAdventureSettingsPacket {
    pub no_pvm: bool,
    pub no_mvp: bool,
    pub immutable_world: bool,
    pub show_name_tags: bool,
    pub auto_jump: bool,
}
impl crate::bedrock::codec::BedrockCodec for UpdateAdventureSettingsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.no_pvm.encode(buf)?;
        self.no_mvp.encode(buf)?;
        self.immutable_world.encode(buf)?;
        self.show_name_tags.encode(buf)?;
        self.auto_jump.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let no_pvm = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let no_mvp = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let immutable_world = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let show_name_tags = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let auto_jump = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            no_pvm,
            no_mvp,
            immutable_world,
            show_name_tags,
            auto_jump,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeathInfoPacket {
    pub cause: String,
    pub messages: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for DeathInfoPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.cause)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.cause).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let len = self.messages.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.messages {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let cause = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let messages = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self { cause, messages })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EditorNetworkPacket {
    pub route_to_manager: bool,
    pub payload: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for EditorNetworkPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.route_to_manager.encode(buf)?;
        self.payload.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let route_to_manager = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let payload = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { route_to_manager, payload })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct FeatureRegistryPacket {
    pub features: Vec<FeatureRegistryPacketFeaturesItem>,
}
impl crate::bedrock::codec::BedrockCodec for FeatureRegistryPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.features.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.features {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let features = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <FeatureRegistryPacketFeaturesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { features })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerStatsPacket {
    pub server_time: f32,
    pub network_time: f32,
}
impl crate::bedrock::codec::BedrockCodec for ServerStatsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.server_time).encode(buf)?;
        crate::bedrock::codec::F32LE(self.network_time).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let server_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let network_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { server_time, network_time })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RequestNetworkSettingsPacket {
    pub client_protocol: i32,
}
impl crate::bedrock::codec::BedrockCodec for RequestNetworkSettingsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.client_protocol.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let client_protocol = <i32 as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { client_protocol })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GameTestRequestPacket {
    pub max_tests_per_batch: i32,
    pub repetitions: i32,
    pub rotation: GameTestRequestPacketRotation,
    pub stop_on_error: bool,
    pub position: BlockCoordinates,
    pub tests_per_row: i32,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for GameTestRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarInt(self.max_tests_per_batch).encode(buf)?;
        crate::bedrock::codec::VarInt(self.repetitions).encode(buf)?;
        self.rotation.encode(buf)?;
        self.stop_on_error.encode(buf)?;
        self.position.encode(buf)?;
        crate::bedrock::codec::VarInt(self.tests_per_row).encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let max_tests_per_batch = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let repetitions = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let rotation = <GameTestRequestPacketRotation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let stop_on_error = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let tests_per_row = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self {
            max_tests_per_batch,
            repetitions,
            rotation,
            stop_on_error,
            position,
            tests_per_row,
            name,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GameTestResultsPacket {
    pub succeeded: bool,
    pub error: String,
    pub name: String,
}
impl crate::bedrock::codec::BedrockCodec for GameTestResultsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.succeeded.encode(buf)?;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.error)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.error).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let succeeded = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let error = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { succeeded, error, name })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateClientInputLocksPacket {
    pub locks: InputLockFlags,
    pub position: Vec3F,
}
impl crate::bedrock::codec::BedrockCodec for UpdateClientInputLocksPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.locks.encode(buf)?;
        self.position.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let locks = <InputLockFlags as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let position = <Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { locks, position })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientCheatAbilityPacket {
    pub entity_unique_id: i64,
    pub permission_level: PermissionLevel,
    pub command_permission: CommandPermissionLevel,
    pub abilities: Vec<AbilityLayers>,
}
impl crate::bedrock::codec::BedrockCodec for ClientCheatAbilityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I64LE(self.entity_unique_id).encode(buf)?;
        self.permission_level.encode(buf)?;
        self.command_permission.encode(buf)?;
        let len = self.abilities.len();
        (len as u8).encode(buf)?;
        for item in &self.abilities {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entity_unique_id = <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let permission_level = <PermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let command_permission = <CommandPermissionLevel as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let abilities = {
            let len = (<u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
                as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <AbilityLayers as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self {
            entity_unique_id,
            permission_level,
            command_permission,
            abilities,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraPresetsPacket {
    pub presets: Vec<CameraPresets>,
}
impl crate::bedrock::codec::BedrockCodec for CameraPresetsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.presets.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.presets {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let presets = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraPresets as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { presets })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UnlockedRecipesPacket {
    pub unlock_type: UnlockedRecipesPacketUnlockType,
    pub recipes: Vec<String>,
}
impl crate::bedrock::codec::BedrockCodec for UnlockedRecipesPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.unlock_type.encode(buf)?;
        let len = self.recipes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.recipes {
            let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                (item)
                    .chars()
                    .map(|ch| {
                        let code = ch as u32;
                        if code <= 0xFF { code as u8 } else { b'?' }
                    })
                    .collect()
            } else {
                (item).as_bytes().to_vec()
            };
            let len = bytes.len();
            crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
            buf.put_slice(&bytes);
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let unlock_type = <UnlockedRecipesPacketUnlockType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let recipes = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    });
            }
            tmp_vec
        };
        Ok(Self { unlock_type, recipes })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraInstructionPacket {
    pub instruction_set: Option<CameraInstructionPacketInstructionSet>,
    pub clear: Option<bool>,
    pub fade: Option<CameraInstructionPacketFade>,
    pub target: Option<CameraInstructionPacketTarget>,
    pub remove_target: Option<bool>,
    pub fov: Option<CameraInstructionPacketFov>,
    pub spline: Option<CameraSplineInstruction>,
    pub attach_to_entity: Option<i64>,
    pub detach_from_entity: Option<bool>,
}
impl crate::bedrock::codec::BedrockCodec for CameraInstructionPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        match &self.instruction_set {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.clear {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fade {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.target {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.remove_target {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.fov {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.spline {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.attach_to_entity {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::I64LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        match &self.detach_from_entity {
            Some(v) => {
                buf.put_u8(1);
                (*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let instruction_set = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraInstructionPacketInstructionSet as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let clear = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let fade = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraInstructionPacketFade as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let target = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraInstructionPacketTarget as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let remove_target = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        let fov = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraInstructionPacketFov as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let spline = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <CameraSplineInstruction as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        let attach_to_entity = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::I64LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            } else {
                None
            }
        };
        let detach_from_entity = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(<bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            } else {
                None
            }
        };
        Ok(Self {
            instruction_set,
            clear,
            fade,
            target,
            remove_target,
            fov,
            spline,
            attach_to_entity,
            detach_from_entity,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CompressedBiomeDefinitionsPacket {
    pub raw_payload: ByteArray,
}
impl crate::bedrock::codec::BedrockCodec for CompressedBiomeDefinitionsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.raw_payload.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.raw_payload {
            (*item).encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let raw_payload = {
            let res: ByteArray = {
                let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?
                    .0 as i64;
                if raw < 0 {
                    return Err(crate::bedrock::error::DecodeError::NegativeLength {
                        value: raw,
                    });
                }
                let len = raw as usize;
                let mut tmp_vec = Vec::with_capacity(len);
                for _ in 0..len {
                    tmp_vec
                        .push(
                            <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                        );
                }
                tmp_vec
            };
            res
        };
        Ok(Self { raw_payload })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrimDataPacket {
    pub patterns: Vec<TrimDataPacketPatternsItem>,
    pub materials: Vec<TrimDataPacketMaterialsItem>,
}
impl crate::bedrock::codec::BedrockCodec for TrimDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.patterns.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.patterns {
            item.encode(buf)?;
        }
        let len = self.materials.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.materials {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let patterns = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TrimDataPacketPatternsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let materials = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <TrimDataPacketMaterialsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { patterns, materials })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct OpenSignPacket {
    pub position: BlockCoordinates,
    pub is_front: bool,
}
impl crate::bedrock::codec::BedrockCodec for OpenSignPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        self.is_front.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <BlockCoordinates as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let is_front = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { position, is_front })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AgentAnimationPacket {
    pub animation: AgentAnimationPacketAnimation,
    pub entity_runtime_id: i64,
}
impl crate::bedrock::codec::BedrockCodec for AgentAnimationPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.animation.encode(buf)?;
        crate::bedrock::codec::VarLong(self.entity_runtime_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let animation = <AgentAnimationPacketAnimation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            animation,
            entity_runtime_id,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RefreshEntitlementsPacket {}
impl crate::bedrock::codec::BedrockCodec for RefreshEntitlementsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ToggleCrafterSlotRequestPacket {
    pub position: Vec3Li,
    pub slot: u8,
    pub disabled: bool,
}
impl crate::bedrock::codec::BedrockCodec for ToggleCrafterSlotRequestPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.position.encode(buf)?;
        self.slot.encode(buf)?;
        self.disabled.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let position = <Vec3Li as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let slot = <u8 as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let disabled = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self { position, slot, disabled })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetPlayerInventoryOptionsPacket {
    pub left_tab: SetPlayerInventoryOptionsPacketLeftTab,
    pub right_tab: SetPlayerInventoryOptionsPacketRightTab,
    pub filtering: bool,
    pub layout: SetPlayerInventoryOptionsPacketLayout,
    pub crafting_layout: SetPlayerInventoryOptionsPacketCraftingLayout,
}
impl crate::bedrock::codec::BedrockCodec for SetPlayerInventoryOptionsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.left_tab.encode(buf)?;
        self.right_tab.encode(buf)?;
        self.filtering.encode(buf)?;
        self.layout.encode(buf)?;
        self.crafting_layout.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let left_tab = <SetPlayerInventoryOptionsPacketLeftTab as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let right_tab = <SetPlayerInventoryOptionsPacketRightTab as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let filtering = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        let layout = <SetPlayerInventoryOptionsPacketLayout as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let crafting_layout = <SetPlayerInventoryOptionsPacketCraftingLayout as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            left_tab,
            right_tab,
            filtering,
            layout,
            crafting_layout,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetHudPacket {
    pub elements: Vec<Element>,
    pub visibility: SetHudPacketVisibility,
}
impl crate::bedrock::codec::BedrockCodec for SetHudPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.elements.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.elements {
            item.encode(buf)?;
        }
        self.visibility.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let elements = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <Element as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let visibility = <SetHudPacketVisibility as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { elements, visibility })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AwardAchievementPacket {
    pub achievement_id: i32,
}
impl crate::bedrock::codec::BedrockCodec for AwardAchievementPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::I32LE(self.achievement_id).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let achievement_id = <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self { achievement_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundCloseFormPacket {}
impl crate::bedrock::codec::BedrockCodec for ClientboundCloseFormPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        Ok(Self {})
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerboundLoadingScreenPacket {
    pub type_: i32,
    pub loading_screen_id: Option<u32>,
}
impl crate::bedrock::codec::BedrockCodec for ServerboundLoadingScreenPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::ZigZag32(self.type_).encode(buf)?;
        match &self.loading_screen_id {
            Some(v) => {
                buf.put_u8(1);
                crate::bedrock::codec::U32LE(*v).encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <crate::bedrock::codec::ZigZag32 as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let loading_screen_id = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <crate::bedrock::codec::U32LE as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?
                        .0,
                )
            } else {
                None
            }
        };
        Ok(Self { type_, loading_screen_id })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct JigsawStructureDataPacket {
    pub structure_data: crate::bedrock::codec::Nbt,
}
impl crate::bedrock::codec::BedrockCodec for JigsawStructureDataPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.structure_data.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let structure_data = <crate::bedrock::codec::Nbt as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { structure_data })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CurrentStructureFeaturePacket {
    pub current_feature: String,
}
impl crate::bedrock::codec::BedrockCodec for CurrentStructureFeaturePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.current_feature)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.current_feature).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let current_feature = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        Ok(Self { current_feature })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerboundDiagnosticsPacket {
    pub average_frames_per_second: f32,
    pub average_server_sim_tick_time: f32,
    pub average_client_sim_tick_time: f32,
    pub average_begin_frame_time: f32,
    pub average_input_time: f32,
    pub average_render_time: f32,
    pub average_end_frame_time: f32,
    pub average_remainder_time_percent: f32,
    pub average_unaccounted_time_percent: f32,
}
impl crate::bedrock::codec::BedrockCodec for ServerboundDiagnosticsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::F32LE(self.average_frames_per_second).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_server_sim_tick_time).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_client_sim_tick_time).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_begin_frame_time).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_input_time).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_render_time).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_end_frame_time).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_remainder_time_percent).encode(buf)?;
        crate::bedrock::codec::F32LE(self.average_unaccounted_time_percent).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let average_frames_per_second = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_server_sim_tick_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_client_sim_tick_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_begin_frame_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_input_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_render_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_end_frame_time = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_remainder_time_percent = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let average_unaccounted_time_percent = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            average_frames_per_second,
            average_server_sim_tick_time,
            average_client_sim_tick_time,
            average_begin_frame_time,
            average_input_time,
            average_render_time,
            average_end_frame_time,
            average_remainder_time_percent,
            average_unaccounted_time_percent,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraAimAssistPacket {
    pub preset_id: String,
    pub view_angle: Vec2F,
    pub distance: f32,
    pub target_mode: CameraAimAssistPacketTargetMode,
    pub action: CameraAimAssistPacketAction,
    pub show_debug_render: bool,
}
impl crate::bedrock::codec::BedrockCodec for CameraAimAssistPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.preset_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.preset_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.view_angle.encode(buf)?;
        crate::bedrock::codec::F32LE(self.distance).encode(buf)?;
        self.target_mode.encode(buf)?;
        self.action.encode(buf)?;
        self.show_debug_render.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let preset_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let view_angle = <Vec2F as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let distance = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let target_mode = <CameraAimAssistPacketTargetMode as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let action = <CameraAimAssistPacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let show_debug_render = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            preset_id,
            view_angle,
            distance,
            target_mode,
            action,
            show_debug_render,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ContainerRegistryCleanupPacket {
    pub removed_containers: Vec<FullContainerName>,
}
impl crate::bedrock::codec::BedrockCodec for ContainerRegistryCleanupPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.removed_containers.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.removed_containers {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let removed_containers = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <FullContainerName as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { removed_containers })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MovementEffectPacket {
    pub runtime_id: i64,
    pub effect_type: MovementEffectType,
    pub effect_duration: i32,
    pub tick: i64,
}
impl crate::bedrock::codec::BedrockCodec for MovementEffectPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        self.effect_type.encode(buf)?;
        crate::bedrock::codec::VarInt(self.effect_duration).encode(buf)?;
        crate::bedrock::codec::VarLong(self.tick).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let effect_type = <MovementEffectType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let effect_duration = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let tick = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            runtime_id,
            effect_type,
            effect_duration,
            tick,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SetMovementAuthorityPacket {
    pub movement_authority: SetMovementAuthorityPacketMovementAuthority,
}
impl crate::bedrock::codec::BedrockCodec for SetMovementAuthorityPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.movement_authority.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let movement_authority = <SetMovementAuthorityPacketMovementAuthority as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { movement_authority })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CameraAimAssistPresetsPacket {
    pub categories: Vec<CameraAimAssistPresetsPacketCategoriesItem>,
    pub presets: Vec<CameraAimAssistPresetsPacketPresetsItem>,
    pub operation: CameraAimAssistPresetsPacketOperation,
}
impl crate::bedrock::codec::BedrockCodec for CameraAimAssistPresetsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.categories.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.categories {
            item.encode(buf)?;
        }
        let len = self.presets.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.presets {
            item.encode(buf)?;
        }
        self.operation.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let categories = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraAimAssistPresetsPacketCategoriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let presets = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <CameraAimAssistPresetsPacketPresetsItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let operation = <CameraAimAssistPresetsPacketOperation as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            categories,
            presets,
            operation,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientCameraAimAssistPacket {
    pub preset_id: String,
    pub action: ClientCameraAimAssistPacketAction,
    pub allow_aim_assist: bool,
}
impl crate::bedrock::codec::BedrockCodec for ClientCameraAimAssistPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.preset_id)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.preset_id).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.action.encode(buf)?;
        self.allow_aim_assist.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let preset_id = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let action = <ClientCameraAimAssistPacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let allow_aim_assist = <bool as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self {
            preset_id,
            action,
            allow_aim_assist,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientMovementPredictionSyncPacket {
    pub data_flags: i64,
    pub bounding_box: ClientMovementPredictionSyncPacketBoundingBox,
    pub movement_speed: f32,
    pub underwater_movement_speed: f32,
    pub lava_movement_speed: f32,
    pub jump_strength: f32,
    pub health: f32,
    pub hunger: f32,
    pub entity_runtime_id: i64,
    pub is_flying: bool,
}
impl crate::bedrock::codec::BedrockCodec for ClientMovementPredictionSyncPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.data_flags).encode(buf)?;
        self.bounding_box.encode(buf)?;
        crate::bedrock::codec::F32LE(self.movement_speed).encode(buf)?;
        crate::bedrock::codec::F32LE(self.underwater_movement_speed).encode(buf)?;
        crate::bedrock::codec::F32LE(self.lava_movement_speed).encode(buf)?;
        crate::bedrock::codec::F32LE(self.jump_strength).encode(buf)?;
        crate::bedrock::codec::F32LE(self.health).encode(buf)?;
        crate::bedrock::codec::F32LE(self.hunger).encode(buf)?;
        crate::bedrock::codec::VarLong(self.entity_runtime_id).encode(buf)?;
        self.is_flying.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let data_flags = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let bounding_box = <ClientMovementPredictionSyncPacketBoundingBox as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let movement_speed = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let underwater_movement_speed = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let lava_movement_speed = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let jump_strength = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let health = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let hunger = <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let entity_runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let is_flying = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            data_flags,
            bounding_box,
            movement_speed,
            underwater_movement_speed,
            lava_movement_speed,
            jump_strength,
            health,
            hunger,
            entity_runtime_id,
            is_flying,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct UpdateClientOptionsPacket {
    pub graphics_mode: Option<UpdateClientOptionsPacketGraphicsMode>,
}
impl crate::bedrock::codec::BedrockCodec for UpdateClientOptionsPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        match &self.graphics_mode {
            Some(v) => {
                buf.put_u8(1);
                v.encode(buf)?;
            }
            None => buf.put_u8(0),
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let graphics_mode = {
            let present = u8::decode(buf, ())?;
            if present != 0 {
                Some(
                    <UpdateClientOptionsPacketGraphicsMode as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            } else {
                None
            }
        };
        Ok(Self { graphics_mode })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerVideoCapturePacket {
    pub action: PlayerVideoCapturePacketAction,
    pub content: Option<PlayerVideoCapturePacketContent>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerVideoCapturePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.action.encode(buf)?;
        if let Some(v) = &self.content {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let action = <PlayerVideoCapturePacketAction as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let content = match action {
            PlayerVideoCapturePacketAction::Start => {
                Some(
                    <PlayerVideoCapturePacketContent as crate::bedrock::codec::BedrockCodec>::decode(
                        buf,
                        (),
                    )?,
                )
            }
            _ => None,
        };
        Ok(Self { action, content })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerUpdateEntityOverridesPacket {
    pub runtime_id: i64,
    pub property_index: i32,
    pub type_: PlayerUpdateEntityOverridesPacketType,
    pub value: Option<PlayerUpdateEntityOverridesPacketValue>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerUpdateEntityOverridesPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        crate::bedrock::codec::VarLong(self.runtime_id).encode(buf)?;
        crate::bedrock::codec::VarInt(self.property_index).encode(buf)?;
        self.type_.encode(buf)?;
        if let Some(v) = &self.value {
            match v {
                PlayerUpdateEntityOverridesPacketValue::SetFloat(v) => {
                    crate::bedrock::codec::F32LE(*v).encode(buf)?;
                }
                PlayerUpdateEntityOverridesPacketValue::SetInt(v) => {
                    crate::bedrock::codec::I32LE(*v).encode(buf)?;
                }
            }
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let runtime_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let property_index = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let type_ = <PlayerUpdateEntityOverridesPacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let value = match type_ {
            PlayerUpdateEntityOverridesPacketType::SetFloat => {
                Some(
                    PlayerUpdateEntityOverridesPacketValue::SetFloat(
                        <crate::bedrock::codec::F32LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            PlayerUpdateEntityOverridesPacketType::SetInt => {
                Some(
                    PlayerUpdateEntityOverridesPacketValue::SetInt(
                        <crate::bedrock::codec::I32LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            _ => None,
        };
        Ok(Self {
            runtime_id,
            property_index,
            type_,
            value,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PlayerLocationPacket {
    pub type_: PlayerLocationPacketType,
    pub entity_unique_id: i64,
    pub position: Option<Vec3F>,
}
impl crate::bedrock::codec::BedrockCodec for PlayerLocationPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.type_.encode(buf)?;
        crate::bedrock::codec::VarLong(self.entity_unique_id).encode(buf)?;
        if let Some(v) = &self.position {
            v.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let type_ = <PlayerLocationPacketType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let entity_unique_id = <crate::bedrock::codec::VarLong as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        let position = match type_ {
            PlayerLocationPacketType::Coordinates => {
                Some(<Vec3F as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?)
            }
            _ => None,
        };
        Ok(Self {
            type_,
            entity_unique_id,
            position,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundControlsSchemePacket {
    pub scheme: ClientboundControlsSchemePacketScheme,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundControlsSchemePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.scheme.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let scheme = <ClientboundControlsSchemePacketScheme as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { scheme })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerScriptDebugDrawerPacket {
    pub shapes: Vec<ServerScriptDebugDrawerPacketShapesItem>,
}
impl crate::bedrock::codec::BedrockCodec for ServerScriptDebugDrawerPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.shapes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.shapes {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let shapes = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ServerScriptDebugDrawerPacketShapesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { shapes })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerboundPackSettingChangePacket {
    pub pack_id: uuid::Uuid,
    pub pack_setting: ServerboundPackSettingChangePacketPackSetting,
}
impl crate::bedrock::codec::BedrockCodec for ServerboundPackSettingChangePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        self.pack_id.encode(buf)?;
        self.pack_setting.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let pack_id = <uuid::Uuid as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let pack_setting = <ServerboundPackSettingChangePacketPackSetting as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        Ok(Self { pack_id, pack_setting })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ClientboundDataStorePacket {
    pub entries: Vec<ClientboundDataStorePacketEntriesItem>,
}
impl crate::bedrock::codec::BedrockCodec for ClientboundDataStorePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.entries.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.entries {
            item.encode(buf)?;
        }
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let entries = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ClientboundDataStorePacketEntriesItem as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        Ok(Self { entries })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GraphicsOverrideParameterPacket {
    pub values: Vec<ParameterKeyframeValue>,
    pub biome_identifier: String,
    pub parameter_type: GraphicsOverrideParameterType,
    pub reset: bool,
}
impl crate::bedrock::codec::BedrockCodec for GraphicsOverrideParameterPacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let len = self.values.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        for item in &self.values {
            item.encode(buf)?;
        }
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.biome_identifier)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.biome_identifier).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.parameter_type.encode(buf)?;
        self.reset.encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let values = {
            let raw = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0 as i64;
            if raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: raw,
                });
            }
            let len = raw as usize;
            let mut tmp_vec = Vec::with_capacity(len);
            for _ in 0..len {
                tmp_vec
                    .push(
                        <ParameterKeyframeValue as crate::bedrock::codec::BedrockCodec>::decode(
                            buf,
                            (),
                        )?,
                    );
            }
            tmp_vec
        };
        let biome_identifier = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let parameter_type = <GraphicsOverrideParameterType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let reset = <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?;
        Ok(Self {
            values,
            biome_identifier,
            parameter_type,
            reset,
        })
    }
}
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ServerboundDataStorePacket {
    pub name: String,
    pub property: String,
    pub path: String,
    pub data_type: ServerboundDataStorePacketDataType,
    pub data: Option<ServerboundDataStorePacketData>,
    pub update_count: i32,
}
impl crate::bedrock::codec::BedrockCodec for ServerboundDataStorePacket {
    type Args = ();
    fn encode<B: bytes::BufMut>(&self, buf: &mut B) -> Result<(), std::io::Error> {
        let _ = buf;
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.name)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.name).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.property)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.property).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
            (&self.path)
                .chars()
                .map(|ch| {
                    let code = ch as u32;
                    if code <= 0xFF { code as u8 } else { b'?' }
                })
                .collect()
        } else {
            (&self.path).as_bytes().to_vec()
        };
        let len = bytes.len();
        crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
        buf.put_slice(&bytes);
        self.data_type.encode(buf)?;
        if let Some(v) = &self.data {
            match v {
                ServerboundDataStorePacketData::Bool(v) => {
                    (*v).encode(buf)?;
                }
                ServerboundDataStorePacketData::Double(v) => {
                    crate::bedrock::codec::F64LE(*v).encode(buf)?;
                }
                ServerboundDataStorePacketData::String(v) => {
                    let bytes: Vec<u8> = if "".eq_ignore_ascii_case("latin1") {
                        (v)
                            .chars()
                            .map(|ch| {
                                let code = ch as u32;
                                if code <= 0xFF { code as u8 } else { b'?' }
                            })
                            .collect()
                    } else {
                        (v).as_bytes().to_vec()
                    };
                    let len = bytes.len();
                    crate::bedrock::codec::VarInt(len as i32).encode(buf)?;
                    buf.put_slice(&bytes);
                }
            }
        }
        crate::bedrock::codec::VarInt(self.update_count).encode(buf)?;
        Ok(())
    }
    fn decode<B: bytes::Buf>(
        buf: &mut B,
        _args: Self::Args,
    ) -> Result<Self, crate::bedrock::error::DecodeError> {
        let _ = buf;
        let name = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let property = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let path = {
            let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                    buf,
                    (),
                )?
                .0) as i64;
            if len_raw < 0 {
                return Err(crate::bedrock::error::DecodeError::NegativeLength {
                    value: len_raw,
                });
            }
            let len = len_raw as usize;
            if buf.remaining() < len {
                return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                    declared: len,
                    available: buf.remaining(),
                });
            }
            let mut bytes = vec![0u8; len];
            buf.copy_to_slice(&mut bytes);
            let s = if "".eq_ignore_ascii_case("latin1") {
                bytes.into_iter().map(|b| b as char).collect::<String>()
            } else {
                String::from_utf8_lossy(&bytes).into_owned()
            };
            s
        };
        let data_type = <ServerboundDataStorePacketDataType as crate::bedrock::codec::BedrockCodec>::decode(
            buf,
            (),
        )?;
        let data = match data_type {
            ServerboundDataStorePacketDataType::Bool => {
                Some(
                    ServerboundDataStorePacketData::Bool(
                        <bool as crate::bedrock::codec::BedrockCodec>::decode(buf, ())?,
                    ),
                )
            }
            ServerboundDataStorePacketDataType::Double => {
                Some(
                    ServerboundDataStorePacketData::Double(
                        <crate::bedrock::codec::F64LE as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0,
                    ),
                )
            }
            ServerboundDataStorePacketDataType::String => {
                Some(
                    ServerboundDataStorePacketData::String({
                        let len_raw = (<crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                                buf,
                                (),
                            )?
                            .0) as i64;
                        if len_raw < 0 {
                            return Err(crate::bedrock::error::DecodeError::NegativeLength {
                                value: len_raw,
                            });
                        }
                        let len = len_raw as usize;
                        if buf.remaining() < len {
                            return Err(crate::bedrock::error::DecodeError::StringLengthExceeded {
                                declared: len,
                                available: buf.remaining(),
                            });
                        }
                        let mut bytes = vec![0u8; len];
                        buf.copy_to_slice(&mut bytes);
                        let s = if "".eq_ignore_ascii_case("latin1") {
                            bytes.into_iter().map(|b| b as char).collect::<String>()
                        } else {
                            String::from_utf8_lossy(&bytes).into_owned()
                        };
                        s
                    }),
                )
            }
        };
        let update_count = <crate::bedrock::codec::VarInt as crate::bedrock::codec::BedrockCodec>::decode(
                buf,
                (),
            )?
            .0;
        Ok(Self {
            name,
            property,
            path,
            data_type,
            data,
            update_count,
        })
    }
}
