use crate::ir::{Container, Primitive, Type};
use crate::parser::ParseResult;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use syn::Ident;

struct Context {
    definitions: Vec<TokenStream>,
    emitted: HashSet<String>,
}

pub fn generate(
    version: &str,
    parse_result: &ParseResult,
    output_dir: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let module_name = format!("v{}", version.replace(".", "_"));
    let file_path = output_dir.join(format!("{}.rs", module_name));
    let mut file = File::create(&file_path)?;

    let mut ctx = Context {
        definitions: Vec::new(),
        emitted: HashSet::new(),
    };

    // 1. Emit named types
    let mut type_names: Vec<_> = parse_result.types.keys().collect();
    type_names.sort();

    for name in type_names {
        if let Some(t) = parse_result.types.get(name) {
            if is_primitive_name(name) {
                continue;
            }
            // We define them. If they are containers, this will recurse into fields.
            define_type(name, t, &mut ctx)?;
        }
    }

    // 2. Emit Packets
    for packet in &parse_result.packets {
        let struct_name = camel_case(&packet.name);
        // This defines the struct
        define_container(&struct_name, &packet.body, &mut ctx)?;
    }

    // 3. PacketId enum
    let mut packet_variants = Vec::new();
    for packet in &parse_result.packets {
        let name = format_ident!("{}", camel_case(&packet.name));
        let id = packet.id;
        packet_variants.push(quote! {
            #name = #id
        });
    }

    let packet_id_enum = quote! {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[repr(u32)]
        pub enum PacketId {
            #(#packet_variants),*
        }
    };
    ctx.definitions.push(packet_id_enum);

    // Combine all definitions
    let all_defs = &ctx.definitions;
    let final_code = quote! {
        #![allow(non_camel_case_types)]
        #![allow(non_snake_case)]
        #![allow(dead_code)]
        #![allow(unused_imports)]
        use serde::{Serialize, Deserialize};

        #(#all_defs)*
    };

    let syntax_tree = syn::parse2(final_code).map_err(|e| format!("Failed to parse generated code: {}", e))?;
    let formatted = prettyplease::unparse(&syntax_tree);

    write!(file, "// Generated by valentine_gen. Do not edit.\n\n")?;
    write!(file, "{}", formatted)?;

    Ok(())
}

fn is_primitive_name(name: &str) -> bool {
    matches!(name, "int" | "bool" | "byte" | "short" | "long" | "float" | "double" | "string" | "varint" | "varlong" | "uuid")
}

fn define_type(
    name: &str,
    t: &Type,
    ctx: &mut Context,
) -> Result<(), Box<dyn std::error::Error>> {
    let safe_name_str = clean_type_name(name);
    if ctx.emitted.contains(&safe_name_str) {
        return Ok(())
    }
    // Mark emitted before processing to handle recursion (though mostly avoiding duplication)
    ctx.emitted.insert(safe_name_str.clone());

    let ident = format_ident!("{}", safe_name_str);

    let def = match t {
        Type::Primitive(p) => {
            let rust_type = primitive_to_rust_tokens(p);
            quote! {
                pub type #ident = #rust_type;
            }
        }
        Type::Reference(r) => {
            let ref_ident = format_ident!("{}", clean_type_name(r));
            quote! {
                pub type #ident = #ref_ident;
            }
        }
        Type::Container(c) => {
            // generate_container_struct logic
            build_container_struct(&safe_name_str, c, ctx)?
        }
        Type::Array { count_type: _, inner_type } => {
            // For array type definition, we just need the inner type token
            // But inner type might be complex and need defining
            let inner_tokens = resolve_type_to_tokens(inner_type, &format!("{}_Item", safe_name_str), ctx)?;
            quote! {
                pub type #ident = Vec<#inner_tokens>;
            }
        }
        Type::Switch { compare_to: _, fields, default } => {
            let mut variants = Vec::new();
            
            // Default
            let default_type_tokens = resolve_type_to_tokens(default, &format!("{}_Default", safe_name_str), ctx)?;
            let is_unit = matches!(default.as_ref(), Type::Primitive(Primitive::Void));
            
            if is_unit {
                 variants.push(quote! { Default });
            } else {
                 variants.push(quote! { Default(#default_type_tokens) });
            }

            for (case_name, case_type) in fields {
                let case_variant_ident = format_ident!("{}", camel_case(case_name));
                let case_type_tokens = resolve_type_to_tokens(case_type, &format!("{}_{}", safe_name_str, camel_case(case_name)), ctx)?;
                
                let is_case_unit = matches!(case_type, Type::Primitive(Primitive::Void));

                if is_case_unit {
                    variants.push(quote! { #case_variant_ident });
                } else {
                    variants.push(quote! { #case_variant_ident(#case_type_tokens) });
                }
            }

            quote! {
                #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
                pub enum #ident {
                    #(#variants),*
                }
            }
        }
        Type::Bitfield { name: _, storage_type, flags } => {
            let storage_tokens = primitive_to_rust_tokens(storage_type);
            let mut consts = Vec::new();
            
            for (flag_name, val) in flags {
                 let const_name_str = format!("{}_{}", safe_name_str.to_uppercase(), flag_name.to_uppercase().replace(".", "_"));
                 let const_ident = format_ident!("{}", const_name_str);
                 let val_lit = proc_macro2::Literal::u32_unsuffixed(*val);
                 consts.push(quote! {
                    pub const #const_ident: #ident = #val_lit;
                 });
            }

            quote! {
                pub type #ident = #storage_tokens;
                #(#consts)*
            }
        }
    };

    ctx.definitions.push(def);
    Ok(())
}

fn define_container(
    name: &str,
    container: &Container,
    ctx: &mut Context,
) -> Result<(), Box<dyn std::error::Error>> {
    let safe_name_str = clean_type_name(name);
    if ctx.emitted.contains(&safe_name_str) {
        return Ok(())
    }
    ctx.emitted.insert(safe_name_str.clone());

    let def = build_container_struct(&safe_name_str, container, ctx)?;
    ctx.definitions.push(def);
    Ok(())
}

fn build_container_struct(
    name: &str,
    container: &Container,
    ctx: &mut Context,
) -> Result<TokenStream, Box<dyn std::error::Error>> {
    let struct_ident = format_ident!("{}", name);
    let mut fields = Vec::new();

    for field in &container.fields {
        let field_name_clean = clean_field_name(&field.name);
        let field_ident = format_ident!("{}", field_name_clean);
        
        let field_type_hint = format!("{}_{}", name, camel_case(&field.name));
        let type_tokens = resolve_type_to_tokens(&field.type_def, &field_type_hint, ctx)?;
        
        fields.push(quote! {
            pub #field_ident: #type_tokens
        });
    }

    Ok(quote! {
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct #struct_ident {
            #(#fields),*
        }
    })
}

// Returns the tokens representing the type (e.g. "i32", "MyStruct", "Vec<u8>").
// If the type needs a definition (e.g. nested struct), it defines it in `ctx` and returns the name.
fn resolve_type_to_tokens(
    t: &Type,
    hint_name: &str,
    ctx: &mut Context,
) -> Result<TokenStream, Box<dyn std::error::Error>> {
    match t {
        Type::Primitive(p) => Ok(primitive_to_rust_tokens(p)),
        Type::Reference(r) => {
            let ident = format_ident!("{}", clean_type_name(r));
            Ok(quote! { #ident })
        }
        Type::Container(c) => {
            let name = if c.name == "anon" { hint_name } else { &c.name };
            let safe_name = clean_type_name(name);
            
            // If not emitted, emit it using define_type logic
            // We can call define_type recursively.
            // Note: define_type checks emitted.
            // But define_type expects &Type. We have Type::Container(c).
            // We need to pass t.
            define_type(&safe_name, t, ctx)?;
            
            let ident = format_ident!("{}", safe_name);
            Ok(quote! { #ident })
        }
        Type::Array { count_type: _, inner_type } => {
             let inner_tokens = resolve_type_to_tokens(inner_type, &format!("{}_Item", hint_name), ctx)?;
             Ok(quote! { Vec<#inner_tokens> })
        }
        Type::Switch { .. } | Type::Bitfield { .. } => {
             let safe_name = clean_type_name(hint_name);
             define_type(&safe_name, t, ctx)?;
             let ident = format_ident!("{}", safe_name);
             Ok(quote! { #ident })
        }
    }
}

fn primitive_to_rust_tokens(p: &Primitive) -> TokenStream {
    match p {
        Primitive::Bool => quote! { bool },
        Primitive::U8 => quote! { u8 },
        Primitive::I8 => quote! { i8 },
        Primitive::U16 => quote! { u16 },
        Primitive::I16 => quote! { i16 },
        Primitive::U32 => quote! { u32 },
        Primitive::I32 => quote! { i32 },
        Primitive::U64 => quote! { u64 },
        Primitive::I64 => quote! { i64 },
        Primitive::F32 => quote! { f32 },
        Primitive::F64 => quote! { f64 },
        Primitive::VarInt => quote! { i32 },
        Primitive::VarLong => quote! { i64 },
        Primitive::McString => quote! { String },
        Primitive::Uuid => quote! { String }, 
        Primitive::Void => quote! { () },
        Primitive::ByteArray => quote! { Vec<u8> },
    }
}

fn clean_type_name(s: &str) -> String {
    let s = s.replace("/", "_").replace(" ", "_");
    camel_case(&s)
}

fn clean_field_name(s: &str) -> String {
    let s = s.replace(" ", "_");
    let s = match s.as_str() {
        "type" => "type_",
        "box" => "box_",
        "match" => "match_",
        "struct" => "struct_",
        "enum" => "enum_",
        "impl" => "impl_",
        "crate" => "crate_",
        "pub" => "pub_",
        "mod" => "mod_",
        "super" => "super_",
        "self" => "self_",
        "Self" => "Self_",
        "extern" => "extern_",
        "use" => "use_",
        "fn" => "fn_",
        "virtual" => "virtual_",
        _ => &s,
    };
    
    if s.chars().next().map(|c| c.is_numeric()).unwrap_or(false) {
        format!("_{}", s)
    } else {
        s.to_string()
    }
}

fn camel_case(s: &str) -> String {
    let mut result = String::new();
    let mut next_cap = true;
    for c in s.chars() {
        if c == '_' || c == '/' || c == ' ' || c == '-' {
            next_cap = true;
        } else {
            if next_cap {
                result.extend(c.to_uppercase());
                next_cap = false;
            } else {
                result.push(c);
            }
        }
    }
    if result.is_empty() {
        return "Empty".to_string();
    }
    if result.chars().next().unwrap().is_numeric() {
        result.insert(0, '_');
    }
    result
}
